{"code": "public void loadColorTableFromDataTable(){\n  if (getDataTable().getColorTable() != null) {\n    getChartColorManager().setColorTable(getDataTable().getColorTable(),getDataTable().isColorByPosition());\n    if (getDataTable().getColorTableHeatMap() != null) {\n      getChartColorManager().setHeatMapTable(getDataTable().getColorTableHeatMap());\n      getDataTable().setColorTableHeatMap(getChartColorManager().getHeatMapTable().getName());\n    }\n  }\n  if (!getChartColorManager().isUsingProgramColors())   getChartColorManager().loadColorEdits(getDataTable().getColorEdits());\n}\n", "nl": "load color table from data table"}
{"code": "public static <T extends GenericEntity>List<T> filterByAnd(List<T> values,Map<String,? extends Object> fields){\n  if (values == null)   return null;\n  List<T> result=null;\n  if (UtilValidate.isEmpty(fields)) {\n    result=new LinkedList<T>();\n    result.addAll(values);\n  }\n else {\n    result=new LinkedList<T>();\n    for (    T value : values) {\n      if (value.matchesFields(fields)) {\n        result.add(value);\n      }\n    }\n  }\n  return result;\n}\n", "nl": "returns the values that match the values in fields"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  InspectorWindow inspectorWindow=(InspectorWindow)getViewer();\n  TreePath[] paths=inspectorWindow.getDataTree().getSelectionPaths();\n  if (paths != null)   inspectorWindow.collapse(paths);\n else {\n    for (    NodeBase root : inspectorWindow.getClassification2RootNode().values()) {\n      inspectorWindow.collapse(root);\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public JpaRelationshipRepository(JpaModule module,Class<S> sourceResourceClass,Class<T> targetResourceClass){\n  super(module,targetResourceClass);\n  this.sourceResourceClass=sourceResourceClass;\n  JpaMapping<?,S> sourceMapping=module.getMapping(sourceResourceClass);\n  if (sourceMapping != null) {\n    this.sourceEntityClass=sourceMapping.getEntityClass();\n    this.sourceMapper=sourceMapping.getMapper();\n  }\n else {\n    this.sourceEntityClass=sourceResourceClass;\n    this.sourceMapper=IdentityMapper.newInstance();\n  }\n  this.entityMeta=module.getMetaLookup().getMeta(sourceEntityClass).asEntity();\n}\n", "nl": "JPA relationship directly exposed as repository"}
{"code": "private static void start(Context context,Class<?> daemonClazzName,int interval){\n  String cmd=context.getDir(BIN_DIR_NAME,Context.MODE_PRIVATE).getAbsolutePath() + File.separator + DAEMON_BIN_NAME;\n  StringBuilder cmdBuilder=new StringBuilder();\n  cmdBuilder.append(cmd);\n  cmdBuilder.append(\" -p \");\n  cmdBuilder.append(context.getPackageName());\n  cmdBuilder.append(\" -s \");\n  cmdBuilder.append(daemonClazzName.getName());\n  cmdBuilder.append(\" -t \");\n  cmdBuilder.append(interval);\n  try {\n    Runtime.getRuntime().exec(cmdBuilder.toString()).waitFor();\n  }\n catch (  IOException|InterruptedException e) {\n    Log.e(TAG,\"start daemon error: \" + e.getMessage());\n  }\n}\n", "nl": "start daemon"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set edgeWidth=\");\n  int width=np.getInt(0,1000);\n  np.matchIgnoreCase(\";\");\n  if (getViewer() instanceof GraphView) {\n    boolean changed=false;\n    GraphView viewer=(GraphView)getViewer();\n    for (    Edge e : viewer.getSelectedEdges()) {\n      viewer.setLineWidth(e,width);\n      changed=true;\n    }\n    if (changed) {\n      viewer.repaint();\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private static void pushTransactionStartStamp(Transaction t){\n  Map<Transaction,Timestamp> map=suspendedTxStartStamps.get();\n  Timestamp stamp=transactionStartStamp.get();\n  if (stamp != null) {\n    map.put(t,stamp);\n  }\n else {\n    Debug.logError(\"Error in transaction handling - no start stamp to push.\",module);\n  }\n}\n", "nl": "Put the stamp to remember later"}
{"code": "public JsonObject toJson(){\n  JsonObject json=new JsonObject();\n  json.put(\"statusCode\",statusCode.code());\n  if (body != null) {\n    json.put(\"body\",body.toString());\n  }\n  json.put(\"headers\",headers.names().stream().map(null).reduce(new JsonArray(),null,null));\n  return json;\n}\n", "nl": "Convert this to JSON"}
{"code": "private String runEditor() throws IOException {\n  Map<String,String> env=System.getenv();\n  String editor=Optional.ofNullable(env.get(\"EDITOR\")).orElse(DEFAULT_EDITOR);\n  ProcessBuilder builder=new ProcessBuilder(\"/bin/bash\",\"-c\",editor + \" </dev/tty >/dev/tty \" + tempFile.getAbsolutePath());\n  try {\n    builder.start().waitFor();\n  }\n catch (  InterruptedException e) {\n    throw new RuntimeException(e);\n  }\n  return String.join(\"\\n\",Files.readAllLines(tempFile.toPath()));\n}\n", "nl": "load the user's preferred editor to edit a query"}
{"code": "public boolean contains(T obj){\n  lock.lock();\n  try {\n    return contains_impl(obj);\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "is this object contained in the SL ?"}
{"code": "public final void finalize(){\n  try {\n    closeFallbackInputStream();\n    closeFallbackOutputStream();\n    closeCounterDataInputStream();\n    closeCounterDataOutputStream();\n  }\n catch (  Exception e) {\n    LOG.error(\"finalize() - The opened streams to the files could not be closed\");\n  }\n}\n", "nl": "This method closes all the file descriptors that could be still opened before destroying the object"}
{"code": "public static ConstraintTableLayout inferGroup(ArrayList<ConstraintWidget> widgets){\n  ScoutGroup group=new ScoutGroup(widgets.toArray(new ConstraintWidget[widgets.size()]));\n  ConstraintTableLayout ret=new ConstraintTableLayout();\n  if (group.mCols * group.mRows >= widgets.size()) {\n    ret.setNumRows(group.mRows);\n    ret.setNumCols(group.mCols);\n  }\n  if (group.mSupported) {\n    for (int i=0; i < group.mCols; i++) {\n      ret.setColumnAlignment(i,group.mColAlign[i]);\n    }\n  }\n  return ret;\n}\n", "nl": "Given a collection of widgets infer a good group choice"}
{"code": "public static Shape parse(String s,ShapeFormat shapeFormat){\n  try {\n    return fromSpatial4JShape(getReader(shapeFormat).read(s));\n  }\n catch (  IOException e) {\n    throw new IllegalStateException(\"Failed to parse shape using \" + shapeFormat,e);\n  }\ncatch (  ParseException e) {\n    throw new IllegalArgumentException(\"Failed to parse shape using \" + shapeFormat,e);\n  }\n}\n", "nl": "Parses the specified string using the specified shape format"}
{"code": "private void textSelectionChanged(ITextSelection selection){\n  lastSelectionWasText=true;\n  AnnotateBlock match=null;\n  for (Iterator iterator=svnAnnotateBlocks.iterator(); iterator.hasNext(); ) {\n    AnnotateBlock block=(AnnotateBlock)iterator.next();\n    if (block.contains(selection.getStartLine())) {\n      match=block;\n      break;\n    }\n  }\n  if (match == null) {\n    return;\n  }\n  StructuredSelection listSelection=new StructuredSelection(match);\n  viewer.setSelection(listSelection,true);\n}\n", "nl": "A selection event in the Annotate Source Editor"}
{"code": "public DateTimeColumn atTime(TimeColumn c){\n  DateTimeColumn newColumn=DateTimeColumn.create(this.name() + \" \" + c.name());\n  for (int r=0; r < this.size(); r++) {\n    int c1=this.getInt(r);\n    int c2=c.getInt(r);\n    if (c1 == MISSING_VALUE || c2 == TimeColumn.MISSING_VALUE) {\n      newColumn.add(DateTimeColumn.MISSING_VALUE);\n    }\n else {\n      LocalDate value1=PackedLocalDate.asLocalDate(c1);\n      LocalTime time=PackedLocalTime.asLocalTime(c2);\n      newColumn.add(PackedLocalDateTime.pack(value1,time));\n    }\n  }\n  return newColumn;\n}\n", "nl": "Returns a DateTime column where each value consists of the dates from this column combined with the corresponding times from the other column"}
{"code": "public static List<String> extractUrls(String text){\n  String lines[]=text.split(\"\\\\s+\");\n  List<String> containedUrls=new ArrayList<String>();\n  String urlRegex=\"((https?|ftp|gopher|telnet|file):((//)|(\\\\\\\\))+[\\\\w\\\\d:#@%/;$()~_?\\\\+-=\\\\\\\\\\\\.&]*)\";\n  Pattern pattern=Pattern.compile(urlRegex,Pattern.CASE_INSENSITIVE);\n  for (  String line : lines) {\n    Matcher urlMatcher=pattern.matcher(line);\n    while (urlMatcher.find()) {\n      containedUrls.add(line.substring(urlMatcher.start(0),urlMatcher.end(0)));\n    }\n  }\n  return containedUrls;\n}\n", "nl": "Returns a list with all links contained in the input"}
{"code": "private void addToQueue(SerialMessage serialMessage){\n  if (serialMessage == null) {\n    return;\n  }\n  if (!msgQueue.contains(serialMessage) && msgQueue.remainingCapacity() > 1) {\n    msgQueue.add(serialMessage);\n  }\n  sendMessage();\n}\n", "nl": "Move the messages to the queue"}
{"code": "public Matrix minus(Matrix B){\n  checkMatrixDimensions(B);\n  Matrix X=new Matrix(m,n);\n  double[][] C=X.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      C[i][j]=A[i][j] - B.A[i][j];\n    }\n  }\n  return X;\n}\n", "nl": "C = A - B"}
{"code": "public boolean isSet(_Fields field){\n  if (field == null) {\n    throw new IllegalArgumentException();\n  }\nswitch (field) {\ncase AVERAGE_LOAD:\n    return isSetAverageLoad();\ncase OLD_GC:\n  return isSetOldGC();\ncase THREAD_NUM:\nreturn isSetThreadNum();\ncase QUEUE_SIZE:\nreturn isSetQueueSize();\ncase METHOD_QPS_MAP:\nreturn isSetMethodQpsMap();\n}\nthrow new IllegalStateException();\n}\n", "nl": "Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise"}
{"code": "private void add(String world,PermissionHolder holder,String permission){\n  try {\n    if (world != null && !world.equals(\"\")) {\n      holder.setPermission(permission,true,server,world);\n    }\n else {\n      holder.setPermission(permission,true,server);\n    }\n  }\n catch (  ObjectAlreadyHasException ignored) {\n  }\n  save(holder);\n}\n", "nl": "Generic method to add a permission to a holder"}
{"code": "public void dump(Writer writer){\n  PrintWriter pw=new PrintWriter(new BufferedWriter(writer));\n  pw.println(\"#========== Wave ==========\");\n  pw.println(\"#Type: NULL\");\n  pw.println(\"#Sample_Rate: \" + (int)audioFormat.getSampleRate());\n  pw.println(\"#Num_of_Samples: \" + samples.length / 2);\n  pw.println(\"#Num_of_Channels: \" + audioFormat.getChannels());\n  if (samples != null) {\n    for (int i=0; i < samples.length; i+=2) {\n      pw.println(WaveUtils.bytesToShort(samples[i],samples[i + 1]));\n    }\n  }\n  pw.flush();\n}\n", "nl": "Dumps the wave out to the given stream"}
{"code": "public void addRedefinedGroupDecl(XSGroupDecl derived,XSGroupDecl base,SimpleLocator locator){\n  if (fRGCount == fRedefinedGroupDecls.length) {\n    fRedefinedGroupDecls=resize(fRedefinedGroupDecls,fRGCount << 1);\n    fRGLocators=resize(fRGLocators,fRGCount);\n  }\n  fRGLocators[fRGCount / 2]=locator;\n  fRedefinedGroupDecls[fRGCount++]=derived;\n  fRedefinedGroupDecls[fRGCount++]=base;\n}\n", "nl": "add a group redefined by restriction: for later constraint checking"}
{"code": "public String toString(){\n  StringBuffer s=new StringBuffer();\n  boolean colon=false;\n  s.append(\"ClassHierarchy:{\");\n  for (  TypeNode typeNode : typeNodeList) {\n    if (colon) {\n      s.append(\",\");\n    }\n else {\n      colon=true;\n    }\n    s.append(typeNode);\n  }\n  s.append(\"}\");\n  return s.toString();\n}\n", "nl": "Returns a string representation of this object"}
{"code": "@Override public ElectionEntry clone(){\n  try {\n    ElectionEntry cloneEntry=(ElectionEntry)super.clone();\n    cloneEntry._actState=new ActiveElectionState();\n    cloneEntry.attributeSetTemplates=attributeSetTemplates.clone();\n    for (int i=0; i < cloneEntry.attributeSetTemplates.length; i++) {\n      if (cloneEntry.attributeSetTemplates[i] instanceof ActiveElectionState) {\n        cloneEntry.attributeSetTemplates[i]=cloneEntry._actState;\n        break;\n      }\n    }\n    return cloneEntry;\n  }\n catch (  CloneNotSupportedException e) {\n    throw new InternalError();\n  }\n}\n", "nl": "clone the ElectionEntry so that don't override on direct reference of ActiveElectionState"}
{"code": "public synchronized String decrypt(String str){\n  byte[] dec;\n  try {\n    dec=decoder.decodeBuffer(str);\n    byte[] utf8=decrypter.doFinal(dec);\n    return new String(utf8,\"UTF-8\");\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  IllegalBlockSizeException e) {\n    e.printStackTrace();\n  }\ncatch (  BadPaddingException e) {\n    e.printStackTrace();\n  }\n  return str;\n}\n", "nl": "Decrypt a string"}
{"code": "public void releaseScan() throws SAException {\n  if (_curValueList != null) {\n    _curValueList.releaseScan();\n    _curValueList=null;\n  }\n  if (_entriesIter != null) {\n    _entriesIter.releaseScan();\n    _entriesIter=null;\n  }\n  _curValueListHolder=null;\n}\n", "nl": "release SLHolder for this scan"}
{"code": "protected void jimplifyInterface(DexBody body){\n  SootMethodRef ref=getSootMethodRef(InvocationType.Interface);\n  if (!ref.declaringClass().isInterface()) {\n    jimplifyVirtual(body);\n    return;\n  }\n  List<Local> parameters=buildParameters(body,false);\n  invocation=Jimple.v().newInterfaceInvokeExpr(parameters.get(0),getSootMethodRef(InvocationType.Interface),parameters.subList(1,parameters.size()));\n  body.setDanglingInstruction(this);\n}\n", "nl": "Executes the \"jimplify\" operation for an interface invocation"}
{"code": "@Override public void begin(@SwingCoordinate int x,@SwingCoordinate int y,@InputEventMask int startMask){\n  super.begin(x,y,startMask);\n  int androidX=Coordinates.getAndroidX(myScreenView,myStartX);\n  int androidY=Coordinates.getAndroidY(myScreenView,myStartY);\n  DrawConstraintModel model=ConstraintModel.getDrawConstraintModel(myScreenView);\n  model.updateModifiers(startMask);\n  model.setInteractionComponent(myComponent.getParent() != null ? myComponent.getParent() : myComponent);\n  model.mousePressed(androidX,androidY);\n}\n", "nl": "Start the mouse interaction"}
{"code": "private ContainerNetworkState updateNetwork(ContainerNetworkState network,String newSubnet,String newGateway) throws Throwable {\n  ContainerNetworkState patch=new ContainerNetworkState();\n  if (newSubnet != null || newGateway != null) {\n    Ipam ipam=new Ipam();\n    IpamConfig ipamConfig=new IpamConfig();\n    ipamConfig.subnet=newSubnet;\n    ipamConfig.gateway=newGateway;\n    ipam.config=new IpamConfig[]{ipamConfig};\n    patch.ipam=ipam;\n  }\n  return doPatch(patch,network.documentSelfLink);\n}\n", "nl": "pass <code>null</code> for no change"}
{"code": "@Override public boolean endContentModel(int[] currentState){\n  int state=currentState[0];\n  if (state == XSCMValidator.FIRST_ERROR || state == XSCMValidator.SUBSEQUENT_ERROR) {\n    return false;\n  }\n  if (fHasOptionalContent && state == STATE_START) {\n    return true;\n  }\n  for (int i=0; i < fNumElements; i++) {\n    if (!fIsOptionalElement[i] && currentState[i + 1] == STATE_START)     return false;\n  }\n  return true;\n}\n", "nl": "The method indicates the end of list of children"}
{"code": "@Override protected void drawYLabels(Canvas c,float fixedPosition,float[] positions,float offset){\n  mAxisLabelPaint.setTypeface(mYAxis.getTypeface());\n  mAxisLabelPaint.setTextSize(mYAxis.getTextSize());\n  mAxisLabelPaint.setColor(mYAxis.getTextColor());\n  for (int i=0; i < mYAxis.mEntryCount; i++) {\n    String text=mYAxis.getFormattedLabel(i);\n    if (!mYAxis.isDrawTopYLabelEntryEnabled() && i >= mYAxis.mEntryCount - 1)     return;\n    c.drawText(text,positions[i * 2],fixedPosition - offset,mAxisLabelPaint);\n  }\n}\n", "nl": "draws the y-labels on the specified x-position"}
{"code": "private void sortChildrenByRank(NodeBase node){\n  SortedSet<NodeBase> children=new TreeSet<>();\n  for (int i=0; i < node.getChildCount(); i++) {\n    NodeBase child=(NodeBase)node.getChildAt(i);\n    children.add(child);\n  }\n  node.removeAllChildren();\n  for (  NodeBase a : children) {\n    node.add(a);\n  }\n}\n", "nl": "sort all children of a node by rank"}
{"code": "public static Matrix random(int m,int n){\n  Matrix A=new Matrix(m,n);\n  double[][] X=A.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      X[i][j]=Math.random();\n    }\n  }\n  return A;\n}\n", "nl": "Generate matrix with random elements"}
{"code": "public int read(ClassificationsFooterRMA3 classificationsFooter,IInputReader reader) throws IOException {\n  map.clear();\n  long start=classificationsFooter.getStart(classificationType);\n  if (start != 0) {\n    reader.seek(start);\n    final int numberOfClasses=reader.readInt();\n    for (int i=0; i < numberOfClasses; i++) {\n      int classId=reader.readInt();\n      int sum=reader.readInt();\n      for (int z=0; z < 8; z++)       reader.skipBytes(sum);\n      map.put(classId,sum);\n    }\n  }\n  return map.size();\n}\n", "nl": "reads the named classification block"}
{"code": "public void testWriteReadEmpty() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(empty);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  ReplicationTransmissionPolicy copy=(ReplicationTransmissionPolicy)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(empty,copy));\n}\n", "nl": "Test read and write empty ClusterPolicy object"}
{"code": "public ParticleSystem(ViewGroup parentView,int maxParticles,Drawable drawable,long timeToLive){\n  this(parentView,maxParticles,timeToLive);\n  if (drawable instanceof BitmapDrawable) {\n    Bitmap bitmap=((BitmapDrawable)drawable).getBitmap();\n    for (int i=0; i < mMaxParticles; i++) {\n      mParticles.add(new Particle(bitmap));\n    }\n  }\n else   if (drawable instanceof AnimationDrawable) {\n    AnimationDrawable animation=(AnimationDrawable)drawable;\n    for (int i=0; i < mMaxParticles; i++) {\n      mParticles.add(new AnimatedParticle(animation));\n    }\n  }\n else {\n  }\n}\n", "nl": "Creates a particle system with the given parameters"}
{"code": "private static double mlsadf2(double x,double b[],int m,double a,double d[],int pt2,int pt3[]){\n  double out=0.0;\n  for (int i=PADEORDER; i > 0; i--) {\n    int pt2_plus_i=pt2 + i;\n    d[pt2_plus_i]=mlsafir(d[pt2_plus_i - 1],b,m,a,d,pt3[i]);\n    double v=d[pt2_plus_i] * pade[ppade + i];\n    x+=((1 & i) == 1) ? v : -v;\n    out+=v;\n  }\n  d[pt2]=x;\n  out+=x;\n  return out;\n}\n", "nl": "mlsdaf2: sub functions for MLSA filter"}
{"code": "public int write(byte[] buffer,final int bytes){\n  int remaining;\n  if ((remaining=checkSpace(true)) == 0) {\n    Log.e(RingBuffer.class.getSimpleName(),\"Buffer overrun. Data will not be written\");\n    return 0;\n  }\n  final int bytesWrite=bytes > remaining ? remaining : bytes;\n  for (int i=0; i < bytesWrite; ++i) {\n    this.buffer[wp++]=buffer[i];\n    if (wp == size)     wp=0;\n  }\n  return bytesWrite;\n}\n", "nl": "Write a number of bytes to ring buffer;"}
{"code": "public boolean moveDown(int firstRow,int lastRow){\n  firstRow=Math.max(0,firstRow);\n  if (lastRow >= getNumberRows() - 1)   return false;\n else {\n    List<Integer>[] array=new List[getNumberRows()];\n    for (int i=0; i < getNumberRows(); i++)     array[i]=getCompressedRow2Reads(i);\n    List<Integer> replaced=array[lastRow + 1];\n    System.arraycopy(array,firstRow,array,firstRow + 1,lastRow + 1 - firstRow);\n    array[firstRow]=replaced;\n    compressedRow2Reads.clear();\n    compressedRow2Reads.addAll(Arrays.asList(array));\n    return true;\n  }\n}\n", "nl": "move the selected rows of sequences down one"}
{"code": "public static String encodeUnicodeStr(String s){\n  StringBuilder sb=new StringBuilder(s.length() * 3);\n  for (  char c : s.toCharArray()) {\n    if (c < 256) {\n      sb.append(c);\n    }\n else {\n      sb.append(\"\\\\u\");\n      sb.append(Character.forDigit((c >>> 12) & 0xf,16));\n      sb.append(Character.forDigit((c >>> 8) & 0xf,16));\n      sb.append(Character.forDigit((c >>> 4) & 0xf,16));\n      sb.append(Character.forDigit((c) & 0xf,16));\n    }\n  }\n  return sb.toString();\n}\n", "nl": "encode Unicode string"}
{"code": "public void updateModel(NlModel model,boolean preserveXmlTags){\n  assertThat(model).isNotNull();\n  name(\"linear2.xml\");\n  NlModel newModel=preserveXmlTags ? model : build();\n  model.updateHierarchy(newModel.getFile().getRootTag(),buildViewInfos(newModel));\n  for (  NlComponent component : newModel.getComponents()) {\n    checkStructure(component);\n  }\n}\n", "nl": "Update the given model to reflect the component hierarchy in the given builder"}
{"code": "public void lockUserInput(){\n  locked=true;\n  statusbar.setText1(\"\");\n  statusbar.setText2(\"Busy...\");\n  frame.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n  getCommandManager().setEnableCritical(false);\n  searchManager.getFindDialogAsToolBar().setEnableCritical(false);\n  samplesSpreadSheet.lockUserInput();\n}\n", "nl": "ask view to prevent user input"}
{"code": "public final void fallback(final List data) throws DataFallbackException {\n  if (isFallbackFileEmpty())   fFileController.closeFallbackInputStream();\n  fFileController.openFallbackOutputStream();\n  final int size=data.size();\n  for (int i=0; i != size; i++) {\n    fFileController.writeLine((IFallback)data.get(i));\n  }\n  fFileController.setNumberOfLines(fFileController.getNumberOfLines() + size);\n}\n", "nl": "Writes a set of DataCacheObjects into the fallback log mechanism"}
{"code": "public static void compute(double minScore,double topPercent,double maxExpected,float minPercentIdentity,IReadBlock readBlock,String classificationName,BitSet activeMatchesForClassification){\n  activeMatchesForClassification.clear();\n  for (int i=0; i < readBlock.getNumberOfAvailableMatchBlocks(); i++) {\n    final IMatchBlock matchBlock=readBlock.getMatchBlock(i);\n    if (!matchBlock.isIgnore() && matchBlock.getBitScore() >= minScore && matchBlock.getExpected() <= maxExpected && matchBlock.getPercentIdentity() >= minPercentIdentity) {\n      if (matchBlock.getId(classificationName) > 0)       activeMatchesForClassification.set(i);\n    }\n  }\n  float bestScore=0;\n  for (int i=activeMatchesForClassification.nextSetBit(0); i != -1; i=activeMatchesForClassification.nextSetBit(i + 1)) {\n    final IMatchBlock matchBlock=readBlock.getMatchBlock(i);\n    float score=matchBlock.getBitScore();\n    if (score > bestScore)     bestScore=score;\n  }\n  applyTopPercentFilter(topPercent,bestScore,minPercentIdentity,readBlock,activeMatchesForClassification);\n}\n", "nl": "get the set of matches active for the given read"}
{"code": "@Override public EntryCreatedRS startChildItem(StartTestItemRQ rq,String parent){\n  TestItem parentItem=testItemRepository.findOne(parent);\n  validate(parentItem,parent);\n  validate(rq,parentItem);\n  TestItem item=testItemBuilder.get().addStartItemRequest(rq).addParent(parentItem).addPath(parentItem).addStatus(Status.IN_PROGRESS).build();\n  testItemRepository.save(item);\n  parentItem.setHasChilds(true);\n  testItemRepository.save(parentItem);\n  return new EntryCreatedRS(item.getId());\n}\n", "nl": "Starts children item and building it's path from parent with parant's"}
{"code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) private void verifyPortMappings(ContainerState containerState,String expectedPortBindings){\n  Map<String,Object> hostConfig=Utils.fromJson(containerState.attributes.get(DOCKER_CONTAINER_HOST_CONFIG_PROP_NAME),Map.class);\n  Map<String,List<Map<String,String>>> hostConfigPorts=(Map)hostConfig.get(DOCKER_CONTAINER_PORT_BINDINGS_PROP_NAME);\n  assertEquals(\"Unexpected number of port mappings\",1,hostConfigPorts.size());\n  Entry<String,List<Map<String,String>>> entry=hostConfigPorts.entrySet().iterator().next();\n  DockerPortMapping portMapping=DockerPortMapping.fromMap(entry);\n  DockerPortMapping expectedPortMapping=DockerPortMapping.fromString(expectedPortBindings);\n  assertEquals(\"port mapping host ip\",expectedPortMapping.getHostIp(),portMapping.getHostIp());\n  assertEquals(\"port mapping container port\",expectedPortMapping.getContainerPort(),portMapping.getContainerPort());\n  assertNotNull(\"port mapping host port\",portMapping.getHostPort());\n}\n", "nl": "Verify the port mappings in the created container"}
{"code": "public void saveAuxData(Map<String,byte[]> label2data) throws IOException {\n  final long location=footerSectionRMA6.getStartAuxDataSection();\n  io=new InputOutputReaderWriter(new File(fileName),READ_WRITE);\n  io.setLength(location);\n  io.seek(location);\n  io.writeInt(label2data.size());\n  for (  String name : label2data.keySet()) {\n    io.writeString(name);\n    byte[] bytes=label2data.get(name);\n    io.writeInt(bytes.length);\n    io.write(bytes,0,bytes.length);\n  }\n  footerSectionRMA6.setEndAuxDataSection(io.getPosition());\n  footerSectionRMA6.setStartFooterSection(io.getPosition());\n  footerSectionRMA6.write(io);\n  close();\n}\n", "nl": "save the aux data to the rma6 file"}
{"code": "@Override public int update(int scrollAmount){\n  final int currentScrollPosition=myScrollView.getScrollY();\n  final int newScrollY=Math.min(myMaxScrollableHeight,Math.max(0,myStartScrollPosition + scrollAmount * myScrollUnitSize));\n  if (newScrollY == currentScrollPosition) {\n    return 0;\n  }\n  myScrollView.setScrollY(newScrollY);\n  handleScrolling(myScrollView);\n  return newScrollY - currentScrollPosition;\n}\n", "nl": "Sets the scroll position to scrollAmount pixels"}
{"code": "private boolean atBinaryOperator(int prec){\n  if (matchesAnyOf(OPERATOR_PRECEDENCE.get(prec))) {\n    return true;\n  }\n  if (matchesSequence(TokenKind.NOT,TokenKind.IN)) {\n    return true;\n  }\n  return false;\n}\n", "nl": "Consumes current token iff it's a binary operator at the given precedence level (with special-case handling of 'NOT' 'IN' double token binary operator)"}
{"code": "public void sync() throws CanceledException {\n  getChartDrawer().forceUpdate();\n  seriesList.sync(getChartData().getSeriesNames(),getChartData().getSamplesTooltips(),false);\n  if (getChartData() instanceof IChartData) {\n    classesList.sync(((IChartData)getChartData()).getClassNames(),getChartData().getClassesTooltips(),false);\n    classesList.fireSyncToViewer();\n  }\n  attributesList.sync(getDir().getDocument().getSampleAttributeTable().getNumericalAttributes(),null,false);\n}\n", "nl": "synchronize data"}
{"code": "public Writer render(String templatePath,Map<String,Object> parentContext) throws SurveyWrapperException {\n  URL templateUrl=null;\n  try {\n    templateUrl=FlexibleLocation.resolveLocation(templatePath);\n  }\n catch (  MalformedURLException e) {\n    throw new SurveyWrapperException(e);\n  }\n  if (templateUrl == null) {\n    String errMsg=\"Problem getting the template for Survey from URL: \" + templatePath;\n    Debug.logError(errMsg,module);\n    throw new IllegalArgumentException(errMsg);\n  }\n  Writer writer=new StringWriter();\n  this.render(templateUrl,writer,parentContext);\n  return writer;\n}\n", "nl": "Renders the Survey"}
{"code": "public LocateOptions build(){\n  LocateOptions options=new LocateOptions();\n  options.watch=this.watch;\n  options.setView=this.setView;\n  options.maxZoom=this.maxZoom;\n  options.timeout=this.timeout;\n  options.maximumAge=this.maximumAge;\n  options.enableHighAccuracy=this.enableHighAccuracy;\n  return options;\n}\n", "nl": "Builds the LocateOptions new instance </br>"}
{"code": "public static void createFile(String filePath,String content) throws IOException {\n  FileWriter writer=null;\n  try {\n    writer=new FileWriter(filePath);\n    writer.write(content);\n  }\n catch (  IOException ex) {\n    throw ex;\n  }\n finally {\n    if (writer != null) {\n      writer.close();\n    }\n  }\n}\n", "nl": "create file"}
{"code": "public int encrypt(byte[] data,int offset,int length){\n  length+=4;\n  if (!updatedKey) {\n    length+=4;\n    length+=8 - length % 8;\n    encXORPass(data,offset,length,Rnd.nextInt());\n    cipher.cipher(data,offset,length);\n    cipher.updateKey(key);\n    updatedKey=true;\n  }\n else {\n    length+=8 - length % 8;\n    appendChecksum(data,offset,length);\n    cipher.cipher(data,offset,length);\n  }\n  return length;\n}\n", "nl": "Encrypt given data"}
{"code": "public void shareToWeiXin(String webpageUrl,String title,String description){\n  WXWebpageObject webpage=new WXWebpageObject();\n  webpage.webpageUrl=webpageUrl;\n  WXMediaMessage msg=new WXMediaMessage(webpage);\n  msg.title=title;\n  msg.description=description;\n  Bitmap thumb=BitmapFactory.decodeResource(context.getResources(),R.mipmap.ic_launcher);\n  msg.thumbData=Util.bmpToByteArray(thumb,true);\n  SendMessageToWX.Req req=new SendMessageToWX.Req();\n  req.transaction=buildTransaction(\"webpage\");\n  req.message=msg;\n  req.scene=SendMessageToWX.Req.WXSceneSession;\n  api.sendReq(req);\n}\n", "nl": "WeChat share meeting"}
{"code": "public void dumpRow(PrintStream out){\n  for (int i=0; i < columnNames.length; i++) {\n    out.print(\"Column \");\n    out.print(i);\n    out.print(\" \");\n    out.print(columnNames[i]);\n    out.print(\" : \");\n    try {\n      out.println(line[i]);\n    }\n catch (    ArrayIndexOutOfBoundsException aioobe) {\n      out.println(\"Unable to get cell \" + i + \" of this line\");\n    }\n  }\n}\n", "nl": "Dumps to a PrintStream the information relative to the row that caused the problem"}
{"code": "public void notifyReturned(NotifyContext notifyContext,ITemplateHolder template){\n  if (notifyContext == null)   return;\n  if (_filterManager._isFilter[FilterOperationCodes.AFTER_NOTIFY_TRIGGER]) {\n    Object[] entries=new Object[2];\n    entries[0]=notifyContext.getEntry();\n    entries[1]=template;\n    try {\n      _filterManager.invokeFilters(FilterOperationCodes.AFTER_NOTIFY_TRIGGER,null,entries);\n    }\n catch (    Exception e) {\n      if (_logger.isLoggable(Level.FINE))       _logger.log(Level.FINE,\"Exception was thrown by filter on AFTER_NOTIFY_TRIGGER.\",e);\n    }\n  }\n  decreaseCounter(notifyContext);\n}\n", "nl": "Called when a notification returned"}
{"code": "static private void syncAux2Summary(String fileName,byte[] bytes,DataTable table) throws IOException {\n  if (bytes != null) {\n    String string=Basic.toString(bytes);\n    if (string.startsWith(DataTable.MEGAN6_SUMMARY_TAG_NOT_USED_ANYMORE) || string.startsWith(DataTable.MEGAN4_SUMMARY_TAG) || string.startsWith(\"!MEGAN4\")) {\n      BufferedReader r=new BufferedReader(new StringReader(string));\n      table.read(r,true);\n      r.close();\n    }\n else     if (string.startsWith(\"!MEGAN\")) {\n      System.err.println(\"Archive is in an old format, upgrading to MEGAN6\");\n      BufferedReader r=new BufferedReader(new StringReader(string));\n      table.importMEGAN3SummaryFile(fileName,r,false);\n      r.close();\n    }\n  }\n}\n", "nl": "sync bytes from aux block to summary"}
{"code": "@Override public void close(){\n  try {\n    reader.close();\n    refReader.close();\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n}\n", "nl": "closes the accessor"}
{"code": "public static void d(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_DEBUG) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.d(tag,msg);\n}\n", "nl": "Send a DEBUG log message"}
{"code": "private void initResourcesIfNecessary(){\n  if (centerDrawable == null) {\n    centerDrawable=getContext().getResources().getDrawable(wheelForeground);\n  }\n  if (topShadow == null) {\n    topShadow=new GradientDrawable(Orientation.TOP_BOTTOM,SHADOWS_COLORS);\n  }\n  if (bottomShadow == null) {\n    bottomShadow=new GradientDrawable(Orientation.BOTTOM_TOP,SHADOWS_COLORS);\n  }\n  setBackgroundResource(wheelBackground);\n}\n", "nl": "Initializes resources"}
{"code": "public static <K>void addToDoubleInMap(Map<K,Object> theMap,K key,Double value){\n  Double curValue=(Double)theMap.get(key);\n  if (curValue != null) {\n    theMap.put(key,curValue + value);\n  }\n else {\n    theMap.put(key,value);\n  }\n}\n", "nl": "Adds value to the key entry in theMap, or creates a new one if not already there"}
{"code": "public static int update(W q,V v){\n  String passwd=(String)v.value(\"password\");\n  if (!X.isEmpty(passwd)) {\n    passwd=encrypt(passwd);\n    v.set(\"password\",passwd,true);\n  }\n else {\n    v.remove(\"password\");\n  }\n  return Helper.update(q,v.set(\"updated\",System.currentTimeMillis()),User.class);\n}\n", "nl": "update the user by query"}
{"code": "public static int cleanSuspendedTransactions() throws GenericTransactionException {\n  Transaction trans=null;\n  int num=0;\n  while ((trans=popSuspendedTransaction()) != null) {\n    resume(trans);\n    rollback();\n    num++;\n  }\n  clearTransactionStartStampStack();\n  return num;\n}\n", "nl": "BE VERY CAREFUL WHERE YOU CALL THIS!!"}
{"code": "public static String acceptRoleAssignment(HttpServletRequest request,HttpServletResponse response){\n  ServletContext ctx=(ServletContext)request.getAttribute(\"servletContext\");\n  RequestHandler rh=(RequestHandler)ctx.getAttribute(\"_REQUEST_HANDLER_\");\n  Locale locale=UtilHttp.getLocale(request);\n  if (addToOrderRole(request)) {\n    try {\n      EventHandler eh=rh.getEventFactory().getEventHandler(\"service\");\n      eh.invoke(new Event(\"service\",\"\",\"wfAcceptRoleAssignment\",true),null,request,response);\n    }\n catch (    EventHandlerException e) {\n      Debug.logError(e,\"Invocation error\",module);\n      request.setAttribute(\"_ERROR_MESSAGE_\",UtilProperties.getMessage(resource_error,\"OrderFailedToInvokeTheWfAcceptRoleAssignmentService\",locale));\n      return \"error\";\n    }\n    return \"success\";\n  }\n  return \"error\";\n}\n", "nl": "Accept role assignment event"}
{"code": "public Long putClassLoader(ClassLoader classLoader){\n  if (classLoader == null)   throw new IllegalArgumentException(\"Argument cannot be null - 'classLoader'.\");\n  Long previousId=_classLoaderToIdMap.get(classLoader);\n  if (previousId != null)   return previousId;\nsynchronized (_lock) {\n    previousId=_classLoaderToIdMap.get(classLoader);\n    if (previousId != null)     return previousId;\n    removeMarkers();\n    long id=generateClassLoaderKey();\n    if (_logger.isLoggable(Level.FINE))     _logger.fine(\"introducing new class loader to cache [\" + ClassLoaderHelper.getClassLoaderLogName(classLoader) + \"] to the class provider, class loader designated id is \"+ id);\n    _classLoaders.put(id,new ClassLoaderContext(classLoader,Represent.REGULAR));\n    _classLoaderToIdMap.put(classLoader,id);\n    return id;\n  }\n}\n", "nl": "Add new class loader to the cache, if the class loader is already present, the existing key will be returned"}
{"code": "public String toString(){\nswitch (type) {\ncase APPEND:\n    return \"A \" + parentId + \" \"+ taxId+ \" '\"+ taxName+ \"'\";\ncase DELETE:\n  return \"D \" + taxId;\ncase RENAME:\nreturn \"R \" + taxId + \" '\"+ taxName+ \"'\";\ndefault :\nreturn \"NONE\";\n}\n}\n", "nl": "write the edit"}
{"code": "public static void deleteLocalDataLoadFolderLocation(CarbonLoadModel loadModel,boolean isCompactionFlow){\n  String databaseName=loadModel.getDatabaseName();\n  String tableName=loadModel.getTableName();\n  String tempLocationKey=databaseName + CarbonCommonConstants.UNDERSCORE + tableName+ CarbonCommonConstants.UNDERSCORE+ loadModel.getTaskNo();\n  if (isCompactionFlow) {\n    tempLocationKey=CarbonCommonConstants.COMPACTION_KEY_WORD + '_' + tempLocationKey;\n  }\n  String localStoreLocation=CarbonProperties.getInstance().getProperty(tempLocationKey,CarbonCommonConstants.STORE_LOCATION_DEFAULT_VAL);\n  try {\n    CarbonUtil.deleteFoldersAndFiles(new File[]{new File(localStoreLocation).getParentFile()});\n    LOGGER.info(\"Deleted the local store location\" + localStoreLocation);\n  }\n catch (  CarbonUtilException e) {\n    LOGGER.error(e,\"Failed to delete local data load folder location\");\n  }\n}\n", "nl": "This method will delete the local data load folder location after data load is complete"}
{"code": "public boolean allowNamespace(String namespace){\n  if (fType == NSCONSTRAINT_ANY)   return true;\n  if (fType == NSCONSTRAINT_NOT) {\n    boolean found=false;\n    int listNum=fNamespaceList.length;\n    for (int i=0; i < listNum && !found; i++) {\n      if (namespace == fNamespaceList[i])       found=true;\n    }\n    if (!found)     return true;\n  }\n  if (fType == NSCONSTRAINT_LIST) {\n    int listNum=fNamespaceList.length;\n    for (int i=0; i < listNum; i++) {\n      if (namespace == fNamespaceList[i])       return true;\n    }\n  }\n  return false;\n}\n", "nl": "Validation Rule: Wildcard allows Namespace Name"}
{"code": "public static <V>List<V> invertList(List<V> sourceList){\n  if (isEmpty(sourceList)) {\n    return sourceList;\n  }\n  List<V> invertList=new ArrayList<V>(sourceList.size());\n  for (int i=sourceList.size() - 1; i >= 0; i--) {\n    invertList.add(sourceList.get(i));\n  }\n  return invertList;\n}\n", "nl": "invert list"}
{"code": "@ApiMethod(path=\"{type}/count\",verb=ApiVerb.GET,description=\"Returns the number of entries in space of the specified type\\n\",produces={MediaType.APPLICATION_JSON_VALUE}) @RequestMapping(value=\"/{type}/count\",method=RequestMethod.GET,produces={MediaType.APPLICATION_JSON_VALUE}) public @ResponseBody Map<String,Object> count(@ApiPathParam(name=\"type\",description=TYPE_DESCRIPTION) @PathVariable String type) throws ObjectNotFoundException {\n  GigaSpace gigaSpace=ControllerUtils.xapCache.get();\n  Integer cnt;\n  try {\n    cnt=gigaSpace.count(new SpaceDocument(type));\n  }\n catch (  DataAccessException e) {\n    throw translateDataAccessException(gigaSpace,e,type);\n  }\n  if (cnt == null) {\n    cnt=0;\n  }\n  Map<String,Object> result=new Hashtable<String,Object>();\n  result.put(\"status\",\"success\");\n  result.put(\"data\",cnt);\n  return result;\n}\n", "nl": "REST COUNT request handler"}
{"code": "public void addChildren(MyJTreeNode node){\n  final Node v=node.getV();\n  final DefaultTreeModel model=(DefaultTreeModel)getModel();\n  if (v.getOutDegree() > 0 && node.getChildCount() == 0) {\n    for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n      final Node w=e.getTarget();\n      final MyJTreeNode wNode=new MyJTreeNode(w);\n      node.add(wNode);\n      id2node.put((Integer)w.getInfo(),wNode);\n      model.nodeStructureChanged(wNode);\n    }\n  }\n  model.nodeStructureChanged(node);\n}\n", "nl": "add all children of a given node"}
{"code": "@VisibleForTesting boolean syncProject(BlazeContext context){\n  SyncResult syncResult=SyncResult.FAILURE;\n  try {\n    SaveUtil.saveAllFiles();\n    onSyncStart(project,context);\n    syncResult=doSyncProject(context);\n  }\n catch (  AssertionError|Exception e) {\n    LOG.error(e);\n    IssueOutput.error(\"Internal error: \" + e.getMessage()).submit(context);\n  }\n finally {\n    afterSync(project,context,syncResult);\n  }\n  return syncResult == SyncResult.SUCCESS || syncResult == SyncResult.PARTIAL_SUCCESS;\n}\n", "nl": "Returns true if sync successfully completed"}
{"code": "public long addQuery(byte[] queryText,int queryTextLength,int numberOfMatches,byte[] matchesText,int matchesTextLength,int[][] match2Classification2Id,long mateLocation) throws IOException {\n  final long location=readerWriter.getPosition();\n  if (isPairedReads)   readerWriter.writeLong(mateLocation);\n  readerWriter.writeString(queryText,0,queryTextLength);\n  readerWriter.writeInt(numberOfMatches);\n  for (int i=0; i < numberOfMatches; i++) {\n    for (int j=0; j < numberOfClassificationNames; j++) {\n      readerWriter.writeInt(match2Classification2Id[i][j]);\n    }\n  }\n  readerWriter.writeString(matchesText,0,matchesTextLength);\n  this.totalNumberOfReads++;\n  this.totalNumberOfMatches+=numberOfMatches;\n  return location;\n}\n", "nl": "add a query and its matches to the file"}
{"code": "public static void appendElementDescription(@NotNull StringBuilder sb,@NotNull PsiElement element){\n  if (element instanceof LazyValueResourceElementWrapper) {\n    LazyValueResourceElementWrapper wrapper=(LazyValueResourceElementWrapper)element;\n    XmlAttributeValue value=wrapper.computeElement();\n    if (value != null) {\n      element=value;\n    }\n  }\n  PsiFile file=element.getContainingFile();\n  int offset=element.getTextOffset();\n  TextRange segment=element.getTextRange();\n  appendSourceDescription(sb,file,offset,segment);\n}\n", "nl": "Appends a description of the given element, suitable as unit test golden file output"}
{"code": "private String createRegexFromRule(String urlRuleText){\n  String regexText=StringUtils.replaceEach(urlRuleText,new String[]{\"?\",\".\",\"+\",\"[\",\"]\",\"(\",\")\",\"{\",\"}\",\"#\",\" \",\"\\\\\",\"$\"},new String[]{\"\\\\?\",\"\\\\.\",\"\\\\+\",\"\\\\[\",\"\\\\]\",\"\\\\(\",\"\\\\)\",\"\\\\{\",\"\\\\}\",\"\\\\#\",\"\\\\ \",\"\\\\\\\\\",\"\\\\$\"});\n  regexText=regexText.substring(0,MASK_START_URL.length()) + StringUtils.replace(regexText.substring(MASK_START_URL.length(),regexText.length() - 1),\"|\",\"\\\\|\") + regexText.substring(regexText.length() - 1);\n  regexText=StringUtils.replace(regexText,MASK_ANY_SYMBOL,REGEXP_ANY_SYMBOL);\n  regexText=StringUtils.replace(regexText,MASK_SEPARATOR,REGEXP_SEPARATOR);\n  if (regexText.startsWith(MASK_START_URL)) {\n    regexText=REGEXP_START_URL + regexText.substring(MASK_START_URL.length());\n  }\n else   if (regexText.startsWith(MASK_PIPE)) {\n    regexText=REGEXP_START_STRING + regexText.substring(MASK_PIPE.length());\n  }\n  if (regexText.endsWith(MASK_PIPE)) {\n    regexText=regexText.substring(0,regexText.length() - 1) + REGEXP_END_STRING;\n  }\n  return regexText;\n}\n", "nl": "Creates regexp from url rule text"}
{"code": "@Override public boolean equals(Object o){\n  if (this == o) {\n    return true;\n  }\n  if (!(o instanceof Point3D)) {\n    return false;\n  }\n  Point3D point3D=(Point3D)o;\n  return x == point3D.x && y == point3D.y && z == point3D.z;\n}\n", "nl": "Checks if this point is equal to another point"}
{"code": "private void movePos(float deltaY){\n  if ((deltaY < 0 && mPtrIndicator.isInStartPosition())) {\n    if (DEBUG) {\n      PtrCLog.e(LOG_TAG,String.format(\"has reached the top\"));\n    }\n    return;\n  }\n  int to=mPtrIndicator.getCurrentPosY() + (int)deltaY;\n  if (mPtrIndicator.willOverTop(to)) {\n    if (DEBUG) {\n      PtrCLog.e(LOG_TAG,String.format(\"over top\"));\n    }\n    to=PtrIndicator.POS_START;\n  }\n  mPtrIndicator.setCurrentPos(to);\n  int change=to - mPtrIndicator.getLastPosY();\n  updatePos(change);\n}\n", "nl": "if deltaY > 0, move the content down"}
{"code": "public static void tintTextView(@NonNull TextView textview,ColorStateList tintColor){\n  textview.setTextColor(tintColor);\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {\n    Drawable[] drawables=textview.getCompoundDrawablesRelative();\n    textview.setCompoundDrawablesRelative(tintDrawable(drawables[0],tintColor),tintDrawable(drawables[1],tintColor),tintDrawable(drawables[2],tintColor),tintDrawable(drawables[3],tintColor));\n  }\n else {\n    Drawable[] drawables=textview.getCompoundDrawables();\n    textview.setCompoundDrawables(tintDrawable(drawables[0],tintColor),tintDrawable(drawables[1],tintColor),tintDrawable(drawables[2],tintColor),tintDrawable(drawables[3],tintColor));\n  }\n}\n", "nl": "Tints TextView's text color and it's compound drawables"}
{"code": "protected RequestHandle sendRequest(DefaultHttpClient client,HttpContext httpContext,HttpUriRequest uriRequest,String contentType,ResponseHandlerInterface responseHandler,Context context){\n  if (contentType != null) {\n    uriRequest.setHeader(\"Content-Type\",contentType);\n  }\n  responseHandler.setRequestHeaders(uriRequest.getAllHeaders());\n  responseHandler.setRequestURI(uriRequest.getURI());\n  Future<?> request=threadPool.submit(new AsyncHttpRequest(client,httpContext,uriRequest,responseHandler));\n  if (context != null) {\n    List<WeakReference<Future<?>>> requestList=requestMap.get(context);\n    if (requestList == null) {\n      requestList=new LinkedList<WeakReference<Future<?>>>();\n      requestMap.put(context,requestList);\n    }\n    requestList.add(new WeakReference<Future<?>>(request));\n  }\n  return new RequestHandle(request);\n}\n", "nl": "Puts a new request in queue as a new thread in pool to be executed"}
{"code": "public boolean registerPathFlag(int id,int maxSize){\n  if (pathFlags != null && id < pathFlags.size() && pathFlags.get(id))   return false;\n  if (pathFlags == null) {\nsynchronized (this) {\n      if (pathFlags == null) {\n        AtomicBitSet pf=new AtomicBitSet(maxSize);\n        pathFlags=pf;\n      }\n    }\n  }\n  return pathFlags.set(id);\n}\n", "nl": "Registers that a worker thread with the given ID has already processed this abstraction"}
{"code": "@Override public void notationDecl(String name,XMLResourceIdentifier identifier,Augmentations augs) throws XNIException {\n  XMLNotationDecl notationDecl=new XMLNotationDecl();\n  notationDecl.setValues(name,identifier.getPublicId(),identifier.getLiteralSystemId(),identifier.getBaseSystemId());\n  int notationIndex=getNotationDeclIndex(name);\n  if (notationIndex == -1) {\n    notationIndex=createNotationDecl();\n    setNotationDecl(notationIndex,notationDecl);\n  }\n}\n", "nl": "A notation declaration"}
{"code": "public static double b2en(double b[],int m,double a){\n  double cep[], ir[];\n  int arrayLength=(m + 1) + 2 * IRLENG;\n  double[] spectrum2en_buff=new double[arrayLength];\n  cep=new double[arrayLength];\n  ir=new double[arrayLength];\n  b2mc(b,spectrum2en_buff,m,a);\n  freqt(spectrum2en_buff,m,cep,IRLENG - 1,-a);\n  c2ir(cep,IRLENG,ir,IRLENG);\n  double en=0.0;\n  for (int i=0; i < IRLENG; i++)   en+=ir[i] * ir[i];\n  return en;\n}\n", "nl": "b2en: functions for postfiltering"}
{"code": "public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"sort direction=\");\n  final String direction=np.getWordMatchesIgnoringCase(\"up down\");\n  np.matchIgnoreCase(\"attribute=\");\n  final String attribute=np.getWordRespectCase();\n  np.matchIgnoreCase(\";\");\n  final SamplesViewer viewer=((SamplesViewer)getViewer());\n  viewer.getSamplesTable().sortByColumn(attribute,direction.equals(\"up\"));\n}\n", "nl": "parses the given command and executes it"}
{"code": "public boolean add(Object obj_){\n  _buf[_bottom]=obj_;\n  _bottom=(_bottom == _buf.length - 1) ? 0 : _bottom + 1;\n  if (_bottom == _top) {\n    int oldLen=_buf.length;\n    int newLen=oldLen * 2;\n    Object[] newBuf=new Object[newLen];\n    int topToEnd=oldLen - _top;\n    int newTop=newLen - topToEnd;\n    System.arraycopy(_buf,0,newBuf,0,_top);\n    System.arraycopy(_buf,_top,newBuf,newTop,topToEnd);\n    _buf=newBuf;\n    _top=newTop;\n    return true;\n  }\n  return false;\n}\n", "nl": "add an element to the bottom of the queue"}
{"code": "@SuppressWarnings(\"unchecked\") private void restoreBadges(){\n  Bundle restoredBundle=savedInstanceState;\n  if (restoredBundle != null) {\n    if (restoredBundle.containsKey(BADGE_FULL_TEXT_KEY)) {\n      shouldShowBadgeWithNinePlus=restoredBundle.getBoolean(BADGE_FULL_TEXT_KEY);\n    }\n    if (restoredBundle.containsKey(BUDGES_ITEM_BUNDLE_KEY)) {\n      badgeSaveInstanceHashMap=(HashMap<Integer,Object>)savedInstanceState.getSerializable(BUDGES_ITEM_BUNDLE_KEY);\n      if (badgeSaveInstanceHashMap != null) {\n        for (        Integer integer : badgeSaveInstanceHashMap.keySet()) {\n          BadgeHelper.forceShowBadge(badgeList.get(integer),(BadgeItem)badgeSaveInstanceHashMap.get(integer),shouldShowBadgeWithNinePlus);\n        }\n      }\n    }\n  }\n}\n", "nl": "Restore available badges from saveInstance"}
{"code": "public ShareProjectCommand(ISVNRepositoryLocation location,IProject project,String remoteDirName,boolean createDirectory){\n  this.location=location;\n  this.project=project;\n  if (remoteDirName == null) {\n    this.remoteDirName=project.getName();\n  }\n else {\n    this.remoteDirName=remoteDirName;\n  }\n  this.createDirectory=createDirectory;\n}\n", "nl": "if remoteDirName is null, the name of the project is used   "}
{"code": "@Override public void updateButtons(boolean canGoPrev,boolean canGoNext,boolean canCancel,boolean canFinish){\n  JButton prev=getPreviousButton();\n  if (prev != null) {\n    prev.setEnabled(canGoPrev);\n  }\n  JButton next=getNextButton();\n  if (next != null) {\n    next.setEnabled(canGoNext);\n  }\n  getFinishButton().setEnabled(canFinish);\n  getCancelButton().setEnabled(canCancel);\n  if (!ApplicationManager.getApplication().isUnitTestMode()) {\n    getRootPane().setDefaultButton(canFinish ? getFinishButton() : getNextButton());\n  }\n}\n", "nl": "Update the buttons for the wizard"}
{"code": "public void terminate(){\n  run=false;\n  if (ss != null) {\n    try {\n      ss.close();\n    }\n catch (    Exception e) {\n      logger.log(Level.WARNING,\"Exception closing Webster ServerSocket\",e);\n    }\n  }\n  if (lifeCycle != null) {\n    lifeCycle.unregister(this);\n  }\n  if (pool != null) {\n    pool.shutdown();\n  }\n}\n", "nl": "Terminate a running Webster instance"}
{"code": "public void removeOwnership(NamespaceBundles bundles){\n  boolean hasError=false;\n  for (  NamespaceBundle bundle : bundles.getBundles()) {\n    if (getOwnedServiceUnit(bundle) == null) {\n      continue;\n    }\n    try {\n      this.removeOwnership(bundle);\n    }\n catch (    Exception e) {\n      LOG.warn(String.format(\"Failed to remove ownership of a service unit: %s\",bundle),e);\n      hasError=true;\n    }\n  }\n  checkState(!hasError,\"Not able to remove all owned bundles\");\n}\n", "nl": "Method to remove ownership of all owned bundles"}
{"code": "public void login(CredentialProvider credentialProvider) throws LoginFailedException, RemoteServerException {\n  if (credentialProvider == null) {\n    throw new NullPointerException(\"Credential Provider is null\");\n  }\n  this.credentialProvider=credentialProvider;\n  startTime=currentTimeMillis();\n  playerProfile=new PlayerProfile(this);\n  settings=new Settings(this);\n  inventories=new Inventories(this);\n  initialize();\n}\n", "nl": "Login user with the provided provider"}
{"code": "private void createTry(polyglot.ast.Try tryStmt){\n  polyglot.ast.Block finallyBlock=tryStmt.finallyBlock();\n  if (finallyBlock == null) {\n    createTryCatch(tryStmt);\n  }\n else {\n    createTryCatchFinally(tryStmt);\n  }\n}\n", "nl": "Try Stmt Creation"}
{"code": "public static int[] curveGenerator(Point[] knots){\n  if (knots == null) {\n    throw new NullPointerException(\"Knots cannot be null\");\n  }\n  int n=knots.length - 1;\n  if (n < 1) {\n    throw new IllegalArgumentException(\"Atleast two points are required\");\n  }\n  if (Build.VERSION.SDK_INT >= 21) {\n    return getOutputPointsForNewerDevices(knots);\n  }\n else {\n    return getOutputPointsForOlderDevices(knots);\n  }\n}\n", "nl": "Generates Curve {in a plane ranging from 0-255} using the knots provided"}
{"code": "public static List<String> makeProductFeatureCategoryIdListFromPrefixed(Map<String,Object> parameters){\n  List<String> prodFeatureCategoryIdList=FastList.newInstance();\n  if (parameters == null)   return prodFeatureCategoryIdList;\n  for (  Map.Entry<String,Object> entry : parameters.entrySet()) {\n    String parameterName=entry.getKey();\n    if (parameterName.startsWith(\"SEARCH_PROD_FEAT_CAT\")) {\n      String productFeatureCategoryId=(String)entry.getValue();\n      if (UtilValidate.isNotEmpty(productFeatureCategoryId)) {\n        prodFeatureCategoryIdList.add(productFeatureCategoryId);\n      }\n    }\n  }\n  return prodFeatureCategoryIdList;\n}\n", "nl": "Handles parameters coming in prefixed with \"SEARCH_PROD_FEAT_CAT\" where the parameter value is a productFeatureCategoryId; meant to be used with text entry boxes or check-boxes and such"}
{"code": "protected static void prepareSparseMatrix(SparseMatrix adjMatrix){\n  for (int i=0; i != adjMatrix.getRowsCount(); i++) {\n    double sum=0.0;\n    ArrayList<Pair> row=adjMatrix.getRow(i);\n    for (int j=0; j != row.size(); j++) {\n      sum+=row.get(j).getSecond();\n    }\n    if (sum != 0.0) {\n      for (int j=0; j != row.size(); j++) {\n        double old_value=row.get(j).getSecond();\n        row.get(j).setSecond(old_value / sum);\n      }\n    }\n  }\n  adjMatrix.inv();\n}\n", "nl": "Transfer the adjacency matrix into the form pagerank can use, that's normalization and transposition"}
{"code": "public void refreshDays(){\n  mEventList.clear();\n  mPMonth=(GregorianCalendar)mCalendar.clone();\n  CalendarGridviewAdapter.firstDay=mCalendar.get(GregorianCalendar.DAY_OF_WEEK);\n  int mMaxWeekNumber=mCalendar.getActualMaximum(Calendar.WEEK_OF_MONTH);\n  mMonthLength=mMaxWeekNumber * 7;\n  int mMaxP=getmMaxP();\n  int mCalMaxP=mMaxP - (CalendarGridviewAdapter.firstDay - 1);\n  mPMonthMaxSet=(GregorianCalendar)mPMonth.clone();\n  mPMonthMaxSet.set(GregorianCalendar.DAY_OF_MONTH,mCalMaxP + 1);\n  setData(getCalendarData());\n}\n", "nl": "refresh current month days"}
{"code": "public void invalidateWheel(boolean clearCaches){\n  if (clearCaches) {\n    recycle.clearAll();\n    if (itemsLayout != null) {\n      itemsLayout.removeAllViews();\n    }\n    scrollingOffset=0;\n  }\n else   if (itemsLayout != null) {\n    recycle.recycleItems(itemsLayout,firstItem,new ItemsRange());\n  }\n  invalidate();\n}\n", "nl": "Invalidates wheel"}
{"code": "public double norm1(){\n  double f=0;\n  for (int j=0; j < n; j++) {\n    double s=0;\n    for (int i=0; i < m; i++) {\n      s+=Math.abs(A[i][j]);\n    }\n    f=Math.max(f,s);\n  }\n  return f;\n}\n", "nl": "One norm"}
{"code": "public static void close(Closeable stream){\n  if (null != stream) {\n    try {\n      stream.close();\n    }\n catch (    IOException e) {\n      LOG.error(\"Exception while closing the Log stream\");\n    }\n  }\n}\n", "nl": "closes the stream"}
{"code": "public void notifyLockInput(){\n  if (!locked) {\nsynchronized (directorListeners) {\n      IDirectorListener[] listeners=directorListeners.toArray(new IDirectorListener[directorListeners.size()]);\n      for (      IDirectorListener directorListener : listeners) {\n        if (directorListener != this)         directorListener.lockUserInput();\n      }\n    }\n  }\n  locked=true;\n}\n", "nl": "notify listeners to prevent user input"}
{"code": "private Point2D computeCenter(ArrayList<Point2D> points){\n  final Point center=new Point(0,0);\n  if (points.size() > 0) {\n    for (    Point2D aPt : points) {\n      center.x+=(int)aPt.getX();\n      center.y+=(int)aPt.getY();\n    }\n    center.x/=points.size();\n    center.y/=points.size();\n  }\n  return center;\n}\n", "nl": "computes the center for a set of points"}
{"code": "static boolean checkWin(char _xo){\n  for (int i=0; i < field_size; i++) {\n    if (field[i][0] == _xo && field[i][1] == _xo && field[i][2] == _xo)     return true;\n    if (field[0][i] == _xo && field[1][i] == _xo && field[2][i] == _xo)     return true;\n  }\n  if (field[0][0] == _xo && field[1][1] == _xo && field[2][2] == _xo)   return true;\n  if (field[2][0] == _xo && field[1][1] == _xo && field[0][2] == _xo)   return true;\n  return false;\n}\n", "nl": "Checking victory"}
{"code": "public void startDragDropInteraction(){\n  for (  Layer layer : myLayers) {\n    if (layer instanceof ConstraintsLayer) {\n      ConstraintsLayer constraintsLayer=(ConstraintsLayer)layer;\n      if (!constraintsLayer.isShowOnHover()) {\n        constraintsLayer.setShowOnHover(true);\n        repaint();\n      }\n    }\n  }\n}\n", "nl": "Gives us a chance to change layers behaviour upon drag and drop interaction starting"}
{"code": "@Override public boolean equals(Object o){\n  if (this == o) {\n    return true;\n  }\n  if (!(o instanceof Account)) {\n    return false;\n  }\n  Account account=(Account)o;\n  if (name != null ? !name.equals(account.name) : account.name != null) {\n    return false;\n  }\n  return !(passwordHash != null ? !passwordHash.equals(account.passwordHash) : account.passwordHash != null);\n}\n", "nl": "Retunrns true if players name and password has are equals"}
{"code": "public HistorySearchViewerFilter(String user,String comment,Date startDate,Date endDate,boolean regExp,SVNRevision.Number startRevision,SVNRevision.Number endRevision){\n  this.user=user;\n  this.comment=comment;\n  this.startDate=startDate;\n  this.endDate=endDate;\n  this.regExp=regExp;\n  this.startRevision=startRevision;\n  this.endRevision=endRevision;\n}\n", "nl": "Construct a new HistorySearchViewerFilter"}
{"code": "public double normInf(){\n  double f=0;\n  for (int i=0; i < m; i++) {\n    double s=0;\n    for (int j=0; j < n; j++) {\n      s+=Math.abs(A[i][j]);\n    }\n    f=Math.max(f,s);\n  }\n  return f;\n}\n", "nl": "Infinity norm"}
{"code": "public void disconnect(){\n  if (connectionState == ConnectionState.Disconnected || connectionState == ConnectionState.Connecting || !client.isConnected()) {\n    return;\n  }\n  AirMapLog.i(\"TrafficService\",\"Disconnecting from alerts\");\n  removeAllTraffic();\n  try {\n    client.disconnect(connectionState,actionListener);\n    checkForUpdatedFlight=false;\n  }\n catch (  MqttException e) {\n    AirMapLog.e(\"TrafficService\",\"Error disconnecting\");\n  }\n finally {\n    onDisconnect(false);\n  }\n}\n", "nl": "Disconnect from the server and stop receiving updates"}
{"code": "public SyncResult syncLibraries(String oldLibrary,String newLibrary){\n  try {\n    long taskId=trySync(oldLibrary,newLibrary);\n    while (true) {\n      JSONObject taskStatus=getTaskStatus(taskId);\n      JSONObject taskDetails=getTaskDetails(taskStatus);\n      if (isSyncComplete(taskStatus,taskDetails)) {\n        return taskDetailsToSyncResult(taskDetails);\n      }\n      if (quietSleep(progressUpdateFrequency))       return SyncResult.fail();\n    }\n  }\n catch (  Throwable t) {\n    return SyncResult.fail(t.getMessage());\n  }\n}\n", "nl": "Synchronously sync libraries"}
{"code": "public void initMeteorGameWhenConditionStart(){\n  Random rnd=new Random();\n  for (int i=0; i < roomClients.size(); i++)   roomClients.get(i).setnDestoryMeteor(0);\n  for (int i=0; i < Settings.nSettingAsteroidNumber; i++) {\n    sendMessageInTheRoomPeople(Settings._ANSWER_METEORGAME_UNIVERSE_INIT + \"\",rnd.nextInt(Settings.nGameAsteroidSceneWidth) + \"\",rnd.nextInt(Settings.nGameAsteroidSceneHeight) + \"\");\n    try {\n      Thread.sleep(20);\n    }\n catch (    InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n  sendMessageInTheRoomPeople(Settings._ANSWER_METEORGAME_PLAY_START + \"\",Boolean.toString(true));\n}\n", "nl": "init meteor game when game start"}
{"code": "public ControlZoomOptions build(){\n  ControlZoomOptions options=new ControlZoomOptions();\n  options.position=this.position;\n  options.zoomInText=this.zoomInText;\n  options.zoomOutText=this.zoomOutText;\n  options.zoomInTitle=this.zoomInTitle;\n  options.zoomOutTitle=this.zoomOutTitle;\n  return options;\n}\n", "nl": "Builds the ControlZoomOptions new instance"}
{"code": "static public COMPARISON_MODE parseMode(String parameterString){\n  try {\n    if (parameterString != null) {\n      NexusStreamParser np=new NexusStreamParser(new StringReader(parameterString));\n      while (np.peekNextToken() != NexusStreamParser.TT_EOF) {\n        if (np.peekMatchIgnoreCase(\"mode=\")) {\n          np.matchIgnoreCase(\"mode=\");\n          return COMPARISON_MODE.valueOfIgnoreCase(np.getWordRespectCase());\n        }\n else         np.getWordRespectCase();\n      }\n    }\n  }\n catch (  Exception ex) {\n  }\n  return COMPARISON_MODE.ABSOLUTE;\n}\n", "nl": "Convenience method: gets the mode encoded in the parameter string"}
{"code": "void addMarkers(Token tok){\n  SyntaxDocument sDoc=(SyntaxDocument)pane.getDocument();\n  sDoc.readLock();\n  String text=tok.getText(sDoc);\n  Iterator<Token> it=sDoc.getTokens(0,sDoc.getLength());\n  while (it.hasNext()) {\n    Token nextToken=it.next();\n    if (nextToken.length == tok.length && text.equals(nextToken.getText(sDoc))) {\n      Markers.markToken(pane,nextToken,marker);\n    }\n  }\n  sDoc.readUnlock();\n}\n", "nl": "add highlights for the given pattern"}
{"code": "public static Matrix identity(int m,int n){\n  Matrix A=new Matrix(m,n);\n  double[][] X=A.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      X[i][j]=(i == j ? 1.0 : 0.0);\n    }\n  }\n  return A;\n}\n", "nl": "Generate identity matrix"}
{"code": "public void removeKey(String key){\n  String validKey=convertToValidKey(key);\n  try {\n    mDiskCache.remove(validKey);\n    Log_OC.d(TAG,\"removeKey from cache: \" + validKey);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Remove passed key from cache"}
{"code": "public static KeyCombination translateAccelerator(KeyStroke acceleratorKey){\n  final List<KeyCombination.Modifier> modifiers=new ArrayList<>();\n  if ((acceleratorKey.getModifiers() & java.awt.event.InputEvent.SHIFT_DOWN_MASK) != 0)   modifiers.add(KeyCombination.SHIFT_DOWN);\n  if ((acceleratorKey.getModifiers() & java.awt.event.InputEvent.CTRL_DOWN_MASK) != 0)   modifiers.add(KeyCombination.CONTROL_DOWN);\n  if ((acceleratorKey.getModifiers() & java.awt.event.InputEvent.ALT_DOWN_MASK) != 0)   modifiers.add(KeyCombination.ALT_DOWN);\n  if ((acceleratorKey.getModifiers() & InputEvent.META_DOWN_MASK) != 0)   modifiers.add(KeyCombination.META_DOWN);\n  KeyCode keyCode=Utilities.getKeyCodeFX(acceleratorKey.getKeyCode());\n  return new KeyCodeCombination(keyCode,modifiers.toArray(new KeyCombination.Modifier[modifiers.size()]));\n}\n", "nl": "converts a swing accelerator key to a JavaFX key combination"}
{"code": "public void testRequiredProjects() throws IOException {\n  VirtualFile project1=createGradleProjectToImport(dir,module(1));\n  VirtualFile project2=createGradleProjectToImport(dir,module(2),module(1));\n  assert project1 != null && project2 != null : \"Something wrong with the setup\";\n  configureTopLevelProject(dir,Arrays.asList(module(1),module(2)),Collections.<String>emptySet());\n  Map<String,VirtualFile> projects=moduleListToMap(GradleModuleImporter.getRelatedProjects(project2,getProject()));\n  assertEquals(2,projects.size());\n  assertEquals(project1,projects.get(pathToGradleName(module(1))));\n  assertEquals(project2,projects.get(pathToGradleName(module(2))));\n}\n", "nl": "Verify basic case of importing a project that has source dependency"}
{"code": "public void rotateZ(double theta){\n  Matrix3D tmp=new Matrix3D();\n  double c=Math.cos(theta);\n  double s=Math.sin(theta);\n  tmp.set(0,0,c);\n  tmp.set(0,1,-s);\n  tmp.set(1,0,s);\n  tmp.set(1,1,c);\n  preMultiply(tmp);\n}\n", "nl": "rotate transformation about the Z axis"}
{"code": "public static void makeUnderlinedTextClickable(TextView textView,ClickableSpan onclick){\n  SpannedString string=(SpannedString)textView.getText();\n  int underlineStart=string.nextSpanTransition(0,string.length(),UnderlineSpan.class);\n  int underlineEnd=string.nextSpanTransition(underlineStart,string.length(),UnderlineSpan.class);\n  SpannableString ss=new SpannableString(string);\n  ss.setSpan(onclick,underlineStart,underlineEnd,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n  textView.setText(ss);\n  textView.setMovementMethod(LinkMovementMethod.getInstance());\n}\n", "nl": "Create an underline text clickable"}
{"code": "public synchronized void clearStaleEntries(){\n  if (_logger.isLoggable(Level.FINER))   _logger.finer(\"clearing stale entries from stub cache\");\n  List<StubId> staleEntries=new ArrayList<StubId>();\n  for (  Map.Entry<StubId,TouchedItem<Object>> entry : _cachedStubs.entrySet()) {\n    if (!entry.getValue().clearTouched())     staleEntries.add(entry.getKey());\n  }\n  if (_logger.isLoggable(Level.FINER)) {\n    int staleEntriesCount=staleEntries.size();\n    if (staleEntriesCount > 0)     _logger.finer(\"found \" + staleEntriesCount + \" stale entries in cache, removing them\");\n else     _logger.finer(\"no stale entries found in cache\");\n  }\n  for (  StubId id : staleEntries) {\n    _cachedStubs.remove(id);\n    for (    Set<StubId> set : _classLoaderContext.values())     set.remove(id);\n  }\n}\n", "nl": "Clear stale entries, an entry is considered stale if it was not touched in the last two clean cycles"}
{"code": "public static double[] diff(double[] a){\n  if (a == null) {\n    return null;\n  }\n else   if (a.length < 2) {\n    return new double[0];\n  }\n  double[] b=new double[a.length - 1];\n  for (int i=0; i < a.length - 1; i++) {\n    b[i]=a[i + 1] - a[i];\n  }\n  return b;\n}\n", "nl": "Get first-order discrete difference along adjacent values in an array"}
{"code": "static public String encode(byte[] binaryData){\n  if (binaryData == null)   return null;\n  int lengthData=binaryData.length;\n  int lengthEncode=lengthData * 2;\n  char[] encodedData=new char[lengthEncode];\n  int temp;\n  for (int i=0; i < lengthData; i++) {\n    temp=binaryData[i];\n    if (temp < 0)     temp+=256;\n    encodedData[i * 2]=lookUpHexAlphabet[temp >> 4];\n    encodedData[i * 2 + 1]=lookUpHexAlphabet[temp & 0xf];\n  }\n  return new String(encodedData);\n}\n", "nl": "Encode a byte array to hex string"}
{"code": "public String upload_file1(String group_name,long file_size,UploadCallback callback,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String parts[]=this.upload_file(group_name,file_size,callback,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload file to storage server (by callback)"}
{"code": "@Override public void modelChanged(@NotNull DesignSurface surface,@Nullable NlModel model){\n  setSurface(surface);\n  if (model != null) {\n    model.addListener(this);\n  }\n  computeOffsets(surface.getCurrentScreenView());\n  if (model != null) {\n    List<NlComponent> selection=model.getSelectionModel().getSelection();\n    if (selection.isEmpty()) {\n      selection=model.getComponents();\n    }\n    updateComponents(selection);\n  }\n  configureUI();\n  myMiniMap.repaint();\n}\n", "nl": "The model of the design surface changed"}
{"code": "public FortDeployPokemonResponse.Result deployPokemon(Pokemon pokemon) throws LoginFailedException, RemoteServerException {\n  FortDeployPokemonMessage reqMsg=FortDeployPokemonMessage.newBuilder().setFortId(getId()).setPlayerLatitude(api.getLatitude()).setPlayerLongitude(api.getLongitude()).setPokemonId(pokemon.getId()).build();\n  ServerRequest serverRequest=new ServerRequest(RequestType.FORT_DEPLOY_POKEMON,reqMsg);\n  api.getRequestHandler().sendServerRequests(serverRequest);\n  try {\n    return FortDeployPokemonResponse.parseFrom(serverRequest.getData()).getResult();\n  }\n catch (  InvalidProtocolBufferException e) {\n    throw new RemoteServerException();\n  }\n}\n", "nl": "Deploy pokemon"}
{"code": "private static boolean checkNullForDims(Object object){\n  Integer[] dimensions=(Integer[])object;\n  for (  Integer dimension : dimensions) {\n    if (null != dimension) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "To check whether the dimensions are empty/null"}
{"code": "private String fixedValue2RelativeValue(String pitchAttribute,double[] baseF0Contour){\n  pitchAttribute=pitchAttribute.substring(0,pitchAttribute.length() - 2);\n  double fixedValue=(new Float(pitchAttribute)).doubleValue();\n  double meanValue=MathUtils.mean(baseF0Contour);\n  double relative=(100.0 * fixedValue) / meanValue;\n  if (relative > 100) {\n    return \"+\" + df.format((relative - 100)) + \"%\";\n  }\n  return \"-\" + df.format((100 - relative)) + \"%\";\n}\n", "nl": "mapping a fixed value to a relative value"}
{"code": "public void draw(Canvas c,Rect bounds){\n  mCirclePaint.setColor(mBackgroundColor);\n  mCirclePaint.setAlpha(mAlpha);\n  c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mArcPaint.setColor(mColors[mColorIndex]);\n  mArcPaint.setAlpha(mAlpha);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mArcPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n}\n", "nl": "Draw the progress spinner"}
{"code": "protected Cookie decodeCookie(String cookieString){\n  byte[] bytes=hexStringToByteArray(cookieString);\n  ByteArrayInputStream byteArrayInputStream=new ByteArrayInputStream(bytes);\n  Cookie cookie=null;\n  try {\n    ObjectInputStream objectInputStream=new ObjectInputStream(byteArrayInputStream);\n    cookie=((SerializableOkHttpCookies)objectInputStream.readObject()).getCookies();\n  }\n catch (  IOException e) {\n    Log.d(LOG_TAG,\"IOException in decodeCookie\",e);\n  }\ncatch (  ClassNotFoundException e) {\n    Log.d(LOG_TAG,\"ClassNotFoundException in decodeCookie\",e);\n  }\n  return cookie;\n}\n", "nl": "String to cookies"}
{"code": "public CART load(String fileName) throws IOException, MaryConfigurationException {\n  FileInputStream fis=new FileInputStream(fileName);\n  try {\n    return loadFromStream(fis);\n  }\n  finally {\n    fis.close();\n  }\n}\n", "nl": "Load the cart from the given file"}
{"code": "static public void syncRecomputedArchive2Summary(String dataSetName,String algorithmName,BlastMode blastMode,String parameters,IConnector connector,DataTable table,int additionalReads) throws IOException {\n  String[] classifications=connector.getAllClassificationNames();\n  table.clear();\n  table.setCreator(ProgramProperties.getProgramName());\n  table.setCreationDate((new Date()).toString());\n  table.setAlgorithm(ClassificationType.Taxonomy.toString(),algorithmName);\n  table.setParameters(parameters);\n  table.setTotalReads(connector.getNumberOfReads());\n  table.setAdditionalReads(additionalReads);\n  table.setSamples(new String[]{dataSetName},new Long[]{connector.getUId()},new Integer[]{connector.getNumberOfReads()},new BlastMode[]{blastMode});\n  for (  String classification : classifications) {\n    IClassificationBlock block=connector.getClassificationBlock(classification);\n    if (block != null)     syncClassificationBlock2Summary(0,1,block,table);\n  }\n}\n", "nl": "synchronizes recomputed data from an archive to a summary and also parameters"}
{"code": "public YCCircleFlowIndicator(Context context,AttributeSet attrs){\n  super(context,attrs);\n  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.YCCircleFlowIndicator);\n  int activeType=a.getInt(R.styleable.YCCircleFlowIndicator_activeType,STYLE_FILL);\n  int activeDefaultColor=0xFFFFFFFF;\n  int activeColor=a.getColor(R.styleable.YCCircleFlowIndicator_activeColor,activeDefaultColor);\n  int inactiveType=a.getInt(R.styleable.YCCircleFlowIndicator_inactiveType,STYLE_STROKE);\n  int inactiveDefaultColor=0x44FFFFFF;\n  int inactiveColor=a.getColor(R.styleable.YCCircleFlowIndicator_inactiveColor,inactiveDefaultColor);\n  radius=a.getDimension(R.styleable.YCCircleFlowIndicator_radius,4.0f);\n  circleSeparation=a.getDimension(R.styleable.YCCircleFlowIndicator_circleSeparation,2 * radius + radius);\n  activeRadius=a.getDimension(R.styleable.YCCircleFlowIndicator_activeRadius,0.5f);\n  fadeOutTime=a.getInt(R.styleable.YCCircleFlowIndicator_fadeOut,0);\n  mCentered=a.getBoolean(R.styleable.YCCircleFlowIndicator_centered,false);\n  initColors(activeColor,inactiveColor,activeType,inactiveType);\n}\n", "nl": "The contructor used with an inflater"}
{"code": "public int readLocations(long position,IInputReader reader,int classId,ListOfLongs list) throws IOException {\n  reader.seek(position);\n  final int numberOfClasses=reader.readInt();\n  for (int i=0; i < numberOfClasses; i++) {\n    final int currentId=reader.readInt();\n    reader.readInt();\n    final int count=reader.readInt();\n    if (currentId == classId) {\n      for (int z=0; z < count; z++) {\n        list.add(reader.readLong());\n      }\n    }\n else     reader.skipBytes(count * 8);\n  }\n  return list.size();\n}\n", "nl": "read all locations for a given class and adds them to list"}
{"code": "public void startIndexSvnRepoJobs(String uniquename){\n  try {\n    Scheduler scheduler=Singleton.getScheduler();\n    JobDetail job=newJob(IndexSvnRepoJob.class).withIdentity(\"updateindex-svn-\" + uniquename).build();\n    SimpleTrigger trigger=newTrigger().withIdentity(\"updateindex-svn-\" + uniquename).withSchedule(simpleSchedule().withIntervalInSeconds(this.INDEXTIME).repeatForever()).build();\n    job.getJobDataMap().put(\"REPOLOCATIONS\",this.REPOLOCATION);\n    job.getJobDataMap().put(\"LOWMEMORY\",this.LOWMEMORY);\n    scheduler.scheduleJob(job,trigger);\n    scheduler.start();\n  }\n catch (  SchedulerException ex) {\n    LOGGER.severe(\" caught a \" + ex.getClass() + \"\\n with message: \"+ ex.getMessage());\n  }\n}\n", "nl": "Creates a svn repo indexer job which will pull from the list of git repositories and start indexing them"}
{"code": "private void handleRecoveryFailure(Exception e,int retries) throws Exception {\n  if (_logger.isLoggable(Level.WARNING)) {\n    _logger.log(Level.WARNING,\"Space recovery failure.\",e);\n  }\n  if (retries == RecoveryManager.RECOVERY_RETRIES || getEngine().getCacheManager().isOffHeapCachePolicy())   throw e;\n  close();\n  _engine=new SpaceEngine(this);\n  if (_leaderSelector != null) {\n    _logger.info(\"Space recovery failed - selecting primary\");\n    _leaderSelector.select();\n  }\n  initReplicationStateBasedOnActiveElection();\n}\n", "nl": "Handle primary backup recovery failure"}
{"code": "public BoxFolder createSharedFolder(String folderName,String parentId) throws BoxSDKServiceException {\n  BoxFolder createFolder=createFolder(folderName,parentId);\n  try {\n    createFolder.createSharedLink(BoxSharedLink.Access.OPEN,null,null);\n    return createFolder;\n  }\n catch (  BoxAPIException e) {\n    throw new BoxSDKServiceException(\"Can't create shared link for directory: \" + createFolder.getID(),e);\n  }\n}\n", "nl": "Creates a shared folder in the given parent folder"}
{"code": "public static byte[] long2buff(long n){\n  byte[] bs;\n  bs=new byte[8];\n  bs[0]=(byte)((n >> 56) & 0xFF);\n  bs[1]=(byte)((n >> 48) & 0xFF);\n  bs[2]=(byte)((n >> 40) & 0xFF);\n  bs[3]=(byte)((n >> 32) & 0xFF);\n  bs[4]=(byte)((n >> 24) & 0xFF);\n  bs[5]=(byte)((n >> 16) & 0xFF);\n  bs[6]=(byte)((n >> 8) & 0xFF);\n  bs[7]=(byte)(n & 0xFF);\n  return bs;\n}\n", "nl": "long convert to buff (big-endian)"}
{"code": "public static void assertEquals(String msg,RealMatrix expected,RealMatrix observed,double tolerance){\n  Assert.assertNotNull(msg + \"\\nObserved should not be null\",observed);\n  if (expected.getColumnDimension() != observed.getColumnDimension() || expected.getRowDimension() != observed.getRowDimension()) {\n    StringBuilder messageBuffer=new StringBuilder(msg);\n    messageBuffer.append(\"\\nObserved has incorrect dimensions.\");\n    messageBuffer.append(\"\\nobserved is \" + observed.getRowDimension() + \" x \"+ observed.getColumnDimension());\n    messageBuffer.append(\"\\nexpected \" + expected.getRowDimension() + \" x \"+ expected.getColumnDimension());\n    Assert.fail(messageBuffer.toString());\n  }\n  RealMatrix delta=expected.subtract(observed);\n  if (delta.getNorm() >= tolerance) {\n    StringBuilder messageBuffer=new StringBuilder(msg);\n    messageBuffer.append(\"\\nExpected: \" + expected);\n    messageBuffer.append(\"\\nObserved: \" + observed);\n    messageBuffer.append(\"\\nexpected - observed: \" + delta);\n    Assert.fail(messageBuffer.toString());\n  }\n}\n", "nl": "verifies that two matrices are close (1-norm)"}
{"code": "private static byte[][] rotateArray(byte[][] bitarray){\n  byte[][] temp=new byte[bitarray[0].length][bitarray.length];\n  for (int ii=0; ii < bitarray.length; ii++) {\n    int inverseii=bitarray.length - ii - 1;\n    for (int jj=0; jj < bitarray[0].length; jj++) {\n      temp[jj][inverseii]=bitarray[ii][jj];\n    }\n  }\n  return temp;\n}\n", "nl": "Takes and rotates the it 90 degrees"}
{"code": "public void visitPhpMethodReference(MethodReference reference){\n  if (!this.isPropelDefined()) {\n    return;\n  }\n  String strName=reference.getName();\n  if (null == strName || !strName.equals(\"count\")) {\n    return;\n  }\n  this.inspectSignature(reference.getSignature(),reference,null);\n}\n", "nl": "Entry point: methods calls"}
{"code": "private boolean equal(byte[] key1,byte[] key2){\n  if (key1.length != key2.length)   return false;\n else {\n    for (int i=0; i < key1.length; i++) {\n      if (key1[i] != key2[i])       return false;\n    }\n    return true;\n  }\n}\n", "nl": "equalOverShorterOfBoth keys?"}
{"code": "public static void e(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_ERROR) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.e(tag,msg);\n}\n", "nl": "Send an ERROR log message"}
{"code": "static IBlockState applyColour(IBlockState state,Colour colour){\n  for (  IProperty prop : (java.util.Set<IProperty>)state.getProperties().keySet()) {\n    if (prop.getName().equals(\"color\") && prop.getValueClass() == net.minecraft.item.EnumDyeColor.class) {\n      net.minecraft.item.EnumDyeColor current=(net.minecraft.item.EnumDyeColor)state.getValue(prop);\n      if (!current.getName().equalsIgnoreCase(colour.name())) {\n        return state.withProperty(prop,EnumDyeColor.valueOf(colour.name()));\n      }\n    }\n  }\n  return state;\n}\n", "nl": "Recolour the Minecraft block"}
{"code": "public void writeAuxBlocks(Map<String,byte[]> label2data) throws IOException {\n  getFooterSectionRMA6().setStartAuxDataSection(readerWriter.getPosition());\n  if (label2data == null)   readerWriter.writeInt(0);\n else {\n    readerWriter.writeInt(label2data.size());\n    for (    String label : label2data.keySet()) {\n      readerWriter.writeStringNoCompression(label);\n      final byte[] data=label2data.get(label);\n      if (data == null)       readerWriter.writeInt(0);\n else {\n        readerWriter.writeInt(data.length);\n        readerWriter.write(data,0,data.length);\n      }\n    }\n  }\n  getFooterSectionRMA6().setEndAuxDataSection(readerWriter.getPosition());\n}\n", "nl": "write aux blocks"}
{"code": "public static Vector<String> processVoiceExampleText(String text){\n  StringTokenizer st=new StringTokenizer(text,\"#\");\n  Vector<String> sentences=null;\n  while (st.hasMoreTokens()) {\n    if (sentences == null)     sentences=new Vector<String>();\n    sentences.add(st.nextToken());\n  }\n  return sentences;\n}\n", "nl": "Divides the example text of a voice into sentences in a vector"}
{"code": "public static int checkSurveyResponse(HttpServletRequest request,String surveyId){\n  Delegator delegator=(Delegator)request.getAttribute(\"delegator\");\n  GenericValue userLogin=(GenericValue)request.getSession().getAttribute(\"userLogin\");\n  String productStoreId=getProductStoreId(request);\n  if (userLogin == null) {\n    return -1;\n  }\n  return checkSurveyResponse(delegator,userLogin.getString(\"partyId\"),productStoreId,surveyId);\n}\n", "nl": "Returns the number of responses for this survey by party"}
{"code": "public DecorationCursor queryDecorations(){\n  QueryHelper qh=new QueryHelper();\n  qh.Columns=null;\n  qh.Table=S.TABLE_DECORATIONS;\n  qh.Selection=null;\n  qh.SelectionArgs=null;\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=\"skill_1_name ASC\";\n  qh.Limit=null;\n  return new DecorationCursor(wrapJoinHelper(builderDecoration(),qh));\n}\n", "nl": "****************************** DECORATION QUERIES"}
{"code": "public static Process buildCreateAllFieldsProcess(Long id,Properties properties){\n  if (properties == null) {\n    properties=new Properties();\n  }\n  Process process=Process.create(\"P_TEST\" + id).id(id).description(\"foo\").aliveTag(AliveTag.create(\"P_TEST\" + id + \":ALIVE\").build(),70000).statusTag(StatusTag.create(\"P_TEST\" + id + \":STATUS\").build()).maxMessageDelay(2000).maxMessageSize(200).build();\n  properties.setProperty(\"name\",\"P_TEST\" + id);\n  properties.setProperty(\"description\",\"foo\");\n  properties.setProperty(\"statusTagId\",String.valueOf(100l));\n  properties.setProperty(\"aliveInterval\",String.valueOf(70000));\n  properties.setProperty(\"aliveTagId\",String.valueOf(101l));\n  properties.setProperty(\"maxMessageDelay\",String.valueOf(2000));\n  properties.setProperty(\"maxMessageSize\",String.valueOf(200));\n  return process;\n}\n", "nl": "Expected status tag id is 101 Expected alive tag id is 100"}
{"code": "public void decreasePangPangEnemyLife(String... protocols){\n  for (int i=0; i < Settings.nPangPangEnemyHeight; i++)   for (int j=0; j < Settings.nPangPangEnemyWidth; j++)   if (mEnemy[i][j].getsUnitName().equals(protocols[0])) {\n    mEnemy[i][j].decreaseShield();\n    if (mEnemy[i][j].get_Is_Dead()) {\n      sendMessageInTheRoomPeople(Settings._ANSWER_PANGAPNG_ENEMY_COLLISION_EVENT + \"\",protocols[0]);\n      mpCtr.set_Enemy_Cnt_Minus();\n      break;\n    }\n  }\n}\n", "nl": "decrease pangpang enemy number"}
{"code": "private int measureShort(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(2 * mRadius + getPaddingTop() + getPaddingBottom() + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the height of this view"}
{"code": "protected void drawXAxis(Graphics2D gc){\n  gc.setFont(getFont(ChartViewer.FontKeys.XAxisFont.toString()));\n  gc.setColor(getFontColor(ChartViewer.FontKeys.XAxisFont.toString(),Color.BLACK));\n  gc.setColor(Color.BLACK);\n  int x=5;\n  int y=getHeight() - bottomMargin + 25;\n  if (!isTranspose())   gc.drawString(getChartData().getSeriesLabel(),x,y);\n else   gc.drawString(getChartData().getClassesLabel(),x,y);\n}\n", "nl": "draw the x axis"}
{"code": "private void download(boolean neutral,List<Selectable> list){\n  for (int i=0; i != list.size(); ++i) {\n    if ((neutral || list.get(i).isChecked()) && !list.get(i).isDisable()) {\n      mDownloadList.add(mDetailAdapter.getItem(i));\n    }\n  }\n  if (!mDownloadList.isEmpty()) {\n    showProgressDialog();\n    if (PermissionUtils.requestPermission(this,REQUEST_DOWNLOAD)) {\n      mPresenter.updateIndex(mDetailAdapter.getDateSet());\n    }\n  }\n}\n", "nl": "download: load download -> select chapter -> check permission -> update index -> add task"}
{"code": "public void writeFileContent(String content,Path path,FileMatch sourceFileMatch) throws CommandException {\n  try {\n    File outputFile=path.toFile();\n    BOMInputStream inputStream=new BOMInputStream(FileUtils.openInputStream(sourceFileMatch.getPath().toFile()),false,boms);\n    if (inputStream.hasBOM()) {\n      FileUtils.writeByteArrayToFile(outputFile,inputStream.getBOM().getBytes());\n      FileUtils.writeByteArrayToFile(outputFile,content.getBytes(inputStream.getBOMCharsetName()),true);\n    }\n else {\n      FileUtils.writeStringToFile(outputFile,content,StandardCharsets.UTF_8);\n    }\n  }\n catch (  IOException e) {\n    throw new CommandException(\"Cannot write file content in path: \" + path.toString(),e);\n  }\n}\n", "nl": "Writes the content into a file using same format as source file"}
{"code": "public InfoflowResults analyzeAPKFile(String fileName,boolean enableImplicitFlows,boolean enableStaticFields,boolean flowSensitiveAliasing) throws IOException, XmlPullParserException {\n  String androidJars=System.getenv(\"ANDROID_JARS\");\n  if (androidJars == null)   androidJars=System.getProperty(\"ANDROID_JARS\");\n  if (androidJars == null)   throw new RuntimeException(\"Android JAR dir not set\");\n  System.out.println(\"Loading Android.jar files from \" + androidJars);\n  SetupApplication setupApplication=new SetupApplication(androidJars,fileName);\n  setupApplication.setTaintWrapper(new EasyTaintWrapper(\"EasyTaintWrapperSource.txt\"));\n  setupApplication.calculateSourcesSinksEntrypoints(\"SourcesAndSinks.txt\");\n  setupApplication.setEnableImplicitFlows(enableImplicitFlows);\n  setupApplication.setEnableStaticFieldTracking(enableStaticFields);\n  setupApplication.setFlowSensitiveAliasing(flowSensitiveAliasing);\n  return setupApplication.runInfoflow();\n}\n", "nl": "Analyzes the given APK file for data flows"}
{"code": "@Override public boolean accept(File directory,String fileName){\n  if (!super.accept(directory,fileName))   return false;\n  try {\n    return DAAParser.isMeganizedDAAFile((new File(directory,fileName)).getPath(),true);\n  }\n catch (  IOException e) {\n    return false;\n  }\n}\n", "nl": "is file acceptable?"}
{"code": "private void typeAlphabetic(char c){\n  if (Character.isUpperCase(c)) {\n    controller.keyPress(KeyEvent.VK_SHIFT);\n  }\n  controller.keyPress(Character.toUpperCase(c));\n  controller.keyRelease(Character.toUpperCase(c));\n  if (Character.isUpperCase(c)) {\n    controller.keyRelease(KeyEvent.VK_SHIFT);\n  }\n}\n", "nl": "Type an alphabetic latin character"}
{"code": "private void changeSize(float targetSize,float parentSize,View targetView){\n  ViewGroup.LayoutParams params=targetView.getLayoutParams();\n  if (targetSize != 0.0f) {\n    params.width=(int)targetSize;\n    params.height=(int)targetSize;\n  }\n else {\n    if (parentSize != 0.0f) {\n      params.width=(int)parentSize;\n      params.height=(int)parentSize;\n    }\n  }\n  targetView.setLayoutParams(params);\n}\n", "nl": "ChangeSize of target view"}
{"code": "protected static void deleteRecursiveSilent(CarbonFile f){\n  if (f.isDirectory()) {\n    if (f.listFiles() != null) {\n      for (      CarbonFile c : f.listFiles()) {\n        deleteRecursiveSilent(c);\n      }\n    }\n  }\n  if (f.exists() && !f.delete()) {\n    return;\n  }\n}\n", "nl": "this method will delete the folders recursively"}
{"code": "private int[][] computePercentileLimits(int[] sample,int resamplingSize,int repeats,double leftValue,double rightValue) throws CanceledException {\n  int length=sample.length;\n  int[][] diff=new int[repeats][length];\n  for (int i=0; i < repeats; i++) {\n    int[] N1=getRandomSample(sample,resamplingSize);\n    int[] N2=getRandomSample(sample,resamplingSize);\n    diff[i]=getAbsoluteDifference(N1,N2);\n  }\n  int[][] p5_95=new int[length][3];\n  for (int i=0; i < length; i++) {\n    int[] diff_i=extractRow(diff,i);\n    p5_95[i]=getPercentileInterval(diff_i,leftValue,rightValue);\n  }\n  return p5_95;\n}\n", "nl": "here we compare a sample with it self and compute the left-value and right-value percentile limits"}
{"code": "private void bindViews(){\n  contentRoot=findViewById(R.id.contentRoot);\n  edMessage=(EmojiconEditText)findViewById(R.id.editTextMessage);\n  btSendMessage=(ImageView)findViewById(R.id.buttonMessage);\n  btSendMessage.setOnClickListener(this);\n  btEmoji=(ImageView)findViewById(R.id.buttonEmoji);\n  emojIcon=new EmojIconActions(this,contentRoot,edMessage,btEmoji);\n  emojIcon.ShowEmojIcon();\n  rvListMessage=(RecyclerView)findViewById(R.id.messageRecyclerView);\n  mLinearLayoutManager=new LinearLayoutManager(this);\n  mLinearLayoutManager.setStackFromEnd(true);\n}\n", "nl": "Vincular views com Java API"}
{"code": "public static String removePackageName(String fully_qualified_name_){\n  if (fully_qualified_name_ == null)   return null;\n  int lastdot=fully_qualified_name_.lastIndexOf('.');\n  if (lastdot < 0) {\n    return \"\";\n  }\n else {\n    return fully_qualified_name_.substring(lastdot + 1);\n  }\n}\n", "nl": "Remove the package name from a fully qualified class name"}
{"code": "public String putImage(String theFolder,String theImageName,Bitmap theBitmap){\n  if (theFolder == null || theImageName == null || theBitmap == null)   return null;\n  this.DEFAULT_APP_IMAGEDATA_DIRECTORY=theFolder;\n  String mFullPath=setupFullPath(theImageName);\n  if (!mFullPath.equals(\"\")) {\n    lastImagePath=mFullPath;\n    saveBitmap(mFullPath,theBitmap);\n  }\n  return mFullPath;\n}\n", "nl": "Saves 'theBitmap' into folder 'theFolder' with the name 'theImageName'"}
{"code": "public static void drawTransparentString(String text,int xPos,int yPos,int transparency,boolean shadow){\n  if (transparency > 100 || transparency < 0)   throw new IllegalArgumentException(\"Transparency can not be \" + transparency + \"%\");\n  int i=0xF | (int)((transparency / 100d) * 255) << 24;\n  getGlStateManager().pushMatrix();\n  getGlStateManager().enableBlend();\n  if (shadow) {\n    getFontRendererObjHandler().drawStringWithShadow(text,xPos,yPos,i);\n  }\n else {\n    getFontRendererObjHandler().drawString(text,xPos,yPos,i);\n  }\n  getGlStateManager().disableAlpha();\n  getGlStateManager().disableBlend();\n  getGlStateManager().popMatrix();\n}\n", "nl": "Draws a text with the given transparency"}
{"code": "public static void cleanup(FileSystem fs,String dataSchemasProp,String querySchemasProp,String stopListProp) throws Exception {\n  Inputs.deleteESInput();\n  fs.close();\n  SystemConfiguration.setProperty(\"pir.stopListFile\",stopListProp);\n  if (!dataSchemasProp.equals(\"none\")) {\n    DataSchemaLoader.initialize();\n  }\n  if (!querySchemasProp.equals(\"none\")) {\n    QuerySchemaLoader.initialize();\n  }\n}\n", "nl": "Delete all necessary inputs, clean up"}
{"code": "protected TableViewer createTable(Composite parent,int span){\n  Table table=new Table(parent,SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER| SWT.SINGLE| SWT.FULL_SELECTION);\n  GridData data=new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL);\n  data.horizontalSpan=span;\n  table.setLayoutData(data);\n  TableLayout layout=new TableLayout();\n  layout.addColumnData(new ColumnWeightData(100,true));\n  table.setLayout(layout);\n  TableColumn col=new TableColumn(table,SWT.NONE);\n  col.setResizable(true);\n  return new TableViewer(table);\n}\n", "nl": "Creates the table for the repositories"}
{"code": "public void clearPaymentMethodsById(List<String> paymentMethodIdsToRemove){\n  if (UtilValidate.isEmpty(paymentMethodIdsToRemove))   return;\n  for (Iterator<CartPaymentInfo> iter=paymentInfo.iterator(); iter.hasNext(); ) {\n    CartPaymentInfo info=iter.next();\n    if (paymentMethodIdsToRemove.contains(info.paymentMethodId)) {\n      iter.remove();\n    }\n  }\n}\n", "nl": "remove all the paymentMethods based on the paymentMethodIds"}
{"code": "public static File[] sortLocalFolder(File[] files){\nswitch (mSortOrder) {\ncase 0:\n    files=FileStorageUtils.sortLocalFilesByName(files);\n  break;\ncase 1:\nfiles=FileStorageUtils.sortLocalFilesByDate(files);\nbreak;\ncase 2:\nfiles=FileStorageUtils.sortLocalFilesBySize(files);\nbreak;\n}\nreturn files;\n}\n", "nl": "Sorts all filenames, regarding last user decision"}
{"code": "public void reportContigStats(){\n  if (contigs.size() == 0) {\n    System.err.println(String.format(\"Contigs:%,9d\",0));\n  }\n else {\n    final int[] sizes=new int[contigs.size()];\n    int pos=0;\n    for (    Pair<String,String> pair : contigs) {\n      sizes[pos++]=pair.getSecond().length();\n    }\n    Arrays.sort(sizes);\n    System.err.println(String.format(\"Contigs:%,9d\",sizes.length));\n    System.err.println(String.format(\"Min len:%,9d\",sizes[0]));\n    System.err.println(String.format(\"Med len:%,9d\",sizes[sizes.length / 2]));\n    System.err.println(String.format(\"Max len:%,9d\",sizes[sizes.length - 1]));\n  }\n}\n", "nl": "report contigs stats"}
{"code": "public boolean isFileSystemCaseSensitive(){\n  File dir=new File(\".\");\n  File[] files=dir.listFiles();\n  if (files == null)   return false;\n  for (  File file : files) {\n    if (file.isFile()) {\n      String lowerCaseFilePath=file.getAbsolutePath().toLowerCase();\n      String upperCaseFilePath=file.getAbsolutePath().toUpperCase();\n      File lowerCaseFile=new File(lowerCaseFilePath);\n      File upperCaseFile=new File(upperCaseFilePath);\n      if (!(lowerCaseFile.exists() && upperCaseFile.exists())) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "An naive approach to check whether the file system is case sensitive or not"}
{"code": "public void initComponents() throws SpaceComponentsInitializeException {\n  try {\n    SpaceInitializationIndicator.setInitializer();\n    initPrimaryOnlyComponents();\n    initBackupComponents();\n  }\n  finally {\n    SpaceInitializationIndicator.unsetInitializer();\n  }\n}\n", "nl": "Initialize all space components"}
{"code": "public Map<String,Object> finalizeOrderEntryShip(int shipGroupIndex,String shippingContactMechId,String supplierPartyId){\n  Map<String,Object> result;\n  String errMsg=null;\n  if (UtilValidate.isNotEmpty(shippingContactMechId)) {\n    this.cart.setShippingContactMechId(shipGroupIndex,shippingContactMechId);\n    if (UtilValidate.isNotEmpty(supplierPartyId)) {\n      this.cart.setSupplierPartyId(shipGroupIndex,supplierPartyId);\n    }\n    result=ServiceUtil.returnSuccess();\n  }\n else {\n    errMsg=UtilProperties.getMessage(resource_error,\"checkhelper.enter_shipping_address\",(cart != null ? cart.getLocale() : Locale.getDefault()));\n    result=ServiceUtil.returnError(errMsg);\n  }\n  return result;\n}\n", "nl": "Sets the shipping contact mechanism for a given ship group on the cart"}
{"code": "public void performQuery(JavaDStream<MapWritable> input){\n  logger.info(\"Performing query: \");\n  if (!useQueueStream) {\n    input.window(Durations.seconds(windowLength),Durations.seconds(windowLength));\n  }\n  JavaPairDStream<Integer,List<BigInteger>> selectorHashToDocRDD=input.mapToPair(new HashSelectorsAndPartitionData(bVars));\n  JavaPairDStream<Integer,Iterable<List<BigInteger>>> selectorGroupRDD=selectorHashToDocRDD.groupByKey();\n  JavaPairDStream<Long,BigInteger> encRowRDD=selectorGroupRDD.flatMapToPair(new EncRowCalc(accum,bVars));\n  encryptedColumnCalc(encRowRDD);\n  start();\n}\n", "nl": "Method to perform the query given an input JavaDStream of JSON"}
{"code": "private void generateBroadcastReceiverLifecycle(Set<String> entryPoints,SootClass currentClass,JNopStmt endClassStmt,Local classLocal){\n  createIfStmt(endClassStmt);\n  Stmt onReceiveStmt=searchAndBuildMethod(AndroidEntryPointConstants.BROADCAST_ONRECEIVE,currentClass,entryPoints,classLocal);\n  JNopStmt startWhileStmt=new JNopStmt();\n  JNopStmt endWhileStmt=new JNopStmt();\n  body.getUnits().add(startWhileStmt);\n  createIfStmt(endWhileStmt);\n  boolean hasAdditionalMethods=false;\n  if (modelAdditionalMethods) {\n    for (    SootMethod currentMethod : currentClass.getMethods())     if (entryPoints.contains(currentMethod.toString()))     hasAdditionalMethods|=createPlainMethodCall(classLocal,currentMethod);\n  }\n  addCallbackMethods(currentClass);\n  body.getUnits().add(endWhileStmt);\n  if (hasAdditionalMethods)   createIfStmt(startWhileStmt);\n  createIfStmt(onReceiveStmt);\n}\n", "nl": "Generates the lifecycle for an Android broadcast receiver class"}
{"code": "public static void loadInstalledVersions(){\n  IAndroidTarget[] targets=getCompilationTargets();\n  IAndroidTarget highestInstalledTarget=null;\n  ourInstalledVersions.clear();\n  for (  IAndroidTarget target : targets) {\n    if (target.isPlatform() && target.getVersion().getFeatureLevel() >= SdkVersionInfo.LOWEST_COMPILE_SDK_VERSION && (highestInstalledTarget == null || target.getVersion().getFeatureLevel() > highestInstalledTarget.getVersion().getFeatureLevel() && !target.getVersion().isPreview())) {\n      highestInstalledTarget=target;\n    }\n    if (target.getVersion().isPreview() || !target.getAdditionalLibraries().isEmpty()) {\n      AndroidTargetComboBoxItem targetInfo=new AndroidTargetComboBoxItem(target);\n      ourInstalledVersions.add(targetInfo.target.getVersion());\n    }\n  }\n  ourHighestInstalledApiTarget=highestInstalledTarget;\n}\n", "nl": "Load the installed android versions from the SDK"}
{"code": "private void createFormal(polyglot.ast.Formal formal,int counter){\n  soot.Type sootType=Util.getSootType(formal.type().type());\n  soot.Local formalLocal=createLocal(formal.localInstance());\n  soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(sootType,counter);\n  paramRefCount++;\n  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(formalLocal,paramRef);\n  body.getUnits().add(stmt);\n  Util.addLnPosTags(((soot.jimple.IdentityStmt)stmt).getRightOpBox(),formal.position());\n  Util.addLnPosTags(stmt,formal.position());\n}\n", "nl": "Formal creation - method parameters"}
{"code": "public Item(int objId,ItemTemplate itemTemplate){\n  super(objId);\n  this.itemTemplate=itemTemplate;\n  this.activationCount=itemTemplate.getActivationCount();\n  if (itemTemplate.getExpireTime() != 0) {\n    expireTime=((int)(System.currentTimeMillis() / 1000) + itemTemplate.getExpireTime() * 60) - 1;\n  }\n  int optionSlotBonus=itemTemplate.getOptionSlotBonus();\n  if (optionSlotBonus != 0) {\n    optionalSocket=-1;\n  }\n  this.persistentState=PersistentState.NEW;\n  updateChargeInfo(0);\n}\n", "nl": "Create simple item with minimum information"}
{"code": "public void clear(){\n  creationDate=null;\n  sampleNames.clear();\n  blastModes.clear();\n  sampleSizes.clear();\n  sampleUIds.clear();\n  disabledSamples.clear();\n  totalReads=0;\n  additionalReads=0;\n  classification2collapsedIds.clear();\n  classification2NodeStyle.clear();\n  classification2algorithm.clear();\n  classification2NodeFormats.clear();\n  classification2EdgeFormats.clear();\n  parameters=null;\n  classification2class2counts.clear();\n}\n", "nl": "erase the summary block"}
{"code": "static float max(float[][] array,int[] result){\n  int max1=0;\n  int max2=0;\n  float val=array[max1][max2];\n  for (int i=0; i < array.length; i++) {\n    for (int j=0; j < array[0].length; j++) {\n      if (val < array[i][j]) {\n        max1=i;\n        max2=j;\n        val=array[max1][max2];\n      }\n    }\n  }\n  result[0]=max1;\n  result[1]=max2;\n  return val;\n}\n", "nl": "Calculate the maximum of a 2D array"}
{"code": "public static void expandDigits(String numberString,WordRelation wordRelation){\n  int numberDigits=numberString.length();\n  for (int i=0; i < numberDigits; i++) {\n    char digit=numberString.charAt(i);\n    if (isDigit(digit)) {\n      wordRelation.addWord(digit2num[numberString.charAt(i) - '0']);\n    }\n else {\n      wordRelation.addWord(\"umpty\");\n    }\n  }\n}\n", "nl": "Expands given token to list of words pronouncing it as digits"}
{"code": "private void initialize() throws IOException, ConnectionException {\n  if (!getDriver().isKeyspaceInitialized()) {\n    getDriver().initializeKeyspace();\n  }\n  LOGGER.info(\"Mutating schema\");\n  Plan.Result<Integer> result=getMutagen().mutate(getDriver().getKeyspace());\n  State<Integer> state=result.getLastState();\n  if (result.isMutationComplete()) {\n    LOGGER.info(\"Schema mutation complete. Final state: {}\",state != null ? state.getID() : \"null\");\n  }\n  if (result.getException() != null) {\n    String message=\"Exception mutating schema \" + \"(last state: \" + (state != null ? state.getID() : \"null\") + \", completed mutations: \\\"\"+ result.getCompletedMutations()+ \"\\\", remaining mutations: \\\"\"+ result.getRemainingMutations()+ \"\\\")\";\n    LOGGER.error(message,result.getException());\n    throw new IOException(message,result.getException());\n  }\n}\n", "nl": "Initialize the keyspace using Mutagen"}
{"code": "public static void showProfile(android.support.v4.app.Fragment fragment,String pilotId,@Nullable HashMap<String,String> extras){\n  if ((pilotId == null || pilotId.isEmpty()) && AirMap.hasValidAuthenticatedUser()) {\n    pilotId=AirMap.getUserId();\n  }\n  Intent intent=new Intent(fragment.getContext(),ProfileActivity.class);\n  intent.putExtra(ProfileActivity.ARG_PILOT_ID,pilotId);\n  if (extras != null) {\n    intent.putExtra(CreateFlightActivity.KEY_VALUE_EXTRAS,extras);\n  }\n  fragment.startActivity(intent);\n}\n", "nl": "Display the authenticated pilot's profile"}
{"code": "public SampleSet(DataInputStream is) throws IOException {\n  int numSamples;\n  sampleInfo=new SampleInfo(is);\n  numSamples=is.readInt();\n  this.samples=new Sample[numSamples];\n  for (int i=0; i < numSamples; i++) {\n    samples[i]=Sample.loadBinary(is);\n  }\n}\n", "nl": "Creates a SampleSet by reading it from the given input stream"}
{"code": "public void clear(){\n  uid=0;\n  readHeader=null;\n  readSequence=null;\n  readWeight=1;\n  mateReadUId=0;\n  mateType=0;\n  readLength=0;\n  complexity=0;\n  numberOfMatches=0;\n  matchBlocks=new MatchBlockRMA2[0];\n}\n", "nl": "erase the block  (for reuse)"}
{"code": "@Override public void stop() throws ConnectException {\n  fLog.trace(\"Stopping\");\n  try {\n    iWriter.close();\n  }\n catch (  IOException exception) {\n    throw new ConnectException(exception);\n  }\n}\n", "nl": "Stop the sink task"}
{"code": "public void testWriteReadFull() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(clusterPolicy);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  ClusterPolicy copy=(ClusterPolicy)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(clusterPolicy,copy));\n}\n", "nl": "Test read and write full ClusterPolicy object"}
{"code": "private boolean isSuccess(final Player player,final Item parentItem,final Item targetItem,final Item supplementItem,final int targetWeapon){\n  if (parentItem.getItemTemplate() != null) {\n    ItemTemplate itemTemplate=parentItem.getItemTemplate();\n    if (itemTemplate.getCategory() == ItemCategory.ENCHANTMENT || itemTemplate.getCategory() == ItemCategory.AMPLIFICATION || (parentItem.getItemTemplate().getCategory() == targetItem.getItemTemplate().getCategory() && itemTemplate.getCategory() == ItemCategory.STIGMA)) {\n      return EnchantService.enchantItem(player,parentItem,targetItem,supplementItem);\n    }\n    return EnchantService.socketManastone(player,parentItem,targetItem,supplementItem,targetWeapon);\n  }\n  return false;\n}\n", "nl": "Check, if the item enchant will be successful"}
{"code": "@Override protected float evaluate(Target target) throws Exception {\n  assert target != null;\n  float[] result=null;\n  try {\n    result=(float[])cart.interpret(target);\n  }\n catch (  IllegalArgumentException e) {\n    throw new Exception(\"Could not interpret target '\" + target + \"'\",e);\n  }\n  float value=0;\n  try {\n    value=result[1];\n  }\n catch (  ArrayIndexOutOfBoundsException e) {\n    throw new Exception(\"Could not handle predicted value: '\" + value + \"'\",e);\n  }\n  return value;\n}\n", "nl": "Apply the CART to a Target to get its predicted value"}
{"code": "private void updateCovarianceDiagonalOnly(boolean hsig,final RealMatrix bestArz){\n  double oldFac=hsig ? 0 : ccov1Sep * cc * (2 - cc);\n  oldFac+=1 - ccov1Sep - ccovmuSep;\n  diagC=diagC.scalarMultiply(oldFac).add(square(pc).scalarMultiply(ccov1Sep)).add((times(diagC,square(bestArz).multiply(weights))).scalarMultiply(ccovmuSep));\n  diagD=sqrt(diagC);\n  if (diagonalOnly > 1 && iterations > diagonalOnly) {\n    diagonalOnly=0;\n    B=eye(dimension,dimension);\n    BD=diag(diagD);\n    C=diag(diagC);\n  }\n}\n", "nl": "Update of the covariance matrix C for diagonalOnly > 0"}
{"code": "public List<LocalDate> bottom(int n){\n  List<LocalDate> bottom=new ArrayList<>();\n  int[] values=data.toIntArray();\n  IntArrays.parallelQuickSort(values);\n  for (int i=0; i < n && i < values.length; i++) {\n    bottom.add(PackedLocalDate.asLocalDate(values[i]));\n  }\n  return bottom;\n}\n", "nl": "Returns the smallest (\"bottom\") n values in the column"}
{"code": "public void bind(Activity activity){\n  List<IBinding> bindings=getViewBinder(activity).bind(activity);\n  for (  IBinding binding : bindings) {\n    Topping topping=getOrCreateTopping(binding.getToppingId());\n    autoUpdateBinding(binding,topping);\n  }\n  Set<IBinding> _bindings=getBindings(activity.getClass());\n  _bindings.addAll(bindings);\n}\n", "nl": "Bind all the annotated elements to a given activity"}
{"code": "public ImageIcon loadImage(String imageName){\n  try {\n    ClassLoader classloader=getClass().getClassLoader();\n    java.net.URL url=classloader.getResource(imageName);\n    if (url != null) {\n      ImageIcon icon=new ImageIcon(url);\n      return icon;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  throw new IllegalArgumentException(\"Unable to load image: \" + imageName);\n}\n", "nl": "Helper method to load an image file from the CLASSPATH"}
{"code": "public static <T>T readObjectFromFile(String path,Class<T> type,SparkContext sc) throws IOException {\n  FileSystem fileSystem=FileSystem.get(sc.hadoopConfiguration());\n  try (ObjectInputStream ois=new ObjectInputStream(new BufferedInputStream(fileSystem.open(new Path(path))))){\n    Object o;\n    try {\n      o=ois.readObject();\n    }\n catch (    ClassNotFoundException e) {\n      throw new RuntimeException(e);\n    }\n    return (T)o;\n  }\n }\n", "nl": "Read an object from HDFS (or local) using default Java object serialization"}
{"code": "public Builder merge(final Property property){\n  if (property.getter != null) {\n    getter=property.getter;\n    getterMethod=null;\n  }\n  if (property.setter != null) {\n    setter=property.setter;\n    setterMethod=null;\n  }\n  if (elementType == null || (property.elementType != null && elementType.isAssignableFrom(property.elementType))) {\n    elementType=property.elementType;\n  }\n  if (propertyType == null || (property.type != null && propertyType.isAssignableFrom(property.type))) {\n    propertyType=property.type;\n  }\n  name=property.name;\n  return this;\n}\n", "nl": "Merges the attributes of the specified property into this one"}
{"code": "public static ByteBuffer processOutboundPackage(ByteBuffer roData,int exchangeId,boolean connectionOk){\n  roData.rewind();\n  if (BuildConfig.DEBUG) {\n    XposedBridge.log(\"Processing outbound package of size \" + Integer.toString(roData.remaining()));\n  }\n  try {\nsynchronized (sync) {\n    }\n  }\n catch (  Throwable e) {\n    XposedBridge.log(e);\n  }\n  return null;\n}\n", "nl": "Processes single package going from client to server roData is created by allocate and had to have array"}
{"code": "public static boolean calculatePhysicalParryRate(Creature attacker,Creature attacked){\n  if (attacked.getObserveController().checkAttackStatus(AttackStatus.PARRY)) {\n    return true;\n  }\n  float accuracy=attacker.getGameStats().getMainHandPAccuracy().getCurrent();\n  float parry=0;\n  if (attacked instanceof Player) {\n    parry=attacked.getGameStats().getParry().getBonus() + getMovementModifier(attacked,StatEnum.PARRY,attacked.getGameStats().getParry().getBase()) + attacked.getGameStats().getStat(StatEnum.PVP_PARRY,0).getCurrent();\n  }\n else {\n    parry=attacked.getGameStats().getParry().getBonus() + getMovementModifier(attacked,StatEnum.PARRY,attacked.getGameStats().getParry().getBase());\n  }\n  float parryRate=parry - accuracy;\n  return calculatePhysicalEvasion(parryRate,400);\n}\n", "nl": "Calculates PARRY chance"}
{"code": "public CreateSiteWindow fillLiveCopy(String siteOwner,boolean liveCopy,List<String> rollOutConfigs){\n  ownerDropDown.selectByText(siteOwner);\n  WebElement checkBox=currentWindow.findElement(By.name(\"isLiveCopy\"));\n  if (!liveCopy) {\n    checkBox.click();\n  }\n  for (  String config : rollOutConfigs) {\n    currentWindow.findElement(By.xpath(\"//span[text()='Add Item']\")).click();\n    List<WebElement> inputs=currentWindow.findElements(By.xpath(\"//img[@src='/libs/cq/ui/resources/0.gif']\"));\n    inputs.get(inputs.size() - 1).click();\n    List<WebElement> options=currentWindow.findElements(By.xpath(\"//div[text()='\" + config + \"']\"));\n    options.stream().filter(null).forEach(null);\n  }\n  return this;\n}\n", "nl": "Fill data on Live copy view"}
{"code": "public void showUntrustedCertDialog(RemoteOperationResult result){\n  FragmentManager fm=getSupportFragmentManager();\n  SslUntrustedCertDialog dialog=(SslUntrustedCertDialog)fm.findFragmentByTag(DIALOG_UNTRUSTED_CERT);\n  if (dialog == null) {\n    dialog=SslUntrustedCertDialog.newInstanceForFullSslError((CertificateCombinedException)result.getException());\n    FragmentTransaction ft=fm.beginTransaction();\n    dialog.show(ft,DIALOG_UNTRUSTED_CERT);\n  }\n}\n", "nl": "Show untrusted cert dialog"}
{"code": "public AuthSignupQuery(VkApiClient client,UserActor actor,String firstName,String lastName,int clientId,String clientSecret,String phone){\n  super(client,\"auth.signup\",SignupResponse.class);\n  accessToken(actor.getAccessToken());\n  firstName(firstName);\n  lastName(lastName);\n  clientId(clientId);\n  clientSecret(clientSecret);\n  phone(phone);\n}\n", "nl": "Creates a AbstractQueryBuilder instance that can be used to build api request with various parameters"}
{"code": "public void dump(){\n  System.out.println(\" FD Count: \" + getFrameData().length);\n  for (int i=0; i < getFrameData().length; i++) {\n    System.out.print(\" \" + getFrameData(i));\n  }\n  System.out.println();\n  System.out.println(\" RD Count: \" + getResidualSize());\n  for (int i=0; i < getResidualData().length; i++) {\n    System.out.print(\" \" + getResidualData(i));\n  }\n  System.out.println();\n}\n", "nl": "Dumps the sample:"}
{"code": "private void buildViewForMeasuring(){\n  if (itemsLayout != null) {\n    recycle.recycleItems(itemsLayout,firstItem,new ItemsRange());\n  }\n else {\n    createItemsLayout();\n  }\n  int addItems=visibleItems / 2;\n  for (int i=currentItem + addItems; i >= currentItem - addItems; i--) {\n    if (addViewItem(i,true)) {\n      firstItem=i;\n    }\n  }\n}\n", "nl": "Builds view for measuring"}
{"code": "private int measureHeight(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=mPaintSelected.getStrokeWidth() + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)Math.ceil(result);\n}\n", "nl": "Determines the height of this view"}
{"code": "public boolean isDirectDictionaryColumns(){\n  List<ColumnExpression> listOfExp=new ArrayList<ColumnExpression>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n  getColumnList(this,listOfExp);\n  for (  ColumnExpression ce : listOfExp) {\n    if (!ce.getCarbonColumn().hasEncoding(Encoding.DICTIONARY)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "the method will return flag (true or false) depending on the existence of the direct dictionary columns in conditional expression"}
{"code": "protected void moveToUnusable(){\n  try {\n    _space.stopInternal();\n  }\n catch (  SpaceAlreadyStoppedException e) {\n  }\ncatch (  RemoteException e) {\n  }\n}\n", "nl": "Change space state to UNHEALTHY, so it is redeployed"}
{"code": "public static int[] shuffle(int[] intArray,int shuffleCount){\n  int length;\n  if (intArray == null || shuffleCount < 0 || (length=intArray.length) < shuffleCount) {\n    return null;\n  }\n  int[] out=new int[shuffleCount];\n  for (int i=1; i <= shuffleCount; i++) {\n    int random=getRandom(length - i);\n    out[i - 1]=intArray[random];\n    int temp=intArray[length - i];\n    intArray[length - i]=intArray[random];\n    intArray[random]=temp;\n  }\n  return out;\n}\n", "nl": "Shuffling algorithm, Randomly permutes the specified int array"}
{"code": "public Class toClass(String codebase) throws IOException, ClassNotFoundException {\n  if (name.charAt(0) != ';') {\n    return ClassLoading.loadClass(codebase,name,null,integrity,null);\n  }\n  StringTokenizer st=new StringTokenizer(name,\";\");\n  String[] ifs=new String[st.countTokens()];\n  for (int i=0; i < ifs.length; i++) {\n    ifs[i]=st.nextToken();\n  }\n  return ClassLoading.loadProxyClass(codebase,ifs,null,integrity,null);\n}\n", "nl": "Converts this descriptor to a Class instance, loading from codebase"}
{"code": "static void printField(){\n  for (int y=0; y <= field_size; y++) {\n    System.out.print(y);\n  }\n  System.out.println();\n  for (int y=0; y < field_size; y++) {\n    System.out.print(y + 1);\n    for (int x=0; x < field_size; x++) {\n      System.out.print(field[x][y]);\n    }\n    System.out.println();\n  }\n}\n", "nl": "Displays of the playing field"}
{"code": "private boolean handleMotionEvent(WXGestureType WXGestureType,MotionEvent motionEvent){\n  if (component.containsGesture(WXGestureType)) {\n    List<Map<String,Object>> list=createFireEventParam(motionEvent);\n    for (    Map<String,Object> map : list) {\n      WXSDKManager.getInstance().fireEvent(component.mInstanceId,component.mDomObj.ref,WXGestureType.toString(),map);\n    }\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Handle low-level gesture"}
{"code": "private QueryAnswers materialiseComplete(){\n  QueryAnswers insertAnswers=new QueryAnswers();\n  if (getAtoms().stream().filter(null).collect(Collectors.toSet()).size() < getVarSet().size())   throw new IllegalStateException(ErrorMessage.MATERIALIZATION_ERROR.getMessage(getMatchQuery().toString()));\n  if (!getMatchQuery().ask().execute()) {\n    InsertQuery insert=Graql.insert(getPattern().getVars()).withGraph(graph);\n    insert.stream().filter(null).forEach(null);\n  }\n  return insertAnswers;\n}\n", "nl": "materialise the query provided all variables are mapped"}
{"code": "protected int parseInt(String buffer,int start,int end) throws NumberFormatException {\n  int radix=10;\n  int result=0;\n  int digit=0;\n  int limit=-Integer.MAX_VALUE;\n  int multmin=limit / radix;\n  int i=start;\n  do {\n    digit=getDigit(buffer.charAt(i));\n    if (digit < 0)     throw new NumberFormatException(\"'\" + buffer + \"' has wrong format\");\n    if (result < multmin)     throw new NumberFormatException(\"'\" + buffer + \"' has wrong format\");\n    result*=radix;\n    if (result < limit + digit)     throw new NumberFormatException(\"'\" + buffer + \"' has wrong format\");\n    result-=digit;\n  }\n while (++i < end);\n  return -result;\n}\n", "nl": "Given start and end position, parses string value"}
{"code": "public static String selectAgreement(HttpServletRequest request,HttpServletResponse response){\n  Delegator delegator=(Delegator)request.getAttribute(\"delegator\");\n  LocalDispatcher dispatcher=(LocalDispatcher)request.getAttribute(\"dispatcher\");\n  ShoppingCart cart=getCartObject(request);\n  ShoppingCartHelper cartHelper=new ShoppingCartHelper(delegator,dispatcher,cart);\n  String agreementId=request.getParameter(\"agreementId\");\n  Map<String,Object> result=cartHelper.selectAgreement(agreementId);\n  if (ServiceUtil.isError(result)) {\n    request.setAttribute(\"_ERROR_MESSAGE_\",ServiceUtil.getErrorMessage(result));\n    return \"error\";\n  }\n  return \"success\";\n}\n", "nl": "Assign agreement"}
{"code": "private static boolean parentHandlingSelection(@NotNull NlComponent component){\n  NlComponent parent=component.getParent();\n  if (parent == null) {\n    return false;\n  }\n  ViewInfo view=parent.viewInfo;\n  if (view == null) {\n    return false;\n  }\n  ViewHandler handler=parent.getViewHandler();\n  if (handler != null && handler instanceof ViewGroupHandler) {\n    ViewGroupHandler viewGroupHandler=(ViewGroupHandler)handler;\n    if (viewGroupHandler.handlesPainting()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Utility function that checks if the component is a child of a view group that handles painting"}
{"code": "public int[][][] fromFileMultipleChannels(File file) throws IOException {\n  BufferedImage image=ImageIO.read(file);\n  image=scalingIfNeed(image,channels > 3);\n  int w=image.getWidth(), h=image.getHeight();\n  int bands=image.getSampleModel().getNumBands();\n  int[][][] ret=new int[channels][h][w];\n  byte[] pixels=((DataBufferByte)image.getRaster().getDataBuffer()).getData();\n  for (int i=0; i < h; i++) {\n    for (int j=0; j < w; j++) {\n      for (int k=0; k < channels; k++) {\n        if (k >= bands)         break;\n        ret[k][i][j]=pixels[channels * w * i + channels * j + k];\n      }\n    }\n  }\n  return ret;\n}\n", "nl": "Load a rastered image from file"}
{"code": "private int countVisibleNodes(){\n  int count=0;\n  for (  NodeBase root : classification2RootNode.values()) {\n    Stack<NodeBase> stack=new Stack<>();\n    if (root != null) {\n      stack.push(root);\n      while (stack.size() > 0) {\n        NodeBase node=stack.pop();\n        if (dataTree.isVisible(new TreePath(node.getPath())))         count++;\n        for (int i=0; i < node.getChildCount(); i++) {\n          NodeBase child=(NodeBase)node.getChildAt(i);\n          stack.add(child);\n        }\n      }\n    }\n  }\n  return count;\n}\n", "nl": "count visible nodes"}
{"code": "public static <T>T toBlocking(Observable<T> observable) throws LoginFailedException, RemoteServerException {\n  try {\n    return observable.toBlocking().first();\n  }\n catch (  RuntimeException e) {\n    if (e.getCause() instanceof AsyncLoginFailedException) {\n      throw new LoginFailedException(e.getMessage(),e.getCause());\n    }\n    if (e.getCause() instanceof AsyncRemoteServerException) {\n      throw new RemoteServerException(e.getMessage(),e.getCause());\n    }\n    throw new AsyncPokemonGoException(\"Unknown exception occurred. \",e);\n  }\n}\n", "nl": "Convert an observable to the actual result, recovering the actual exception and throwing that"}
{"code": "public static String decodeQueryValue(String query){\n  String retString;\n  retString=replaceString(query,\"%25\",\"%\");\n  retString=replaceString(retString,\"%20\",\" \");\n  retString=replaceString(retString,\"%26\",\"&\");\n  retString=replaceString(retString,\"%3F\",\"?\");\n  retString=replaceString(retString,\"%3D\",\"=\");\n  return retString;\n}\n", "nl": "Decodes a single query value from an HTTP URL parameter, replacing %ASCII values with characters"}
{"code": "@Override public void createApplication(Application.Name applicationName){\n  final String CQL=\"insert into applicationList(app_name) values(?)\";\n  try {\n    getDriver().getKeyspace().prepareQuery(getKeyspace().applicationList_CF()).withCql(CQL).asPreparedStatement().withByteBufferValue(applicationName,ApplicationNameSerializer.get()).execute().getResult();\n  }\n catch (  Exception e) {\n    throw new RepositoryException(\"Unable to insert into top level application list: \\\"\" + applicationName.toString() + \"\\\"\"+ e);\n  }\n}\n", "nl": "Creates an application at top level"}
{"code": "public static int calculateConnectionServerCount(int vmcount){\n  Float f=(vmcount / (float)2000.00);\n  f=(float)Math.ceil(f);\n  if (f >= 5) {\n    f++;\n    f++;\n  }\n else {\n    f++;\n  }\n  final int i=f.intValue();\n  return i;\n}\n", "nl": "Calculate number of connection servers"}
{"code": "public static byte[] hexStringToBytes(String hexString){\n  if (hexString == null || hexString.equals(\"\")) {\n    return null;\n  }\n  hexString=hexString.toUpperCase();\n  int length=hexString.length() / 2;\n  char[] hexChars=hexString.toCharArray();\n  byte[] d=new byte[length];\n  for (int i=0; i < length; i++) {\n    int pos=i * 2;\n    d[i]=(byte)(charToByte(hexChars[pos]) << 4 | charToByte(hexChars[pos + 1]));\n  }\n  return d;\n}\n", "nl": "Convert hex string to byte[] "}
{"code": "public Matrix minusEquals(Matrix B){\n  checkMatrixDimensions(B);\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      A[i][j]=A[i][j] - B.A[i][j];\n    }\n  }\n  return this;\n}\n", "nl": "A = A - B"}
{"code": "public String parse(File file,JSON m){\n  try {\n    Template template=getTemplate(file);\n    if (template != null) {\n      StringWriter w=new StringWriter();\n      BufferedWriter writer=new BufferedWriter(w);\n      template.merge(new VelocityContext(m),writer);\n      writer.flush();\n      writer.close();\n      return w.toString();\n    }\n  }\n catch (  Exception e) {\n    log.error(e.getMessage(),e);\n  }\n  return null;\n}\n", "nl": "parse the file to string with the json"}
{"code": "private ExtractedItemsCollection selectItemByChance(Collection<ExtractedItemsCollection> itemsCollections){\n  float sumOfChances=calcSumOfChances(itemsCollections);\n  float currentSum=0f;\n  float rnd=(float)Rnd.get(0,(int)(sumOfChances - 1) * 1000) / 1000;\n  ExtractedItemsCollection selectedCollection=null;\n  for (  ExtractedItemsCollection collection : itemsCollections) {\n    currentSum+=collection.getChance();\n    if (rnd < currentSum) {\n      selectedCollection=collection;\n      break;\n    }\n  }\n  return selectedCollection;\n}\n", "nl": "Select only 1 item based on chance attributes"}
{"code": "private void flushAndRelease(){\n  final int flushResult=SimpleLame.flush(mp3Buffer);\n  if (flushResult > 0) {\n    try {\n      os.write(mp3Buffer,0,flushResult);\n    }\n catch (    final IOException e) {\n      Log.e(TAG,\"Lame flush error\");\n    }\n  }\n}\n", "nl": "Flush all data left in lame buffer to file"}
{"code": "public void draw(Canvas c,Rect bounds){\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mPaint.setColor(mCurrentColor);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n  if (mAlpha < 255) {\n    mCirclePaint.setColor(mBackgroundColor);\n    mCirclePaint.setAlpha(255 - mAlpha);\n    c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  }\n}\n", "nl": "Draw the progress spinner"}
{"code": "private static String parseRefSeqId(String aLine){\n  int pos=aLine.indexOf(IdParser.REFSEQ_TAG);\n  if (pos != -1) {\n    int start=pos + IdParser.REFSEQ_TAG.length();\n    int end=start;\n    while (end < aLine.length() && (Character.isLetterOrDigit(aLine.charAt(end)) || aLine.charAt(end) == '_'))     end++;\n    if (end > start)     return aLine.substring(start,end);\n  }\n  return null;\n}\n", "nl": "parses a Accession id"}
{"code": "private ArrayList<SootClass> createExceptions(polyglot.ast.ProcedureDecl procedure){\n  ArrayList<SootClass> exceptions=new ArrayList<SootClass>();\n  Iterator throwsIt=procedure.throwTypes().iterator();\n  while (throwsIt.hasNext()) {\n    polyglot.types.Type throwType=((polyglot.ast.TypeNode)throwsIt.next()).type();\n    exceptions.add(((soot.RefType)Util.getSootType(throwType)).getSootClass());\n  }\n  return exceptions;\n}\n", "nl": "creates soot exceptions from polyglot throws"}
{"code": "@OnClick(R.id.fab) public void onClick(){\n  appbar.setExpanded(true,false);\n  SharedPreferences.Editor editor=sharedPreferences.edit();\nswitch (getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK) {\ncase Configuration.UI_MODE_NIGHT_YES:\n    editor.putBoolean(SHARED_PREF_DAY,true);\n  break;\ncase Configuration.UI_MODE_NIGHT_NO:\neditor.putBoolean(SHARED_PREF_DAY,false);\nbreak;\n}\neditor.apply();\nsetDayNightMode(sharedPreferences.getBoolean(SHARED_PREF_DAY,true));\ngetWindow().setWindowAnimations(R.style.WindowAnimationFadeInOut);\nrecreate();\n}\n", "nl": "Toggle Night Mode"}
{"code": "private void doUpdateValues(final TagValueUpdate tagValueUpdate){\n  updateTagQuality(tagValueUpdate.getDataTagQuality());\n  alarms.clear();\n  alarms.addAll(tagValueUpdate.getAlarms());\n  description=tagValueUpdate.getDescription();\n  valueDescription=tagValueUpdate.getValueDescription();\n  serverTimestamp=tagValueUpdate.getServerTimestamp();\n  daqTimestamp=tagValueUpdate.getDaqTimestamp();\n  sourceTimestamp=tagValueUpdate.getSourceTimestamp();\n  tagValue=tagValueUpdate.getValue();\n  mode=tagValueUpdate.getMode();\n  simulated=tagValueUpdate.isSimulated();\n}\n", "nl": "Inner method for updating the all value fields from this <code>Tag</code> instance"}
{"code": "public void testFromStoredFieldsWithWeightExpression() throws Exception {\n  createAndStartIndex(\"storedsuggestexpr\");\n  send(\"registerFields\",\"{\" + \"fields: {text: {type: text, store: true, search: false},\" + \"negWeight: {type: float, sort: true},\"+ \"payload: {type: text, store: true, search: false}}}\");\n  send(\"addDocument\",\"{fields: {text: 'the cat meows', negWeight: -1, payload: 'payload1'}}\");\n  long indexGen=getLong(send(\"addDocument\",\"{fields: {text: 'the dog barks', negWeight: -2, payload: 'payload2'}}\"),\"indexGen\");\n  JSONObject result=send(\"buildSuggest\",\"{source: {searcher: {indexGen: \" + indexGen + \"}, suggestField: text, weightExpression: -negWeight, payloadField: payload}, class: 'AnalyzingSuggester', suggestName: 'suggest', analyzer: {tokenizer: Whitespace, tokenFilters: [LowerCase]}}\");\n  for (int i=0; i < 2; i++) {\n    result=send(\"suggestLookup\",\"{text: the, suggestName: suggest}\");\n    assertEquals(2,getInt(result,\"results[0].weight\"));\n    assertEquals(\"the dog barks\",get(result,\"results[0].key\"));\n    assertEquals(\"payload2\",get(result,\"results[0].payload\"));\n    assertEquals(1,getInt(result,\"results[1].weight\"));\n    assertEquals(\"the cat meows\",get(result,\"results[1].key\"));\n    assertEquals(\"payload1\",get(result,\"results[1].payload\"));\n    bounceServer();\n    send(\"startIndex\");\n  }\n}\n", "nl": "Build a suggest, pulling suggestions/payloads from stored fields, and weight from an expression"}
{"code": "private ResultSet executeQuery(String query) throws SQLException {\n  if (m_stmt == null)   m_stmt=m_conn.createStatement();\n  long timein=System.currentTimeMillis();\n  s_logger.info(\"Issuing query: \" + query);\n  ResultSet rset=m_stmt.executeQuery(query);\n  long time=System.currentTimeMillis() - timein;\n  s_logger.info(\"External query processing completed: \" + (time / 1000) + \".\"+ (time % 1000)+ \" seconds.\");\n  return rset;\n}\n", "nl": "Execute a query and return the corresponding result set"}
{"code": "public void extendSelection(int toRow,int toCol){\n  if (toRow != -1) {\n    if (toRow > totalRows)     toRow=totalRows;\n    if (toRow < firstRow)     firstRow=toRow;\n else     if (toRow >= lastRow)     lastRow=toRow;\n  }\n  if (toCol != -1) {\n    if (toCol > totalCols)     toCol=totalCols;\n    if (toCol < firstCol)     firstCol=toCol;\n else     if (toCol >= lastCol)     lastCol=toCol;\n  }\n  fireSelectionChanged();\n}\n", "nl": "extend a selection"}
{"code": "public boolean isSystemApplication(Context context){\n  PackageManager packageManager=context.getPackageManager();\n  String packageName=context.getPackageName();\n  if (packageManager == null || packageName == null || packageName.length() == 0) {\n    return false;\n  }\n  try {\n    ApplicationInfo app=packageManager.getApplicationInfo(packageName,0);\n    return (app != null && (app.flags & ApplicationInfo.FLAG_SYSTEM) > 0);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  return false;\n}\n", "nl": "/ whether packageName is system application"}
{"code": "public static void loadCacheFromHDFS(FileSystem fs,String hdfsFileName,Query query) throws IOException {\n  logger.info(\"Loading cache from hdfsFileName = \" + hdfsFileName);\n  Path expPath=new Path(hdfsFileName);\n  try (BufferedReader br=new BufferedReader(new InputStreamReader(fs.open(expPath)))){\n    String line;\n    while ((line=br.readLine()) != null) {\n      String[] rowValTokens=line.split(\",\");\n      BigInteger base=query.getQueryElement(Integer.parseInt(rowValTokens[0]));\n      String[] expMod=rowValTokens[1].split(\"-\");\n      BigInteger exponent=new BigInteger(expMod[0]);\n      BigInteger value=new BigInteger(expMod[1]);\n      Tuple3<BigInteger,BigInteger,BigInteger> key=new Tuple3<>(base,exponent,query.getNSquared());\n      expCache.put(key,value);\n    }\n  }\n }\n", "nl": "Populate the cache based on the pre-generated exp table in hdfs"}
{"code": "public static void validate(SpaceURL spaceURL) throws Exception {\n  if (_logger.isLoggable(Level.FINE)) {\n    _logger.fine(\"attributesSpaceUrl  =  \" + spaceURL);\n  }\n  try {\n    validateURL(spaceURL);\n  }\n catch (  SpaceURLValidationException e) {\n    if (_logger.isLoggable(Level.FINE)) {\n      _logger.fine(\"Exception while validating space URL: \" + e.getMessage() + \"\\nSpace URL: \"+ spaceURL);\n    }\n    throw e;\n  }\n}\n", "nl": "The method is used for valid the space url before finding it from space"}
{"code": "@Override protected String dateToString(DateTimeData date){\n  StringBuffer message=new StringBuffer(6);\n  message.append('-');\n  message.append('-');\n  message.append('-');\n  append(message,date.day,2);\n  append(message,(char)date.utc,0);\n  return message.toString();\n}\n", "nl": "Converts gDay object representation to String"}
{"code": "public static void parse(PokemonGo api,RequestType requestType,ByteString data){\n  try {\nswitch (requestType) {\ncase GET_INVENTORY:\n      api.getInventories().updateInventories(GetInventoryResponse.parseFrom(data));\n    break;\ncase DOWNLOAD_SETTINGS:\n  api.getSettings().updateSettings(DownloadSettingsResponse.parseFrom(data));\nbreak;\ndefault :\nbreak;\n}\n}\n catch (InvalidProtocolBufferException e) {\nthrow new AsyncRemoteServerException(e);\n}\n}\n", "nl": "parse the response received during commonRequest"}
{"code": "public synchronized void resume(){\n  if (isPaused()) {\n    setPaused(false);\n    if (!isCancelled() && line != null) {\n      line.start();\n      notify();\n    }\n  }\n}\n", "nl": "Resumes audio output"}
{"code": "private void drawText(Canvas canvas,int index,Paint paint,String text){\n  if (isIllegalIndex(index)) {\n    return;\n  }\n  int x=getXByIndex(index);\n  int y=getYByIndex(index);\n  float top=cellHeight + (y - 1) * cellHeight;\n  float bottom=top + cellHeight;\n  float baseline=RenderUtil.getBaseline(top,bottom,paint);\n  float startX=RenderUtil.getStartX(cellWidth * (x - 1) + cellWidth * 0.5f,paint,text);\n  canvas.drawText(text,startX,baseline,paint);\n}\n", "nl": "draw text, around the middle of the cell decided by the index"}
{"code": "public static ArrayList<String> matches(String text,int results){\n  ArrayList<String> urls=new ArrayList<String>();\n  String[] splitString=(text.split(\" \"));\n  for (  String string : splitString) {\n    try {\n      URL item=new URL(string);\n      urls.add(item.toString());\n    }\n catch (    Exception e) {\n    }\n    if (results == FIRST && urls.size() > 0)     break;\n  }\n  return urls;\n}\n", "nl": "It finds urls inside the text and return the matched ones"}
{"code": "@Override public int next(){\n  try {\n    if (pairedReads)     reader.skipBytes(8);\n    readText=reader.readString();\n    final int numberOfMatches=reader.readInt();\n    reader.skipBytes(numberOfMatches * cNames.length * 4);\n    matchesText=reader.readString().getBytes();\n    matchesTextLength=matchesText.length;\n    return numberOfMatches;\n  }\n catch (  IOException ex) {\n    Basic.caught(ex);\n    return -1;\n  }\n}\n", "nl": "gets the next matches"}
{"code": "private void fixList(Node<E> t,Node<E> h){\n  Node<E> curNodeNext;\n  Node<E> curNode=t;\n  while (h == this.head && curNode != h) {\n    curNodeNext=curNode.getNext();\n    curNodeNext.setPrev(curNode);\n    curNode=curNode.getNext();\n  }\n}\n", "nl": "Fixing the backwards pointers when needed"}
{"code": "public void remove(String accountName){\n  Iterator<String> it=mMap.keySet().iterator();\n  while (it.hasNext()) {\n    String key=it.next();\n    Log_OC.d(\"IndexedForest\",\"Number of pending downloads= \" + mMap.size());\n    if (key.startsWith(accountName)) {\n      mMap.remove(key);\n    }\n  }\n}\n", "nl": "Remove the elements that contains account as a part of its key"}
{"code": "public JsonObject toJson(){\n  JsonObject json=new JsonObject();\n  json.put(\"path\",path);\n  if (method != null) {\n    json.put(\"method\",method.name());\n  }\n  if (headers != null && !headers.isEmpty()) {\n    json.put(\"headers\",toJsonArray(headers));\n  }\n  if (params != null && !params.isEmpty()) {\n    json.put(\"params\",toJsonArray(params));\n  }\n  if (formAttributes != null && !formAttributes.isEmpty()) {\n    json.put(\"formAttributes\",toJsonArray(formAttributes));\n  }\n  return json;\n}\n", "nl": "Convert this to JSON"}
{"code": "private void drawBackground(Canvas canvas){\n  canvas.save();\n  float dragPercent=Math.min(1f,Math.abs(mPercent));\n  float backgroundScale;\n  float scalePercentDelta=dragPercent - SCALE_START_PERCENT;\n  if (scalePercentDelta > 0) {\n    float scalePercent=scalePercentDelta / (1.0f - SCALE_START_PERCENT);\n    backgroundScale=BACKGROUND_INITIAL_SCALE - (BACKGROUND_INITIAL_SCALE - 1.0f) * scalePercent;\n  }\n else {\n    backgroundScale=BACKGROUND_INITIAL_SCALE;\n  }\n  canvas.scale(backgroundScale,backgroundScale,canvas.getWidth() / 2f,mParent.getTotalDragDistance() / 2f);\n  mConfig.getBackgroundDrawable().setBounds(0,0,canvas.getWidth(),mParent.getTotalDragDistance());\n  mConfig.getBackgroundDrawable().draw(canvas);\n  canvas.restore();\n}\n", "nl": "Background *"}
{"code": "@Override public void saveObject(Serializable oObj,String sObjectName,String sObjectCategory){\n  super.saveObject(oObj,sObjectName,sObjectCategory);\n  if (existsObject(sObjectCategory,ListCategoryName)) {\n    ArrayList<String> nlist=(ArrayList<String>)loadObject(sObjectCategory,ListCategoryName);\n    nlist.add(sObjectName);\n    super.saveObject(nlist,sObjectCategory,ListCategoryName);\n  }\n else {\n    ArrayList<String> nlist=new ArrayList<String>();\n    nlist.add(sObjectName);\n    super.saveObject(nlist,sObjectCategory,ListCategoryName);\n  }\n}\n", "nl": "save object with a given name"}
{"code": "private void validateRelation(RelationImpl relation){\n  if (!ValidateGlobalRules.validateRelationshipStructure(relation)) {\n    String roles=\"\";\n    String rolePlayers=\"\";\n    for (    Map.Entry<RoleType,Instance> entry : relation.rolePlayers().entrySet()) {\n      if (entry.getKey() != null)       roles=roles + entry.getKey().getId() + \",\";\n      if (entry.getValue() != null)       rolePlayers=rolePlayers + entry.getValue().getId() + \",\";\n    }\n    errorsFound.add(ErrorMessage.VALIDATION_RELATION.getMessage(relation.getId(),relation.type().getId(),roles.split(\",\").length,roles,rolePlayers.split(\",\").length,roles));\n  }\n}\n", "nl": "Validation rules exclusive to relations"}
{"code": "public void storeLegionEmblem(Player activePlayer,int legionId,int emblemId,int color_r,int color_g,int color_b,LegionEmblemType emblemType){\n  if (legionRestrictions.canStoreLegionEmblem(activePlayer,legionId,emblemId)) {\n    Legion legion=activePlayer.getLegion();\n    if (legion.getLegionEmblem().isDefaultEmblem()) {\n      addHistory(legion,\"\",LegionHistoryType.EMBLEM_REGISTER);\n    }\n else {\n      addHistory(legion,\"\",LegionHistoryType.EMBLEM_MODIFIED);\n    }\n    activePlayer.getInventory().decreaseKinah(LegionConfig.LEGION_EMBLEM_REQUIRED_KINAH);\n    legion.getLegionEmblem().setEmblem(emblemId,color_r,color_g,color_b,emblemType,null);\n    updateMembersEmblem(legion,emblemType);\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_CHANGE_EMBLEM);\n  }\n}\n", "nl": "Stores the new legion emblem"}
{"code": "private void createActionList(){\n  View view;\n  String title;\n  Drawable icon;\n  OnClickListener listener;\n  for (int i=0; i < actionList.size(); i++) {\n    title=actionList.get(i).getTitle();\n    icon=actionList.get(i).getIcon();\n    listener=actionList.get(i).getOnClickListerner();\n    view=getActionItem(title,icon,listener);\n    view.setFocusable(true);\n    view.setClickable(true);\n    mTrack.addView(view);\n  }\n}\n", "nl": "Create action list"}
{"code": "public static boolean exists(String collection,Bson query) throws SQLException {\n  TimeStamp t1=TimeStamp.create();\n  boolean b=false;\n  try {\n    b=MongoHelper.load(collection,query) != null;\n  }\n  finally {\n    if (log.isDebugEnabled())     log.debug(\"exists cost=\" + t1.past() + \"ms,  collection=\"+ collection+ \", query=\"+ query+ \", result=\"+ b);\n  }\n  return b;\n}\n", "nl": "test the data exists ?"}
{"code": "public SerialMessage clearAssociationMessage(int group){\n  logger.debug(\"NODE {}: Creating new message for application command ASSOCIATIONCMD_REMOVE group={}, node=all\",getNode().getNodeId(),group);\n  SerialMessage result=new SerialMessage(getNode().getNodeId(),SerialMessageClass.SendData,SerialMessageType.Request,SerialMessageClass.SendData,SerialMessagePriority.Config);\n  ByteArrayOutputStream outputData=new ByteArrayOutputStream();\n  outputData.write(getNode().getNodeId());\n  outputData.write(3);\n  outputData.write(getCommandClass().getKey());\n  outputData.write(ASSOCIATIONCMD_REMOVE);\n  outputData.write(group);\n  result.setMessagePayload(outputData.toByteArray());\n  return result;\n}\n", "nl": "Gets a SerialMessage with the ASSOCIATIONCMD_REMOVE command"}
{"code": "public void onFailure(int statusCode,Header[] headers,byte[] responseBody,Throwable error){\n  try {\n    String response=responseBody == null ? null : new String(responseBody,getCharset());\n    onFailure(statusCode,headers,error,response);\n  }\n catch (  UnsupportedEncodingException e) {\n    onFailure(statusCode,headers,e,null);\n  }\n}\n", "nl": "Fired when a request fails to complete, override to handle in your own code"}
{"code": "private ResultPoint[] centerEdges(ResultPoint y,ResultPoint z,ResultPoint x,ResultPoint t){\n  float yi=y.getX();\n  float yj=y.getY();\n  float zi=z.getX();\n  float zj=z.getY();\n  float xi=x.getX();\n  float xj=x.getY();\n  float ti=t.getX();\n  float tj=t.getY();\n  if (yi < width / 2.0f) {\n    return new ResultPoint[]{new ResultPoint(ti - CORR,tj + CORR),new ResultPoint(zi + CORR,zj + CORR),new ResultPoint(xi - CORR,xj - CORR),new ResultPoint(yi + CORR,yj - CORR)};\n  }\n else {\n    return new ResultPoint[]{new ResultPoint(ti + CORR,tj + CORR),new ResultPoint(zi + CORR,zj - CORR),new ResultPoint(xi - CORR,xj + CORR),new ResultPoint(yi - CORR,yj - CORR)};\n  }\n}\n", "nl": "recenters the points of a constant distance towards the center"}
{"code": "private static boolean isVerticallyConstrained(ConstraintWidget widget){\n  if (widget.getAnchor(ConstraintAnchor.Type.BOTTOM).isConnected()) {\n    return true;\n  }\n  if (widget.getAnchor(ConstraintAnchor.Type.TOP).isConnected()) {\n    return true;\n  }\n  if (widget.getAnchor(ConstraintAnchor.Type.BASELINE).isConnected()) {\n    return true;\n  }\n  return false;\n}\n", "nl": "true if top bottom or baseline are connected"}
{"code": "public static boolean isTomorrow(Calendar _calendar){\n  Calendar now=Calendar.getInstance();\n  if ((now.get(Calendar.DAY_OF_MONTH) + 1) == _calendar.get(Calendar.DAY_OF_MONTH)) {\n    if (now.get(Calendar.MONTH) == _calendar.get(Calendar.MONTH)) {\n      if (now.get(Calendar.YEAR) == _calendar.get(Calendar.YEAR)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Allows to know if a given calendar instance is set Today+1 (Tomorrow)"}
{"code": "private Relation addNewRolePlayer(Map<RoleType,Instance> roleMap,RoleType roleType,Instance instance){\n  if (instance != null)   mindmapsGraph.putCasting((RoleTypeImpl)roleType,(InstanceImpl)instance,this);\n  if (mindmapsGraph.isBatchLoadingEnabled()) {\n    setHash(null);\n  }\n else {\n    setHash(roleMap);\n  }\n  return this;\n}\n", "nl": "Adds a new role player to this relation"}
{"code": "public static byte[] hexStringToBytes(String hexString){\n  if (hexString == null || hexString.equals(\"\")) {\n    return null;\n  }\n  hexString=hexString.toUpperCase();\n  int length=hexString.length() / 2;\n  char[] hexChars=hexString.toCharArray();\n  byte[] d=new byte[length];\n  for (int i=0; i < length; i++) {\n    int pos=i * 2;\n    d[i]=(byte)(charToByte(hexChars[pos]) << 4 | charToByte(hexChars[pos + 1]));\n  }\n  return d;\n}\n", "nl": "Convert hex string to byte[]"}
{"code": "public static void dumpTreeToBuilder(final @NotNull StringBuilder builder,final @NotNull TreeElement element,final int indentation){\n  for (int i=0; i < indentation; i++) {\n    builder.append(\"  \");\n  }\n  builder.append(element.getPresentation().getPresentableText()).append('\\n');\n  for (  TreeElement treeElement : element.getChildren()) {\n    dumpTreeToBuilder(builder,treeElement,indentation + 1);\n  }\n}\n", "nl": "Helper function for pretty-printing a tree element"}
{"code": "public Map<String,List<ChartObject>> maxByDate(List<ChartObject> input,Period period,String maxSeries){\n  final Function<ChartObject,String> chartObjectToDate=null;\n  final BinaryOperator<ChartObject> chartObjectReducer=null;\n  final Map<String,Optional<ChartObject>> groupByDate=input.stream().sorted(null).collect(Collectors.groupingBy(chartObjectToDate,null,Collectors.reducing(chartObjectReducer)));\n  final Map<String,ChartObject> range=buildRange(input,period);\n  final LinkedHashMap<String,List<ChartObject>> result=new LinkedHashMap<>();\n  range.forEach(null);\n  return result;\n}\n", "nl": "Return grouped objects with MAX element in each group by specified criteria"}
{"code": "private static void deleteRecursiveSilent(CarbonFile f){\n  if (f.isDirectory()) {\n    if (f.listFiles() != null) {\n      for (      CarbonFile c : f.listFiles()) {\n        deleteRecursiveSilent(c);\n      }\n    }\n  }\n  if (f.exists() && !f.delete()) {\n    return;\n  }\n}\n", "nl": "this method will delete the folders recursively"}
{"code": "public static void show(byte[] b){\n  int count=0;\n  for (int i=0; i < b.length; i++) {\n    if (count == 8) {\n      System.out.print(\"  \");\n    }\n else     if (count == 16) {\n      System.out.println(\"\");\n      count=0;\n      continue;\n    }\n    System.out.print(Integer.toHexString(b[i] & 0xFF).toUpperCase() + \" \");\n    count++;\n  }\n  System.out.println();\n}\n", "nl": "debug display array"}
{"code": "public static void createRipple(View v,int primaryColor){\n  BaseRippleDrawable rippleDrawable=new BaseRippleDrawable();\n  rippleDrawable.setDrawable(v.getBackground());\n  rippleDrawable.setColor(primaryColor);\n  rippleDrawable.setBounds(v.getPaddingLeft(),v.getPaddingTop(),v.getPaddingRight(),v.getPaddingBottom());\n  v.setOnTouchListener(rippleDrawable);\n  if (Build.VERSION.SDK_INT >= 16) {\n    v.setBackground(rippleDrawable);\n  }\n else {\n    v.setBackgroundDrawable(rippleDrawable);\n  }\n}\n", "nl": "Creates ripple effect to mView"}
{"code": "@deprecated public static final boolean equals(int codepoint,CharSequence other){\n  if (other == null) {\n    return false;\n  }\nswitch (other.length()) {\ncase 1:\n    return codepoint == other.charAt(0);\ncase 2:\n  return (codepoint > 65535) && (codepoint == Character.codePointAt(other,0));\n}\nreturn false;\n}\n", "nl": "/*    "}
{"code": "private void updateMembersEmblem(Legion legion,LegionEmblemType emblemType){\n  LegionEmblem legionEmblem=legion.getLegionEmblem();\n  for (  Player onlineLegionMember : legion.getOnlineLegionMembers()) {\n    PacketSendUtility.broadcastPacket(onlineLegionMember,new SM_LEGION_UPDATE_EMBLEM(legion.getLegionId(),legionEmblem.getEmblemId(),legionEmblem.getColor_r(),legionEmblem.getColor_g(),legionEmblem.getColor_b(),emblemType),true);\n    if (legionEmblem.getEmblemType() == LegionEmblemType.CUSTOM) {\n      sendEmblemData(onlineLegionMember,legionEmblem,legion.getLegionId(),legion.getLegionName());\n    }\n  }\n}\n", "nl": "This method will send a packet to every legion member"}
{"code": "@RequestMapping(method=RequestMethod.POST,value=\"/api/drops/export\") public ExportDropConfig exportDrop(@RequestBody ExportDropConfig exportDropConfig) throws DropExporterException {\n  PollableFuture<Drop> exportDropFuture=dropService.startDropExportProcess(exportDropConfig,PollableTask.INJECT_CURRENT_TASK);\n  exportDropConfig.setPollableTask(exportDropFuture.getPollableTask());\n  try {\n    exportDropConfig.setDropId(exportDropFuture.get().getId());\n  }\n catch (  ExecutionException|InterruptedException e) {\n    logger.debug(\"Cannot get dropId from the pollable due to exception\",e);\n  }\n  return exportDropConfig;\n}\n", "nl": "WS to start exporting a drop"}
{"code": "private void interpolate(float[] spectrum){\n  for (int i=0; i < spectrum.length; i++) {\n    if (spectrum[i] < previousSpectrum[i]) {\n      double interpolationCoefficient=0.97;\n      spectrum[i]=(float)(previousSpectrum[i] * interpolationCoefficient);\n    }\n    previousSpectrum[i]=spectrum[i];\n  }\n}\n", "nl": "Provides smooth lowering for waves"}
{"code": "@Override public int countMissing(){\n  int count=0;\n  for (int i=0; i < size(); i++) {\n    if (get(i) == MISSING_VALUE) {\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Returns the count of missing values in this column"}
{"code": "public boolean hasMoreRecords() throws IOException {\n  row=parser.parseNext();\n  if (row == null && blockCounter + 1 >= this.csvParserVo.getBlockDetailsList().size()) {\n    close();\n    return false;\n  }\n  if (row == null) {\n    initialize();\n    row=parser.parseNext();\n  }\n  return true;\n}\n", "nl": "Below method will be used to check whether any more records is present or not"}
{"code": "public ByteArray copy(){\n  ByteArray result=new ByteArray();\n  if (buf != null) {\n    byte[] data=new byte[length];\n    System.arraycopy(buf,offset,data,0,length);\n    result.reset(data);\n  }\n  return result;\n}\n", "nl": "make a copy"}
{"code": "public static void main(String... args){\n  System.setErr(System.out);\n  ProcessLogger.log(\"JavaProcess - Starting with args: \" + Arrays.asList(args));\n  try {\n    JavaProcess jp=new JavaProcess(args);\n    jp.run();\n  }\n catch (  Throwable t) {\n    ProcessLogger.log(\"JavaProcess - Termination was caused by: \",t);\n    System.exit(1);\n  }\n}\n", "nl": "the main method to initialize JavaProcess"}
{"code": "public static List<AttackResult> calculatePhysicalAttackResult(Creature attacker,Creature attacked){\n  AttackStatus attackerStatus=null;\n  int damage=StatFunctions.calculateAttackDamage(attacker,attacked,true,SkillElement.NONE);\n  List<AttackResult> attackList=new ArrayList<AttackResult>();\n  AttackStatus mainHandStatus=calculateMainHandResult(attacker,attacked,attackerStatus,damage,attackList);\n  if (attacker instanceof Player && ((Player)attacker).getEquipment().getOffHandWeaponType() != null) {\n    calculateOffHandResult(attacker,attacked,mainHandStatus,attackList);\n  }\n  attacked.getObserveController().checkShieldStatus(attackList,null,attacker);\n  return attackList;\n}\n", "nl": "Calculate physical attack status and damage"}
{"code": "private void createThrowStmt(Body body,Unit oldStmt,LocalCreation lc){\n  RefType tp=RefType.v(\"java.lang.NullPointerException\");\n  Local lcEx=lc.newLocal(tp);\n  SootMethodRef constructorRef=Scene.v().makeConstructorRef(tp.getSootClass(),Collections.singletonList((Type)RefType.v(\"java.lang.String\")));\n  Stmt newExStmt=Jimple.v().newAssignStmt(lcEx,Jimple.v().newNewExpr(tp));\n  body.getUnits().insertBefore(newExStmt,oldStmt);\n  Stmt invConsStmt=Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(lcEx,constructorRef,Collections.singletonList(StringConstant.v(\"Invalid array reference replaced by Soot\"))));\n  body.getUnits().insertBefore(invConsStmt,oldStmt);\n  body.getUnits().swapWith(oldStmt,Jimple.v().newThrowStmt(lcEx));\n}\n", "nl": "Creates a new statement that throws a NullPointerException"}
{"code": "private void postInitViewPager(){\n  if (isInEditMode()) {\n    return;\n  }\n  try {\n    Field scroller=ViewPager.class.getDeclaredField(\"mScroller\");\n    scroller.setAccessible(true);\n    Field interpolator=ViewPager.class.getDeclaredField(\"sInterpolator\");\n    interpolator.setAccessible(true);\n    mScroller=new WXSmoothScroller(getContext(),(Interpolator)interpolator.get(null));\n    scroller.set(this,mScroller);\n  }\n catch (  Exception e) {\n    WXLogUtils.e(\"[CircleViewPager] postInitViewPager: \",e);\n  }\n}\n", "nl": "Override the Scroller instance with our own class so we can change the duration"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"setProp\");\n  String label=np.getWordRespectCase();\n  np.matchIgnoreCase(\"=\");\n  String value=np.getWordRespectCase();\n  if (NexusStreamParser.isBoolean(value)) {\n    ProgramProperties.put(label,Boolean.parseBoolean(value));\n  }\n else   if (NexusStreamParser.isInteger(value)) {\n    ProgramProperties.put(label,Integer.parseInt(value));\n  }\n else   if (NexusStreamParser.isFloat(value)) {\n    ProgramProperties.put(label,Float.parseFloat(value));\n  }\n else   ProgramProperties.put(label,value);\n  np.matchIgnoreCase(\";\");\n}\n", "nl": "parses the given command and executes it"}
{"code": "public int read(byte[] buffer,final int bytes){\n  int remaining;\n  if ((remaining=checkSpace(false)) == 0) {\n    Log.d(RingBuffer.class.getSimpleName(),\"No data\");\n    return 0;\n  }\n  final int bytesRead=bytes > remaining ? remaining : bytes;\n  for (int i=0; i < bytesRead; ++i) {\n    buffer[i]=this.buffer[rp++];\n    if (rp == size)     rp=0;\n  }\n  return bytesRead;\n}\n", "nl": "Read a number of bytes from ring buffer"}
{"code": "public static Bitmap takeScreenShotWithStatusBar(Activity activity){\n  View view=activity.getWindow().getDecorView();\n  view.setDrawingCacheEnabled(true);\n  view.buildDrawingCache();\n  Bitmap bmp=view.getDrawingCache();\n  int width=getScreenWidthInPx(activity);\n  int height=getScreenHeightInPx(activity);\n  Bitmap bp=Bitmap.createBitmap(bmp,0,0,width,height);\n  view.destroyDrawingCache();\n  return bp;\n}\n", "nl": "Take a screenshot with the status bar"}
{"code": "public static Pixmap tintPixmap(Pixmap pixmap,Color color){\n  Color tempColor=new Color();\n  for (int y=0; y < pixmap.getHeight(); y++) {\n    for (int x=0; x < pixmap.getWidth(); x++) {\n      tempColor.set(pixmap.getPixel(x,y));\n      float a=tempColor.a;\n      tempColor.mul(color);\n      tempColor.a=a;\n      pixmap.setColor(tempColor);\n      pixmap.drawPixel(x,y);\n      tempColor.set(pixmap.getPixel(x,y));\n    }\n  }\n  return pixmap;\n}\n", "nl": "Does not dispose pixmap"}
{"code": "public static String readFromFile(String fileName) throws IOException {\n  InputStream in=RequestExecutionHelper.class.getClassLoader().getResourceAsStream(fileName);\n  try {\n    String result=StreamHelper.readStreamContent(in);\n    return result;\n  }\n  finally {\n    in.close();\n  }\n}\n", "nl": "Read File content"}
{"code": "public void draw(Canvas c,Rect bounds){\n  mCirclePaint.setColor(mBackgroundColor);\n  mCirclePaint.setAlpha(mAlpha);\n  c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mArcPaint.setColor(mColors[mColorIndex]);\n  mArcPaint.setAlpha(mAlpha);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mArcPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n}\n", "nl": "Draw the progress spinner"}
{"code": "private static float standardDeviation(float[] pos){\n  float sum=0.f;\n  float sumSqr=0.f;\n  int count=0;\n  for (  float po : pos) {\n    if (Float.isNaN(po)) {\n      continue;\n    }\n    count++;\n    sum+=po;\n    sumSqr+=po * po;\n  }\n  return (float)Math.sqrt(sumSqr / count - (sum / count) * (sum / count));\n}\n", "nl": "Calculate the standard deviation skipping Nan floats"}
{"code": "public static void expand(Player player,boolean isNpcExpand){\n  if (!canExpand(player)) {\n    return;\n  }\n  PacketSendUtility.sendPacket(player,new SM_SYSTEM_MESSAGE(1300431,\"9\"));\n  if (isNpcExpand) {\n    player.setNpcExpands(player.getNpcExpands() + 1);\n  }\n else {\n    player.setQuestExpands(player.getQuestExpands() + 1);\n  }\n  PacketSendUtility.sendPacket(player,SM_CUBE_UPDATE.cubeSize(StorageType.CUBE,player));\n}\n", "nl": "Expands the cubes"}
{"code": "public FeatureVector computeFeatureVector(Target target){\n  byte[] byteFeatures=new byte[byteValuedDiscreteFeatureProcessors.length];\n  short[] shortFeatures=new short[shortValuedDiscreteFeatureProcessors.length];\n  float[] floatFeatures=new float[continuousFeatureProcessors.length];\n  for (int i=0; i < byteValuedDiscreteFeatureProcessors.length; i++) {\n    byteFeatures[i]=byteValuedDiscreteFeatureProcessors[i].process(target);\n  }\n  for (int i=0; i < shortValuedDiscreteFeatureProcessors.length; i++) {\n    shortFeatures[i]=shortValuedDiscreteFeatureProcessors[i].process(target);\n  }\n  for (int i=0; i < continuousFeatureProcessors.length; i++) {\n    floatFeatures[i]=continuousFeatureProcessors[i].process(target);\n  }\n  return new FeatureVector(byteFeatures,shortFeatures,floatFeatures,0);\n}\n", "nl": "Using the set of feature processors defined when creating the target feature computer, compute a feature vector for the target"}
{"code": "private void validateNumCoresBlockSort(){\n  String numCoresStr=carbonProperties.getProperty(CarbonCommonConstants.NUM_CORES_BLOCK_SORT,CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);\n  try {\n    int numCores=Integer.parseInt(numCoresStr);\n    if (numCores < CarbonCommonConstants.NUM_CORES_BLOCK_SORT_MIN_VAL || numCores > CarbonCommonConstants.NUM_CORES_BLOCK_SORT_MAX_VAL) {\n      LOGGER.info(\"The num cores value \\\"\" + numCoresStr + \"\\\" for block sort is invalid. Using the default value \\\"\"+ CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);\n      carbonProperties.setProperty(CarbonCommonConstants.NUM_CORES_BLOCK_SORT,CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);\n    }\n  }\n catch (  NumberFormatException e) {\n    LOGGER.info(\"The num cores value \\\"\" + numCoresStr + \"\\\" for block sort is invalid. Using the default value \\\"\"+ CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);\n    carbonProperties.setProperty(CarbonCommonConstants.NUM_CORES_BLOCK_SORT,CarbonCommonConstants.NUM_CORES_BLOCK_SORT_DEFAULT_VAL);\n  }\n}\n", "nl": "This method validates the number cores specified for mdk block sort"}
{"code": "private void uncollapseSelectedNodesRec(Node v,Set<Integer> ids,Set<Integer> seen){\n  Integer id=(Integer)v.getInfo();\n  if (!seen.contains(id)) {\n    if (ids.contains(id))     seen.add(id);\n    if (id != null)     getCollapsedIds().remove(id);\n    for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n      uncollapseSelectedNodesRec(e.getOpposite(v),ids,seen);\n    }\n  }\n}\n", "nl": "recursively does the work"}
{"code": "private int[] normalizeCycle(int[] cycle){\n  int[] result=new int[cycle.length];\n  int i=1;\n  while (cycle[i] != 1 && i < cycle.length)   i++;\n  int j=1;\n  while (i < cycle.length) {\n    result[j]=cycle[i];\n    i++;\n    j++;\n  }\n  i=1;\n  while (j < result.length) {\n    result[j]=cycle[i];\n    i++;\n    j++;\n  }\n  return result;\n}\n", "nl": "normalizes cycle so that cycle[1]=1"}
{"code": "public void paint(Graphics gc0){\n  Graphics2D gc=(Graphics2D)gc0;\n  SelectionGraphics<String[]> sgc=(gc instanceof SelectionGraphics ? (SelectionGraphics<String[]>)gc : null);\n  if (sgc == null) {\n    super.paint(gc);\n    gc.setColor(Color.WHITE);\n    gc.fill(getVisibleRect());\n  }\n  draw(gc,null);\n}\n", "nl": "draw the legend"}
{"code": "public static String loadDigestes(JarFile jarFile,JarEntry je) throws Exception {\n  InputStream bis=null;\n  StringBuilder sb=new StringBuilder();\n  try {\n    InputStream is=jarFile.getInputStream(je);\n    byte[] bytes=new byte[ShareConstants.BUFFER_SIZE];\n    bis=new BufferedInputStream(is);\n    int readBytes;\n    while ((readBytes=bis.read(bytes)) > 0) {\n      sb.append(new String(bytes,0,readBytes));\n    }\n  }\n  finally {\n    closeQuietly(bis);\n  }\n  return sb.toString();\n}\n", "nl": "for faster, read and get the contents"}
{"code": "protected Map<String,Set<String>> filterQueryParamsByKey(QueryParamsParserContext context,String queryKey){\n  Map<String,Set<String>> filteredQueryParams=new HashMap<>();\n  for (  String paramName : context.getParameterNames()) {\n    if (paramName.startsWith(queryKey)) {\n      filteredQueryParams.put(paramName,context.getParameterValue(paramName));\n    }\n  }\n  return filteredQueryParams;\n}\n", "nl": "Filters provided query params to one starting with provided string key"}
{"code": "@SuppressWarnings(\"unchecked\") private V deepClone(final K id,final V reference){\n  try {\n    ByteArrayOutputStream baos=new ByteArrayOutputStream();\n    ObjectOutputStream oos=new ObjectOutputStream(baos);\n    oos.writeObject(reference);\n    ByteArrayInputStream bais=new ByteArrayInputStream(baos.toByteArray());\n    ObjectInputStream ois=new ObjectInputStream(bais);\n    return (V)ois.readObject();\n  }\n catch (  Exception ex) {\n    LOGGER.error(\"deepClone() - Caught exception whilst trying to make a serialization copy of object with id \" + id,ex);\n    throw new RuntimeException(\"An error occured whilst trying to make a serialization copy of object with id \" + id,ex);\n  }\n}\n", "nl": "Returns a deep copy through serialization"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"select items=\");\n  String what=np.getWordMatchesIgnoringCase(\"all none\");\n  np.matchRespectCase(\";\");\n  final InspectorWindow inspectorWindow=(InspectorWindow)getViewer();\nswitch (what) {\ncase \"all\":\n    inspectorWindow.getDataTree().setSelectionInterval(0,inspectorWindow.getDataTree().getRowCount());\n  break;\ncase \"none\":\ninspectorWindow.getDataTree().clearSelection();\nbreak;\n}\n}\n", "nl": "parses the given command and executes it"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  InspectorWindow inspectorWindow=(InspectorWindow)getViewer();\n  String regularExpression=ProgramProperties.get(MeganProperties.FINDREAD,\"\");\n  regularExpression=JOptionPane.showInputDialog(inspectorWindow.getFrame(),\"Enter regular expression for read names:\",regularExpression);\n  if (regularExpression != null && regularExpression.trim().length() != 0) {\n    regularExpression=regularExpression.trim();\n    ProgramProperties.put(MeganProperties.FINDREAD,regularExpression);\n    execute(\"show read='\" + regularExpression + \"';\");\n  }\n}\n", "nl": "action to be performed"}
{"code": "private boolean readLine(InputStream in,StringBuffer buf) throws IOException {\n  while (true) {\n    int c=in.read();\n    if (c < 0)     return (buf.length() > 0);\n    if (c == '\\r') {\n      in.mark(1);\n      c=in.read();\n      if (c != '\\n')       in.reset();\n      return (true);\n    }\n    if (c == '\\n')     return (true);\n    buf.append((char)c);\n  }\n}\n", "nl": "Read up to CRLF, return false if EOF"}
{"code": "public void disableSamples(Collection<String> sampleNames){\n  int size=disabledSamples.size();\n  Set<String> newDisabled=new HashSet<>();\n  newDisabled.addAll(disabledSamples);\n  newDisabled.addAll(sampleNames);\n  if (newDisabled.size() != size) {\n    if (originalData == null) {\n      originalData=new DataTable();\n      originalData.copy(this);\n    }\n    copyEnabled(newDisabled,originalData);\n    disabledSamples.clear();\n    disabledSamples.addAll(newDisabled);\n  }\n}\n", "nl": "disable some of the samples"}
{"code": "Collection<? extends ClientRequestResult> handleCommandHandleRequest(final ClientRequest commandRequest){\nswitch (commandRequest.getResultType()) {\ncase TRANSFER_COMMAND_HANDLES_LIST:\n    return commandExecutionManager.processRequest(commandRequest.getTagIds());\ndefault :\n  LOG.error(\"handleCommandHandleRequest() - Could not generate response message. Unknown enum ResultType \" + commandRequest.getResultType());\n}\nreturn null;\n}\n", "nl": "Inner method which handles the CommandTagHandle Requests"}
{"code": "public void writeLongLittleEndian(long a) throws IOException {\n  ensureSize(size + 8);\n  bytes[size++]=((byte)(a));\n  bytes[size++]=((byte)(a >> 8));\n  bytes[size++]=((byte)(a >> 16));\n  bytes[size++]=((byte)(a >> 24));\n  bytes[size++]=((byte)(a >> 32));\n  bytes[size++]=((byte)(a >> 40));\n  bytes[size++]=((byte)(a >> 48));\n  bytes[size++]=((byte)(a >> 56));\n}\n", "nl": "write long, little endian"}
{"code": "public SerialMessage clearAssociationMessage(int group){\n  logger.debug(\"NODE {}: Creating new message for command MULTI_ASSOCIATIONCMD_REMOVE node all, endpoint all, group {}\",getNode().getNodeId(),group);\n  SerialMessage result=new SerialMessage(getNode().getNodeId(),SerialMessageClass.SendData,SerialMessageType.Request,SerialMessageClass.SendData,SerialMessagePriority.Set);\n  ByteArrayOutputStream outputData=new ByteArrayOutputStream();\n  outputData.write(this.getNode().getNodeId());\n  outputData.write(3);\n  outputData.write(getCommandClass().getKey());\n  outputData.write(MULTI_ASSOCIATIONCMD_REMOVE);\n  outputData.write(group);\n  result.setMessagePayload(outputData.toByteArray());\n  return result;\n}\n", "nl": "Gets a SerialMessage with the MULTI_ASSOCIATIONCMD_REMOVE command to remove all nodes"}
{"code": "public static int verifyOrder(String input,String[] subStrings){\n  int prev=-1;\n  for (int i=0; i < subStrings.length; i++) {\n    int current=input.indexOf(subStrings[i]);\n    if (current < prev) {\n      return i;\n    }\n else {\n      prev=current;\n    }\n  }\n  return -1;\n}\n", "nl": "Verify that the list of substrings appear in the order provided in a string"}
{"code": "public MarketEditQuery(VkApiClient client,UserActor actor,int ownerId,int itemId,String name,String description,int categoryId,float price,int mainPhotoId){\n  super(client,\"market.edit\",OkResponse.class);\n  accessToken(actor.getAccessToken());\n  ownerId(ownerId);\n  itemId(itemId);\n  name(name);\n  description(description);\n  categoryId(categoryId);\n  price(price);\n  mainPhotoId(mainPhotoId);\n}\n", "nl": "Creates a AbstractQueryBuilder instance that can be used to build api request with various parameters"}
{"code": "private void createUserLayerDataSources(){\n  if (inlineDataSource == null) {\n    ConsoleManager.getInstance().error(this,\"No inline data source creation object set\");\n  }\n else {\n    userLayerDataSourceInfo=inlineDataSource.connect(this.editorFileInterface);\n    if (userLayerDataSourceInfo != null) {\n      for (      DataSourceInfo dsInfo : userLayerDataSourceInfo) {\n        if (dsInfo.hasData()) {\n          dsInfo.populateFieldMap();\n        }\n      }\n    }\n  }\n}\n", "nl": "Create inline data sources"}
{"code": "static boolean isWeekend(int dayOfWeek,@Constants.Weekend int weekendValue){\nswitch (weekendValue) {\ncase Constants.Weekend.SATURDAY_SUNDAY:\n    return Calendar.SATURDAY == dayOfWeek || Calendar.SUNDAY == dayOfWeek;\ncase Constants.Weekend.FRIDAY_SATURDAY:\n  return Calendar.FRIDAY == dayOfWeek || Calendar.SATURDAY == dayOfWeek;\ncase Constants.Weekend.THURSDAY_FRIDAY:\nreturn Calendar.THURSDAY == dayOfWeek || Calendar.FRIDAY == dayOfWeek;\ncase Constants.Weekend.FRIDAY_ONLY:\nreturn Calendar.FRIDAY == dayOfWeek;\ncase Constants.Weekend.SATURDAY_ONLY:\nreturn Calendar.SATURDAY == dayOfWeek;\ncase Constants.Weekend.SUNDAY_ONLY:\nreturn Calendar.SUNDAY == dayOfWeek;\ndefault :\nreturn false;\n}\n}\n", "nl": "Determines if the passed day of week is weekend"}
{"code": "public List<GenericValue> makeAllOrderItemPriceInfos(){\n  List<GenericValue> allInfos=new LinkedList<GenericValue>();\n  for (  ShoppingCartItem item : cartLines) {\n    Collection<GenericValue> infos=item.getOrderItemPriceInfos();\n    if (infos != null) {\n      for (      GenericValue orderItemPriceInfo : infos) {\n        orderItemPriceInfo.set(\"orderItemSeqId\",item.getOrderItemSeqId());\n        allInfos.add(orderItemPriceInfo);\n      }\n    }\n  }\n  return allInfos;\n}\n", "nl": "make a list of OrderItemPriceInfos from the ShoppingCartItems"}
{"code": "public static int sign(int iValue){\n  if (iValue > 0) {\n    return 1;\n  }\n  if (iValue < 0) {\n    return -1;\n  }\n  return 0;\n}\n", "nl": "Returns 1 if the number is positive, -1 if the number is negative, and 0 otherwise"}
{"code": "public static void changeMemberGroup(Player player,int firstPlayer,int secondPlayer,int allianceGroupId){\n  PlayerAlliance alliance=player.getPlayerAlliance2();\n  Preconditions.checkNotNull(alliance,\"Alliance should not be null for group change\");\n  if (alliance.isLeader(player) || alliance.isViceCaptain(player)) {\n    alliance.onEvent(new ChangeMemberGroupEvent(alliance,firstPlayer,secondPlayer,allianceGroupId));\n  }\n else {\n    PacketSendUtility.sendMessage(player,\"You do not have the authority for that.\");\n  }\n}\n", "nl": "Move members between alliance groups"}
{"code": "public static Map<String,Object> testRefund(DispatchContext dctx,Map<String,? extends Object> context){\n  Locale locale=(Locale)context.get(\"locale\");\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  Debug.logInfo(\"Test Refund Process\",module);\n  result.put(\"refundResult\",Boolean.TRUE);\n  result.put(\"refundAmount\",context.get(\"refundAmount\"));\n  result.put(\"refundRefNum\",UtilDateTime.nowAsString());\n  result.put(\"refundFlag\",\"R\");\n  result.put(\"refundMessage\",UtilProperties.getMessage(resource,\"AccountingPaymentTestRefund\",locale));\n  return result;\n}\n", "nl": "Test refund service (returns true)"}
{"code": "public void writeIntoSPTKLF0File(String sptkFileName) throws IOException {\n  LEDataOutputStream lf0Data=new LEDataOutputStream(new BufferedOutputStream(new FileOutputStream(sptkFileName)));\n  for (int i=0; i < this.contour.length; i++) {\n    double f0Val=contour[i];\n    if (contour[i] == 0.0f) {\n      lf0Data.writeFloat(NEGATIVE_MAXIMUM);\n    }\n else {\n      lf0Data.writeFloat((float)Math.log(contour[i]));\n    }\n  }\n  lf0Data.flush();\n  lf0Data.close();\n}\n", "nl": "write contour into a lf0 file in SPTK format"}
{"code": "public void validate(){\n  if (USE_OLD_GUARANTEED_NOTIFICATIONS && isGuaranteedNotifications() && isFifo())   throw new UnsupportedOperationException(\"Notify delivery in case of a server failure can not be guaranteed for FIFO notifications.\");\n  if (isDurableNotifications()) {\n    if (triggerNotifyTemplate != null && triggerNotifyTemplate)     throw new UnsupportedOperationException(\"Notify template cannot be triggered at backup space in durable notifications\");\n    if (replicateNotifyTemplate != null && !replicateNotifyTemplate)     throw new UnsupportedOperationException(\"Notify template is always replicated in durable notifications\");\n  }\n else {\n    if (isBatching() && getBatchSize() != getBatchPendingThreshold())     throw new UnsupportedOperationException(\"Batch pending threshold cannot be different than batch size in non-durable notification\");\n  }\n}\n", "nl": "Checks configuration validity"}
{"code": "public Object clone(){\n  System.err.println(this.getClass().getName() + \": The clone() method should be checked...\");\n  DocumentNGramDistroGraph gRes=new DocumentNGramDistroGraph(MinSize,MaxSize,CorrelationWindow);\n  gRes.DataString=DataString;\n  gRes.DegradedEdges.putAll(this.DegradedEdges);\n  gRes.NGramGraphArray=this.NGramGraphArray.clone();\n  gRes.Normalizer=this.Normalizer;\n  gRes.TextPreprocessor=this.TextPreprocessor;\n  gRes.WordEvaluator=this.WordEvaluator;\n  gRes.EdgeDistros=(HashMap)this.EdgeDistros.clone();\n  return gRes;\n}\n", "nl": "TODO: CHECK"}
{"code": "public void search(String query){\n  try {\n    presenter.start(query);\n  }\n catch (  InternetConnectionException e) {\n    Log.e(TAG,e.getMessage(),e);\n    Toast.makeText(mActivity,e.getMessage(),Toast.LENGTH_LONG).show();\n  }\n  mActivity.showLoaderWithTitleAndDescription(getString(R.string.main_screen),getString(R.string.searching));\n}\n", "nl": "<p>Starts the presenter, searching for a specific user's query</p>"}
{"code": "@Override public void populateField(ProcessFunction value){\n  processFunction=value;\n  if (textField != null) {\n    textField.setText(ParameterFunctionUtils.getString(processFunction));\n    UndoManager.getInstance().addUndoEvent(new UndoEvent(this,getFieldId(),oldValueObj,value));\n    oldValueObj=value;\n    valueUpdated();\n  }\n}\n", "nl": "Populate process function field"}
{"code": "protected FieldMatrix<Fraction> permuteRows(FieldMatrix<Fraction> matrix,int[] permutation){\n  if (!matrix.isSquare()) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.NON_SQUARE_MATRIX,matrix.getRowDimension(),matrix.getColumnDimension());\n  }\n  if (matrix.getRowDimension() != permutation.length) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,matrix.getRowDimension(),permutation.length);\n  }\n  int n=matrix.getRowDimension();\n  int m=matrix.getColumnDimension();\n  Fraction out[][]=new Fraction[m][n];\n  for (int i=0; i < n; i++) {\n    for (int j=0; j < m; j++) {\n      out[i][j]=matrix.getEntry(permutation[i],j);\n    }\n  }\n  return new Array2DRowFieldMatrix<Fraction>(out);\n}\n", "nl": "Returns the result of applying the given row permutation to the matrix"}
{"code": "private void changeAnnouncement(Player activePlayer,String announcement){\n  if (legionRestrictions.canChangeAnnouncement(activePlayer.getLegionMember(),announcement)) {\n    Legion legion=activePlayer.getLegion();\n    Timestamp currentTime=new Timestamp(System.currentTimeMillis());\n    storeNewAnnouncement(legion.getLegionId(),currentTime,announcement);\n    legion.addAnnouncementToList(currentTime,announcement);\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_WRITE_NOTICE_DONE);\n    PacketSendUtility.broadcastPacketToLegion(legion,new SM_LEGION_EDIT(0x05,(int)(System.currentTimeMillis() / 1000),announcement));\n  }\n}\n", "nl": "This will add a new announcement to the DB and change the current announcement"}
{"code": "public synchronized void addNewQuery(QueryID queryID,String indexName,int shardOrd,String text,byte[] returnNodeID){\n  QueryAndID query=queryQueue.remove(queryID);\n  if (query != null) {\n    assert query.state == 1;\n    assert query.nodeID != null;\n    query.returnNodeID=returnNodeID;\n    query.text=text;\n    queryDone.add(query);\n  }\n else {\n    queryQueue.put(queryID,new QueryAndID(queryID,indexName,shardOrd,text,returnNodeID));\n    notify();\n  }\n}\n", "nl": "Enroll a new query into the queue"}
{"code": "private static Element loadDocument(URL location) throws WebAppConfigurationException {\n  try {\n    Document document=UtilXml.readXmlDocument(location,true);\n    Element rootElement=document.getDocumentElement();\n    if (Debug.verboseOn())     Debug.logVerbose(\"Loaded XML Config - \" + location,module);\n    return rootElement;\n  }\n catch (  Exception e) {\n    Debug.logError(e,module);\n    throw new WebAppConfigurationException(e);\n  }\n}\n", "nl": "Loads the XML file and returns the root element"}
{"code": "public static String createClubId(Delegator delegator,String prefix,int length){\n  final String clubSeqName=\"PartyClubSeq\";\n  String clubId=prefix != null ? prefix : \"\";\n  Long seq=delegator.getNextSeqIdLong(clubSeqName);\n  clubId=clubId + UtilFormatOut.formatPaddedNumber(seq.longValue(),(length - clubId.length() - 1));\n  int check=UtilValidate.getLuhnCheckDigit(clubId);\n  clubId=clubId + Integer.toString(check);\n  return clubId;\n}\n", "nl": "Generate a sequenced club id using the prefix passed and a sequence value + check digit"}
{"code": "public void uncollapse(Set<Integer> toUncollapse,Set<Integer> collapsedIds){\n  Set<Integer> newCollapsed=new HashSet<>();\n  for (Node v=getFirstNode(); v != null; v=v.getNext()) {\n    int vId=(Integer)v.getInfo();\n    if (toUncollapse.contains(vId) && collapsedIds.contains(vId)) {\n      for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n        Node w=e.getTarget();\n        newCollapsed.add((Integer)w.getInfo());\n      }\n    }\n  }\n  collapsedIds.removeAll(toUncollapse);\n  collapsedIds.addAll(newCollapsed);\n}\n", "nl": "modify the given set of collapsedIds so that the toUncollapse ids are uncollapsed"}
{"code": "public Matrix(Vector<double[]> rows,boolean clone){\n  m=rows.size();\n  n=rows.get(0).length;\n  A=new double[m][n];\n  if (clone) {\n    for (int i=0; i < m; i++)     A[i]=rows.get(i).clone();\n  }\n else {\n    for (int i=0; i < m; i++)     A[i]=rows.get(i);\n  }\n  for (int i=0; i < m; i++)   if (A[i].length != n)   (new IllegalArgumentException(\"Length of row \" + i + \" is \"+ A[i].length+ \". Should be \"+ n)).printStackTrace();\n}\n", "nl": "Construct a matrix from a Vector of double[]"}
{"code": "public void updateEnableStateFXItems(){\n  for (  MenuItem menuItem : menuItem2CommandFX.keySet()) {\n    ICommand command=menuItem2CommandFX.get(menuItem);\n    menuItem.setDisable(!command.isApplicable());\n    if (command instanceof ICheckBoxCommand) {\n      ((CheckMenuItem)menuItem).setSelected(((ICheckBoxCommand)command).isSelected());\n    }\n  }\n}\n", "nl": "update the enable state for only the FX menu items"}
{"code": "private static String byteToHex(byte[] digest){\n  StringBuilder builder=new StringBuilder();\n  for (  byte b : digest) {\n    String hex=Integer.toHexString(0xff & b);\n    if (hex.length() == 1) {\n      builder.append('0');\n    }\n    builder.append(hex);\n  }\n  return builder.toString();\n}\n", "nl": "Transform binary to hex"}
{"code": "public CAS process(String text){\n  CAS cas=retrieve();\n  cas.setDocumentText(text);\n  try {\n    analysisEngine.process(cas);\n  }\n catch (  AnalysisEngineProcessException e) {\n    if (text != null && !text.isEmpty())     return process(text);\n    throw new RuntimeException(e);\n  }\n  return cas;\n}\n", "nl": "Use the given analysis engine and process the given text You must release the return cas yourself"}
{"code": "public void testSettingInHighApiTheme(){\n  VirtualFile virtualFile=myFixture.copyFileToProject(\"themeEditor/apiTestBefore/stylesApi.xml\",\"res/values/styles.xml\");\n  myFixture.copyFileToProject(\"themeEditor/apiTestBefore/stylesApi-v14.xml\",\"res/values-v14/styles.xml\");\n  myFixture.copyFileToProject(\"themeEditor/apiTestBefore/stylesApi-v19.xml\",\"res/values-v19/styles.xml\");\n  myFixture.copyFileToProject(\"themeEditor/apiTestBefore/stylesApi-v21.xml\",\"res/values-v21/styles.xml\");\n  ConfigurationManager configurationManager=myFacet.getConfigurationManager();\n  Configuration configuration=configurationManager.getConfiguration(virtualFile);\n  ThemeResolver themeResolver=new ThemeResolver(configuration);\n  ConfiguredThemeEditorStyle theme=themeResolver.getTheme(\"Theme.MyOtherTheme\");\n  assertNotNull(theme);\n  theme.setValue(\"android:windowIsFloating\",\"holo_purple\");\n  theme.setValue(\"android:actionBarDivider\",\"myValue\");\n  theme.setParent(\"android:Theme.Holo.Light.DarkActionBar\");\n  myFixture.checkResultByFile(\"res/values/styles.xml\",\"themeEditor/apiTestAfter8/stylesApi.xml\",true);\n  myFixture.checkResultByFile(\"res/values-v14/styles.xml\",\"themeEditor/apiTestAfter8/stylesApi-v14.xml\",true);\n  myFixture.checkResultByFile(\"res/values-v19/styles.xml\",\"themeEditor/apiTestAfter8/stylesApi-v19.xml\",true);\n  myFixture.checkResultByFile(\"res/values-v21/styles.xml\",\"themeEditor/apiTestAfter8/stylesApi-v21.xml\",true);\n}\n", "nl": "Test setting a low-api attributes and parent in a theme defined only in higher api files"}
{"code": "private static void deleteRecursive(File f) throws CarbonUtilException {\n  if (f.isDirectory()) {\n    if (f.listFiles() != null) {\n      for (      File c : f.listFiles()) {\n        deleteRecursive(c);\n      }\n    }\n  }\n  if (f.exists() && !f.delete()) {\n    throw new CarbonUtilException(\"Error while deleting the folders and files\");\n  }\n}\n", "nl": "Recursively delete the files"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"rename attribute=\");\n  final String attribute=np.getWordRespectCase();\n  np.matchIgnoreCase(\"newName=\");\n  String newName=np.getWordRespectCase();\n  np.matchIgnoreCase(\";\");\n  final SamplesViewer viewer=(SamplesViewer)getDir().getViewerByClass(SamplesViewer.class);\n  viewer.getSamplesTable().renameAttribute(attribute,newName);\n}\n", "nl": "parses the given command and executes it"}
{"code": "private Map<String,List<TableBlockInfo>> mappedAndGetTaskIdToTableBlockInfo(Map<String,List<TableBlockInfo>> segmentToTableBlocksInfos){\n  Map<String,List<TableBlockInfo>> taskIdToTableBlockInfoMap=new ConcurrentHashMap<String,List<TableBlockInfo>>();\n  Iterator<Entry<String,List<TableBlockInfo>>> iterator=segmentToTableBlocksInfos.entrySet().iterator();\n  while (iterator.hasNext()) {\n    Entry<String,List<TableBlockInfo>> next=iterator.next();\n    List<TableBlockInfo> value=next.getValue();\n    for (    TableBlockInfo blockInfo : value) {\n      String taskNo=DataFileUtil.getTaskNo(blockInfo.getFilePath());\n      List<TableBlockInfo> list=taskIdToTableBlockInfoMap.get(taskNo);\n      if (null == list) {\n        list=new ArrayList<TableBlockInfo>();\n        taskIdToTableBlockInfoMap.put(taskNo,list);\n      }\n      list.add(blockInfo);\n    }\n  }\n  return taskIdToTableBlockInfoMap;\n}\n", "nl": "Below method will be used to get the task id to all the table block info belongs to that task id mapping"}
{"code": "public boolean filterOut(final SAMRecord record){\n  if (include) {\n    if (record.getDuplicateReadFlag()) {\n      return false;\n    }\n  }\n else {\n    if (!record.getDuplicateReadFlag()) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "public Matrix(double vals[],int m){\n  this.m=m;\n  n=(m != 0 ? vals.length / m : 0);\n  if (m * n != vals.length) {\n    throw new IllegalArgumentException(\"Array length must be a multiple of m.\");\n  }\n  A=new double[m][n];\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      A[i][j]=vals[i + j * m];\n    }\n  }\n}\n", "nl": "Construct a matrix from a one-dimensional packed array"}
{"code": "private String preprocessSLD(StyledLayerDescriptor sld){\n  if (sld == null) {\n    return null;\n  }\n  SLDWriterInterface sldWriter=SLDWriterFactory.createWriter(null);\n  DuplicatingStyleVisitor duplicator=new DuplicatingStyleVisitor();\n  sld.accept(duplicator);\n  StyledLayerDescriptor sldCopy=(StyledLayerDescriptor)duplicator.getCopy();\n  for (  StyledLayer styledLayer : sldCopy.layers()) {\n    if (styledLayer instanceof UserLayer) {\n      UserLayerImpl userLayer=(UserLayerImpl)styledLayer;\n      userLayer.setInlineFeatureDatastore(null);\n      userLayer.setInlineFeatureType(null);\n    }\n  }\n  String sldContents=sldWriter.encodeSLD(null,sldCopy);\n  return sldContents;\n}\n", "nl": "Take a copy of the StyledLayerDescriptor and null out the inline features"}
{"code": "protected void init(ModelEntity modelEntity){\n  assertIsMutable();\n  if (modelEntity == null) {\n    throw new IllegalArgumentException(\"Cannot create a GenericEntity with a null modelEntity parameter\");\n  }\n  this.modelEntity=modelEntity;\n  this.entityName=modelEntity.getEntityName();\n  this.observable=new Observable();\n  if (this.entityName == null) {\n    throw new IllegalArgumentException(\"Cannot create a GenericEntity with a null entityName in the modelEntity parameter\");\n  }\n}\n", "nl": "Creates new GenericEntity"}
{"code": "private void drawBuilding(Canvas canvas){\n  final Matrix matrix=mMatrix;\n  matrix.reset();\n  float dragPercent=Math.min(1f,Math.abs(mPercent));\n  float buildingScale;\n  buildingScale=BUILDING_INITIAL_SCALE + (BUILDING_FINAL_SCALE - BUILDING_INITIAL_SCALE) * dragPercent;\n  matrix.preScale(buildingScale,buildingScale);\n  final float offsetX=mScreenWidth / 2 - mBuilding.getWidth() / 2 + (1f - buildingScale) * mBuilding.getWidth() / 2;\n  final float offsetY=mBuildingTopOffset;\n  matrix.postTranslate(offsetX,offsetY);\n  canvas.drawBitmap(mBuilding,matrix,null);\n}\n", "nl": "Draw building"}
{"code": "public static Map<String,Object> dom2Map(Document doc){\n  Map<String,Object> maproot=new HashMap<String,Object>();\n  if (doc == null)   return maproot;\n  Element root=doc.getRootElement();\n  List list1=root.elements();\n  for (  Object obj : list1) {\n    Element element=(Element)obj;\n    Map<String,Object> map=new HashMap<String,Object>();\n    element2Map(element,map);\n    maproot.put(element.getName(),map);\n  }\n  return maproot;\n}\n", "nl": "Document to map"}
{"code": "public String toString(){\n  StringBuilder builder=new StringBuilder();\n  Set<Map.Entry<String,ColumnSchemaDetails>> entries=columnSchemaDetailsMap.entrySet();\n  Iterator<Map.Entry<String,ColumnSchemaDetails>> iterator=entries.iterator();\n  while (iterator.hasNext()) {\n    Map.Entry<String,ColumnSchemaDetails> entry=iterator.next();\n    builder.append(entry.getKey());\n    builder.append(CarbonCommonConstants.HASH_SPC_CHARACTER);\n    builder.append(entry.getValue().toString());\n    if (iterator.hasNext()) {\n      builder.append(CarbonCommonConstants.HASH_SPC_CHARACTER);\n    }\n  }\n  return builder.toString();\n}\n", "nl": "return the string object"}
{"code": "@Override public boolean isSchemaLanguageSupported(String schemaLanguage){\n  if (schemaLanguage == null) {\n    throw new NullPointerException(JAXPValidationMessageFormatter.formatMessage(fXMLSchemaLoader.getLocale(),\"SchemaLanguageNull\",null));\n  }\n  if (schemaLanguage.length() == 0) {\n    throw new IllegalArgumentException(JAXPValidationMessageFormatter.formatMessage(fXMLSchemaLoader.getLocale(),\"SchemaLanguageLengthZero\",null));\n  }\n  return schemaLanguage.equals(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n}\n", "nl": "<p>Is specified schema supported by this <code>SchemaFactory</code>?</p>"}
{"code": "public static byte[] encryptSHA(byte[] bytes){\n  try {\n    MessageDigest md=MessageDigest.getInstance(\"SHA\");\n    md.update(bytes);\n    return md.digest();\n  }\n catch (  NoSuchAlgorithmException e) {\n    e.printStackTrace();\n  }\n  return new byte[0];\n}\n", "nl": "Encrypt SHA1"}
{"code": "private boolean parseUnescapedField(int fieldUpto) throws ParseException {\n  int fieldStart=bufferUpto;\n  while (bufferUpto < chars.length) {\n    char c=chars[bufferUpto++];\n    if (c == delimChar) {\n      addOneField(fieldUpto,fieldStart,bufferUpto - fieldStart - 1);\n      return true;\n    }\n else     if (c == NEWLINE) {\n      addOneField(fieldUpto,fieldStart,bufferUpto - fieldStart - 1);\n      bufferUpto--;\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Returns true if a field was parsed, else false if the end of the bytes was hit first"}
{"code": "public void resetMove(){\n  if (owner.getAi2().isLogging()) {\n    AI2Logger.moveinfo(owner,\"MC perform stop\");\n  }\n  started.set(false);\n  targetDestX=0;\n  targetDestY=0;\n  targetDestZ=0;\n  pointX=0;\n  pointY=0;\n  pointZ=0;\n}\n", "nl": "Initialize values to default ones"}
{"code": "public MonsterAilmentCursor queryAilmentsFromMonster(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=true;\n  qh.Table=S.TABLE_AILMENT;\n  qh.Columns=null;\n  qh.Selection=S.COLUMN_AILMENT_MONSTER_ID + \" = \" + id;\n  qh.SelectionArgs=null;\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new MonsterAilmentCursor(wrapHelper(qh));\n}\n", "nl": "MONSTER AILMENT QUERIES"}
{"code": "public static boolean isDirty(final ISVNLocalResource svnResource,LocalResourceStatus status){\n  try {\n    if (!svnResource.exists())     return false;\n    if (svnResource.getIResource().getType() == IResource.FILE) {\n      return ((status.isTextModified() || status.isPropModified() || status.isReplaced()|| status.isAdded()) && !status.isIgnored() && !svnResource.isIgnored());\n    }\n else {\n      return svnResource.isDirty();\n    }\n  }\n catch (  SVNException e) {\n    if (!e.operationInterrupted()) {\n      SVNUIPlugin.log(e.getStatus());\n    }\n    return true;\n  }\n}\n", "nl": "tells if given svn resource is dirty or not"}
{"code": "@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) @Override public void onBaseContextAttached(Context base){\n  super.onBaseContextAttached(base);\n  MultiDex.install(base);\n  SampleApplicationContext.application=getApplication();\n  SampleApplicationContext.context=getApplication();\n  TinkerManager.setTinkerApplicationLike(this);\n  TinkerManager.initFastCrashProtect();\n  TinkerManager.setUpgradeRetryEnable(true);\n  TinkerInstaller.setLogIml(new MyLogImp());\n  TinkerManager.installTinker(this);\n}\n", "nl": "install multiDex before install tinker so we don't need to put the tinker lib classes in the main dex"}
{"code": "public void invalidateWheel(boolean clearCaches){\n  if (clearCaches) {\n    recycle.clearAll();\n    if (itemsLayout != null) {\n      itemsLayout.removeAllViews();\n    }\n    scrollingOffset=0;\n  }\n else   if (itemsLayout != null) {\n    recycle.recycleItems(itemsLayout,firstItem,new ItemsRange());\n  }\n  invalidate();\n}\n", "nl": "Invalidates wheel"}
{"code": "private void initCreateUserinfoSchma() throws SQLException {\n  ResultSet rs;\n  rs=stmt.executeQuery(\"show tables from test like'userinformation'\");\n  if (false == rs.next()) {\n    String sql=\"CREATE TABLE userinformation \" + \"(id varchar(10) not NULL, \" + \" password VARCHAR(10) not Null, \"+ \" PRIMARY KEY ( id )) Engine=Innodb default charset = utf8\";\n    stmt.executeUpdate(sql);\n  }\n  rs=stmt.executeQuery(\"show tables from test like'useripandaccess'\");\n  if (false == rs.next()) {\n    String sql=\"CREATE TABLE useripandaccess \" + \"(id varchar(10) not NULL, \" + \"ipaddress varchar(30) not NULL, \"+ \"accessAndTerminateTime datetime not null,\"+ \"type varchar(10)\"+ \") Engine=Innodb default charset = utf8\";\n    stmt.executeUpdate(sql);\n  }\n}\n", "nl": "int database system scema for gameplayer"}
{"code": "public static boolean incrementIfLessThan(AtomicInteger counter,int max){\n  while (true) {\n    int current=counter.intValue();\n    if (current < max) {\n      if (counter.compareAndSet(current,current + 1)) {\n        return true;\n      }\n    }\n else {\n      return false;\n    }\n  }\n}\n", "nl": "Atomically increment the counter if it's below the given max value"}
{"code": "@Nullable public static Label createLabelFromRuleName(@Nullable BlazePackage blazePackage,@Nullable String ruleName){\n  if (blazePackage == null || ruleName == null) {\n    return null;\n  }\n  WorkspacePath packagePath=blazePackage.buildFile.getPackageWorkspacePath();\n  RuleName name=RuleName.createIfValid(ruleName);\n  if (packagePath == null || name == null) {\n    return null;\n  }\n  return new Label(packagePath,name);\n}\n", "nl": "Returns null if this is not a valid Label (if either the package path or rule name are invalid)"}
{"code": "public boolean parseBoolean(String text) throws DataParseException {\n  if (TRUE.equalsIgnoreCase(text)) {\n    return true;\n  }\n else   if (FALSE.equalsIgnoreCase(text)) {\n    return false;\n  }\n else {\n    throw new DataParseException(\"Input does not represent a boolean value: \" + text);\n  }\n}\n", "nl": "Parse a boolean value from a text string"}
{"code": "private void applyCrop(){\n  if (isCropping || mBitmap == null) {\n    return;\n  }\n  isCropping=true;\n  final int width=mBitmap.getWidth();\n  final int height=mBitmap.getHeight();\n  String path=new File(getCacheDir(),CROPPED + System.currentTimeMillis() + FORMAT).getPath();\n  mBitmap=mCropView.getCroppedImage();\n  supportInvalidateOptionsMenu();\n  SavePhotoTask task=new SavePhotoTask.Builder().setAngle(mAngle).setSize(width,height).setRect(mCropView.getActualCropRect()).setContext(this).setOutPath(path).setCallback(this).setUri(mUri).build();\n  task.execute();\n}\n", "nl": "Cropping bitmap"}
{"code": "private void overwriteDictionaryMetaFile(ColumnDictionaryChunkMeta firstDictionaryChunkMeta,String dictionaryFile) throws IOException {\n  ThriftWriter thriftMetaChunkWriter=new ThriftWriter(dictionaryFile,false);\n  try {\n    thriftMetaChunkWriter.open();\n    thriftMetaChunkWriter.write(firstDictionaryChunkMeta);\n  }\n catch (  IOException e) {\n  }\n finally {\n    thriftMetaChunkWriter.close();\n  }\n}\n", "nl": "This method will overwrite a given file with data provided"}
{"code": "private Log validate(String logId,String projectName){\n  Log log=logRepository.findOne(logId);\n  expect(log,notNull()).verify(ErrorType.LOG_NOT_FOUND,logId);\n  final TestItem testItem=testItemRepository.findOne(log.getTestItemRef());\n  expect(testItem,not(Preconditions.IN_PROGRESS)).verify(ErrorType.TEST_ITEM_IS_NOT_FINISHED,formattedSupplier(\"Unable to delete log '{}' when test item '{}' in progress state\",log.getId(),testItem.getId()));\n  final String expectedProjectName=launchRepository.findOne(testItem.getLaunchRef()).getProjectRef();\n  expect(expectedProjectName,equalTo(projectName)).verify(ErrorType.FORBIDDEN_OPERATION,formattedSupplier(\"Log '{}' not under specified '{}' project\",logId,projectName));\n  return log;\n}\n", "nl": "Validate specified log against parent objects and project"}
{"code": "@PreDestroy public void stop(){\n  if (leaderLock != null) {\n    leaderLock.release();\n  }\n  if (scheduler != null) {\n    scheduler.shutdownNow();\n  }\n  isLeader=false;\n}\n", "nl": "Release the leader lock if necessary"}
{"code": "public S2Point ortho(){\n  int k=largestAbsComponent();\n  S2Point temp;\n  if (k == 1) {\n    temp=new S2Point(1,0,0);\n  }\n else   if (k == 2) {\n    temp=new S2Point(0,1,0);\n  }\n else {\n    temp=new S2Point(0,0,1);\n  }\n  return S2Point.normalize(crossProd(this,temp));\n}\n", "nl": "return a vector orthogonal to this one"}
{"code": "public void unregister(ILeasedEntryCacheInfo leaseCacheInfo,long expiration){\n  boolean unregister;\n  if (leaseCacheInfo.isOffHeapEntry())   unregister=expiration != Long.MAX_VALUE && !_alwaysDisableEntriesLeases;\n else   unregister=leaseCacheInfo.isConnectedToLeaseManager();\n  if (unregister) {\n    if (!leaseCacheInfo.isOffHeapEntry()) {\n      leaseCacheInfo.getLeaseManagerListRef().remove(leaseCacheInfo.getLeaseManagerPosition());\n    }\n else {\n      Long expirationTime=((expiration / _expirationTimeInterval + 1) * _expirationTimeInterval);\n      Cell cell=_expirationList.get(expirationTime);\n      if (cell != null)       cell.unregisterByPos(leaseCacheInfo.getLeaseManagerPosition(),true);\n    }\n    leaseCacheInfo.setLeaseManagerListRefAndPosition(null,null);\n  }\n}\n", "nl": "unregister from lease manager based on direct backrefs Note: entry/template must be locked"}
{"code": "public String toStringAsBinarySequences(Taxa taxa){\n  StringBuilder buf=new StringBuilder();\n  for (Iterator it=taxa.iterator(); it.hasNext(); ) {\n    String name=(String)it.next();\n    int t=taxa.indexOf(name);\n    buf.append(\"> \").append(name).append(\"\\n\");\n    for (int s=1; s <= size(); s++) {\n      Split split=getSplit(s);\n      if (split.getA().get(t))       buf.append(\"1\");\n else       buf.append(\"0\");\n    }\n    buf.append(\"\\n\");\n  }\n  return buf.toString();\n}\n", "nl": "gets the splits as binary sequences in fastA format"}
{"code": "public void sendCrxRequest(HttpUriRequest request,String desiredMessage) throws IOException {\n  String result;\n  try (CloseableHttpResponse response=httpClient.execute(request)){\n    result=EntityUtils.toString(response.getEntity());\n  }\n   if (!result.contains(desiredMessage)) {\n    throw new IOException(\"crx request failure: \" + result + \" doesn't contain desired message: \"+ desiredMessage);\n  }\n}\n", "nl": "This method sends request to author instance"}
{"code": "public void draw(Canvas c,Rect bounds){\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mPaint.setColor(mCurrentColor);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n  if (mAlpha < 255) {\n    mCirclePaint.setColor(mBackgroundColor);\n    mCirclePaint.setAlpha(255 - mAlpha);\n    c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  }\n}\n", "nl": "Draw the progress spinner"}
{"code": "private void fireFrameSaved(int frameNumber){\n  if (listenerList == null)   return;\n  Object[] listeners=listenerList.getListenerList();\n  for (int i=listeners.length - 2; i >= 0; i-=2) {\n    if (listeners[i] == FrameSavedListener.class) {\n      ((FrameSavedListener)listeners[i + 1]).frameSaved(frameNumber);\n    }\n  }\n}\n", "nl": "Warns all listeners of a new frame added event"}
{"code": "public MonsterHabitatCursor queryHabitatLocation(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=true;\n  qh.Table=S.TABLE_HABITAT;\n  qh.Columns=null;\n  qh.Selection=S.COLUMN_HABITAT_LOCATION_ID + \" = ?\";\n  qh.SelectionArgs=new String[]{String.valueOf(id)};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=\"m\" + S.COLUMN_MONSTERS_SORT_NAME + \" ASC\";\n  qh.Limit=null;\n  return new MonsterHabitatCursor(wrapJoinHelper(builderHabitat(qh.Distinct),qh));\n}\n", "nl": "Get a cursor with a query to grab all monsters by a location"}
{"code": "public boolean filterOut(final SAMRecord record){\n  if (include) {\n    if (record.getReadPairedFlag()) {\n      return false;\n    }\n  }\n else {\n    if (!record.getReadPairedFlag()) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "public void addToClassification(Integer classId,int size,List<Long> positions) throws IOException {\n  numberOfClasses++;\n  classificationIndexTmpFileWriter.writeInt(classId);\n  if (size == positions.size())   classificationIndexTmpFileWriter.writeInt(size);\n else {\n    classificationIndexTmpFileWriter.writeInt(-size);\n    classificationIndexTmpFileWriter.writeInt(positions.size());\n  }\n  if (positions.size() > 0) {\n    classificationIndexTmpFileWriter.writeLong(io.getPosition());\n    for (    Long pos : positions) {\n      io.writeLong(pos);\n    }\n  }\n else {\n    classificationIndexTmpFileWriter.writeLong(-1);\n  }\n}\n", "nl": "add an entry to the classification"}
{"code": "@NotNull public static List<AttributeSnapshot> createAttributesForTag(@NotNull XmlTag tag){\n  XmlAttribute[] psiAttributes=tag.getAttributes();\n  List<AttributeSnapshot> attributes=Lists.newArrayListWithExpectedSize(psiAttributes.length);\n  for (  XmlAttribute psiAttribute : psiAttributes) {\n    AttributeSnapshot attribute=createAttributeSnapshot(psiAttribute);\n    if (attribute != null) {\n      attributes.add(attribute);\n    }\n  }\n  return attributes;\n}\n", "nl": "Creates a list of attribute snapshots corresponding to the attributes of the given tag"}
{"code": "private String makeAbsolute(String uri){\n  if (uri == null) {\n    uri=\"\";\n  }\n  try {\n    URL url=new URL(uri);\n    return url.toString();\n  }\n catch (  MalformedURLException mue) {\n    try {\n      URL fileURL=FileURL.makeURL(uri);\n      return fileURL.toString();\n    }\n catch (    MalformedURLException mue2) {\n      return uri;\n    }\n  }\n}\n", "nl": "Attempt to construct an absolute URI"}
{"code": "public void loadFromFile(String sFileName) throws FileNotFoundException, IOException {\n  FileReader frFile=new FileReader(sFileName);\n  String sText=\"\";\n  int c=frFile.read();\n  while (c != -1) {\n    sText+=c;\n    c=frFile.read();\n  }\n  addText(sText);\n  frFile.close();\n}\n", "nl": "Loads a text file with filename sFilename and adds all its words to the definitions"}
{"code": "public PieChartDrawer createInstance(){\n  final PieChartDrawer drawer=new PieChartDrawer();\n  drawer.setViewer(viewer);\n  drawer.setChartData(new DefaultChartData());\n  drawer.setClass2HigherClassMapper(class2HigherClassMapper);\n  drawer.setSeriesLabelGetter(seriesLabelGetter);\n  drawer.setExecutorService(executorService);\n  return drawer;\n}\n", "nl": "create a new instance of the given type of drawer, sharing internal data structures"}
{"code": "synchronized void redo(RTEditText editor){\n  Stack<Operation> redoStack=getRedoStack(editor);\n  if (!redoStack.empty()) {\n    Stack<Operation> undoStack=getUndoStack(editor);\n    Operation op=redoStack.pop();\n    push(op,undoStack);\n    op.redo(editor);\n    while (!redoStack.empty() && op.canMerge(redoStack.peek())) {\n      op=redoStack.pop();\n      push(op,undoStack);\n      op.redo(editor);\n    }\n  }\n}\n", "nl": "Re-do the last undone operation for a specific rich text editor"}
{"code": "private void initializeParameters(){\n  analysisParams=new HntmAnalyzerParams();\n  analysisParams.harmonicModel=HntmAnalyzerParams.HARMONICS_PLUS_NOISE;\n  analysisParams.noiseModel=HntmAnalyzerParams.WAVEFORM;\n  analysisParams.useHarmonicAmplitudesDirectly=true;\n  analysisParams.harmonicSynthesisMethodBeforeNoiseAnalysis=HntmSynthesizerParams.LINEAR_PHASE_INTERPOLATION;\n  analysisParams.regularizedCepstrumWarpingMethod=RegularizedCepstrumEstimator.REGULARIZED_CEPSTRUM_WITH_POST_MEL_WARPING;\n  synthesisParams=new HntmSynthesizerParams();\n  synthesisParams.harmonicPartSynthesisMethod=HntmSynthesizerParams.LINEAR_PHASE_INTERPOLATION;\n  synthesisParams.overlappingHarmonicPartSynthesis=false;\n  synthesisParams.harmonicSynthesisOverlapInSeconds=0.010f;\n  synthesisParams.writeHarmonicPartToSeparateFile=false;\n  synthesisParams.writeNoisePartToSeparateFile=false;\n  synthesisParams.writeTransientPartToSeparateFile=false;\n  synthesisParams.writeOriginalMinusHarmonicPartToSeparateFile=false;\n}\n", "nl": "intialize hnm parameters"}
{"code": "public static String md5(String str){\n  if (str == null) {\n    return null;\n  }\n  try {\n    MessageDigest messageDigest=MessageDigest.getInstance(\"MD5\");\n    messageDigest.update(str.getBytes());\n    return new String(encodeHex(messageDigest.digest()));\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "encode By MD5"}
{"code": "private String rateLabels2RelativeValues(String rateAttribute){\n  if (rateAttribute.equals(\"x-slow\")) {\n    return \"-50%\";\n  }\n else   if (rateAttribute.equals(\"slow\")) {\n    return \"-33.3%\";\n  }\n else   if (rateAttribute.equals(\"medium\")) {\n    return \"+0%\";\n  }\n else   if (rateAttribute.equals(\"fast\")) {\n    return \"+33%\";\n  }\n else   if (rateAttribute.equals(\"x-fast\")) {\n    return \"+100%\";\n  }\n  return \"+0%\";\n}\n", "nl": "a look-up table for mapping rate labels to relative values"}
{"code": "public static String pack_metadata(NameValuePair[] meta_list){\n  if (meta_list.length == 0) {\n    return \"\";\n  }\n  StringBuffer sb=new StringBuffer(32 * meta_list.length);\n  sb.append(meta_list[0].getName()).append(FDFS_FIELD_SEPERATOR).append(meta_list[0].getValue());\n  for (int i=1; i < meta_list.length; i++) {\n    sb.append(FDFS_RECORD_SEPERATOR);\n    sb.append(meta_list[i].getName()).append(FDFS_FIELD_SEPERATOR).append(meta_list[i].getValue());\n  }\n  return sb.toString();\n}\n", "nl": "pack metadata array to string"}
{"code": "private FrameData(@NotNull DeviceData deviceData,@NotNull FrameData large){\n  myDeviceData=deviceData;\n  myDouble=large;\n  myOrientation=large.myOrientation;\n  myX=large.myX / 2;\n  myY=large.myY / 2;\n  myWidth=large.myWidth / 2;\n  myHeight=large.myHeight / 2;\n  myFrameWidth=large.myFrameWidth / 2;\n  myFrameHeight=large.myFrameHeight / 2;\n  myCropX1=0;\n  myCropY1=0;\n  myCropX2=myFrameWidth;\n  myCropY2=myFrameHeight;\n}\n", "nl": "Copies the larger frame data and makes a smaller (half size) version; this is used for faster thumbnail painting during render previews etc"}
{"code": "public SampleAttributeTable extractTable(Collection<String> samples){\n  SampleAttributeTable sampleAttributeTable=new SampleAttributeTable();\n  for (  String sample : getSampleOrder()) {\n    if (samples.contains(sample)) {\n      sampleAttributeTable.addSample(sample,getAttributesToValues(sample),true,true);\n    }\n  }\n  sampleAttributeTable.attributeOrder.clear();\n  sampleAttributeTable.attributeOrder.addAll(attributeOrder);\n  for (  String attribute : attribute2type.keySet()) {\n    sampleAttributeTable.attribute2type.put(attribute,attribute2type.get(attribute));\n  }\n  sampleAttributeTable.removeUndefinedAttributes();\n  return sampleAttributeTable;\n}\n", "nl": "extract a metadata table containing the named samples"}
{"code": "public Matrix times(double s){\n  Matrix X=new Matrix(m,n);\n  double[][] C=X.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      C[i][j]=s * A[i][j];\n    }\n  }\n  return X;\n}\n", "nl": "Multiply a matrix by a scalar, C = s*A"}
{"code": "public void testWriteReadEmpty() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(empty);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  LoadBalancingPolicy copy=(LoadBalancingPolicy)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(empty,copy));\n}\n", "nl": "Test read and write empty ClusterPolicy object"}
{"code": "public ShortArrayList top(int n){\n  ShortArrayList top=new ShortArrayList();\n  short[] values=data.toShortArray();\n  ShortArrays.parallelQuickSort(values,ReverseShortComparator.instance());\n  for (int i=0; i < n && i < values.length; i++) {\n    top.add(values[i]);\n  }\n  return top;\n}\n", "nl": "Returns the largest (\"top\") n values in the column"}
{"code": "private int measureShort(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(2 * mRadius + getPaddingTop() + getPaddingBottom() + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the height of this view"}
{"code": "synchronized void undo(RTEditText editor){\n  Stack<Operation> undoStack=getUndoStack(editor);\n  if (!undoStack.empty()) {\n    Stack<Operation> redoStack=getRedoStack(editor);\n    Operation op=undoStack.pop();\n    push(op,redoStack);\n    op.undo(editor);\n    while (!undoStack.empty() && op.canMerge(undoStack.peek())) {\n      op=undoStack.pop();\n      push(op,redoStack);\n      op.undo(editor);\n    }\n  }\n}\n", "nl": "Undo the last operation for a specific rich text editor"}
{"code": "@Override public boolean equals(Object obj){\n  if (!(obj instanceof GenericEntity))   return false;\n  try {\n    return this.compareTo((GenericEntity)obj) == 0;\n  }\n catch (  ClassCastException e) {\n    return false;\n  }\n}\n", "nl": "Determines the equality of two GenericEntity objects, overrides the default equals"}
{"code": "@Subscribe public void onEvent(LoginEventResult result){\n  if (result.isLoggedIn()) {\n    LatLng latLng=LocationManager.getInstance(MainActivity.this).getLocation();\n    if (latLng != null) {\n      nianticManager.getCatchablePokemon(latLng.latitude,latLng.longitude,0D);\n    }\n else {\n      Snackbar.make(findViewById(R.id.root),getString(R.string.toast_login_error),Snackbar.LENGTH_LONG).show();\n    }\n  }\n}\n", "nl": "Triggers a first pokemon scan after a successful login"}
{"code": "public static byte[] bufferedImageToJPEG(BufferedImage img,float quality) throws IOException {\n  Iterator<ImageWriter> writers=ImageIO.getImageWritersBySuffix(\"jpeg\");\n  if (!writers.hasNext())   throw new IllegalStateException(\"No writers for jpeg...\");\n  ImageWriter writer=(ImageWriter)writers.next();\n  ImageWriteParam imageWriteParam=writer.getDefaultWriteParam();\n  imageWriteParam.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);\n  imageWriteParam.setCompressionQuality(quality);\n  IIOImage iioImage=new IIOImage(img,null,null);\n  ByteArrayOutputStream baos=new ByteArrayOutputStream(img.getWidth() * img.getHeight() * 2);\n  MemoryCacheImageOutputStream mcios=new MemoryCacheImageOutputStream(baos);\n  writer.setOutput(mcios);\n  writer.write(null,iioImage,imageWriteParam);\n  baos.flush();\n  mcios.close();\n  return baos.toByteArray();\n}\n", "nl": "Converts a buffered image to a JPEG image"}
{"code": "private void onCreateFolderOperationFinish(CreateFolderOperation operation,RemoteOperationResult result){\n  if (result.isSuccess()) {\n    refreshListOfFilesFragment();\n  }\n else {\n    try {\n      Toast msg=Toast.makeText(FileDisplayActivity.this,ErrorMessageAdapter.getErrorCauseMessage(result,operation,getResources()),Toast.LENGTH_LONG);\n      msg.show();\n    }\n catch (    NotFoundException e) {\n      Log_OC.e(TAG,\"Error while trying to show fail message \",e);\n    }\n  }\n}\n", "nl": "Updates the view associated to the activity after the finish of an operation trying create a new folder"}
{"code": "public final void closeFallbackInputStream() throws DataFallbackException {\n  if (getInput() != null) {\n    try {\n      if (LOG.isDebugEnabled())       LOG.debug(\"closeInputStream() : Closing the file reader for the file \" + dataFile.getName());\n      getInput().close();\n    }\n catch (    IOException e) {\n      throw new DataFallbackException(e.getMessage());\n    }\n finally {\n      setInput(null);\n    }\n  }\n}\n", "nl": "It closes the input stream"}
{"code": "public static boolean isClassSupport(String clzName){\n  try {\n    Class.forName(clzName);\n    return true;\n  }\n catch (  ClassNotFoundException e) {\n    return false;\n  }\n}\n", "nl": "Check if the class is valid by clzName"}
{"code": "private boolean checkCameraHardware(Context context){\n  if (isInEditMode()) {\n    return false;\n  }\n  if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Check if this device has a camera"}
{"code": "public boolean removeByObject(T obj){\n  lock.lock();\n  IObjectInfo<T> oi=null;\n  try {\n    if (_objectsMap != null) {\n      if ((oi=_objectsMap.remove(obj)) != null) {\n        remove_impl((ObjectInfo<T>)oi);\n        if (m_Size == 0)         _objectsMap=null;\n        return true;\n      }\n      return false;\n    }\n    return removeByObject_impl(obj);\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "given an object scan the list, find it and remove it, returns true if found"}
{"code": "@SuppressLint(\"DefaultLocale\") public static String formatDuration(int duration){\n  duration/=1000;\n  int minute=duration / 60;\n  int hour=minute / 60;\n  minute%=60;\n  int second=duration % 60;\n  if (hour != 0)   return String.format(\"%2d:%02d:%02d\",hour,minute,second);\n else   return String.format(\"%02d:%02d\",minute,second);\n}\n", "nl": "Parse the time in milliseconds into String with the format: hh:mm:ss or mm:ss"}
{"code": "protected void updateNodeData(int r,boolean added){\n  if (added) {\n    m_links.addRow();\n  }\n else {\n    m_nodeTuples.invalidate(r);\n    m_links.removeRow(r);\n  }\n}\n", "nl": "Update the link table to accomodate an inserted or deleted node"}
{"code": "public static byte[] hexStringToBytes(String hexString){\n  if (hexString == null || hexString.equals(\"\")) {\n    return null;\n  }\n  hexString=hexString.toUpperCase();\n  int length=hexString.length() / 2;\n  char[] hexChars=hexString.toCharArray();\n  byte[] d=new byte[length];\n  for (int i=0; i < length; i++) {\n    int pos=i * 2;\n    d[i]=(byte)(charToByte(hexChars[pos]) << 4 | charToByte(hexChars[pos + 1]));\n  }\n  return d;\n}\n", "nl": "Convert hex string to byte[] "}
{"code": "public static boolean shuffle(Object[] objArray,int shuffleCount){\n  int length;\n  if (objArray == null || shuffleCount < 0 || (length=objArray.length) < shuffleCount) {\n    return false;\n  }\n  for (int i=1; i <= shuffleCount; i++) {\n    int random=getRandom(length - i);\n    Object temp=objArray[length - i];\n    objArray[length - i]=objArray[random];\n    objArray[random]=temp;\n  }\n  return true;\n}\n", "nl": "Shuffling algorithm, Randomly permutes the specified array"}
{"code": "public static <T>T toCompose(Observable<T> observable) throws LoginFailedException, RemoteServerException {\n  try {\n    return observable.toBlocking().first();\n  }\n catch (  RuntimeException e) {\n    if (e.getCause() instanceof AsyncLoginFailedException) {\n      throw new LoginFailedException(e.getMessage(),e.getCause());\n    }\n    if (e.getCause() instanceof AsyncRemoteServerException) {\n      throw new RemoteServerException(e.getMessage(),e.getCause());\n    }\n    throw new AsyncPokemonGoException(\"Unknown exception occurred. \",e);\n  }\n}\n", "nl": "Convert an observable to the actual result, recovering the actual exception and throwing that"}
{"code": "public boolean closeDatabase(String dbfile){\n  if (databases.get(dbfile) != null) {\n    SQLiteDatabase db=(SQLiteDatabase)databases.get(dbfile);\n    db.close();\n    databases.remove(dbfile);\n    return true;\n  }\n  return false;\n}\n", "nl": "Close assets database"}
{"code": "public boolean determineBinary(String fileLocation,String fileName,List<String> codeLines,List<String[]> reportList){\n  SearchcodeLib scl=new SearchcodeLib();\n  BinaryFinding binaryFinding=scl.isBinary(codeLines,fileName);\n  if (binaryFinding.isBinary()) {\n    Singleton.getLogger().info(\"Appears to be binary will not index \" + binaryFinding.getReason() + \" \"+ fileLocation);\n    reportList.add(new String[]{fileLocation,\"excluded\",binaryFinding.getReason()});\n    return true;\n  }\n  return false;\n}\n", "nl": "Shared method which performs all logic for determining and doing if the file is believed to be binary"}
{"code": "public void clear(){\n  lock.lock();\n  try {\n    onceUsedObservers.clear();\n  }\n  finally {\n    lock.unlock();\n  }\n  observers.clear();\n  attackCalcObservers.clear();\n}\n", "nl": "Clear all observers"}
{"code": "private void drawDownLoaded(Canvas canvas,STATUS_MARK status,RectF bounds,float angle){\n  publicPaint.setColor(getProgressColor());\nswitch (status) {\ncase DRAW_ARC:\n    canvas.drawArc(bounds,DEGREE_END_ANGLE - angle,0.001f * TOTAL_ANGLE,false,publicPaint);\n  break;\ncase DRAW_MARK:\nfinal Path dst=mDst;\ndst.reset();\ndst.lineTo(0,0);\npathMeasure1.getSegment(mMarkOkstart * mMarkOklength,(mMarkOkstart + mMarkOkdegree) * mMarkOklength,dst,true);\ncanvas.drawPath(dst,publicPaint);\nbreak;\n}\n}\n", "nl": "Draw success"}
{"code": "public static String grabSubjectString(String text) throws IOException {\n  BufferedReader r=new BufferedReader(new StringReader(text));\n  String aLine;\n  StringBuilder buf=new StringBuilder();\n  boolean passedScore=false;\n  while ((aLine=r.readLine()) != null) {\n    aLine=aLine.trim();\n    if (aLine.startsWith(\"Score\")) {\n      if (!passedScore)       passedScore=true;\n else       break;\n    }\n    if (aLine.startsWith(\"Sbjct\")) {\n      String[] words=aLine.split(\" +\");\n      buf.append(words[2]);\n    }\n  }\n  return buf.toString().replaceAll(\"\\n\",\"\").replaceAll(\"\\r\",\"\");\n}\n", "nl": "grab the total subject string"}
{"code": "public void add(String uid){\n  cleanIfNeeded();\n  if (currentSet) {\n    _idSet0.add(uid);\n  }\n else {\n    _idSet1.add(uid);\n  }\n}\n", "nl": "Adds a new UID"}
{"code": "public boolean addInsertion(Insertion insert){\n  setHasNewItems(true);\n  int insertPosition=getItemCount() <= getFootersCount() ? 0 : getItemCount() - getFootersCount();\n  boolean result;\n  if (getFootersCount() == 0) {\n    mInserts.add(insert);\n    result=getItems().add(null);\n  }\n else {\n    mInserts.add(insertPosition,insert);\n    getItems().add(insertPosition,null);\n    result=true;\n  }\n  updateCounter(insert);\n  notifyIfNeed();\n  return result;\n}\n", "nl": "Add custom view insertion to adapter"}
{"code": "public String toString(){\n  StringBuffer buf=new StringBuffer();\n  for (int i=0; i < controls.length; i++) {\n    if (i != 0) {\n      buf.append(\", \");\n      if ((i + 1) == controls.length) {\n        buf.append(\"and \");\n      }\n    }\n    buf.append(controls[i].getType());\n  }\n  return new String(getType() + \" Control containing \" + buf+ \" Controls.\");\n}\n", "nl": "Provides a string representation of the control"}
{"code": "public static DataFrame zeromeanUnitVariance(DataFrame frame,List<String> skipColumns){\n  String[] columnNames=frame.columns();\n  for (  String columnName : columnNames) {\n    if (skipColumns.contains(columnName))     continue;\n    DataFrame meanStd=frame.select(columnName).agg(mean(columnName),stddev(columnName));\n    Row r=meanStd.collect()[0];\n    double mean=((Number)r.get(0)).doubleValue();\n    double std=((Number)r.get(1)).doubleValue();\n    if (std == 0.0)     std=1;\n    frame=frame.withColumn(columnName,frame.col(columnName).minus(mean).divide(std));\n  }\n  return frame;\n}\n", "nl": "Normalize by zero mean unit variance"}
{"code": "@Override public void mouseRelease(int x,int y,ViewTransform transform,Selection selection){\n  for (  TableClickTarget target : mTableClickTargets) {\n    if (target.contains(x,y)) {\n      ConstraintTableLayout table=target.getTable();\n      int column=target.getColumn();\n      table.cycleColumnAlignment(column);\n    }\n  }\n}\n", "nl": "Handle mouse release event to check for our table click targets"}
{"code": "Collection<? extends ClientRequestResult> handleApplyConfigurationRequest(final ClientRequest configurationRequest,final Session session,final Destination replyDestination){\n  final Collection<ConfigurationReport> reports=new ArrayList<>(configurationRequest.getTagIds().size());\n  for (  Long id : configurationRequest.getTagIds()) {\n    final int configId=castLongToInt(id);\nswitch (configurationRequest.getResultType()) {\ncase TRANSFER_CONFIGURATION_REPORT:\n      ClientRequestReportHandler reportHandler=new ClientRequestReportHandler(session,replyDestination,DEFAULT_REPLY_TTL);\n    reports.add(configurationLoader.applyConfiguration(configId,reportHandler));\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Finished processing reconfiguration request with id \" + configId);\n  }\nbreak;\ndefault :\nLOG.error(\"handleConfigurationRequest() - Could not generate response message. Unknown enum ResultType \" + configurationRequest.getResultType());\n}\n}\nreturn reports;\n}\n", "nl": "Inner method which handles the Configuration Requests"}
{"code": "private SegmentNode generate_many_to_all(SegmentNode mp){\n  long left, right;\n  SegmentNode p;\n  left=mp.I1;\n  right=left + mp.L;\n  p=mp.next;\n  while (p != null) {\n    if (p.I1 < left)     left=p.I1;\n    long t=p.I1 + p.L;\n    if (t > right)     right=t;\n    p=p.next;\n  }\n  mp.I1=left;\n  mp.I2=0;\n  mp.L=right - left;\n  mp.next=null;\n  return mp;\n}\n", "nl": "The result is in the form: (p, q, I, 0, L)"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  ServicePanel servicePanel=((RemoteServiceBrowser)getViewer()).getServicePanel();\n  np.matchIgnoreCase(\"select samples=\");\n  String what=np.getWordMatchesIgnoringCase(\"all none\");\n  if (what.equalsIgnoreCase(\"all\"))   servicePanel.selectAll(true);\n else   if (what.equals(\"none\"))   servicePanel.selectAll(false);\n  np.matchRespectCase(\";\");\n  System.err.println(\"Number of nodes selected: \" + servicePanel.getSelectedFiles().size());\n}\n", "nl": "parses the given command and executes it"}
{"code": "private static boolean isForbiddenByClient(String name){\n  if (!NameConfig.NAME_FORBIDDEN_ENABLE || NameConfig.NAME_FORBIDDEN_CLIENT.equals(\"\")) {\n    return false;\n  }\n  if (forbiddenByClient == null || forbiddenByClient.length == 0) {\n    forbiddenByClient=NameConfig.NAME_FORBIDDEN_CLIENT.split(\",\");\n  }\n  for (  String s : forbiddenByClient) {\n    if (name.equalsIgnoreCase(s)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks if a name is forbidden (contains string sequences from config)"}
{"code": "public static String parseCharset(Map<String,String> headers,String defaultCharset){\n  String contentType=headers.get(HTTP.CONTENT_TYPE);\n  if (contentType != null) {\n    String[] params=contentType.split(\";\");\n    for (int i=1; i < params.length; i++) {\n      String[] pair=params[i].trim().split(\"=\");\n      if (pair.length == 2) {\n        if (pair[0].equals(\"charset\")) {\n          return pair[1];\n        }\n      }\n    }\n  }\n  return defaultCharset;\n}\n", "nl": "Retrieve a charset from headers"}
{"code": "@deprecated public CompactCharArray(char[] indexArray,char[] newValues){\n  if (indexArray.length != 2048)   throw new IllegalArgumentException(\"Index out of bounds.\");\n  for (int i=0; i < 2048; i++) {\n    char index=indexArray[i];\n    if ((index < 0) || (index >= newValues.length + 32))     throw new IllegalArgumentException(\"Index out of bounds.\");\n  }\n  this.indices=indexArray;\n  this.values=newValues;\n  this.isCompact=true;\n}\n", "nl": "/*    "}
{"code": "public static String delegateAndAcceptAssignment(HttpServletRequest request,HttpServletResponse response){\n  ServletContext ctx=(ServletContext)request.getAttribute(\"servletContext\");\n  RequestHandler rh=(RequestHandler)ctx.getAttribute(\"_REQUEST_HANDLER_\");\n  Locale locale=UtilHttp.getLocale(request);\n  if (addToOrderRole(request)) {\n    try {\n      EventHandler eh=rh.getEventFactory().getEventHandler(\"service\");\n      eh.invoke(new Event(\"service\",\"\",\"wfAcceptRoleAssignment\",true),null,request,response);\n    }\n catch (    EventHandlerException e) {\n      Debug.logError(e,\"Invocation error\",module);\n      request.setAttribute(\"_ERROR_MESSAGE_\",UtilProperties.getMessage(resource_error,\"OrderFailedToInvokeTheWfDelegateAndAcceptAssignmentService\",locale));\n      return \"error\";\n    }\n    return \"success\";\n  }\n  return \"error\";\n}\n", "nl": "Delegate and accept assignment event"}
{"code": "private boolean canUploadEmblemInfo(Player activePlayer){\n  if (!isBrigadeGeneral(activePlayer)) {\n    return false;\n  }\n else   if (activePlayer.getLegion().getLegionLevel() < 3) {\n    return false;\n  }\n else   if (activePlayer.getLegion().getLegionEmblem().isUploading()) {\n    activePlayer.getLegion().getLegionEmblem().setUploading(false);\n    return false;\n  }\n  return true;\n}\n", "nl": "This method checks all restrictions for upload emblem info"}
{"code": "@Override public void close(){\n  try {\n    if (auth != null) {\n      auth.close();\n    }\n  }\n catch (  IOException e) {\n    LOG.error(\"Failed to close the authentication service\",e);\n  }\n  client.close();\n}\n", "nl": "Close the Pulsar admin client to release all the resources"}
{"code": "public void changeSpaceBackgroundColor(@ColorInt int color){\n  if (color == spaceBackgroundColor) {\n    Log.d(TAG,\"changeSpaceBackgroundColor: color already changed\");\n    return;\n  }\n  spaceBackgroundColor=color;\n  setBackgroundColors();\n  centreContent.changeBackgroundColor(color);\n}\n", "nl": "Change space background color if space view already set up"}
{"code": "boolean deleteTheClientInTheRooms(Client client){\n  boolean result=false;\n  for (int i=gameRooms.size() - 1; i > -1; i--) {\n    if (gameRooms.get(i).exitTheRoom(client)) {\n      result=true;\n      break;\n    }\n  }\n  return result;\n}\n", "nl": "delete the client in the room"}
{"code": "public static boolean isNetworkChanged(Context context,String prevConnectivityType,String mPrevConnectionSubType){\n  String connectivityType=getNetworkType(context);\n  String connectivitySubType=getNetworkSubType(context);\n  if (null == prevConnectivityType) {\n    return false;\n  }\n else   if (!prevConnectivityType.equals(connectivityType)) {\n    return true;\n  }\n else   if (!mPrevConnectionSubType.equals(connectivitySubType)) {\n    return true;\n  }\n  return false;\n}\n", "nl": "Check if network connection has changed"}
{"code": "private String pitchLabels2RelativeValues(String pitchAttribute){\n  if (pitchAttribute.equals(\"x-low\")) {\n    return \"-50%\";\n  }\n else   if (pitchAttribute.equals(\"low\")) {\n    return \"-25%\";\n  }\n else   if (pitchAttribute.equals(\"medium\")) {\n    return \"+0%\";\n  }\n else   if (pitchAttribute.equals(\"high\")) {\n    return \"+100%\";\n  }\n else   if (pitchAttribute.equals(\"x-high\")) {\n    return \"+200%\";\n  }\n  return \"+0%\";\n}\n", "nl": "a look-up for pitch labels to relative changes"}
{"code": "private void applyProsodySpecifications(Document doc){\n  TreeWalker tw=DomUtils.createTreeWalker(doc,doc,MaryXML.PHONE,MaryXML.BOUNDARY,MaryXML.PROSODY);\n  Element e=null;\n  while ((e=(Element)tw.nextNode()) != null) {\n    if (\"prosody\".equals(e.getNodeName())) {\n      NodeList nl=e.getElementsByTagName(\"ph\");\n      applyNewContourSpecifications(nl,e);\n      applySpeechRateSpecifications(nl,e);\n    }\n  }\n}\n", "nl": "A method to modify prosody modifications"}
{"code": "public void testWriteReadEmpty() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(empty);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  ActiveElectionConfig copy=(ActiveElectionConfig)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(empty,copy));\n}\n", "nl": "Test read and write empty ClusterPolicy object"}
{"code": "public void writeString(byte[] str,int offset,int length) throws IOException {\n  if (str == null)   writeInt(0);\n else {\n    if (useCompression && length >= Compressor.MIN_SIZE_FOR_DEFLATION) {\n      if (byteBuffer.length < length)       byteBuffer=new byte[2 * length];\n      int numberOfBytes=compressor.deflateString2ByteArray(str,offset,length,byteBuffer);\n      writeInt(numberOfBytes);\n      outs.write(byteBuffer,0,Math.abs(numberOfBytes));\n      position+=Math.abs(numberOfBytes);\n    }\n else {\n      writeInt(length);\n      outs.write(str,offset,length);\n      position+=length;\n    }\n  }\n}\n", "nl": "write a string, compressed, if long enough"}
{"code": "protected void writeImageDesc() throws IOException {\n  out.write(0x2c);\n  writeShort(0);\n  writeShort(0);\n  writeShort(width);\n  writeShort(height);\n  if (firstFrame) {\n    out.write(0);\n  }\n else {\n    out.write(0x80 | 0 | 0| 0| palSize);\n  }\n}\n", "nl": "Writes Image Descriptor"}
{"code": "private void putLocalNotVersioned(Object key,CacheEntry cacheEntry){\n  CacheEntry oldCacheEntry;\n  if (_putFirst) {\n    oldCacheEntry=_cache.put(key,cacheEntry);\n  }\n else {\n    oldCacheEntry=_cache.replace(key,cacheEntry);\n  }\n  if (oldCacheEntry != null) {\n    if (!(oldCacheEntry instanceof DummyCacheEntry))     _evictionStrategy.discardEntry(oldCacheEntry);\n  }\n else   if (_putFirst && _cache.size() >= _sizeLimit) {\n    _evictionStrategy.evict(this);\n  }\n}\n", "nl": "Save non-vesrioned value in local cache"}
{"code": "public static Hash merge(Hash a,Hash b){\n  try {\n    MessageDigest digest=MessageDigest.getInstance(\"SHA-256\");\n    digest.update(a.bytes);\n    return Hash.createFromSafeArray(digest.digest(digest.digest(b.bytes)));\n  }\n catch (  NoSuchAlgorithmException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Merge two Hashes into one for Merkle Tree calculation"}
{"code": "public void dumpIndex(){\n  for (  Map.Entry<String,IndexEntry> entry : datasetIndex.entrySet()) {\n    String dsName=entry.getKey();\n    TDFDataset ds=getDataset(dsName);\n    int size=0;\n    for (    int sz : ds.tileSizes) {\n      size+=sz;\n    }\n    System.out.println(dsName + \"\\t\" + size);\n    datasetCache.clear();\n  }\n}\n", "nl": "Print index entries (for debugging)"}
{"code": "public void retry(Context context,OCUpload upload){\n  if (upload != null && context != null) {\n    Account account=AccountUtils.getOwnCloudAccountByName(context,upload.getAccountName());\n    retry(context,account,upload);\n  }\n else {\n    throw new IllegalArgumentException(\"Null parameter!\");\n  }\n}\n", "nl": "Call to retry upload identified by remotePath"}
{"code": "public static long stringToMilliseconds(String formattedDate,SimpleDateFormat dateFormat){\n  try {\n    return dateFormat.parse(formattedDate).getTime();\n  }\n catch (  ParseException e) {\n    e.printStackTrace();\n  }\n  return -1;\n}\n", "nl": "Create time in milliseconds from a formatted string with specific date format"}
{"code": "public final void openFallbackInputStream() throws DataFallbackException {\n  if (inputBuf == null) {\n    if (LOG.isDebugEnabled())     LOG.debug(\"openFallbackInputStream() : Opening the reader for the \" + dataFile.getName() + \"file\");\n    try {\n      setInput(new BufferedReader(new FileReader(dataFile)));\n    }\n catch (    IOException e) {\n      throw new DataFallbackException(e.getMessage());\n    }\n  }\n}\n", "nl": "It opens a file input stream"}
{"code": "private void clearOldTraffic(){\n  List<AirMapTraffic> oldAllTraffic=new ArrayList<>();\n  for (  AirMapTraffic traffic : allTraffic) {\n    if (trafficExpired(traffic)) {\n      oldAllTraffic.add(traffic);\n      allTraffic.remove(traffic);\n    }\n  }\n  notifyRemoved(oldAllTraffic);\n}\n", "nl": "Get rid of traffic that is no longer valid (the traffic is expired)"}
{"code": "public ImageIcon loadImage(String imageName){\n  try {\n    ClassLoader classloader=getClass().getClassLoader();\n    java.net.URL url=classloader.getResource(imageName);\n    if (url != null) {\n      ImageIcon icon=new ImageIcon(url);\n      return icon;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  throw new IllegalArgumentException(\"Unable to load image: \" + imageName);\n}\n", "nl": "Helper method to load an image file from the CLASSPATH"}
{"code": "public void addTab(int index,ITab tab){\n  JPanel panel=(JPanel)tab;\n  tabbedPane.insertTab(tab.getLabel(),null,panel,tab.getLabel(),index);\n  if (PCoA_TAB_INDEX >= index)   PCoA_TAB_INDEX++;\n  if (NJ_TAB_INDEX >= index)   NJ_TAB_INDEX++;\n  if (NNET_TAB_INDEX >= index)   NNET_TAB_INDEX++;\n  if (UPGMA_TAB_INDEX >= index)   UPGMA_TAB_INDEX++;\n  if (MATRIX_TAB_INDEX >= index)   MATRIX_TAB_INDEX++;\n}\n", "nl": "add a tab at the indicated position"}
{"code": "public CommandBuilder withLongSwitchIfPresent(Map<String,Object> properties,String key,String switchName){\n  Object value=properties.get(key);\n  if (value != null) {\n    if (value.getClass().isArray()) {\n      Object[] valueArray=(Object[])value;\n      for (      Object valueArrayElement : valueArray) {\n        withLongSwitch(switchName,valueArrayElement);\n      }\n    }\n else {\n      withLongSwitch(switchName,value);\n    }\n  }\n  return this;\n}\n", "nl": "if the given key is present in the map, create a long switch (--switch) with the given switch name"}
{"code": "public CommandBuilder withArgumentIfPresent(Map<String,Object> properties,String... keys){\n  for (  String key : keys) {\n    Object value=properties.get(key);\n    if (value != null) {\n      if (value.getClass().isArray()) {\n        withArguments(ArrayUtils.toStringArray(value));\n      }\n else {\n        withArguments(value.toString());\n      }\n    }\n  }\n  return this;\n}\n", "nl": "If the key(s) is mapped add an argument with the mapped value"}
{"code": "public void writeLong(long a) throws IOException {\n  outs.write((byte)(a));\n  outs.write((byte)(a >> 8));\n  outs.write((byte)(a >> 16));\n  outs.write((byte)(a >> 24));\n  outs.write((byte)(a >> 32));\n  outs.write((byte)(a >> 40));\n  outs.write((byte)(a >> 48));\n  outs.write((byte)(a >> 56));\n}\n", "nl": "write long, little endian"}
{"code": "public void addGlobalElementDeclAll(XSElementDecl decl){\n  if (fAllGlobalElemDecls.get(decl) == null) {\n    fAllGlobalElemDecls.put(decl,decl);\n    if (decl.fSubGroup != null) {\n      if (fSubGroupCount == fSubGroups.length)       fSubGroups=resize(fSubGroups,fSubGroupCount + INC_SIZE);\n      fSubGroups[fSubGroupCount++]=decl;\n    }\n  }\n}\n", "nl": "register one global element"}
{"code": "public void deleteSelectedNodes(){\n  DefaultTreeModel model=(DefaultTreeModel)dataTree.getModel();\n  TreePath[] selectedPaths=dataTree.getSelectionPaths();\n  if (selectedPaths != null) {\n    for (    TreePath selectedPath : selectedPaths) {\n      DefaultMutableTreeNode node=(DefaultMutableTreeNode)selectedPath.getLastPathComponent();\n      node.removeAllChildren();\n      model.nodeStructureChanged(node);\n      DefaultMutableTreeNode parent=(DefaultMutableTreeNode)node.getParent();\n      if (parent != null) {\n        parent.remove(node);\n        model.nodeStructureChanged(parent);\n      }\n    }\n  }\n}\n", "nl": "delete all the selected nodes"}
{"code": "public Set<NlComponent> dependsOn(Collection<? extends NlComponent> nodes,boolean vertical){\n  List<ViewData> reachable=new ArrayList<ViewData>();\n  Set<ViewData> visiting=new HashSet<ViewData>();\n  for (  NlComponent node : nodes) {\n    ViewData view=myNodeToView.get(node);\n    if (view != null) {\n      findBackwards(view,visiting,reachable,vertical,view);\n    }\n  }\n  Set<NlComponent> dependents=new HashSet<NlComponent>(reachable.size());\n  for (  ViewData v : reachable) {\n    dependents.add(v.node);\n  }\n  return dependents;\n}\n", "nl": "Returns the set of views that depend on the given node in either the horizontal or vertical direction"}
{"code": "public boolean hasPhysicalStateEffect(){\n  Iterator<Effect> effectIterator=this.abnormalEffectMap.values().iterator();\n  while (effectIterator.hasNext()) {\n    Effect localEffect=effectIterator.next();\n    if (localEffect.isPhysicalState()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Used to scan effects for Stumble/Stagger/Spin/OpenAerial"}
{"code": "public CounterMap<V,K> invert(){\n  CounterMap<V,K> invertCounterMap=new CounterMap<>();\n  for (  K key : this.keySet()) {\n    Counter<V> keyCounts=this.getCounter(key);\n    for (    V val : keyCounts.keySet()) {\n      double count=keyCounts.getCount(val);\n      invertCounterMap.setCount(val,key,count);\n    }\n  }\n  return invertCounterMap;\n}\n", "nl": "Constructs reverse CounterMap where the count of a pair (k,v) is the count of (v,k) in the current CounterMap"}
{"code": "private void startNetLog(){\n  File outputFile;\n  try {\n    outputFile=File.createTempFile(\"cronet\",\"log\",Environment.getExternalStorageDirectory());\n    cronetEngine.startNetLogToFile(outputFile.toString(),false);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Method to start NetLog to log Cronet events"}
{"code": "public void remove(String name){\n  Integer tt=name2index.get(name);\n  if (tt != null) {\n    name2index.keySet().remove(name);\n    index2name.remove(tt);\n    ntax--;\n    bits.set(tt,false);\n  }\n}\n", "nl": "remove this taxon"}
{"code": "public String upload_file1(String master_file_id,String prefix_name,byte[] file_buff,int offset,int length,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String[] parts=new String[2];\n  this.errno=this.split_file_id(master_file_id,parts);\n  if (this.errno != 0) {\n    return null;\n  }\n  parts=this.upload_file(parts[0],parts[1],prefix_name,file_buff,offset,length,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload file to storage server (by file buff, slave file mode)"}
{"code": "protected void init(Delegator delegator,ModelEntity modelEntity,Object singlePkValue){\n  assertIsMutable();\n  if (modelEntity == null) {\n    throw new IllegalArgumentException(\"Cannot create a GenericEntity with a null modelEntity parameter\");\n  }\n  if (modelEntity.getPksSize() != 1) {\n    throw new IllegalArgumentException(\"Cannot create a GenericEntity with more than one primary key field\");\n  }\n  this.modelEntity=modelEntity;\n  this.entityName=modelEntity.getEntityName();\n  this.delegatorName=delegator.getDelegatorName();\n  this.internalDelegator=delegator;\n  this.observable=new Observable();\n  set(modelEntity.getOnlyPk().getName(),singlePkValue);\n  if (this.entityName == null) {\n    throw new IllegalArgumentException(\"Cannot create a GenericEntity with a null entityName in the modelEntity parameter\");\n  }\n}\n", "nl": "Creates new GenericEntity from existing Map"}
{"code": "private void initSpaceStartupStateManager() throws CreateException {\n  List<String> targetNames=_clusterPolicy.m_ReplicationPolicy.m_ReplicationGroupMembersNames;\n  String spaceName=_clusterPolicy.m_ReplicationPolicy.m_OwnMemberName;\n  _startupManager=new ReplicationStartupManager(spaceName);\n  for (  String name : targetNames) {\n    if (name.equals(spaceName))     continue;\n  }\n  try {\n    if (_startupManager.shouldWait(targetNames)) {\n      _logger.info(\"Waiting for the first space in cluster to start\");\n      _startupManager.waitForLastSpace();\n    }\n  }\n catch (  InterruptedException e) {\n    throw new CreateException(\"ReplicationStartupManager was interrupted\",e);\n  }\n}\n", "nl": "Creates new startup manager and configures it"}
{"code": "public void paint(Graphics g,Transform trans){\n  final Graphics2D g2d=(Graphics2D)g;\n  if (color != null)   g2d.setColor(color);\n  final Point center=trans.w2d(centerX,centerY);\n  final double lenX=Geometry.length(Geometry.diff(trans.w2d(lengthA,0),trans.w2d(0,0)));\n  final double lenY=Geometry.length(Geometry.diff(trans.w2d(0,lengthB),trans.w2d(0,0)));\n  final AffineTransform old=g2d.getTransform();\n  g2d.rotate(angleInRadians,center.getX(),center.getY());\n  g2d.drawOval((int)Math.round(center.getX() - lenX),(int)Math.round(center.getY() - lenY),(int)Math.round(2 * lenX),(int)Math.round(2 * lenY));\n  g2d.setTransform(old);\n}\n", "nl": "paint the ellipse"}
{"code": "private static BigInteger forIndex(int n){\n  if (n == 0)   return BigInteger.ZERO;\n  BigInteger val=BigInteger.ONE.shiftLeft(n);\n  if (n % 2 == 0) {\n    val=val.subtract(BigInteger.ONE);\n  }\n else {\n    val=val.add(BigInteger.ONE);\n  }\n  return val.divide(BigInteger.valueOf(3));\n}\n", "nl": "Computes the Jacobsthal number with the given index using the closed-form equation: J(n) = (2^n - (-1)^n) / 3"}
{"code": "public synchronized void changeState(StartupState newState){\n  if (_currentSpaceState == newState)   return;\n  if (_logger.isLoggable(Level.FINE)) {\n    _logger.log(Level.FINE,\"Changing space [\" + _spaceName + \"] state from \"+ _currentSpaceState+ \" to \"+ newState);\n  }\n  try {\n    saveState(newState);\n  }\n catch (  IOException e) {\n    if (_logger.isLoggable(Level.WARNING)) {\n      _logger.log(Level.WARNING,\" Error on space connect [\" + _spaceName + \"] state.\",e);\n    }\n  }\n  _currentSpaceState=newState;\n}\n", "nl": "Change space state and store it"}
{"code": "private int calculateLayoutWidth(int widthSize,int mode){\n  initResourcesIfNecessary();\n  itemsLayout.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT));\n  itemsLayout.measure(MeasureSpec.makeMeasureSpec(widthSize,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  int width=itemsLayout.getMeasuredWidth();\n  if (mode == MeasureSpec.EXACTLY) {\n    width=widthSize;\n  }\n else {\n    width+=2 * PADDING;\n    width=Math.max(width,getSuggestedMinimumWidth());\n    if (mode == MeasureSpec.AT_MOST && widthSize < width) {\n      width=widthSize;\n    }\n  }\n  itemsLayout.measure(MeasureSpec.makeMeasureSpec(width - 2 * PADDING,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  return width;\n}\n", "nl": "Calculates control width and creates text layouts"}
{"code": "private void addFieldToHostStructure(Structure hostStructure,String fieldName,Field.FieldType fieldtype,Field.DataType fieldDataType,int order){\n  try {\n    Field field=FieldFactory.getFieldByName(\"Host\",fieldName);\n    if (null == field.getVelocityVarName() || field.getVelocityVarName().isEmpty()) {\n      Field newField=new Field(fieldName,fieldtype,fieldDataType,hostStructure,false,false,true,order,false,false,true);\n      Logger.info(this,\"*Added the field '\" + fieldName + \"' to the Host structure\");\n      FieldFactory.saveField(newField);\n    }\n  }\n catch (  DotHibernateException e) {\n    throw new RuntimeException(e.toString(),e);\n  }\n}\n", "nl": "Check for each field if the field already exists in the Host structure, if not the method will add this new field to the Host structure"}
{"code": "public void testSortByVirtualFieldReversed() throws Exception {\n  deleteAllDocs();\n  send(\"addDocument\",\"{fields: {id: 0, boost: 1.0}}\");\n  send(\"addDocument\",\"{fields: {id: 1, boost: 2.0}}\");\n  send(\"search\",\"{query: MatchAllDocsQuery, sort: {fields: [{field: logboost, reverse: true}]}, retrieveFields: [id]}\");\n  assertEquals(2,getInt(\"totalHits\"));\n  assertEquals(1,getInt(\"hits[0].fields.id\"));\n  assertEquals(0,getInt(\"hits[1].fields.id\"));\n  assertEquals(.6931f,getFloat(\"hits[0].fields.sortFields.logboost\"),.0001f);\n  assertEquals(0.0f,getFloat(\"hits[1].fields.sortFields.logboost\"),.0001f);\n}\n", "nl": "Reversed sort by virtual field"}
{"code": "@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){\n  super.onActivityResult(requestCode,resultCode,data);\nswitch (requestCode) {\ncase REQ_CODE_SPEECH_INPUT:\n{\n      if (resultCode == RESULT_OK && null != data) {\n        ArrayList<String> result=data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n        sendMessage(result.get(0));\n      }\n      break;\n    }\n}\n}\n", "nl": "Receiving speech input"}
{"code": "public void pasteClipboard(){\n  final Clipboard clipboard=Clipboard.getSystemClipboard();\n  if (clipboard.getContent(fmt) != null) {\n    spreadsheetView.pasteClipboard();\n  }\n else {\n    String contents=clipboard.getString().trim().replaceAll(\"\\r\\n\",\"\\n\").replaceAll(\"\\r\",\"\\n\");\n    String[] lines=contents.split(\"\\n\");\n    paste(lines);\n  }\n}\n", "nl": "paste into table"}
{"code": "private Collection<Var> migrateAsRelation(String entityTypeParent,String columnType,String childType){\n  String roleParentName=namer.roleParentName(columnType);\n  String roleChildName=namer.roleChildName(columnType);\n  Var entityTypeChild=var().id(childType).isa(\"entity-type\");\n  Var roleTypeParent=var().id(roleParentName).isa(\"role-type\");\n  Var roleTypeChild=var().id(roleChildName).isa(\"role-type\");\n  Var relationType=var().id(namer.relationName(columnType)).isa(\"relation-type\").hasRole(roleParentName).hasRole(roleChildName);\n  Var entityTypeParentPlayingRole=var().id(entityTypeParent).playsRole(roleParentName);\n  entityTypeChild.playsRole(roleChildName);\n  return Lists.newArrayList(entityTypeChild,roleTypeParent,roleTypeChild,relationType,entityTypeParentPlayingRole);\n}\n", "nl": "Migrate a foreign key column as a relation"}
{"code": "public ShowNextTime(){\n  super(new BorderLayout());\n  setOpaque(false);\n  button=new JCheckBox(BundleSupport.getLabel(\"ShowOnStartup\"));\n  button.setSelected(WelcomeOptions.getDefault().isShowOnStartup());\n  button.setOpaque(false);\n  BundleSupport.setAccessibilityProperties(button,\"ShowOnStartup\");\n  add(button,BorderLayout.CENTER);\n  button.addActionListener(this);\n}\n", "nl": "Creates a new instance of RecentProjects"}
{"code": "private void notifyDownloadStart(DownloadFileOperation download){\n  mLastPercent=0;\n  mNotificationBuilder=NotificationUtils.newNotificationBuilder(this);\n  mNotificationBuilder.setSmallIcon(R.drawable.notification_icon).setTicker(getString(R.string.downloader_download_in_progress_ticker)).setContentTitle(getString(R.string.downloader_download_in_progress_ticker)).setOngoing(true).setProgress(100,0,download.getSize() < 0).setContentText(String.format(getString(R.string.downloader_download_in_progress_content),0,new File(download.getSavePath()).getName()));\n  Intent showDetailsIntent=null;\n  if (PreviewImageFragment.canBePreviewed(download.getFile())) {\n    showDetailsIntent=new Intent(this,PreviewImageActivity.class);\n  }\n else {\n    showDetailsIntent=new Intent(this,FileDisplayActivity.class);\n  }\n  showDetailsIntent.putExtra(FileActivity.EXTRA_FILE,download.getFile());\n  showDetailsIntent.putExtra(FileActivity.EXTRA_ACCOUNT,download.getAccount());\n  showDetailsIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n  mNotificationBuilder.setContentIntent(PendingIntent.getActivity(this,(int)System.currentTimeMillis(),showDetailsIntent,0));\n  mNotificationManager.notify(R.string.downloader_download_in_progress_ticker,mNotificationBuilder.build());\n}\n", "nl": "Creates a status notification to show the download progress"}
{"code": "@Deprecated @RequestMapping(value=\"/{type}/_introduce_type\",method=RequestMethod.GET,produces={MediaType.APPLICATION_JSON_VALUE}) public @ResponseBody Map<String,Object> introduceType(@PathVariable String type,@RequestParam(value=SPACEID_PARAM,defaultValue=\"id\") String spaceID){\n  if (logger.isLoggable(Level.FINE))   logger.fine(\"introducing type: \" + type);\n  Map<String,Object> result=new Hashtable<String,Object>();\n  try {\n    GigaSpace gigaSpace=ControllerUtils.xapCache.get();\n    SpaceTypeDescriptor typeDescriptor=gigaSpace.getTypeManager().getTypeDescriptor(type);\n    if (typeDescriptor != null) {\n      throw new TypeAlreadyRegisteredException(type);\n    }\n    SpaceTypeDescriptor spaceTypeDescriptor=new SpaceTypeDescriptorBuilder(type).idProperty(spaceID).routingProperty(spaceID).supportsDynamicProperties(true).create();\n    gigaSpace.getTypeManager().registerTypeDescriptor(spaceTypeDescriptor);\n    result.put(\"status\",\"success\");\n  }\n catch (  IllegalStateException e) {\n    throw new RestException(e.getMessage());\n  }\n  return result;\n}\n", "nl": "REST GET for introducing type to space"}
{"code": "public static boolean blockVariantMatches(IBlockState bs,List<Variation> allowedVariants){\n  for (  IProperty prop : (java.util.Set<IProperty>)bs.getProperties().keySet()) {\n    if (prop.getName().equals(\"variant\") && prop.getValueClass().isEnum()) {\n      Object current=bs.getValue(prop);\n      if (current != null) {\n        for (        Variation var : allowedVariants) {\n          if (var.getValue().equalsIgnoreCase(current.toString()))           return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Test whether this block has a variant attribute which matches the list of allowed variants"}
{"code": "protected boolean newUpdatableStorageConnection(String group_name,String remote_filename) throws IOException, MyException {\n  if (this.storageServer != null) {\n    return false;\n  }\n else {\n    TrackerClient tracker=new TrackerClient();\n    this.storageServer=tracker.getUpdateStorage(this.trackerServer,group_name,remote_filename);\n    if (this.storageServer == null) {\n      throw new MyException(\"getStoreStorage fail, errno code: \" + tracker.getErrorCode());\n    }\n    return true;\n  }\n}\n", "nl": "check storage socket, if null create a new connection"}
{"code": "private static String msecToDateString(FieldDef fd,long value){\n  assert fd.valueType == FieldDef.FieldValueType.DATE_TIME;\n  Calendar calendar=new GregorianCalendar(TimeZone.getTimeZone(\"UTC\"),Locale.ROOT);\n  calendar.setLenient(false);\n  SimpleDateFormat dateTimeFormat=new SimpleDateFormat(fd.dateTimeFormat,Locale.ROOT);\n  dateTimeFormat.setCalendar(calendar);\n  Date date=new Date(value);\n  String result=dateTimeFormat.format(date);\n  System.out.println(\"MSEC TO DATE: value=\" + value + \" s=\"+ result);\n  return result;\n}\n", "nl": "NOTE: this is a slow method, since it makes many objects just to format one date/time value"}
{"code": "@Override public Settings init(String tag){\n  if (tag == null) {\n    throw new NullPointerException(\"tag may not be null\");\n  }\n  if (tag.trim().length() == 0) {\n    throw new IllegalStateException(\"tag may not be empty\");\n  }\n  this.tag=tag;\n  this.settings=new Settings();\n  return settings;\n}\n", "nl": "It is used to change the tag"}
{"code": "public double normF(){\n  double f=0;\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      f=Maths.hypot(f,A[i][j]);\n    }\n  }\n  return f;\n}\n", "nl": "Frobenius norm"}
{"code": "public static void quit(Socket sock) throws IOException {\n  PkgHeader header;\n  byte[] bs=new byte[FDHT_PROTO_PKG_HEADER_SIZE];\n  header=new PkgHeader();\n  header.cmd=FDHT_PROTO_CMD_QUIT;\n  packHeader(header,bs);\n  sock.getOutputStream().write(bs);\n  sock.close();\n}\n", "nl": "send quit command to server and close socket"}
{"code": "private int measureLong(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=mViewPager.getAdapter().getCount();\n    result=(int)(getPaddingLeft() + getPaddingRight() + (count * 2 * mRadius)+ (count - 1) * mRadius + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the width of this view"}
{"code": "public void draw(Canvas c,Rect bounds){\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mPaint.setColor(mCurrentColor);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n  if (mAlpha < 255) {\n    mCirclePaint.setColor(mBackgroundColor);\n    mCirclePaint.setAlpha(255 - mAlpha);\n    c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  }\n}\n", "nl": "Draw the progress spinner"}
{"code": "public static Converter<String,?> determine(Field field){\n  Class clazz=field.getType();\n  Converter<String,?> converter=determinePrimitiveConverter(clazz);\n  if (converter != null) {\n    return converter;\n  }\n  if (List.class.equals(clazz) || Map.class.equals(clazz) || Set.class.equals(clazz)) {\n    return determineCollectionConverter((ParameterizedType)field.getGenericType());\n  }\n  return new JsonConverter(clazz);\n}\n", "nl": "Determine the converter with the field type"}
{"code": "private byte divmod58(byte[] number,int startAt){\n  int remainder=0;\n  for (int i=startAt; i < number.length; i++) {\n    int digit256=(int)number[i] & 0xFF;\n    int temp=remainder * BASE_256 + digit256;\n    number[i]=(byte)(temp / BASE_58);\n    remainder=temp % BASE_58;\n  }\n  return (byte)remainder;\n}\n", "nl": "Base58 helper method"}
{"code": "final public void deny(String url,String error){\n  if (log.isDebugEnabled())   log.debug(this.getClass().getName() + \"[\" + this.getURI()+ \"]\",new Exception(\"deny \" + error));\n  if (isAjax()) {\n    JSON jo=new JSON();\n    jo.put(X.STATE,HttpServletResponse.SC_UNAUTHORIZED);\n    jo.put(X.MESSAGE,lang.get(\"access.deny\"));\n    jo.put(X.ERROR,error);\n    jo.put(X.URL,url);\n    this.response(jo);\n  }\n else {\n    setStatus(HttpServletResponse.SC_FORBIDDEN);\n    this.set(\"me\",this.getUser());\n    this.set(X.ERROR,error);\n    this.set(X.URL,url);\n    this.show(\"/deny.html\");\n  }\n}\n", "nl": "show deny page with error info to end-user"}
{"code": "public static synchronized boolean shouldPauseAdding(){\n  if (Singleton.getPauseBackgroundJobs()) {\n    return true;\n  }\n  int indexQueueSize=Singleton.getCodeIndexQueue().size();\n  int codeIndexLinesCount=Singleton.getCodeIndexLinesCount();\n  if (indexQueueSize > MAXINDEXSIZE) {\n    Singleton.getLogger().info(\"indexQueueSize \" + indexQueueSize + \" larger then \"+ MAXINDEXSIZE);\n    return true;\n  }\n  if (codeIndexLinesCount > MAXLINESINDEXSIZE) {\n    Singleton.getLogger().info(\"codeIndexLinesCount \" + codeIndexLinesCount + \" larger then \"+ MAXLINESINDEXSIZE);\n    return true;\n  }\n  return false;\n}\n", "nl": "Returns true if indexing should be paused, false otherwise used by the parsers to know if they should continue processing or not"}
{"code": "public PolyArea(ZoneName zoneName,int worldId,Point2D[] points,float zMin,float zMax){\n  super(zoneName,worldId,zMin,zMax);\n  if (points.length < 3) {\n    throw new IllegalArgumentException(\"Not enough points, needed at least 3 but got \" + points.length);\n  }\n  float[] xPoints=new float[points.length];\n  float[] yPoints=new float[points.length];\n  for (int i=0, n=points.length; i < n; i++) {\n    Point2D p=points[i];\n    xPoints[i]=p.getX();\n    yPoints[i]=p.getY();\n  }\n  this.poly=new Polygon2D(xPoints,yPoints,points.length);\n}\n", "nl": "Creates new area from given points"}
{"code": "private boolean isConfigurationPluginAvailable(){\n  if (configurationPluginAvailable == null) {\n    try {\n      String value=APILocator.getPluginAPI().loadProperty(pluginName,\"environment\");\n      configurationPluginAvailable=(value != null);\n    }\n catch (    Exception e) {\n      Logger.warn(this,\"Exception while trying to get property 'environment' \",e);\n      configurationPluginAvailable=false;\n    }\n    Logger.info(this,\"Configuration plugin available: \" + configurationPluginAvailable);\n  }\n  return configurationPluginAvailable;\n}\n", "nl": "Check for the \"environment\" key in the pluginAPI"}
{"code": "private static void logOutput(Level level,Command cmd,final String outputType,ByteArrayOutputStream outputBytes){\n  String string=asString(outputBytes).trim();\n  if (string.isEmpty()) {\n    return;\n  }\n  for (  String line : string.split(System.lineSeparator())) {\n    logger.log(level,\"'\" + cmd.getCommandLineElements()[0] + \"' \"+ outputType+ \": \"+ line);\n  }\n}\n", "nl": "Log to the appropiate log level the output of the command"}
{"code": "public void remove(IObjectInfo<T> oi){\n  lock.lock();\n  try {\n    remove_impl((ObjectInfo<T>)oi);\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "remove an element described by ObjectInfo"}
{"code": "public static List<DataFileFooter> readCarbonIndexFile(String taskId,List<TableBlockInfo> tableBlockInfoList,AbsoluteTableIdentifier absoluteTableIdentifier) throws CarbonUtilException {\n  Collections.sort(tableBlockInfoList);\n  CarbonTablePath carbonTablePath=CarbonStorePath.getCarbonTablePath(absoluteTableIdentifier.getStorePath(),absoluteTableIdentifier.getCarbonTableIdentifier());\n  String carbonIndexFilePath=carbonTablePath.getCarbonIndexFilePath(taskId,\"0\",tableBlockInfoList.get(0).getSegmentId());\n  DataFileFooterConverter fileFooterConverter=new DataFileFooterConverter();\n  try {\n    return fileFooterConverter.getIndexInfo(carbonIndexFilePath,tableBlockInfoList);\n  }\n catch (  IOException e) {\n    throw new CarbonUtilException(\"Problem while reading the file metadata\",e);\n  }\n}\n", "nl": "Below method will be used to get all the block index info from index file"}
{"code": "@Deployment public void testParallelJoinEndTime(){\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"forkJoin\");\n  List<Task> tasksToComplete=taskService.createTaskQuery().processInstanceId(processInstance.getId()).list();\n  assertEquals(2,tasksToComplete.size());\n  taskService.complete(tasksToComplete.get(0).getId());\n  taskService.complete(tasksToComplete.get(1).getId());\n  List<HistoricActivityInstance> historicActivityInstance=historyService.createHistoricActivityInstanceQuery().activityId(\"join\").processInstanceId(processInstance.getId()).list();\n  assertNotNull(historicActivityInstance);\n  assertEquals(2,historicActivityInstance.size());\n  assertNotNull(historicActivityInstance.get(0).getEndTime());\n  assertNotNull(historicActivityInstance.get(1).getEndTime());\n}\n", "nl": "Test to validate fix for ACT-1549: endTime of joining parallel gateway is not set"}
{"code": "private void determineSizesFromTaxonomyClassification(){\n  Map<Integer,Integer[]> class2count=classification2class2counts.get(ClassificationType.Taxonomy.toString());\n  if (class2count != null) {\n    int[] sizes=new int[getNumberOfSamples()];\n    for (    Integer classId : class2count.keySet()) {\n      Integer[] counts=class2count.get(classId);\n      if (counts != null) {\n        for (int i=0; i < getNumberOfSamples(); i++) {\n          if (counts[i] != null)           sizes[i]+=counts[i];\n        }\n      }\n    }\n    sampleSizes.clear();\n    for (    Integer size : sizes)     sampleSizes.add(size);\n  }\n}\n", "nl": "determine the size of datasets from the taxonomy classification"}
{"code": "public void use(int ind){\n  if (dat.get(ind).check >= 0)   System.out.println(\"cell reused!!\");\n  if (dat.get(ind).base == 1) {\n    head=dat.get(ind).check;\n  }\n else {\n    dat.get(-dat.get(ind).base).check=dat.get(ind).check;\n  }\n  if (dat.get(ind).check == -datSize) {\n    tail=dat.get(ind).base;\n  }\n else {\n    dat.get(-dat.get(ind).check).base=dat.get(ind).base;\n  }\n  dat.get(ind).check=ind;\n}\n", "nl": "<p>Title:use</p> <p>Description: use [ind] as an entry<p>"}
{"code": "private boolean checkValidation(final SourceDataTag currentSourceDataTag,final ValueUpdate update){\n  if (!isTimestampValid(currentSourceDataTag,update)) {\n    return false;\n  }\n  if (!isConvertible(currentSourceDataTag,update)) {\n    return false;\n  }\n  if (isNumber(currentSourceDataTag.getDataType()) && !isInRange(currentSourceDataTag,update)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Helper method which validates the new tag value and triggers an invalidation in case of a problem"}
{"code": "public void invalidateWheel(boolean clearCaches){\n  if (clearCaches) {\n    recycle.clearAll();\n    if (itemsLayout != null) {\n      itemsLayout.removeAllViews();\n    }\n    scrollingOffset=0;\n  }\n else   if (itemsLayout != null) {\n    recycle.recycleItems(itemsLayout,firstItem,new ItemsRange());\n  }\n  invalidate();\n}\n", "nl": "Invalidates wheel"}
{"code": "public ChatClient registerPlayer(int playerId,String playerLogin,String nick) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n  MessageDigest md=MessageDigest.getInstance(\"SHA-256\");\n  md.reset();\n  md.update(playerLogin.getBytes(\"UTF-8\"),0,playerLogin.length());\n  byte[] accountToken=md.digest();\n  byte[] token=generateToken(accountToken);\n  ChatClient chatClient=new ChatClient(playerId,token,nick);\n  players.put(playerId,chatClient);\n  return chatClient;\n}\n", "nl": "Player registered from server side"}
{"code": "public Object minMax(SelectColumn funcColumn,IQueryResultSet<IEntryPacket> entries,boolean isMax){\n  Object value, maxMin=null;\n  Iterator<IEntryPacket> iter=entries.iterator();\n  while (iter.hasNext()) {\n    IEntryPacket entry=iter.next();\n    value=entries.getFieldValue(funcColumn,entry);\n    if (value == null)     continue;\n    if (maxMin != null)     if (isMax)     maxMin=(((Comparable)value).compareTo(maxMin) > 0) ? value : maxMin;\n else     maxMin=(((Comparable)value).compareTo(maxMin) < 0) ? value : maxMin;\n else     maxMin=value;\n  }\n  return maxMin;\n}\n", "nl": "Finds the minimum/maximum value of given column"}
{"code": "private Response assureAcceptJSON(IHTTPSession session){\n  final Map<String,String> headers=session.getHeaders();\n  if (!APPLICATION_JSON.equals(headers.get(ACCEPT_FIELD))) {\n    return newFixedLengthResponse(Response.Status.NOT_ACCEPTABLE,MIME_PLAINTEXT,\"set accept to application/json or remove it\");\n  }\n else {\n    return null;\n  }\n}\n", "nl": "Ensures that the \"accept\" header is either set to JSON or empty"}
{"code": "public static boolean blockColourMatches(IBlockState bs,List<Colour> allowedColours){\n  for (  IProperty prop : (java.util.Set<IProperty>)bs.getProperties().keySet()) {\n    if (prop.getName().equals(\"color\") && prop.getValueClass() == net.minecraft.item.EnumDyeColor.class) {\n      net.minecraft.item.EnumDyeColor current=(net.minecraft.item.EnumDyeColor)bs.getValue(prop);\n      for (      Colour col : allowedColours) {\n        if (current.getName().equalsIgnoreCase(col.name()))         return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Test whether this block has a colour attribute which matches the list of allowed colours"}
{"code": "@SuppressWarnings(\"unchecked\") public static <T>T copy(Configuration conf,T src,T dst) throws IOException {\n  CopyInCopyOutBuffer buffer=cloneBuffers.get();\n  buffer.outBuffer.reset();\n  SerializationFactory factory=getFactory(conf);\n  Class<T> cls=(Class<T>)src.getClass();\n  Serializer<T> serializer=factory.getSerializer(cls);\n  serializer.open(buffer.outBuffer);\n  serializer.serialize(src);\n  buffer.moveData();\n  Deserializer<T> deserializer=factory.getDeserializer(cls);\n  deserializer.open(buffer.inBuffer);\n  dst=deserializer.deserialize(dst);\n  return dst;\n}\n", "nl": "Make a copy of the writable object using serialization to a buffer"}
{"code": "public final void goToLine(final int lineNumber) throws DataFallbackException {\n  boolean moreLines=true;\n  int readlines=0;\n  openFallbackInputStream();\n  if (lineNumber != 0) {\n    try {\n      while (moreLines && readlines < lineNumber) {\n        if (getInput().readLine() == null)         moreLines=false;\n else         readlines++;\n      }\n    }\n catch (    IOException e) {\n      throw new DataFallbackException(e.getMessage());\n    }\n  }\n}\n", "nl": "It prepares the file descriptor to read from a certain number of lines"}
{"code": "public void hideBudgeAtIndex(final int index){\n  if (badgeList.get(index).getVisibility() == GONE) {\n    Log.d(TAG,\"Budge at index: \" + index + \" already hidden\");\n  }\n else {\n    BadgeHelper.hideBadge(badgeList.get(index));\n    badgeSaveInstanceHashMap.remove(index);\n  }\n}\n", "nl": "Hide badge at index"}
{"code": "public static Authentication newAuthentication(String user,String password,final boolean authenticated,GrantedAuthority... authorities){\n  return new TestingAuthenticationToken(user,password,ImmutableList.<org.springframework.security.core.GrantedAuthority>builder().add(authorities).build()){\n    private static final long serialVersionUID=1L;\n{\n      setAuthenticated(authenticated);\n    }\n  }\n;\n}\n", "nl": "Constructrs authentification using provided credentials and authorities"}
{"code": "public boolean implementsInterface(String name){\n  checkLevel(HIERARCHY);\n  Iterator<SootClass> interfaceIt=getInterfaces().iterator();\n  while (interfaceIt.hasNext()) {\n    SootClass SootClass=interfaceIt.next();\n    if (SootClass.getName().equals(name))     return true;\n  }\n  return false;\n}\n", "nl": "Does this class directly implement the given interface? (see getInterfaceCount())"}
{"code": "public static FileFooter convertFileFooter(List<BlockletInfoColumnar> infoList,int numCols,int[] cardinalities,List<ColumnSchema> columnSchemaList,SegmentProperties segmentProperties) throws IOException {\n  SegmentInfo segmentInfo=new SegmentInfo();\n  segmentInfo.setNum_cols(columnSchemaList.size());\n  segmentInfo.setColumn_cardinalities(CarbonUtil.convertToIntegerList(cardinalities));\n  FileFooter footer=new FileFooter();\n  footer.setNum_rows(getTotalNumberOfRows(infoList));\n  footer.setSegment_info(segmentInfo);\n  for (  BlockletInfoColumnar info : infoList) {\n    footer.addToBlocklet_index_list(getBlockletIndex(info));\n  }\n  footer.setTable_columns(columnSchemaList);\n  for (  BlockletInfoColumnar info : infoList) {\n    footer.addToBlocklet_info_list(getBlockletInfo(info,columnSchemaList,segmentProperties));\n  }\n  return footer;\n}\n", "nl": "It converts list of BlockletInfoColumnar to FileFooter thrift objects"}
{"code": "public JsonObject sendCrxRequest(HttpUriRequest request) throws IOException {\n  String resultJson;\n  try (CloseableHttpResponse response=httpClient.execute(request)){\n    resultJson=EntityUtils.toString(response.getEntity());\n  }\n   JsonObject result;\n  try {\n    result=new JsonParser().parse(resultJson).getAsJsonObject();\n  }\n catch (  JsonSyntaxException e) {\n    throw new JsonSyntaxException(\"Unable to parse as Json: \" + resultJson,e);\n  }\n  if (result.get(\"success\").getAsBoolean()) {\n    return result;\n  }\n  throw new IOException(result.get(\"msg\").getAsString());\n}\n", "nl": "This method sends request to author instance"}
{"code": "public void writeStringNoCompression(String str) throws IOException {\n  if (str == null) {\n    writeInt(0);\n  }\n else {\n    writeInt(str.length());\n    for (int i=0; i < str.length(); i++)     outs.write((byte)str.charAt(i));\n    position+=str.length();\n  }\n}\n", "nl": "Write a string without compression"}
{"code": "public AdsGetStatisticsQuery(VkApiClient client,UserActor actor,int accountId,AdsGetStatisticsIdsType idsType,String ids,AdsGetStatisticsPeriod period,String dateFrom,String dateTo){\n  super(client,\"ads.getStatistics\",Utils.buildParametrizedType(List.class,Stats.class));\n  accessToken(actor.getAccessToken());\n  accountId(accountId);\n  idsType(idsType);\n  ids(ids);\n  period(period);\n  dateFrom(dateFrom);\n  dateTo(dateTo);\n}\n", "nl": "Creates a AbstractQueryBuilder instance that can be used to build api request with various parameters"}
{"code": "LoadReport nextBroker(){\n  List<LoadReport> availableBrokers=zkCache.getAvailableBrokers();\n  if (availableBrokers.isEmpty()) {\n    throw new RestException(Status.SERVICE_UNAVAILABLE,\"No active broker is available\");\n  }\n else {\n    int brokersCount=availableBrokers.size();\n    int nextIdx=Math.abs(counter.getAndIncrement()) % brokersCount;\n    return availableBrokers.get(nextIdx);\n  }\n}\n", "nl": "Find next broke url in round-robin"}
{"code": "public static void surrenderPet(Player player,int petId){\n  PetCommonData petCommonData=player.getPetList().getPet(petId);\n  if (player.getPet() != null && player.getPet().getPetId() == petCommonData.getPetId()) {\n    if (petCommonData.getFeedProgress() != null) {\n      petCommonData.setCancelFeed(true);\n    }\n    PetSpawnService.dismissPet(player,false);\n  }\n  player.getPetList().deletePet(petCommonData.getPetId());\n  PacketSendUtility.sendPacket(player,new SM_PET(2,petCommonData));\n}\n", "nl": "Delete pet"}
{"code": "private Type<?> findInterface(final Class<?> theInterface){\n  Type<?> theInterfaceType=null;\n  LinkedList<Type<?>> types=new LinkedList<Type<?>>();\n  types.add(this);\n  while (theInterfaceType == null && !types.isEmpty()) {\n    Type<?> currentType=types.removeFirst();\n    if (theInterface.equals(currentType.getRawType())) {\n      theInterfaceType=currentType;\n    }\n else     if (!currentType.equals(TypeFactory.TYPE_OF_OBJECT)) {\n      types.addAll(Arrays.asList(currentType.getInterfaces()));\n      types.add(currentType.getSuperType());\n    }\n  }\n  return theInterfaceType;\n}\n", "nl": "Locates a particular interface within the type's object hierarchy"}
{"code": "public static final void emoteStartAttacking(Npc owner){\n  Creature target=(Creature)owner.getTarget();\n  owner.unsetState(CreatureState.WALKING);\n  if (!owner.isInState(CreatureState.WEAPON_EQUIPPED)) {\n    owner.setState(CreatureState.WEAPON_EQUIPPED);\n    PacketSendUtility.broadcastPacket(owner,new SM_EMOTION(owner,EmotionType.START_EMOTE2,0,target.getObjectId()));\n    PacketSendUtility.broadcastPacket(owner,new SM_EMOTION(owner,EmotionType.ATTACKMODE,0,target.getObjectId()));\n  }\n}\n", "nl": "Npc starts attacking from idle state"}
{"code": "public PathOptions build(){\n  PathOptions options=new PathOptions();\n  options.stroke=this.stroke;\n  options.color=this.color;\n  options.weight=this.weight;\n  options.fill=this.fill;\n  options.fillColor=this.fillColor;\n  options.fillOpacity=this.fillOpacity;\n  options.fillRule=this.fillRule;\n  options.dashArray=this.dashArray;\n  options.lineCap=this.lineCap;\n  options.lineJoin=this.lineJoin;\n  options.clickable=this.clickable;\n  options.pointerEvents=this.pointerEvents;\n  options.className=this.className;\n  return options;\n}\n", "nl": "Builds the PathOptions new instance"}
{"code": "public String toString(){\n  StringBuffer text=new StringBuffer();\n  if (m_InfoGains == null) {\n    text.append(\"Information Gain attribute evaluator has not been built\");\n  }\n else {\n    text.append(\"\\tInformation Gain Ranking Filter\");\n    if (!m_missing_merge) {\n      text.append(\"\\n\\tMissing values treated as seperate\");\n    }\n    if (m_Binarize) {\n      text.append(\"\\n\\tNumeric attributes are just binarized\");\n    }\n  }\n  text.append(\"\\n\");\n  return text.toString();\n}\n", "nl": "Describe the attribute evaluator"}
{"code": "private static double computeCorrelationDistanceBetweenClasses(String classA,String classB,Table<String,String,Double> seriesAndClass2Value){\n  final Set<String> series=seriesAndClass2Value.rowKeySet();\n  final ArrayList<Double> xValues=new ArrayList<>(series.size());\n  final ArrayList<Double> yValues=new ArrayList<>(series.size());\n  for (  String seriesName : series) {\n    xValues.add(seriesAndClass2Value.get(seriesName,classA));\n    yValues.add(seriesAndClass2Value.get(seriesName,classB));\n  }\n  return 1 - Correlation.computePersonsCorrelationCoefficent(series.size(),xValues,yValues);\n}\n", "nl": "compute correlation distance between two classes"}
{"code": "private void showArrow(int whichArrow,int requestedX){\n  final View showArrow=(whichArrow == R.id.arrow_up) ? mArrowUp : mArrowDown;\n  final View hideArrow=(whichArrow == R.id.arrow_up) ? mArrowDown : mArrowUp;\n  final int arrowWidth=mArrowUp.getMeasuredWidth();\n  showArrow.setVisibility(View.VISIBLE);\n  ViewGroup.MarginLayoutParams param=(ViewGroup.MarginLayoutParams)showArrow.getLayoutParams();\n  param.leftMargin=requestedX - arrowWidth / 2;\n  hideArrow.setVisibility(View.INVISIBLE);\n}\n", "nl": "Show arrow"}
{"code": "private void back_Position(){\n  sncX=(int)this.map_controler.get_Direc_Dis_X(this.map_controler.dir);\n  velocity.y=-80;\n  position.x+=sncX;\n  if (Math.abs(position.y - posY) <= 4) {\n    GetPath(a_Kind + 10);\n    status=ATTACK;\n  }\n}\n", "nl": "back position"}
{"code": "public void initializeGeo(){\nswitch (getConfiguredGeoType()) {\ncase GEO_MESHES:\n    geoData=new RealGeoData();\n  break;\ncase NO_GEO:\ngeoData=new DummyGeoData();\nbreak;\n}\nlog.info(\"Configured Geo type: \" + getConfiguredGeoType());\ngeoData.loadGeoMaps();\n}\n", "nl": "Initialize geodata based on configuration, load necessary structures"}
{"code": "public static void gc2gc(double c1[],int m1,double g1,double c2[],int m2,double g2){\n  double[] gc2gc_buff=Arrays.copyOf(c1,m1 + 1);\n  c2[0]=gc2gc_buff[0];\n  for (int i=1; i <= m2; i++) {\n    double ss1=0.0;\n    double ss2=0.0;\n    int min=m1 < i ? m1 : i - 1;\n    for (int k=1; k <= min; k++) {\n      int mk=i - k;\n      double cc=gc2gc_buff[k] * c2[mk];\n      ss2+=k * cc;\n      ss1+=mk * cc;\n    }\n    if (i <= m1)     c2[i]=gc2gc_buff[i] + (g2 * ss2 - g1 * ss1) / i;\n else     c2[i]=(g2 * ss2 - g1 * ss1) / i;\n  }\n}\n", "nl": "gc2gc: generalized cepstral transformation"}
{"code": "private String generateAccessToken(LoginReqDto reqDto,String role){\n  PlatformUser platformUser=new PlatformUser(reqDto.getUserId(),StringConstant.EMPTY_STRING,new ArrayList<GrantedAuthority>());\n  platformUser.setDeviceId(reqDto.getDeviceId());\n  platformUser.setPlatform(reqDto.getPlatform());\n  platformUser.setRole(role);\n  platformUser.setLoginTime(new Date().getTime());\n  String token=jwtService.generateToken(platformUser);\n  if (StringUtils.isEmpty(token))   throw new RuntimeException(ERR_FAIL_TO_CREATE_TOKEN);\n  return token;\n}\n", "nl": "Generate token from login request and user role"}
{"code": "public GatheringCursor queryGatheringItem(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Columns=null;\n  qh.Table=S.TABLE_GATHERING;\n  qh.Selection=\"g.\" + S.COLUMN_GATHERING_ITEM_ID + \" = ? \";\n  qh.SelectionArgs=new String[]{\"\" + id};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=\"g.\" + S.COLUMN_GATHERING_RANK + \" DESC, \"+ \"l.\"+ S.COLUMN_LOCATIONS_MAP+ \" ASC\";\n  qh.Limit=null;\n  return new GatheringCursor(wrapJoinHelper(builderGathering(),qh));\n}\n", "nl": "****************************** GATHERING QUERIES"}
{"code": "public static void onAttackBegin(NpcAI2 npcAI,Creature creature){\n  Npc npc=npcAI.getOwner();\n  if (DataManager.NPC_SHOUT_DATA.hasAnyShout(npc.getPosition().getMapId(),npc.getNpcId(),ShoutEventType.ATTACK_BEGIN)) {\n    List<NpcShout> shouts=DataManager.NPC_SHOUT_DATA.getNpcShouts(npc.getPosition().getMapId(),npc.getNpcId(),ShoutEventType.ATTACK_BEGIN,null,0);\n    NpcShoutsService.getInstance().shout(npc,creature,shouts,0,false);\n    shouts.clear();\n    return;\n  }\n}\n", "nl": "Called on Aggro when NPC is ready to attack"}
{"code": "public static HouseObject<?> createNew(House house,ItemTemplate itemTemplate){\n  if (itemTemplate.getActions() == null) {\n    throw new IncompleteArgumentException(\"template actions null\");\n  }\n  SummonHouseObjectAction action=itemTemplate.getActions().getHouseObjectAction();\n  if (action == null) {\n    throw new IncompleteArgumentException(\"template actions miss SummonHouseObjectAction\");\n  }\n  int objectTemplateId=action.getTemplateId();\n  HouseObject<?> obj=createNew(house,IDFactory.getInstance().nextId(),objectTemplateId);\n  if (obj.getObjectTemplate().getUseDays() > 0) {\n    int expireEnd=(int)(DateTime.now().plusDays(obj.getObjectTemplate().getUseDays()).getMillis() / 1000);\n    obj.setExpireTime(expireEnd);\n  }\n  return obj;\n}\n", "nl": "For transferring item from inventory to house registry"}
{"code": "private static InspectionResult checkArrayInitializerExpression(@NotNull PsiArrayInitializerExpression e,@NotNull AllowedValues allowedValues,@NotNull PsiElement scope,@NotNull PsiManager manager,@Nullable Set<PsiExpression> visited){\n  for (  PsiExpression arrayValueExpression : e.getInitializers()) {\n    InspectionResult result=isGoodExpression(arrayValueExpression,allowedValues,scope,manager,visited).useErrorNode(arrayValueExpression);\n    if (result.isInvalid()) {\n      return result;\n    }\n  }\n  return InspectionResult.valid();\n}\n", "nl": "Verifies that all elements in an array initializer expression are within the allowed values"}
{"code": "boolean hasWildcard(){\n  boolean wildcarded=false;\n  for (int i=0; i < websterRoot.length; i++) {\n    String root=websterRoot[i];\n    if ((root.indexOf('*')) != -1) {\n      wildcarded=true;\n      break;\n    }\n  }\n  return (wildcarded);\n}\n", "nl": "See if the root is using a wildcard"}
{"code": "final public static int insertTable(V sets,Class<? extends Bean> t){\n  Table mapping=(Table)t.getAnnotation(Table.class);\n  if (mapping == null) {\n    if (log.isErrorEnabled())     log.error(\"mapping missed in [\" + t + \"] declaretion\");\n    return -1;\n  }\n  if (!X.isEmpty(mapping.name())) {\n    return insertTable(mapping.name(),sets);\n  }\n  return -1;\n}\n", "nl": "insert to the table according the Map(table) declaration"}
{"code": "public static String nodeValue(Node node){\n  if (node == null)   return null;\n  StringBuilder valueBuffer=new StringBuilder();\n  do {\n    if (node.getNodeType() == Node.CDATA_SECTION_NODE || node.getNodeType() == Node.TEXT_NODE || node.getNodeType() == Node.COMMENT_NODE) {\n      valueBuffer.append(node.getNodeValue());\n    }\n  }\n while ((node=node.getNextSibling()) != null);\n  return valueBuffer.toString();\n}\n", "nl": "Return the text (node value) of the first node under this"}
{"code": "@Override public void run(){\n  while (!isInterrupted()) {\n    try {\n      Reference ref=_queue.remove();\n      _entryInfos.remove(ref);\n    }\n catch (    InterruptedException e) {\n      interrupt();\n      break;\n    }\n  }\n}\n", "nl": "Block on the queue until an entry is been cleaned by the GC"}
{"code": "public void execute(IAction action) throws InvocationTargetException, InterruptedException {\n  if (action != null && !action.isEnabled()) {\n    action.setEnabled(true);\n  }\n else {\n    final ISVNRemoteFile svnResource=getSingleSelectedSVNRemoteFile();\n    execute(svnResource);\n  }\n}\n", "nl": "Action to open a SVN Annotate View"}
{"code": "public static FingerLockManager initialize(@NonNull AppCompatActivity activity,@NonNull String keyName){\n  if (activity == null) {\n    return null;\n  }\n  FingerLock fragment=(FingerLock)activity.getSupportFragmentManager().findFragmentByTag(TAG_FINGER_LOCK_FRAGMENT);\n  if (fragment == null) {\n    fragment=createInstance(keyName);\n    activity.getSupportFragmentManager().beginTransaction().add(fragment,TAG_FINGER_LOCK_FRAGMENT).commitNow();\n  }\n  return fragment;\n}\n", "nl": "Call this method to initialize the library"}
{"code": "public void activate(){\n  getViewer().getSearchManager().setSearcher(getSearcher());\n  getViewer().getSearchManager().getFindDialogAsToolBar().clearMessage();\n  if (!inSelection) {\n    inSelection=true;\n    try {\n      chartSelection.clearSelectionAttributes();\n      chartSelection.setSelectedAttribute(getSelectedLabels(),true);\n      this.repaint();\n    }\n  finally {\n      inSelection=false;\n    }\n  }\n}\n", "nl": "call this when tab containing list is activated"}
{"code": "public void testIsPublic(){\n  VirtualFile myFile=myFixture.copyFileToProject(\"themeEditor/styles_1.xml\",\"res/values/styles.xml\");\n  Configuration configuration=myFacet.getConfigurationManager().getConfiguration(myFile);\n  ThemeResolver themeResolver=new ThemeResolver(configuration);\n  ConfiguredThemeEditorStyle projectTheme=themeResolver.getTheme(\"AppTheme\");\n  assertNotNull(projectTheme);\n  assertTrue(projectTheme.isPublic());\n  ConfiguredThemeEditorStyle frameworkPublicTheme=themeResolver.getTheme(\"android:Theme.Material\");\n  assertNotNull(frameworkPublicTheme);\n  assertTrue(frameworkPublicTheme.isPublic());\n  ConfiguredThemeEditorStyle frameworkPrivateTheme=themeResolver.getTheme(\"android:Theme.Material.Dialog.NoFrame\");\n  assertNotNull(frameworkPrivateTheme);\n  assertFalse(frameworkPrivateTheme.isPublic());\n}\n", "nl": "Tests the isPublic() method"}
{"code": "private static BitMatrix bitMatrixFrombitArray(byte[][] input,int margin){\n  BitMatrix output=new BitMatrix(input[0].length + 2 * margin,input.length + 2 * margin);\n  output.clear();\n  for (int y=0, yOutput=output.getHeight() - margin - 1; y < input.length; y++, yOutput--) {\n    for (int x=0; x < input[0].length; x++) {\n      if (input[y][x] == 1) {\n        output.set(x + margin,yOutput);\n      }\n    }\n  }\n  return output;\n}\n", "nl": "This takes an array holding the values of the PDF 417"}
{"code": "private void populateCarbonMeasures(String[] measures){\n  CarbonTable carbonTable=CarbonMetadata.getInstance().getCarbonTable(meta.getDatabaseName() + CarbonCommonConstants.UNDERSCORE + meta.getTableName());\n  meta.carbonMeasures=new CarbonMeasure[measures.length];\n  msrDataType=new DataType[measures.length];\n  for (int i=0; i < measures.length; i++) {\n    CarbonMeasure carbonMeasure=carbonTable.getMeasureByName(meta.getTableName(),measures[i]);\n    msrDataType[i]=carbonMeasure.getDataType();\n    if (DataType.DECIMAL == carbonMeasure.getDataType()) {\n      meta.carbonMeasures[i]=carbonMeasure;\n    }\n  }\n}\n", "nl": "This method will fill the carbon measures"}
{"code": "static int userCheck(String stmt,int offset){\n  if (stmt.length() > offset + 5) {\n    char c1=stmt.charAt(++offset);\n    char c2=stmt.charAt(++offset);\n    char c3=stmt.charAt(++offset);\n    char c4=stmt.charAt(++offset);\n    char c5=stmt.charAt(++offset);\n    if ((c1 == 'S' || c1 == 's') && (c2 == 'E' || c2 == 'e') && (c3 == 'R' || c3 == 'r')&& (c4 == '(')&& (c5 == ')')&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt.charAt(offset)))) {\n      return USER;\n    }\n  }\n  return OTHER;\n}\n", "nl": "SELECT USER()"}
{"code": "private ByteBuffer read(FileChannel channel,int size,long offset){\n  ByteBuffer byteBffer=ByteBuffer.allocate(size);\n  try {\n    channel.position(offset);\n    channel.read(byteBffer);\n  }\n catch (  Exception e) {\n    LOGGER.error(e,e.getMessage());\n  }\n  byteBffer.rewind();\n  return byteBffer;\n}\n", "nl": "This method will be used to read from file based on number of bytes to be read and positon"}
{"code": "private void computeTax2SpeciesMapRec(final Node v,int speciesId,final IntIntMap taxId2SpeciesId,final ProgressListener progress) throws CanceledException {\n  final int taxId=(Integer)v.getInfo();\n  if (speciesId == 0) {\n    if (name2IdMap.getRank(taxId) == TaxonomicLevels.getSpeciesId()) {\n      speciesId=taxId;\n      taxId2SpeciesId.put(taxId,speciesId);\n    }\n  }\n else   taxId2SpeciesId.put(taxId,speciesId);\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e))   computeTax2SpeciesMapRec(e.getTarget(),speciesId,taxId2SpeciesId,progress);\n  progress.incrementProgress();\n}\n", "nl": "recursively compute the taxon-id to species-id map"}
{"code": "@RequestMapping(value=\"/push_logs\",method=RequestMethod.GET) public JsonResponse pagingPushLogs(@RequestParam(\"appId\") Long appId,@RequestParam(value=\"pageNo\",defaultValue=\"1\") Integer pageNo,@RequestParam(value=\"pageSize\",defaultValue=\"10\") Integer pageSize){\n  Response<Page<PushLog>> pageResp=pushLogService.pagingConfigPushLog(appId,pageNo,pageSize);\n  if (!pageResp.isSuccess()) {\n    Logs.error(\"failed to paging push logs(appId={}, pageNo={}, pageSize={}), cause: {}\",appId,pageNo,pageSize,pageResp.getErr());\n    return JsonResponse.notOk(pageResp.getErr());\n  }\n  Page<PushLogDto> logDtoPage=render2PushLogDto(pageResp.getData());\n  return JsonResponse.ok(logDtoPage);\n}\n", "nl": "Paging the config push logs"}
{"code": "public static String hexDump(byte[] b){\n  if (b == null)   return \"\";\n  StringBuffer buf=new StringBuffer();\n  int size=b.length;\n  for (int i=0; i < size; i++) {\n    if ((i + 1) % 16 == 0) {\n      buf.append(zeropad(Integer.toHexString(byteToUInt(b[i])).toUpperCase(),2));\n      buf.append(\"\\n\");\n    }\n else {\n      buf.append(zeropad(Integer.toHexString(byteToUInt(b[i])).toUpperCase(),2));\n      buf.append(\" \");\n    }\n  }\n  return buf.toString();\n}\n", "nl": "Returns the hex dump of the given byte array as 16 bytes per line"}
{"code": "public SkillCursor querySkillFromTree(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=false;\n  qh.Table=S.TABLE_SKILLS;\n  qh.Columns=null;\n  qh.Selection=S.COLUMN_SKILLS_SKILL_TREE_ID + \" = ?\";\n  qh.SelectionArgs=new String[]{String.valueOf(id)};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new SkillCursor(wrapHelper(qh));\n}\n", "nl": "****************************** SKILL QUERIES"}
{"code": "private void failPendingBatchMessages(PulsarClientException ex){\n  if (batchMessageContainer.isEmpty()) {\n    return;\n  }\n  int numMessagesInBatch=batchMessageContainer.numMessagesInBatch;\n  semaphore.release(numMessagesInBatch);\n  try {\n    batchMessageContainer.firstCallback.sendComplete(ex);\n  }\n catch (  Throwable t) {\n    log.warn(\"[{}] [{}] Got exception while completing the callback for msg {}:\",topic,producerName,batchMessageContainer.sequenceId,t);\n  }\n  ReferenceCountUtil.safeRelease(batchMessageContainer.getBatchedSingleMessageMetadataAndPayload());\n  batchMessageContainer.clear();\n}\n", "nl": "fail any pending batch messages that were enqueued, however batch was not closed out"}
{"code": "public void delayMethod(int deltaTime){\n  Robot robot;\n  try {\n    robot=new Robot();\n    robot.delay(deltaTime);\n  }\n catch (  AWTException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "make delay for the sending delay packet"}
{"code": "private void initLabels(){\n  CompareConfiguration cc=getCompareConfiguration();\n  String resourceName=resource.getName();\n  setTitle(Policy.bind(\"SVNCompareRevisionsInput.compareResourceAndVersions\",new Object[]{resourceName}));\n  cc.setLeftEditable(!readOnly);\n  cc.setRightEditable(false);\n  String leftLabel=Policy.bind(\"SVNCompareRevisionsInput.workspace\",new Object[]{resourceName});\n  cc.setLeftLabel(leftLabel);\n  String remoteResourceName=null;\n  if (remoteResource != null) {\n    remoteResourceName=remoteResource.getName();\n  }\n else {\n    remoteResourceName=resourceName;\n  }\n  String rightLabel=Policy.bind(\"SVNCompareRevisionsInput.repository\",new Object[]{remoteResourceName});\n  cc.setRightLabel(rightLabel);\n}\n", "nl": "initialize the labels : the title, the lft label and the right one"}
{"code": "private List<CarbonDictionaryColumnMetaChunk> readDictionaryMetadataFile() throws IOException {\n  CarbonDictionaryMetadataReaderImpl columnMetadataReaderImpl=new CarbonDictionaryMetadataReaderImpl(this.carbonStorePath,this.carbonTableIdentifier,this.columnIdentifier);\n  List<CarbonDictionaryColumnMetaChunk> dictionaryMetaChunkList=null;\n  try {\n    dictionaryMetaChunkList=columnMetadataReaderImpl.read();\n  }\n  finally {\n    columnMetadataReaderImpl.close();\n  }\n  return dictionaryMetaChunkList;\n}\n", "nl": "This method will read dictionary metadata file and return the dictionary meta chunks"}
{"code": "private boolean compareResult(Map<String,List<Distributable>> expectedResult,Map<String,List<Distributable>> actualResult){\n  expectedResult=sortByListSize(expectedResult);\n  actualResult=sortByListSize(actualResult);\n  List<List<Distributable>> expectedList=new LinkedList(expectedResult.entrySet());\n  List<List<Distributable>> mapOfNodesList=new LinkedList(actualResult.entrySet());\n  boolean isEqual=expectedList.size() == mapOfNodesList.size();\n  if (isEqual) {\n    for (int i=0; i < expectedList.size(); i++) {\n      int size1=((List)((Map.Entry)(expectedList.get(i))).getValue()).size();\n      int size2=((List)((Map.Entry)(mapOfNodesList.get(i))).getValue()).size();\n      isEqual=size1 == size2;\n      if (!isEqual) {\n        break;\n      }\n    }\n  }\n  return isEqual;\n}\n", "nl": "compares the blocks allocation"}
{"code": "static Object newInstance(String className,ClassLoader cl,boolean doFallback) throws ConfigurationError {\n  try {\n    Class providerClass=findProviderClass(className,cl,doFallback);\n    Object instance=providerClass.newInstance();\n    if (DEBUG)     debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \"+ cl);\n    return instance;\n  }\n catch (  ClassNotFoundException x) {\n    throw new ConfigurationError(\"Provider \" + className + \" not found\",x);\n  }\ncatch (  Exception x) {\n    throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \"+ x,x);\n  }\n}\n", "nl": "Create an instance of a class using the specified ClassLoader"}
{"code": "public static void w(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_WARNING) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.w(tag,msg);\n}\n", "nl": "Send a WARNING log message"}
{"code": "@Deployment public void testBoundaryEvent(){\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"boundaryEventProcess\");\n  Task task=taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();\n  assertNotNull(task);\n  taskService.complete(task.getId());\n  assertEquals(0L,runtimeService.createProcessInstanceQuery().processInstanceId(processInstance.getId()).count());\n  HistoricActivityInstance historicActivityInstance=historyService.createHistoricActivityInstanceQuery().activityId(\"boundary\").processInstanceId(processInstance.getId()).singleResult();\n  assertNull(historicActivityInstance);\n  processInstance=runtimeService.startProcessInstanceByKey(\"boundaryEventProcess\");\n  task=taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();\n  Execution signalExecution=runtimeService.createExecutionQuery().signalEventSubscriptionName(\"alert\").singleResult();\n  runtimeService.signalEventReceived(\"alert\",signalExecution.getId());\n  assertEquals(0L,runtimeService.createProcessInstanceQuery().processInstanceId(processInstance.getId()).count());\n  historicActivityInstance=historyService.createHistoricActivityInstanceQuery().activityId(\"boundary\").processInstanceId(processInstance.getId()).singleResult();\n  assertNotNull(historicActivityInstance);\n  assertNotNull(historicActivityInstance.getStartTime());\n  assertNotNull(historicActivityInstance.getEndTime());\n}\n", "nl": "Test to validate fix for ACT-1399: Boundary-event and event-based auditing"}
{"code": "public static double calcHaMultiplier(Boolean vcenterhastate){\n  double d=0;\n  if (vcenterhastate) {\n    d=1.125;\n  }\n else {\n    d=1;\n  }\n  return d;\n}\n", "nl": "Calculate HA multiplier"}
{"code": "private CarbonDictionarySortInfo createColumnSortInfo(CarbonDictionarySortModel[] dictionarySortModels){\n  int[] sortIndex;\n  int[] sortIndexInverted;\n  Arrays.sort(dictionarySortModels);\n  sortIndex=new int[dictionarySortModels.length];\n  sortIndexInverted=new int[dictionarySortModels.length];\n  for (int i=0; i < dictionarySortModels.length; i++) {\n    CarbonDictionarySortModel dictionarySortModel=dictionarySortModels[i];\n    sortIndex[i]=dictionarySortModel.getKey();\n    sortIndexInverted[dictionarySortModel.getKey() - 1]=i + 1;\n  }\n  dictionarySortModels=null;\n  List<Integer> sortIndexList=convertToList(sortIndex);\n  List<Integer> sortIndexInvertedList=convertToList(sortIndexInverted);\n  return new CarbonDictionarySortInfo(sortIndexList,sortIndexInvertedList);\n}\n", "nl": "The method prepares the sort_index and sort_index_inverted data"}
{"code": "private static int clampX(int x,ConstraintWidget base){\n  if (x < base.getX()) {\n    x=base.getX();\n  }\n else   if (x > base.getRight()) {\n    x=base.getRight();\n  }\n  return x;\n}\n", "nl": "Clamp to the bounds of the base panel"}
{"code": "protected void stopWatchTextUnit(){\n  if (!textUnitStopWatch.isRunning()) {\n    textUnitStopWatch.start(\"start creating text unit\");\n  }\n  if (++numOfTextUnitProcess % 500 == 0) {\n    logger.info(\"num of text unit added:  {}\",numOfTextUnitProcess);\n    textUnitStopWatch.stop();\n    textUnitStopWatch.start(\"batch \" + numOfTextUnitProcess);\n  }\n}\n", "nl": "Start/stop stop watch in batches for text unit processing"}
{"code": "public static int calculateSampleSize(int srcWidth,int srcHeight,int dstWidth,int dstHeight){\n  final float srcAspect=(float)srcWidth / (float)srcHeight;\n  final float dstAspect=(float)dstWidth / (float)dstHeight;\n  if (srcAspect > dstAspect) {\n    return srcWidth / dstWidth;\n  }\n else {\n    return srcHeight / dstHeight;\n  }\n}\n", "nl": "Figure out what ratio we can load our image into memory at while still being bigger than our desired width and height"}
{"code": "protected AbstractArea(ZoneName zoneName,int worldId,float minZ,float maxZ){\n  if (minZ > maxZ) {\n    throw new IllegalArgumentException(\"minZ(\" + minZ + \") > maxZ(\"+ maxZ+ \")\");\n  }\n  this.minZ=minZ;\n  this.maxZ=maxZ;\n  this.zoneName=zoneName;\n  this.worldId=worldId;\n}\n", "nl": "Creates new AbstractArea with min and max z"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  ClusterViewer viewer=getViewer();\n  np.matchIgnoreCase(\"select=\");\n  String target=np.getWordMatchesIgnoringCase(\"all none invert\");\n  if (target.equalsIgnoreCase(\"all\"))   viewer.selectAll(true);\n else   if (target.equalsIgnoreCase(\"invert\"))   viewer.selectInverted();\n else   viewer.selectAll(false);\n  np.matchIgnoreCase(\";\");\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static byte[] toByteArray(Writable... writables){\n  final DataOutputBuffer out=new DataOutputBuffer();\n  try {\n    for (    Writable w : writables) {\n      w.write(out);\n    }\n    out.close();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"Fail to convert writables to a byte array\",e);\n  }\n  return out.getData();\n}\n", "nl": "Convert writables to a byte array"}
{"code": "public static int calculateMagicalResistRate(Creature attacker,Creature attacked,int accMod){\n  if (attacked.getObserveController().checkAttackStatus(AttackStatus.RESIST)) {\n    return 1000;\n  }\n  int attackerLevel=attacker.getLevel();\n  int targetLevel=attacked.getLevel();\n  int resistRate=attacked.getGameStats().getMResist().getCurrent() - attacker.getGameStats().getMainHandMAccuracy().getCurrent() - attacker.getGameStats().getStat(StatEnum.PVP_MAGICAL_HIT_ACCURACY,0).getCurrent()- accMod;\n  if ((targetLevel - attackerLevel) > 2) {\n    resistRate+=(targetLevel - attackerLevel - 2) * 100;\n  }\n  if (resistRate <= 0) {\n    resistRate=1;\n  }\n  if (resistRate > 500) {\n    resistRate=500;\n  }\n  return resistRate;\n}\n", "nl": "Calculates RESIST chance"}
{"code": "public static void main(String[] args){\n  Locale chs=new Locale(\"zh\",\"CN\");\n  for (int i=1; i < 152; i++) {\n    try {\n      System.out.println(String.format(chs,\"Pokedex# %d is %s in %s\",i,PokeDictionary.translateName(PokeDictionary.getDisplayName(i,Locale.ENGLISH),chs),chs.getDisplayName(chs)));\n    }\n catch (    MissingResourceException e) {\n      Log.e(\"Main\",\"Unable to find Pokemon name with given Pokedex: \",e);\n    }\n  }\n}\n", "nl": "Displays All 151 Pokemon Names for all Supported Locales"}
{"code": "public void handleDecode(Result result,Bitmap barcode){\n  inactivityTimer.onActivity();\n  playBeepSoundAndVibrate();\n  String resultString=result.getText();\n  if (resultString.equals(\"\")) {\n    Toast.makeText(CaptureActivity.this,\"Scan failed!\",Toast.LENGTH_SHORT).show();\n  }\n else {\n    Intent resultIntent=new Intent();\n    Bundle bundle=new Bundle();\n    bundle.putString(\"result\",resultString);\n    resultIntent.putExtras(bundle);\n    this.setResult(RESULT_OK,resultIntent);\n  }\n  CaptureActivity.this.finish();\n}\n", "nl": "Handler scan result"}
{"code": "public static int update(String where,Object[] args,V sets,Class<? extends Bean> t){\n  Table mapping=(Table)t.getAnnotation(Table.class);\n  if (mapping == null) {\n    if (log.isErrorEnabled())     log.error(\"mapping missed in [\" + t + \"] declaretion\");\n    return -1;\n  }\n  if (!X.isEmpty(mapping.name())) {\n    return updateTable(mapping.name(),where,args,sets);\n  }\n  return -1;\n}\n", "nl": "update the data using values"}
{"code": "private View findCurrentCenterView(){\n  float centerX=getWidth() / 2;\n  float viewHalfWidth=settings.getViewWidthPx() / 2;\n  View nearestToCenterView=null;\n  int nearestDeltaX=0;\n  View item;\n  int centerXView;\n  for (int count=getChildCount(), i=0; i < count; i++) {\n    item=getChildAt(i);\n    centerXView=(int)(getDecoratedLeft(item) + viewHalfWidth);\n    if (nearestToCenterView == null || Math.abs(nearestDeltaX) > Math.abs(centerX - centerXView)) {\n      nearestToCenterView=item;\n      nearestDeltaX=(int)(centerX - centerXView);\n    }\n  }\n  return nearestToCenterView;\n}\n", "nl": "Find view in the middle of screen"}
{"code": "public boolean moveStream(final String streamName){\n  try {\n    doMoveStream(streamName);\n    return true;\n  }\n catch (  Exception e) {\n    return false;\n  }\n}\n", "nl": "Move given stream <i>streamName</i>"}
{"code": "@Override public PlatformUser parseToken(String token){\n  try {\n    Claims body=Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();\n    String role=(String)body.get(ROLE);\n    List<GrantedAuthority> authorityList=AuthorityUtils.commaSeparatedStringToAuthorityList(role);\n    PlatformUser user=new PlatformUser(body.getSubject(),StringConstant.EMPTY_STRING,authorityList);\n    user.setDeviceId((String)body.get(DEVICE_ID));\n    user.setPlatform((String)body.get(PLATFORM));\n    user.setRole(role);\n    user.setLoginTime((Long)body.get(LOGIN_TIME));\n    return user;\n  }\n catch (  Exception e) {\n    return null;\n  }\n}\n", "nl": "Parse platform user object from json web token"}
{"code": "public void preMultiply(MatrixN mat){\n  final MatrixN tmp=new MatrixN(size());\n  for (int j=0; j < size(); j++)   for (int i=0; i < size(); i++) {\n    double f=0.;\n    for (int k=0; k < size(); k++)     f+=mat.get(i,k) * get(k,j);\n    tmp.set(i,j,f);\n  }\n  set(tmp);\n}\n", "nl": "pre multiple mat x this"}
{"code": "public INDArray toRaveledTensor(BufferedImage image){\n  try {\n    image=scalingIfNeed(image,false);\n    return toINDArrayBGR(image).ravel();\n  }\n catch (  Exception e) {\n    throw new RuntimeException(\"Unable to load image\",e);\n  }\n}\n", "nl": "Convert an image in to a raveled tensor of the bgr values of the image"}
{"code": "public void union(FlowSet<T> otherFlow,FlowSet<T> destFlow){\n  if (sameType(otherFlow) && sameType(destFlow)) {\n    DavaFlowSet<T> other=(DavaFlowSet<T>)otherFlow;\n    DavaFlowSet<T> dest=(DavaFlowSet<T>)destFlow;\n    if (dest == other) {\n      for (int i=0; i < this.numElements; i++)       dest.add(this.elements[i]);\n    }\n else {\n      if (this != dest)       copy(dest);\n      for (int i=0; i < other.numElements; i++)       dest.add(other.elements[i]);\n    }\n  }\n else   super.union(otherFlow,destFlow);\n}\n", "nl": "Notice that the union method only merges the elements of the flow set DavaFlowSet also contains information regarding abrupt control flow This should also be merged using the copyInternalDataFrom method"}
{"code": "public void addEdge(Object from,Object to,int w){\n  if (this.isUnknown)   throw new RuntimeException(\"Unknown graph can not have edges\");\n  Hashtable<Object,IntContainer> targets=sources.get(from);\n  if (targets == null) {\n    targets=new Hashtable<Object,IntContainer>();\n    sources.put(from,targets);\n  }\n  IntContainer weight=targets.get(to);\n  if (weight == null) {\n    weight=new IntContainer(w);\n    targets.put(to,weight);\n  }\n else {\n    if (weight.value > w)     weight.value=w;\n  }\n}\n", "nl": "Add an edge with weight to the graph"}
{"code": "@Override public boolean deletePlayerItems(final int playerId){\n  Connection con=null;\n  try {\n    con=DatabaseFactory.getConnection();\n    PreparedStatement stmt=con.prepareStatement(DELETE_CLEAN_QUERY);\n    stmt.setInt(1,playerId);\n    stmt.execute();\n    stmt.close();\n  }\n catch (  Exception e) {\n    log.error(\"Error Player all items. PlayerObjId: \" + playerId,e);\n    return false;\n  }\n finally {\n    DatabaseFactory.close(con);\n  }\n  return true;\n}\n", "nl": "Since inventory is not using FK - need to clean items"}
{"code": "private static void extractChainRec(Node v,Edge e,NodeSet used,List<Node> order,EdgeSet selectedEdges){\n  if (!used.contains(v)) {\n    used.add(v);\n    order.add(v);\n    for (Edge f=v.getFirstAdjacentEdge(); f != null; f=v.getNextAdjacentEdge(f)) {\n      if (f != e && selectedEdges.contains(f))       extractChainRec(f.getOpposite(v),f,used,order,selectedEdges);\n    }\n  }\n else   throw new RuntimeException(\"Illegal cycle at: \" + v);\n}\n", "nl": "extract chain of nodes"}
{"code": "private void createThrowStmt(Body body,Unit oldStmt,LocalCreation lc){\n  RefType tp=RefType.v(\"java.lang.NullPointerException\");\n  Local lcEx=lc.newLocal(tp);\n  SootMethodRef constructorRef=Scene.v().makeConstructorRef(tp.getSootClass(),Collections.singletonList((Type)RefType.v(\"java.lang.String\")));\n  Stmt newExStmt=Jimple.v().newAssignStmt(lcEx,Jimple.v().newNewExpr(tp));\n  body.getUnits().insertBefore(newExStmt,oldStmt);\n  Stmt invConsStmt=Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(lcEx,constructorRef,Collections.singletonList(StringConstant.v(\"Null throw statement replaced by Soot\"))));\n  body.getUnits().insertBefore(invConsStmt,oldStmt);\n  body.getUnits().swapWith(oldStmt,Jimple.v().newThrowStmt(lcEx));\n}\n", "nl": "Creates a new statement that throws a NullPointerException"}
{"code": "public void read(IInputReader reader,long startPos) throws IOException {\n  reader.seek(startPos);\n  final int magicNumber=reader.readInt();\n  if (magicNumber != RMA2File.MAGIC_NUMBER) {\n    throw new IOException(\"Not an RMA file\");\n  }\n  final int version=reader.readInt();\n  if (version != 3) {\n    throw new IOException(\"Not an RMA 3 file\");\n  }\n  setFormatDef(reader.readString());\n  FormatDefinition formatDefinition=FormatDefinition.fromString(getFormatDef());\n  for (  Pair<String,FormatDefinition.Type> pair : formatDefinition.getList()) {\n    if (pair.getFirst().equals(\"Creator\"))     setCreator(reader.readString());\n else     if (pair.getFirst().equals(\"CreationDate\"))     setCreationDate(reader.readLong());\n  }\n}\n", "nl": "read the header from a file"}
{"code": "private static ArrayList<ConstraintWidgetContainer> gatherContainers(ConstraintWidgetContainer container){\n  ArrayList<ConstraintWidgetContainer> containers=new ArrayList<>();\n  for (  ConstraintWidget widget : container.getChildren()) {\n    if (widget instanceof ConstraintWidgetContainer) {\n      containers.add((ConstraintWidgetContainer)widget);\n    }\n  }\n  return containers;\n}\n", "nl": "Gather a list of containers that are children of the given container"}
{"code": "public WyporiumTradeCursor queryWyporiumTrades(){\n  QueryHelper qh=new QueryHelper();\n  qh.Columns=null;\n  qh.Table=S.TABLE_WYPORIUM_TRADE;\n  qh.Selection=null;\n  qh.SelectionArgs=null;\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new WyporiumTradeCursor(wrapJoinHelper(builderWyporiumTrade(),qh));\n}\n", "nl": "*************************** WYPORIUM TRADE QUERIES"}
{"code": "public static NameValuePair[] split_metadata(String meta_buff,String recordSeperator,String filedSeperator){\n  String[] rows;\n  String[] cols;\n  NameValuePair[] meta_list;\n  rows=meta_buff.split(recordSeperator);\n  meta_list=new NameValuePair[rows.length];\n  for (int i=0; i < rows.length; i++) {\n    cols=rows[i].split(filedSeperator,2);\n    meta_list[i]=new NameValuePair(cols[0]);\n    if (cols.length == 2) {\n      meta_list[i].setValue(cols[1]);\n    }\n  }\n  return meta_list;\n}\n", "nl": "split metadata to name value pair array"}
{"code": "@Override public void completed(Exception exception,long ledgerId,long entryId){\n  if (exception != null) {\n    producer.cnx.ctx().channel().eventLoop().execute(null);\n  }\n else {\n    if (log.isDebugEnabled()) {\n      log.debug(\"[{}] [{}] [{}] triggered send callback. cnx {}, sequenceId {}\",producer.topic,producer.producerName,producer.producerId,producer.cnx.clientAddress(),sequenceId);\n    }\n    this.ledgerId=ledgerId;\n    this.entryId=entryId;\n    producer.cnx.ctx().channel().eventLoop().execute(this);\n  }\n}\n", "nl": "Executed from managed ledger thread when the message is persisted"}
{"code": "private void tell(List<Entry> bad){\n  for (Iterator<Entry> iter=bad.iterator(); iter.hasNext(); ) {\n    Entry e=iter.next();\n    if (e.renewalsDone()) {\n      final DesiredExpirationListener del=e.desiredExpirationListener();\n      if (del != null) {\n        del.expirationReached(new LeaseRenewalEvent(this,e.lease,e.expiration,null));\n      }\n      continue;\n    }\n    e.listener.notify(new LeaseRenewalEvent(this,e.lease,e.expiration,e.ex));\n  }\n}\n", "nl": "Notify the listener for each lease"}
{"code": "public static ArrayList<String> matches(String text,int results){\n  ArrayList<String> urls=new ArrayList<String>();\n  String[] splitString=(text.split(\" \"));\n  for (  String string : splitString) {\n    try {\n      URL item=new URL(string);\n      urls.add(item.toString());\n    }\n catch (    Exception e) {\n    }\n    if (results == FIRST && urls.size() > 0)     break;\n  }\n  return urls;\n}\n", "nl": "It finds urls inside the text and return the matched ones"}
{"code": "@Override protected void drawBlurredBitmap(Canvas canvas,Bitmap blurredBitmap,int overlayColor){\n  if (blurredBitmap != null) {\n    mRectF.right=getWidth();\n    mRectF.bottom=getHeight();\n    mPaint.reset();\n    mPaint.setAntiAlias(true);\n    BitmapShader shader=new BitmapShader(blurredBitmap,Shader.TileMode.CLAMP,Shader.TileMode.CLAMP);\n    Matrix matrix=new Matrix();\n    matrix.postScale(mRectF.width() / blurredBitmap.getWidth(),mRectF.height() / blurredBitmap.getHeight());\n    shader.setLocalMatrix(matrix);\n    mPaint.setShader(shader);\n    canvas.drawOval(mRectF,mPaint);\n    mPaint.reset();\n    mPaint.setAntiAlias(true);\n    mPaint.setColor(overlayColor);\n    canvas.drawOval(mRectF,mPaint);\n  }\n}\n", "nl": "Custom oval shape"}
{"code": "protected final void startNamespaceMapping() throws SAXException {\n  int count=fNamespaceContext.getDeclaredPrefixCount();\n  if (count > 0) {\n    String prefix=null;\n    String uri=null;\n    for (int i=0; i < count; i++) {\n      prefix=fNamespaceContext.getDeclaredPrefixAt(i);\n      uri=fNamespaceContext.getURI(prefix);\n      fContentHandler.startPrefixMapping(prefix,(uri == null) ? \"\" : uri);\n    }\n  }\n}\n", "nl": "Send startPrefixMapping events"}
{"code": "public static Date stringToDate(String date,String datePattern){\n  DateFormat format=new SimpleDateFormat(datePattern,Locale.ENGLISH);\n  try {\n    return format.parse(date);\n  }\n catch (  ParseException e) {\n    Log.e(\" \" + e.getMessage(),\" Please check if you have valid pattern! \");\n  }\n  return null;\n}\n", "nl": "Convert date from String to Date format"}
{"code": "public boolean canFinish(){\n  IWizardPage page=getContainer().getCurrentPage();\n  if (page == directoryPage) {\n    return directoryPage.useProjectName() || directoryPage.getDirectoryName() != null;\n  }\n else   if (page == finishPage) {\n    return true;\n  }\n  return super.canFinish();\n}\n", "nl": "check if wizard can finish"}
{"code": "public BlacklistEntry(String urlPattern,int statusCode,String httpMethodPattern){\n  this.urlPattern=Pattern.compile(urlPattern);\n  this.statusCode=statusCode;\n  if (httpMethodPattern == null || httpMethodPattern.isEmpty()) {\n    this.httpMethodPattern=null;\n  }\n else {\n    this.httpMethodPattern=Pattern.compile(httpMethodPattern);\n  }\n}\n", "nl": "Creates a new BlacklistEntry which will match both a URL and an HTTP method"}
{"code": "public boolean addAttribute(String attribute,Map<String,Object> sample2value,boolean allowReplaceAttribute,boolean allowAddSample){\n  if (allowReplaceAttribute || !table.columnKeySet().contains(attribute)) {\n    if (sample2value.size() > 0) {\n      for (      String sample : sample2value.keySet()) {\n        if (allowAddSample || getSampleSet().contains(sample))         put(sample,attribute,sample2value.get(sample));\n      }\n    }\n else {\n      for (      String sample : getSampleSet()) {\n        put(sample,attribute,null);\n      }\n    }\n    return true;\n  }\n  return false;\n}\n", "nl": "add an attribute"}
{"code": "public <S>S createService(Class<S> serviceClass){\n  String baseUrl=\"\";\n  try {\n    Field field1=serviceClass.getField(\"BASE_URL\");\n    baseUrl=(String)field1.get(serviceClass);\n  }\n catch (  NoSuchFieldException e) {\n    e.printStackTrace();\n  }\ncatch (  IllegalAccessException e) {\n    e.getMessage();\n    e.printStackTrace();\n  }\n  Retrofit retrofit=new Retrofit.Builder().baseUrl(baseUrl).client(getOkHttpClient()).addConverterFactory(GsonConverterFactory.create(mGsonDateFormat)).addCallAdapterFactory(RxJavaCallAdapterFactory.create()).build();\n  return retrofit.create(serviceClass);\n}\n", "nl": "create a service"}
{"code": "public void paint(Graphics2D gc,Rectangle rect){\n  try {\n    if (gc instanceof SelectionGraphics) {\n      final SelectionGraphics sgc=(SelectionGraphics)gc;\n      select(rect,sgc.getSelectionRectangle(),sgc.getMouseClicks());\n    }\n else     if (!inUpdate) {\n      doPaint(gc,rect);\n    }\n  }\n catch (  Exception ex) {\n  }\n}\n", "nl": "paint the tree"}
{"code": "public void register(String pattern,String result){\n  Assert.isTrue(matchers.size() == results.size());\n  pattern=pattern.trim();\n  if (pattern.length() == 0) {\n    return;\n  }\n  matchers.add(new StringMatcher(pattern,false,false));\n  results.add(result);\n}\n", "nl": "register a pattern and an associated string"}
{"code": "public void start(){\n  logger.info(\"Starting computation...\");\n  jssc.start();\n  try {\n    jssc.awaitTermination();\n  }\n catch (  InterruptedException e) {\n    Thread.interrupted();\n  }\n}\n", "nl": "Method to start the computation"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  AttributesWindow viewer=(AttributesWindow)getViewer();\n  if (viewer != null) {\n    viewer.doSortByAlpha=false;\n    viewer.doSortByNrOfReads=true;\n    int div=viewer.getSplitPane().getDividerLocation();\n    viewer.getSplitPane().remove(viewer.getSplitPane().getTopComponent());\n    viewer.getSplitPane().setTopComponent(viewer.getTreePanel());\n    viewer.getSplitPane().setDividerLocation(div);\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public boolean acquire(){\n  int timeout=acquireTimeout;\n  while (timeout >= 0) {\n    if (ops.setIfAbsent(lockKey,lockValue)) {\n      new Thread(new LockExpiredTask()).start();\n      isHold=true;\n      return true;\n    }\n    try {\n      timeout-=DEFAULT_ACQUIRE_PAUSE_MILLIS;\n      Thread.sleep(DEFAULT_ACQUIRE_PAUSE_MILLIS);\n    }\n catch (    InterruptedException e) {\n    }\n  }\n  return false;\n}\n", "nl": "acquire the lock"}
{"code": "public Repository createRepoAndAssetAndTextUnits(TestIdWatcher testIdWatcher) throws RepositoryNameAlreadyUsedException {\n  Repository repository=createRepository(testIdWatcher);\n  try {\n    PollableFuture<Asset> assetResult=assetService.addOrUpdateAssetAndProcessIfNeeded(repository.getId(),getTestSourceAssetContent(),\"path/to/asset.xliff\");\n    pollableTaskService.waitForPollableTask(assetResult.getPollableTask().getId());\n  }\n catch (  PollableTaskException|InterruptedException|ExecutionException e) {\n    throw new RuntimeException(\"Could not update asset and process it\",e);\n  }\n  return repository;\n}\n", "nl": "Creates a repo supporting few languages, a TM and processes an asset to add text units"}
{"code": "Map<Integer,Integer> strippedWhitespaceUpToColumn(String intro){\n  Map<Integer,Integer> stripped=new TreeMap<>();\n  boolean countingWhitespace=false;\n  int col=0;\n  int count=0;\n  for (  char c : intro.toCharArray()) {\n    if (c == '\\n' && !countingWhitespace) {\n      countingWhitespace=true;\n    }\n else     if (countingWhitespace) {\n      if (Character.isWhitespace(c))       count++;\n else       countingWhitespace=false;\n    }\n    stripped.put(col,count);\n    col++;\n  }\n  return stripped;\n}\n", "nl": "Help count how much newline and margin whitespace we have stripped up to a particular index so we know how to offset anchors"}
{"code": "private boolean containsBlackPoint(int a,int b,int fixed,boolean horizontal){\n  if (horizontal) {\n    for (int x=a; x <= b; x++) {\n      if (image.get(x,fixed)) {\n        return true;\n      }\n    }\n  }\n else {\n    for (int y=a; y <= b; y++) {\n      if (image.get(fixed,y)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Determines whether a segment contains a black point"}
{"code": "public boolean seenTagPrefix(@NotNull String prefix){\n  if (myTags != null) {\n    for (    String tag : myTags.keySet()) {\n      if (tag.startsWith(prefix)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Returns true if the given tag prefix has been seen"}
{"code": "public static String buildHostId(List<String> tenantLinks,String hostId){\n  AssertUtil.assertNotNull(hostId,\"hostId\");\n  String group=extractGroup(tenantLinks);\n  String id=extractHostId(hostId);\n  if (group == null || group.isEmpty()) {\n    return id;\n  }\n else {\n    return group + HOST_ID_TENANT_SEPARATOR + id;\n  }\n}\n", "nl": "Build host id <ul> <li>in a group returns group::hostId <li>not in a group returns hostId </ul>"}
{"code": "private String interpretMessage(Message message,boolean displayHex) throws IOException {\n  byte[] msgData=message.getData();\n  ByteArrayOutputStream out=new ByteArrayOutputStream();\n  if (!displayHex) {\n    return new String(msgData);\n  }\n else {\n    HexDump.dump(msgData,0,out,0);\n    return new String(out.toByteArray());\n  }\n}\n", "nl": "Interprets the message to create a string representation"}
{"code": "private static void deleteRecursive(CarbonFile f) throws CarbonUtilException {\n  if (f.isDirectory()) {\n    if (f.listFiles() != null) {\n      for (      CarbonFile c : f.listFiles()) {\n        deleteRecursive(c);\n      }\n    }\n  }\n  if (f.exists() && !f.delete()) {\n    throw new CarbonUtilException(\"Error while deleting the folders and files\");\n  }\n}\n", "nl": "Recursively delete the files"}
{"code": "private void drawCircle(Canvas canvas,int index,Paint paint,float radius){\n  if (isIllegalIndex(index)) {\n    return;\n  }\n  int x=getXByIndex(index);\n  int y=getYByIndex(index);\n  float centreY=cellHeight + (y - 1) * cellHeight + cellHeight * 0.5f;\n  float centreX=cellWidth * (x - 1) + cellWidth * 0.5f;\n  canvas.drawCircle(centreX,centreY,radius,paint);\n}\n", "nl": "draw circle, around the middle of the cell decided by the index"}
{"code": "@Override public void logoutWithoutApi(){\n  if ((mSelectedMenuItemId == R.id.my_tickets || mSelectedMenuItemId == R.id.drafts)) {\n    mSelectedMenuItemId=R.id.all_tickets;\n    mTitleId=R.string.all_tickets;\n    mCurrentFragment=TicketsFragment.newInstance(false,mOnPageChangeListener);\n    performScreenChange(mSelectedMenuItemId);\n    setTitle(mTitleId);\n  }\n}\n", "nl": "Changes ui when logout executed"}
{"code": "public T next(){\n  if (enable) {\n    if (done) {\n      return null;\n    }\n    if (next == null)     hasNext();\n    if (next != null) {\n      T result=(T)next;\n      next=null;\n      return result;\n    }\n else {\n      return null;\n    }\n  }\n else   return iterator.next();\n}\n", "nl": "gets next element of getLetterCodeIterator"}
{"code": "private void syncProgress(SeekBar seekBar){\n  float value=seekBarProgressToPrefValue(seekBar.getProgress());\n  if (value != mValue) {\n    if (callChangeListener(value)) {\n      setValue(value,false);\n    }\n else {\n      seekBar.setProgress(prefValueToSeekBarProgress(mValue));\n    }\n  }\n}\n", "nl": "Persist the seekBar's progress value if callChangeListener returns true, otherwise set the seekBar's progress to the stored value"}
{"code": "private SAXParserImpl newSAXParserImpl() throws ParserConfigurationException, SAXNotRecognizedException, SAXNotSupportedException {\n  SAXParserImpl saxParserImpl;\n  try {\n    saxParserImpl=new SAXParserImpl(this,features);\n  }\n catch (  SAXNotSupportedException e) {\n    throw e;\n  }\ncatch (  SAXNotRecognizedException e) {\n    throw e;\n  }\ncatch (  SAXException se) {\n    throw new ParserConfigurationException(se.getMessage());\n  }\n  return saxParserImpl;\n}\n", "nl": "Common code for translating exceptions"}
{"code": "public void populate(List<SLDDataInterface> sldDataList){\n  List<ScaleSLDData> scaleDataList=new ArrayList<ScaleSLDData>();\n  for (  SLDDataInterface sldData : sldDataList) {\n    List<ScaleSLDData> scaleSLDDataList=ScalePanelUtils.containsScales(sldData);\n    if ((scaleSLDDataList != null) && !scaleSLDDataList.isEmpty()) {\n      scaleDataList.addAll(scaleSLDDataList);\n    }\n  }\n  dataModel.loadData(scaleDataList);\n}\n", "nl": "Populate the dialog"}
{"code": "private void loadLegionInfo(Legion legion){\n  if (legion == null) {\n    return;\n  }\n  legion.setLegionMembers(DAOManager.getDAO(LegionMemberDAO.class).loadLegionMembers(legion.getLegionId()));\n  legion.setAnnouncementList(DAOManager.getDAO(LegionDAO.class).loadAnnouncementList(legion.getLegionId()));\n  legion.setLegionEmblem(DAOManager.getDAO(LegionDAO.class).loadLegionEmblem(legion.getLegionId()));\n  legion.setLegionWarehouse(DAOManager.getDAO(LegionDAO.class).loadLegionStorage(legion));\n  if (legionRanking.containsKey(legion.getLegionId())) {\n    legion.setLegionRank(legionRanking.get(legion.getLegionId()));\n  }\n  DAOManager.getDAO(LegionDAO.class).loadLegionHistory(legion);\n}\n", "nl": "This method will load the legion information"}
{"code": "public int nextIndex(){\n  try {\n    return currentIndex() + 1;\n  }\n catch (  GenericEntityException e) {\n    if (!closed) {\n      try {\n        this.close();\n      }\n catch (      GenericEntityException e1) {\n        Debug.logError(e1,\"Error auto-closing EntityListIterator on error, so info below for more info on original error; close error: \" + e1.toString(),module);\n      }\n      Debug.logWarning(\"Warning: auto-closed EntityListIterator because of exception: \" + e.toString(),module);\n    }\n    throw new GeneralRuntimeException(e.getNonNestedMessage(),e.getNested());\n  }\n}\n", "nl": "Returns the index of the next result, but does not guarantee that there will be a next result"}
{"code": "private SysMenu buildMenuFromModule(Module module){\n  SysMenu sysMenu=new SysMenu();\n  sysMenu.setId(module.getId());\n  sysMenu.setCode(module.getCode());\n  sysMenu.setName(module.getName());\n  sysMenu.setParent(module.getParent());\n  sysMenu.setUrl(module.getUrl());\n  sysMenu.setController(module.getController());\n  sysMenu.setTemplate(module.getTemplate());\n  sysMenu.setOrderId(module.getOrderId());\n  return sysMenu;\n}\n", "nl": "Build system menu from module"}
{"code": "public void removeIfFirstLastSame(){\n  if (wktPointList != null) {\n    if (wktPointList.size() > 1) {\n      WKTPoint firstPoint=wktPointList.get(0);\n      WKTPoint lastPoint=wktPointList.get(wktPointList.size() - 1);\n      if (firstPoint.equals(lastPoint)) {\n        wktPointList.remove(wktPointList.size() - 1);\n      }\n    }\n  }\n}\n", "nl": "Removes last point if the first and last point are the same"}
{"code": "@Deployment(resources={\"org/activiti/engine/test/api/task/TaskQueryTest.testProcessDefinition.bpmn20.xml\"}) public void testIncludeBinaryVariables() throws Exception {\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"oneTaskProcess\",Collections.singletonMap(\"binaryVariable\",(Object)\"It is I, le binary\".getBytes()));\n  Task task=taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();\n  assertNotNull(task);\n  taskService.setVariableLocal(task.getId(),\"binaryTaskVariable\",(Object)\"It is I, le binary\".getBytes());\n  task=taskService.createTaskQuery().taskId(task.getId()).includeProcessVariables().singleResult();\n  assertNotNull(task);\n  assertNotNull(task.getProcessVariables());\n  byte[] bytes=(byte[])task.getProcessVariables().get(\"binaryVariable\");\n  assertEquals(\"It is I, le binary\",new String(bytes));\n  task=taskService.createTaskQuery().taskId(task.getId()).includeTaskLocalVariables().singleResult();\n  assertNotNull(task);\n  assertNotNull(task.getTaskLocalVariables());\n  bytes=(byte[])task.getTaskLocalVariables().get(\"binaryTaskVariable\");\n  assertEquals(\"It is I, le binary\",new String(bytes));\n}\n", "nl": "Test confirming fix for ACT-1731"}
{"code": "public static <T extends ExtensionPoint>T newInstance(Class<T> clazz,String pluginId) throws SparklerException {\n  try {\n    T instance=clazz.newInstance();\n    instance.init(JOB_CONTEXT,pluginId);\n    return instance;\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new SparklerException(\"Could not create instance of \" + clazz.getName(),e);\n  }\n}\n", "nl": "Instantiates and tests the"}
{"code": "public void onPatchServiceResult(boolean isUpgradePatch){\n  if (!isRetryEnable) {\n    TinkerLog.w(TAG,\"onPatchServiceResult retry disabled, just return\");\n    return;\n  }\n  if (!isUpgradePatch) {\n    TinkerLog.w(TAG,\"onPatchServiceResult is not upgrade patch, just return\");\n    return;\n  }\n  if (retryInfoFile.exists()) {\n    SharePatchFileUtil.safeDeleteFile(retryInfoFile);\n  }\n  if (tempPatchFile.exists()) {\n    SharePatchFileUtil.safeDeleteFile(tempPatchFile);\n  }\n}\n", "nl": "if we receive any result, we can delete the temp retry info file"}
{"code": "public static byte[] convertInputStreamToByteArray(InputStream inputStream,int inputStreamLength) throws IOException {\n  ByteArrayOutputStream out=new ByteArrayOutputStream();\n  int blockSize=DEFAULT_BUFFER_SIZE;\n  byte[] buffer=new byte[blockSize];\n  int left=inputStreamLength;\n  while (left > 0) {\n    int read=inputStream.read(buffer,0,left > blockSize ? blockSize : left);\n    if (read == -1)     break;\n    out.write(buffer,0,read);\n    left-=read;\n  }\n  return out.toByteArray();\n}\n", "nl": "Converts an input stream to a byte array"}
{"code": "public static String formatElementListString(Iterable<String> values,String oneElementMessage,String twoOrThreeElementsMessage,String moreThenThreeElementsMessage){\n  int size=Iterables.size(values);\n  if (size <= 1) {\n    return String.format(oneElementMessage,Iterables.getFirst(values,\"<validation error>\"));\n  }\n else   if (size <= 3) {\n    return String.format(twoOrThreeElementsMessage,atMostTwo(values,size),Iterables.getLast(values));\n  }\n else {\n    return String.format(moreThenThreeElementsMessage,atMostTwo(values,size),size - 2);\n  }\n}\n", "nl": "Formats a message picking the format string depending on number of arguments"}
{"code": "public static int calculateSecurityServerCount(int externalsessioncount){\n  Float f=(externalsessioncount / (float)2000.00);\n  f=(float)Math.ceil(f);\n  if (f > 0.0) {\n    f++;\n  }\n  final int i=f.intValue();\n  return i;\n}\n", "nl": "Calculate number of security servers"}
{"code": "public boolean write(byte[] bytes,int offset,int size){\n  try {\n    os.write(bytes,offset,size);\n  }\n catch (  IOException ioe) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Writes the given bytes to the audio stream"}
{"code": "protected TableViewer createTable(Composite parent,int span){\n  Table table=new Table(parent,SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER| SWT.SINGLE| SWT.FULL_SELECTION);\n  GridData data=new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL);\n  data.horizontalSpan=span;\n  table.setLayoutData(data);\n  TableLayout layout=new TableLayout();\n  layout.addColumnData(new ColumnWeightData(100,true));\n  table.setLayout(layout);\n  TableColumn col=new TableColumn(table,SWT.NONE);\n  col.setResizable(true);\n  return new TableViewer(table);\n}\n", "nl": "Creates the table for the repositories"}
{"code": "private AudioInputStream synthesizeImposedIntonation(AudioFileFormat aft,Element domElement) throws SynthesisException {\n  SourceTargetPair imposeF0Data=vSelector.getBestCandidatePairtoImposeF0(domElement);\n  int targetIndex=imposeF0Data.getTargetUnitIndex();\n  int sourceIndex=imposeF0Data.getSourceUnitIndex();\n  Log.d(Mary.LOG,\"Synthesizing candidate \" + sourceIndex + \" with intonation contour \"+ targetIndex);\n  if (targetIndex == sourceIndex) {\n    return synthesizeSelectedVocalization(sourceIndex,aft,domElement);\n  }\n  return imposeF0ContourOnVocalization(sourceIndex,targetIndex,aft,domElement);\n}\n", "nl": "Synthesize a vocalization which fits better for given target, in addition, impose intonation from closest best vocalization according to given feature definition for intonation selection"}
{"code": "public static void freqt(double c1[],int m1,double c2[],int m2,double a){\n  double b=1 - a * a;\n  double freqt_buff[]=new double[(m2 + m2 + 2)];\n  int g=m2 + 1;\n  for (int i=-m1; i <= 0; i++) {\n    if (0 <= m2)     freqt_buff[g + 0]=c1[-i] + a * (freqt_buff[0]=freqt_buff[g + 0]);\n    if (1 <= m2)     freqt_buff[g + 1]=b * freqt_buff[0] + a * (freqt_buff[1]=freqt_buff[g + 1]);\n    for (int j=2; j <= m2; j++)     freqt_buff[g + j]=freqt_buff[j - 1] + a * ((freqt_buff[j]=freqt_buff[g + j]) - freqt_buff[g + j - 1]);\n  }\n  System.arraycopy(freqt_buff,g,c2,0,m2);\n}\n", "nl": "freqt: frequency transformation"}
{"code": "private void captureImageWithPermission(){\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n    int rc=ActivityCompat.checkSelfPermission(this,Manifest.permission.CAMERA);\n    if (rc == PackageManager.PERMISSION_GRANTED) {\n      captureImage();\n    }\n else {\n      Log.w(TAG,\"Camera permission is not granted. Requesting permission\");\n      requestCameraPermission();\n    }\n  }\n else {\n    captureImage();\n  }\n}\n", "nl": "Request for camera permission"}
{"code": "@deprecated protected Object handleGetObject(String key) throws MissingResourceException {\n  Object o=null;\n  for (int i=0; i < this.bundles.length; i++) {\n    load(i);\n    try {\n      o=this.bundles[i].getObject(key);\n    }\n catch (    MissingResourceException e) {\n      if (i == this.bundles.length - 1) {\n        throw e;\n      }\n    }\n    if (o != null) {\n      break;\n    }\n  }\n  return o;\n}\n", "nl": "/*    "}
{"code": "private void notifyShutdown(){\n  if (eventHandler instanceof LifecycleAware) {\n    try {\n      ((LifecycleAware)eventHandler).onShutdown();\n    }\n catch (    final Throwable ex) {\n      exceptionHandler.handleOnShutdownException(ex);\n    }\n  }\n}\n", "nl": "Notifies the EventHandler immediately prior to this processor shutting down"}
{"code": "public List<LocalDateTime> bottom(int n){\n  List<LocalDateTime> bottom=new ArrayList<>();\n  long[] values=data.toLongArray();\n  LongArrays.parallelQuickSort(values);\n  for (int i=0; i < n && i < values.length; i++) {\n    bottom.add(PackedLocalDateTime.asLocalDateTime(values[i]));\n  }\n  return bottom;\n}\n", "nl": "Returns the smallest (\"bottom\") n values in the column"}
{"code": "private static int gap(ConstraintWidget widget1,Direction direction1,ConstraintWidget widget2,Direction direction2){\nswitch (direction1) {\ncase NORTH:\ncase WEST:\n    return getPos(widget1,direction1) - getPos(widget2,direction2);\ncase SOUTH:\ncase EAST:\n  return getPos(widget2,direction2) - getPos(widget1,direction1);\n}\nreturn 0;\n}\n", "nl": "Get the gap between two specific edges of widgets"}
{"code": "public String readLine() throws IOException {\n  StringBuilder buf=new StringBuilder();\n  byte b=(byte)read();\n  while (b != '\\n') {\n    buf.append((char)b);\n    b=(byte)in.read();\n    if (getPosition() >= length())     break;\n  }\n  return buf.toString();\n}\n", "nl": "read bytes until next end of line"}
{"code": "@Override public void unbindAppearEvent(WXComponent component){\n  ConcurrentHashMap<String,AppearData> appearMap=mAppearMap.get(getInnerView());\n  if (appearMap == null) {\n    return;\n  }\n  AppearData appearData=appearMap.get(component.getRef());\n  if (appearData == null) {\n    return;\n  }\n  appearData.hasAppear=false;\n  if (!appearData.hasDisappear) {\n    appearMap.remove(component.getRef());\n  }\n}\n", "nl": "Remove appear event"}
{"code": "public static boolean isNullableObjectInterface(HashSet<String> resolvedTypesSet){\n  int intCountTypesToInspect=resolvedTypesSet.size();\n  if (resolvedTypesSet.contains(Types.strClassNotResolved)) {\n    --intCountTypesToInspect;\n  }\n  if (resolvedTypesSet.contains(Types.strNull)) {\n    --intCountTypesToInspect;\n  }\n  if (intCountTypesToInspect == 0) {\n    return false;\n  }\n  for (  String strTypeToInspect : resolvedTypesSet) {\n    if (strTypeToInspect.charAt(0) != '\\\\' && !strTypeToInspect.equals(Types.strNull)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "check if nullable object interfaces"}
{"code": "public Response interceptResponse(Request request,Response response){\n  Response finalResponse=response;\n  Log.d(\"Response\",String.format(\"%s \\n%s\",request.url(),request.headers().toString()));\n  try {\n    ResponseBody responseBody=response.body();\n    String responseBodyString=responseBody.string();\n    Log.d(\"Response data\",responseBodyString);\n    finalResponse=response.newBuilder().body(ResponseBody.create(responseBody.contentType(),responseBodyString)).build();\n  }\n catch (  IOException e) {\n    Log.e(\"Response\",\"Error while parsing the response.\");\n  }\n  return finalResponse;\n}\n", "nl": "Intercepts te"}
{"code": "public void WaitUntilAllViewersAreUptoDate(){\n  while (!isAllViewersUptodate()) {\n    try {\n      Thread.sleep(10);\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "nl": "waits until all viewers are uptodate"}
{"code": "public AccessPath mayAlias(AccessPath taintedAP,AccessPath referencedAP){\n  if (taintedAP.equals(referencedAP))   return taintedAP;\n  if (taintedAP.isInstanceFieldRef() || taintedAP.isLocal()) {\n    if (taintedAP.getPlainValue() != referencedAP.getPlainValue())     return null;\n    if (referencedAP.getFieldCount() == 0)     return taintedAP;\n    if (!referencedAP.isInstanceFieldRef())     return null;\n  }\n  if (taintedAP.isStaticFieldRef())   if (!referencedAP.isStaticFieldRef())   return null;\n  return getReferencedAPBase(taintedAP,referencedAP.getFields());\n}\n", "nl": "Gets whether an access path can point to the same runtime object as another or to an object reachable through the other"}
{"code": "public static boolean saveDynamicResInfo(HashMap<String,String> dynamicRes){\n  boolean result=true;\n  SharedPreferences sp=getDynamicInfoSp();\n  SharedPreferences.Editor editor=sp.edit();\n  for (  String packageId : dynamicRes.keySet()) {\n    String pendingPath=dynamicRes.get(packageId);\n    editor.putString(getDynamicResPathKey(packageId),pendingPath);\n  }\n  editor.commit();\n  Log.i(TAG,\"apply res :\" + dynamicRes);\n  injectResources();\n  return result;\n}\n", "nl": "packagid + newResPath"}
{"code": "public static int compare(byte[] buffer1,byte[] buffer2){\n  if (buffer1 == buffer2) {\n    return 0;\n  }\n  int i=0;\n  int j=0;\n  for (; i < buffer1.length && j < buffer2.length; i++, j++) {\n    int a=(buffer1[i] & 0xff);\n    int b=(buffer2[j] & 0xff);\n    if (a != b) {\n      return a - b;\n    }\n  }\n  return 0;\n}\n", "nl": "Compare method for bytes"}
{"code": "public void addHeaderView(View view,int viewHeight,int expandHeight){\n  if (expandHeight != -1) {\n    mHeaderViewExpandHeight=ScreenUtil.dip2px(mContext,expandHeight);\n  }\n  mHeaderViews.clear();\n  mHeaderView=view;\n  if (mHeaderView.getLayoutParams() == null) {\n    mHeaderView.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT,ScreenUtil.dip2px(mContext,viewHeight)));\n  }\n  markHeaderViewHeight(mHeaderView);\n  mHeaderView.getLayoutParams().height=0;\n  mHeaderViews.add(mHeaderView);\n  if (mAdapter != null) {\n    if (!(mAdapter instanceof XWrapAdapter)) {\n      mAdapter=new XWrapAdapter(mHeaderViews,mFootViews,mAdapter);\n    }\n  }\n}\n", "nl": "add header View with the head height and expandheight"}
{"code": "private boolean doesSVNDirectoryExist(){\n  boolean isSVNFolder=false;\n  try {\n    projectStatus=SVNWorkspaceRoot.peekResourceStatusFor(project);\n    ;\n    isSVNFolder=(projectStatus != null) && projectStatus.hasRemote();\n  }\n catch (  final SVNException e) {\n    Shell shell=null;\n    if (getContainer() != null) {\n      shell=getContainer().getShell();\n    }\n    SVNUIPlugin.openError(shell,null,null,e);\n  }\n  return isSVNFolder;\n}\n", "nl": "check if there is a valid svn directory"}
{"code": "private int measureLong(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=mViewPager.getAdapter().getCount();\n    result=(int)(getPaddingLeft() + getPaddingRight() + (count * 2 * mRadius)+ (count + 1) * mRadius + (count - 1) * mIndicatorBetween);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the width of this view"}
{"code": "public static AnalysisEngine defaultAnalysisEngine(){\n  try {\n    if (defaultAnalysisEngine == null)     defaultAnalysisEngine=AnalysisEngineFactory.createEngine(AnalysisEngineFactory.createEngineDescription(SentenceAnnotator.getDescription(),TokenizerAnnotator.getDescription()));\n    return defaultAnalysisEngine;\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Creates a tokenization,/stemming pipeline"}
{"code": "public void testCircularDependencies() throws IOException {\n  VirtualFile project1=createGradleProjectToImport(dir,module(1),module(3));\n  VirtualFile project2=createGradleProjectToImport(dir,module(2),module(1));\n  VirtualFile project3=createGradleProjectToImport(dir,module(3),module(2));\n  configureTopLevelProject(dir,Arrays.asList(module(1),module(2),module(3)),Collections.<String>emptySet());\n  Map<String,VirtualFile> projects=moduleListToMap(GradleModuleImporter.getRelatedProjects(project3,getProject()));\n  assertEquals(3,projects.size());\n  assertEquals(project1,projects.get(pathToGradleName(module(1))));\n  assertEquals(project2,projects.get(pathToGradleName(module(2))));\n  assertEquals(project3,projects.get(pathToGradleName(module(3))));\n}\n", "nl": "Make sure source dependencies are picked recursively"}
{"code": "public static int ping(String url) throws Exception {\n  URL u=new URL(url);\n  HttpURLConnection c=(HttpURLConnection)u.openConnection();\n  c.connect();\n  int code=c.getResponseCode();\n  log.debug(\"ping=\" + url + \", response.code=\"+ code);\n  c.disconnect();\n  return code;\n}\n", "nl": "ping the url, throw exception if occur error"}
{"code": "void handleFieldAnnotation(Host h,Field f){\n  Set<? extends Annotation> aSet=f.getAnnotations();\n  if (aSet != null && !aSet.isEmpty()) {\n    List<Tag> tags=handleAnnotation(aSet,null);\n    if (tags != null)     for (    Tag t : tags)     if (t != null) {\n      h.addTag(t);\n      Debug.printDbg(\"add field annotation: \",t);\n    }\n  }\n}\n", "nl": "Converts field annotations from Dexlib to Jimple"}
{"code": "private int calcSignum(boolean isPositive){\n  if ((years == null || years.signum() == 0) && (months == null || months.signum() == 0) && (days == null || days.signum() == 0)&& (hours == null || hours.signum() == 0)&& (minutes == null || minutes.signum() == 0)&& (seconds == null || seconds.signum() == 0)) {\n    return 0;\n  }\n  if (isPositive) {\n    return 1;\n  }\n else {\n    return -1;\n  }\n}\n", "nl": "TODO: Javadoc"}
{"code": "public void showBadgeAtIndex(int itemIndex,int badgeText,@ColorInt int badgeColor){\n  if (itemIndex < 0 || itemIndex > spaceItems.size()) {\n    throwArrayIndexOutOfBoundsException(itemIndex);\n  }\n else {\n    RelativeLayout badgeView=badgeList.get(itemIndex);\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n      badgeView.setBackground(BadgeHelper.makeShapeDrawable(badgeColor));\n    }\n else {\n      badgeView.setBackgroundDrawable(BadgeHelper.makeShapeDrawable(badgeColor));\n    }\n    BadgeItem badgeItem=new BadgeItem(itemIndex,badgeText,badgeColor);\n    BadgeHelper.showBadge(badgeView,badgeItem,shouldShowBadgeWithNinePlus);\n    badgeSaveInstanceHashMap.put(itemIndex,badgeItem);\n  }\n}\n", "nl": "Show badge at index"}
{"code": "public void addGlobalTypeDecl(XSTypeDefinition decl){\n  fGlobalTypeDecls.put(decl.getName(),decl);\n  if (decl instanceof XSComplexTypeDecl) {\n    ((XSComplexTypeDecl)decl).setNamespaceItem(this);\n  }\n else   if (decl instanceof XSSimpleTypeDecl) {\n    ((XSSimpleTypeDecl)decl).setNamespaceItem(this);\n  }\n}\n", "nl": "register one global type"}
{"code": "private void checkQuantileError(double[] data,double value,double quantile,double tolerance,double referenceValue){\n  final double n=(double)data.length;\n  int nLess=0;\n  for (  double val : data) {\n    if (val < value) {\n      nLess++;\n    }\n  }\n  if (Double.isNaN(referenceValue)) {\n    assertTrue(Double.isNaN(value));\n  }\n else   if (Double.isInfinite(value)) {\n    assertTrue(value == referenceValue);\n  }\n else {\n    assertTrue(\"Quantile error exceeded: value returned = \" + value + \" Reference value = \"+ referenceValue+ \" quantile = \"+ quantile+ \" n = \"+ n+ \" error = \"+ (quantile - (double)nLess / n),FastMath.abs(quantile - (double)nLess / n) < tolerance);\n  }\n}\n", "nl": "Checks to make sure that the actual quantile position (normalized rank) of value is within tolerance of quantile"}
{"code": "public void load(String joinFileName,InputStream joinPdfStream,InputStream joinTreeStream,String trickyPhonesFile) throws IOException, MaryConfigurationException {\n  jcf=new JoinCostFeatures(joinFileName);\n  assert featureDef != null : \"Expected to have a feature definition, but it is null!\";\n  HTSCARTReader htsReader=new HTSCARTReader();\n  int numStates=1;\n  PhoneTranslator phTranslator=new PhoneTranslator(new FileInputStream(trickyPhonesFile));\n  try {\n    joinTree=htsReader.load(numStates,joinTreeStream,joinPdfStream,PdfFileFormat.join,featureDef,phTranslator);\n  }\n catch (  Exception e) {\n    IOException ioe=new IOException(\"Cannot load join model trees\");\n    ioe.initCause(e);\n    throw ioe;\n  }\n}\n", "nl": "Load weights and values from the given file"}
{"code": "public void saveFingerprintAsFile(byte[] fingerprint,String filename){\n  FileOutputStream fileOutputStream;\n  try {\n    fileOutputStream=new FileOutputStream(filename);\n    fileOutputStream.write(fingerprint);\n    fileOutputStream.close();\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Save fingerprint to a file"}
{"code": "public Matrix plusEquals(Matrix B){\n  checkMatrixDimensions(B);\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      A[i][j]=A[i][j] + B.A[i][j];\n    }\n  }\n  return this;\n}\n", "nl": "A = A + B"}
{"code": "private static int skipAlias(String stmt,int offset){\n  offset=ParseUtil.move(stmt,offset,0);\n  if (offset >= stmt.length())   return offset;\nswitch (stmt.charAt(offset)) {\ncase '\\'':\n    return skipString(stmt,offset);\ncase '\"':\n  return skipString2(stmt,offset);\ncase '`':\nreturn skipIdentifierEscape(stmt,offset);\ndefault :\nif (CharTypes.isIdentifierChar(stmt.charAt(offset))) {\nfor (; offset < stmt.length() && CharTypes.isIdentifierChar(stmt.charAt(offset)); ++offset) ;\nreturn offset;\n}\n}\nreturn -1;\n}\n", "nl": "<code>SELECT LAST_INSERT_ID() AS id, </code>"}
{"code": "public void updateEnableState(){\n  if (SwingUtilities.isEventDispatchThread())   super.updateEnableState();\n  for (  MenuItem menuItem : menuItem2CommandFX.keySet()) {\n    ICommand command=menuItem2CommandFX.get(menuItem);\n    menuItem.setDisable(!command.isApplicable());\n    if (command instanceof ICheckBoxCommand) {\n      ((CheckMenuItem)menuItem).setSelected(((ICheckBoxCommand)command).isSelected());\n    }\n  }\n}\n", "nl": "update the enable state"}
{"code": "public void handleLegionRequest(int exOpcode,Player activePlayer,String text){\nswitch (exOpcode) {\ncase 0x09:\n    changeAnnouncement(activePlayer,text);\n  break;\ncase 0x0A:\nchangeSelfIntro(activePlayer,text);\nbreak;\n}\n}\n", "nl": "This method will handle announcement and self intro changement"}
{"code": "public void initializeCooldownGroups(){\n  cooldownGroups=new HashMap<Integer,ArrayList<Integer>>();\n  for (  SkillTemplate skillTemplate : skillTemplates) {\n    int cooldownId=skillTemplate.getCooldownId();\n    if (!cooldownGroups.containsKey(cooldownId)) {\n      cooldownGroups.put(cooldownId,new ArrayList<Integer>());\n    }\n    cooldownGroups.get(cooldownId).add(skillTemplate.getSkillId());\n  }\n}\n", "nl": "This method creates a HashMap with all skills assigned to their representative cooldownIds"}
{"code": "public static String collapseCharacter(String str,char c){\n  StringBuilder sb=new StringBuilder();\n  char last=str.charAt(0);\n  for (int i=0; i < str.length(); i++) {\n    char current=str.charAt(i);\n    if (i == 0 || current != c || last != c) {\n      sb.append(current);\n      last=current;\n    }\n  }\n  return sb.toString();\n}\n", "nl": "Remove/collapse multiple characters"}
{"code": "@Override public void onItemClicked(View view,Flavor item,int position){\n  Scoop.getInstance().choose(item);\n  mAdapter.setCurrentFlavor(item);\n  Intent restart=new Intent(this,ScoopSettingsActivity.class);\n  setResult(RESULT_OK);\n  finish();\n  startActivity(restart);\n  overridePendingTransition(0,0);\n}\n", "nl": "Listener Methods"}
{"code": "private Collection<ExtractedItemsCollection> filterItemsByLevel(Player player,List<ExtractedItemsCollection> itemsCollections){\n  int playerLevel=player.getLevel();\n  Collection<ExtractedItemsCollection> result=new ArrayList<ExtractedItemsCollection>();\n  for (  ExtractedItemsCollection collection : itemsCollections) {\n    if (collection.getMinLevel() > playerLevel) {\n      continue;\n    }\n    if (collection.getMaxLevel() > 0 && collection.getMaxLevel() < playerLevel) {\n      continue;\n    }\n    result.add(collection);\n  }\n  return result;\n}\n", "nl": "Add to result collection only items witch suits player's level"}
{"code": "private int measureShort(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(2 * mRadius + getPaddingTop() + getPaddingBottom() + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the height of this view"}
{"code": "public static String toHexStream(ByteBuffer data){\n  StringBuilder result=new StringBuilder();\n  int counter=0;\n  int b;\n  while (data.hasRemaining()) {\n    b=data.get() & 0xff;\n    result.append(String.format(\"%02X \",b));\n    counter++;\n    if (counter % 16 == 0) {\n      result.append(\"\\n\");\n    }\n  }\n  return result.toString();\n}\n", "nl": "Convert data from given ByteBuffer to hex"}
{"code": "public void write(IOutputWriter writer,Map<Integer,ListOfLongs> classId2locations) throws IOException {\n  writer.writeInt(map.size());\n  for (  Object key : map.keySet()) {\n    writer.writeInt((Integer)key);\n    final Integer sum=map.get(key);\n    writer.writeInt(sum);\n    if (classId2locations != null) {\n      final ListOfLongs list=classId2locations.get(key);\n      if (list.size() != sum)       throw new IOException(\"Wrong number of locations: \" + list.size() + \", should be: \"+ sum);\n      for (int i=0; i < list.size(); i++)       writer.writeLong(list.get(i));\n    }\n  }\n}\n", "nl": "write to file"}
{"code": "private void startFileBasedMerge() throws CarbonSortKeyAndGroupByException {\n  try {\n    dataSorterAndWriterExecutorService.shutdown();\n    dataSorterAndWriterExecutorService.awaitTermination(2,TimeUnit.DAYS);\n  }\n catch (  InterruptedException e) {\n    throw new CarbonSortKeyAndGroupByException(\"Problem while shutdown the server \",e);\n  }\n}\n", "nl": "Below method will be used to start file based merge"}
{"code": "public static void skipFastAText(FileIterator it,boolean isFastA){\n  if (isFastA) {\n    while (it.hasNext() && it.peekNextByte() != '>') {\n      it.next();\n    }\n  }\n else {\n    if (it.hasNext()) {\n      it.next();\n    }\n    if (it.hasNext()) {\n      it.next();\n    }\n    if (it.hasNext()) {\n      it.next();\n    }\n  }\n}\n", "nl": "assuming that the FileIterator has just returned the header line of a fastA or fastQ record, writes the full text of the match"}
{"code": "public static void assertEquals(FieldMatrix<? extends FieldElement<?>> expected,FieldMatrix<? extends FieldElement<?>> observed){\n  Assert.assertNotNull(\"Observed should not be null\",observed);\n  if (expected.getColumnDimension() != observed.getColumnDimension() || expected.getRowDimension() != observed.getRowDimension()) {\n    StringBuilder messageBuffer=new StringBuilder();\n    messageBuffer.append(\"Observed has incorrect dimensions.\");\n    messageBuffer.append(\"\\nobserved is \" + observed.getRowDimension() + \" x \"+ observed.getColumnDimension());\n    messageBuffer.append(\"\\nexpected \" + expected.getRowDimension() + \" x \"+ expected.getColumnDimension());\n    Assert.fail(messageBuffer.toString());\n  }\n  for (int i=0; i < expected.getRowDimension(); ++i) {\n    for (int j=0; j < expected.getColumnDimension(); ++j) {\n      FieldElement<?> eij=expected.getEntry(i,j);\n      FieldElement<?> oij=observed.getEntry(i,j);\n      Assert.assertEquals(eij,oij);\n    }\n  }\n}\n", "nl": "verifies that two matrices are equal"}
{"code": "public Song next(){\nswitch (playMode) {\ncase LOOP:\ncase LIST:\ncase SINGLE:\n    int newIndex=playingIndex + 1;\n  if (newIndex >= songs.size()) {\n    newIndex=0;\n  }\nplayingIndex=newIndex;\nbreak;\ncase SHUFFLE:\nplayingIndex=randomPlayIndex();\nbreak;\n}\nreturn songs.get(playingIndex);\n}\n", "nl": "Move the playingIndex forward depends on the play mode"}
{"code": "private static BitMatrix bitMatrixFrombitArray(byte[][] input,int margin){\n  BitMatrix output=new BitMatrix(input[0].length + 2 * margin,input.length + 2 * margin);\n  output.clear();\n  for (int y=0, yOutput=output.getHeight() - margin - 1; y < input.length; y++, yOutput--) {\n    for (int x=0; x < input[0].length; x++) {\n      if (input[y][x] == 1) {\n        output.set(x + margin,yOutput);\n      }\n    }\n  }\n  return output;\n}\n", "nl": "This takes an array holding the values of the PDF 417"}
{"code": "private static void createWriter(OutputStream outputStream){\n  try {\n    closeWriter();\n    Writer oWriter=new OutputStreamWriter(outputStream,\"UTF-8\");\n    writer=new BufferedWriter(oWriter);\n  }\n catch (  UnsupportedEncodingException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Create a buffered writer given an output stream"}
{"code": "public void testSetValue(){\n  VirtualFile file=myFixture.copyFileToProject(\"themeEditor/themeEditorStyle/styles_2.xml\",\"res/values/styles.xml\");\n  myFixture.copyFileToProject(\"themeEditor/themeEditorStyle/styles_2.xml\",\"res/values-v21/styles.xml\");\n  myFixture.copyFileToProject(\"themeEditor/themeEditorStyle/styles_2.xml\",\"res/values-night/styles.xml\");\n  myFixture.copyFileToProject(\"themeEditor/themeEditorStyle/styles_2.xml\",\"res/values-port/styles.xml\");\n  myFixture.copyFileToProject(\"themeEditor/themeEditorStyle/styles_2.xml\",\"res/values-port-v21/styles.xml\");\n  ItemResourceValue item=new ItemResourceValue(\"colorAccent\",false,\"#000000\",false,null);\n  checkSetValue(file,item,\"\",\"-v21\",\"-night\",\"-port\",\"-port-v21\");\n}\n", "nl": "Tests setValue method for following cases: values, values-v21, values-night, value-port, values-port-v21 setValue(\"colorAccent\", \"#000000\")"}
{"code": "public boolean replaceNaNByZero(){\n  boolean changed=false;\n  for (int i=0; i < matrix.length; i++) {\n    for (int j=0; j < matrix.length; j++) {\n      if (Double.isNaN(matrix[i][j])) {\n        matrix[i][j]=0;\n        changed=true;\n      }\n    }\n  }\n  return changed;\n}\n", "nl": "replace all NaN by zero"}
{"code": "private void drawTitle(Graphics2D gc){\n  if (chartTitle != null) {\n    Dimension labelSize=Basic.getStringSize(gc,chartTitle,gc.getFont()).getSize();\n    int x=(getWidth() - labelSize.width) / 2;\n    int y=labelSize.height + 5;\n    gc.setFont(getFont(ChartViewer.FontKeys.TitleFont.toString()));\n    gc.setColor(getFontColor(ChartViewer.FontKeys.TitleFont.toString(),Color.BLACK));\n    gc.drawString(chartTitle,x,y);\n  }\n}\n", "nl": "draw the title of the chart"}
{"code": "int positionOfItem(Item item){\n  int offset=0;\n  for (  List<?> section : mSections) {\n    int index=section.indexOf(item);\n    if (index != -1) {\n      return offset + index;\n    }\n    offset+=section.size();\n  }\n  return -1;\n}\n", "nl": "Get the position in the list of a given item"}
{"code": "private void mapConfigProperties(ContainerState containerState,Map<String,Object> config){\n  if (config == null) {\n    return;\n  }\n  @SuppressWarnings(\"unchecked\") Collection<String> commandList=(Collection<String>)config.get(DOCKER_CONTAINER_COMMAND_PROP_NAME);\n  if (commandList != null) {\n    containerState.command=commandList.toArray(new String[0]);\n  }\n  String image=(String)config.get(DOCKER_CONTAINER_IMAGE_PROP_NAME);\n  if (image != null) {\n    containerState.image=image;\n  }\n}\n", "nl": "Process properties in the Config object"}
{"code": "public Vector<OCFile> filterHiddenFiles(Vector<OCFile> files){\n  Vector<OCFile> ret=new Vector<>();\n  OCFile current;\n  for (int i=0; i < files.size(); i++) {\n    current=files.get(i);\n    if (!current.isHidden()) {\n      ret.add(current);\n    }\n  }\n  return ret;\n}\n", "nl": "Filter for hidden files"}
{"code": "public static final void banPlayer(Player bannedPlayer,Player banGiver){\n  Preconditions.checkNotNull(bannedPlayer,\"Banned player should not be null\");\n  Preconditions.checkNotNull(banGiver,\"Bangiver player should not be null\");\n  PlayerAlliance alliance=banGiver.getPlayerAlliance2();\n  if (alliance != null) {\n    if (alliance.getTeamType().isDefence()) {\n      VortexService.getInstance().removeDefenderPlayer(bannedPlayer);\n    }\n    PlayerAllianceMember bannedMember=alliance.getMember(bannedPlayer.getObjectId());\n    if (bannedMember != null) {\n      alliance.onEvent(new PlayerAllianceLeavedEvent(alliance,bannedMember.getObject(),LeaveReson.BAN,banGiver.getName()));\n    }\n else {\n      log.warn(\"TEAM2: banning player not in alliance {}\",alliance.onlineMembers());\n    }\n  }\n}\n", "nl": "Remove player from alliance (ban)"}
{"code": "private static void assertJsonArrayEquals(String expected,String actual){\n  ObjectMapper mapper=new ObjectMapper();\n  TypeReference<List<Object>> ref=new TypeReference<List<Object>>(){\n  }\n;\n  try {\n    List<Object> el=mapper.readValue(expected,ref);\n    List<Object> al=mapper.readValue(actual,ref);\n    assertEquals(el,al);\n  }\n catch (  IOException e) {\n    throw new IllegalStateException(e);\n  }\n}\n", "nl": "Assert that two JSON arrays are equal"}
{"code": "public Item add_CharacterTransfer(Item item){\n  if (item.getItemTemplate().isKinah()) {\n    this.kinahItem=item;\n  }\n else   if (!itemStorage.putItem(item)) {\n    return null;\n  }\n  item.setItemLocation(storageType.getId());\n  setPersistentState(PersistentState.UPDATE_REQUIRED);\n  return item;\n}\n", "nl": "used only for character transfers"}
{"code": "private String parseTimeFromPing(String ping){\n  String time=\"\";\n  if (ping.contains(TIME_PING)) {\n    int index=ping.indexOf(TIME_PING);\n    time=ping.substring(index + 5);\n    index=time.indexOf(\" \");\n    time=time.substring(0,index);\n  }\n  return time;\n}\n", "nl": "Gets the time from ping command (if there is)"}
{"code": "@deprecated protected void handleTransliterate(Replaceable text,Transliterator.Position index,boolean incremental){\nsynchronized (this.data) {\n    int loopCount=0;\n    int loopLimit=index.limit - index.start << 4;\n    if (loopLimit < 0) {\n      loopLimit=Integer.MAX_VALUE;\n    }\n    while ((index.start < index.limit) && (loopCount <= loopLimit) && (this.data.ruleSet.transliterate(text,index,incremental))) {\n      loopCount++;\n    }\n  }\n}\n", "nl": "/*    "}
{"code": "private byte[] read(FSDataInputStream channel,int size){\n  byte[] byteBffer=new byte[size];\n  try {\n    channel.readFully(byteBffer);\n  }\n catch (  Exception e) {\n    LOGGER.error(e,e.getMessage());\n  }\n  return byteBffer;\n}\n", "nl": "This method will be used to read from file based on number of bytes to be read and positon"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"compute diversityRatio kmer=\");\n  int kmer=np.getInt(1,Integer.MAX_VALUE);\n  np.matchIgnoreCase(\"step=\");\n  int step=np.getInt(1,Integer.MAX_VALUE);\n  np.matchIgnoreCase(\"mindepth=\");\n  int mindepth=np.getInt(1,Integer.MAX_VALUE);\n  np.matchIgnoreCase(\";\");\n  AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  Pair<Double,Double> kn=ComputeAlignmentProperties.computeSequenceDiversityRatio(viewer.getAlignment(),step,kmer,mindepth,((Director)getDir()).getDocument().getProgressListener());\n  ((Director)getDir()).getDocument().getProgressListener().close();\n  NotificationsInSwing.showInformation(viewer.getFrame(),\"Average diversity ratio:\\n\" + (float)(0 + kn.getFirst()) + \" / \"+ (float)(0 + kn.getSecond())+ \" = \"+ (float)(kn.getFirst() / kn.getSecond()));\n}\n", "nl": "parses the given command and executes it"}
{"code": "@Override protected void initViews(Bundle savedInstanceState){\n  getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n  Intent intent=getIntent();\n  path=intent.getStringExtra(\"path\");\n  tvFilePath=(TextView)findViewById(R.id.tvFilePath);\n  videoListView=(RecyclerView)findViewById(R.id.videoListView);\n  mAdapter=new VideoListAdapter();\n  mLayoutManager=new LinearLayoutManager(this);\n  mLayoutManager.setOrientation(OrientationHelper.VERTICAL);\n  videoListView.setLayoutManager(mLayoutManager);\n  videoListView.setAdapter(mAdapter);\n}\n", "nl": "Initialize the view in the layout"}
{"code": "private void _writeTimeStamp(byte[] buffer,int offset,long time){\n  long seconds=time / 1000L;\n  long milliseconds=time - seconds * 1000L;\n  seconds+=OFFSET_1900_TO_1970;\n  buffer[offset++]=(byte)(seconds >> 24);\n  buffer[offset++]=(byte)(seconds >> 16);\n  buffer[offset++]=(byte)(seconds >> 8);\n  buffer[offset++]=(byte)(seconds >> 0);\n  long fraction=milliseconds * 0x100000000L / 1000L;\n  buffer[offset++]=(byte)(fraction >> 24);\n  buffer[offset++]=(byte)(fraction >> 16);\n  buffer[offset++]=(byte)(fraction >> 8);\n  buffer[offset++]=(byte)(Math.random() * 255.0);\n}\n", "nl": "Writes system time (milliseconds since January 1, 1970) as an NTP time stamp as defined in RFC-1305 at the given offset in the buffer"}
{"code": "private static String findMatchInArray(String strToMatch,String[] matchInArray,String[] returnInArray){\n  for (int i=0; i < matchInArray.length; i++) {\n    if (strToMatch.equals(matchInArray[i])) {\n      if (i < returnInArray.length) {\n        return returnInArray[i];\n      }\n else {\n        return null;\n      }\n    }\n  }\n  return null;\n}\n", "nl": "Finds a match of the given string in the given array, and returns the element at the same index in the returnInArray"}
{"code": "public BlockletBTreeLeafNode(BTreeBuilderInfo builderInfos,int leafIndex,long nodeNumber){\n  BlockletMinMaxIndex minMaxIndex=builderInfos.getFooterList().get(0).getBlockletList().get(leafIndex).getBlockletIndex().getMinMaxIndex();\n  maxKeyOfColumns=minMaxIndex.getMaxValues();\n  minKeyOfColumns=minMaxIndex.getMinValues();\n  numberOfKeys=builderInfos.getFooterList().get(0).getBlockletList().get(leafIndex).getNumberOfRows();\n  dimensionChunksReader=new CompressedDimensionChunkFileBasedReader(builderInfos.getFooterList().get(0).getBlockletList().get(leafIndex).getDimensionColumnChunk(),builderInfos.getDimensionColumnValueSize(),builderInfos.getFooterList().get(0).getBlockInfo().getTableBlockInfo().getFilePath());\n  ValueCompressionModel valueCompressionModel=CarbonUtil.getValueCompressionModel(builderInfos.getFooterList().get(0).getBlockletList().get(leafIndex).getMeasureColumnChunk());\n  measureColumnChunkReader=new CompressedMeasureChunkFileBasedReader(builderInfos.getFooterList().get(0).getBlockletList().get(leafIndex).getMeasureColumnChunk(),valueCompressionModel,builderInfos.getFooterList().get(0).getBlockInfo().getTableBlockInfo().getFilePath());\n  this.nodeNumber=nodeNumber;\n}\n", "nl": "Create a leaf node"}
{"code": "public static Uri createImageUri(Context context){\n  if (\"Lenovo\".equals(Build.MODEL.split(\" \")[0])) {\n    Intent intent=new Intent();\n    intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);\n    String path=Environment.getExternalStorageDirectory() + \"/zjb/photoCache\" + System.currentTimeMillis()+ \".jpg\";\n    imgUri=Uri.parse(\"file:///\" + path);\n  }\n else {\n    String name=\"GetWorld\" + System.currentTimeMillis();\n    ContentValues values=new ContentValues();\n    values.put(MediaStore.Images.Media.TITLE,name);\n    values.put(MediaStore.Images.Media.DISPLAY_NAME,name + \".jpeg\");\n    values.put(MediaStore.Images.Media.MIME_TYPE,\"image/jpeg\");\n    imgUri=context.getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values);\n  }\n  return imgUri;\n}\n", "nl": "creat a uri for takePhoto <p> I don't know the name , what's the meaning of \"GetWorld\"?"}
{"code": "@Override public int hashCode(){\n  int result=31 + MathUtils.hash(getN());\n  result=result * 31 + MathUtils.hash(getGeometricMean());\n  result=result * 31 + MathUtils.hash(getMax());\n  result=result * 31 + MathUtils.hash(getMean());\n  result=result * 31 + MathUtils.hash(getMin());\n  result=result * 31 + MathUtils.hash(getSum());\n  result=result * 31 + MathUtils.hash(getSumSq());\n  result=result * 31 + MathUtils.hash(getSumLog());\n  result=result * 31 + getCovariance().hashCode();\n  return result;\n}\n", "nl": "Returns hash code based on values of statistics"}
{"code": "@RequestMapping(value=\"/rest/activiti/jobs/{jobId}\",method=RequestMethod.POST,produces=\"application/json\") @ResponseStatus(value=HttpStatus.OK) public void executeJob(@PathVariable String jobId) throws BadRequestException {\n  ServerConfig serverConfig=retrieveServerConfig();\n  try {\n    clientService.executeJob(serverConfig,jobId);\n  }\n catch (  ActivitiServiceException e) {\n    throw new BadRequestException(e.getMessage());\n  }\n}\n", "nl": "POST /rest/activiti/jobs/{jobId} -> execute job"}
{"code": "public MonsterHabitatCursor queryHabitatMonster(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=true;\n  qh.Table=S.TABLE_HABITAT;\n  qh.Columns=null;\n  qh.Selection=S.COLUMN_HABITAT_MONSTER_ID + \" = ?\";\n  qh.SelectionArgs=new String[]{String.valueOf(id)};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new MonsterHabitatCursor(wrapJoinHelper(builderHabitat(qh.Distinct),qh));\n}\n", "nl": "Get a cursor with a query to grab all habitats of a monster"}
{"code": "public void draw(Canvas c,Rect bounds){\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mPaint.setColor(mCurrentColor);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n  if (mAlpha < 255) {\n    mCirclePaint.setColor(mBackgroundColor);\n    mCirclePaint.setAlpha(255 - mAlpha);\n    c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  }\n}\n", "nl": "Draw the progress spinner"}
{"code": "public void onPatchServiceResult(boolean isUpgradePatch){\n  if (!isRetryEnable) {\n    TinkerLog.w(TAG,\"onPatchServiceResult retry disabled, just return\");\n    return;\n  }\n  if (!isUpgradePatch) {\n    TinkerLog.w(TAG,\"onPatchServiceResult is not upgrade patch, just return\");\n    return;\n  }\n  if (retryInfoFile.exists()) {\n    SharePatchFileUtil.safeDeleteFile(retryInfoFile);\n  }\n  if (tempPatchFile.exists()) {\n    SharePatchFileUtil.safeDeleteFile(tempPatchFile);\n  }\n}\n", "nl": "if we receive any result, we can delete the temp retry info file"}
{"code": "private void processColumnValuesForOneChunk(int chunkCountForSegment) throws IOException {\n  deleteStorePath();\n  CarbonDictionaryWriterImpl writer=prepareWriter();\n  writer.write(convertStringListToByteArray(dataSet1));\n  writer.close();\n  writer.commit();\n  long end_offset=CarbonUtil.getFileSize(this.dictionaryFilePath);\n  List<byte[]> dictionaryData=readDictionaryFile(0L,0L);\n  List<String> actual=convertByteArrayListToStringValueList(dictionaryData);\n  compareDictionaryData(actual,dataSet1);\n  List<CarbonDictionaryColumnMetaChunk> carbonDictionaryColumnMetaChunks=readDictionaryMetadataFile();\n  assertTrue(1 == carbonDictionaryColumnMetaChunks.size());\n  long start_offset=0L;\n  CarbonDictionaryColumnMetaChunk expected=new CarbonDictionaryColumnMetaChunk(1,2,start_offset,end_offset,1);\n  for (  CarbonDictionaryColumnMetaChunk chunk : carbonDictionaryColumnMetaChunks) {\n    validateDictionaryMetadata(chunk,expected);\n  }\n}\n", "nl": "this method will test the functionality of writing and reading one dictionary chunk"}
{"code": "public static String parse(CommandLineParser.Parameter[] params) throws IOException {\n  String name=null;\n  for (int i=0; i < params.length; i++) {\n    if (params[i].getName().equalsIgnoreCase(SPACE_NAME_PARAMETER)) {\n      for (int j=0; j < params[i].getArguments().length; j++) {\n        name=params[i].getArguments()[j];\n        break;\n      }\n    }\n  }\n  return name;\n}\n", "nl": "Parses space name -name parameter"}
{"code": "public static <T>List<T> toList(T obj1,T obj2,T obj3,T obj4,T obj5,T obj6){\n  List<T> list=new LinkedList<T>();\n  list.add(obj1);\n  list.add(obj2);\n  list.add(obj3);\n  list.add(obj4);\n  list.add(obj5);\n  list.add(obj6);\n  return list;\n}\n", "nl": "Create a list from passed objX parameters"}
{"code": "public static String wordBreak(Item item) throws ProcessException {\n  Item ww=item.getItemAs(Relation.PHRASE);\n  if (ww == null || ww.getNext() != null) {\n    return \"1\";\n  }\n else {\n    String pname=ww.getParent().toString();\n    if (pname.equals(\"BB\")) {\n      return \"4\";\n    }\n else     if (pname.equals(\"B\")) {\n      return \"3\";\n    }\n else {\n      return \"1\";\n    }\n  }\n}\n", "nl": "Classifies the type of word break"}
{"code": "public AudioInputStream synthesize(Voice voice,AudioFileFormat aft,Element domElement) throws Exception {\n  if (!voice.hasVocalizationSupport())   return null;\n  if (domElement.hasAttribute(\"variant\")) {\n    return synthesizeVariant(aft,domElement);\n  }\n  if (f0ContourImposeSupport) {\n    return synthesizeImposedIntonation(aft,domElement);\n  }\n  return synthesizeVocalization(aft,domElement);\n}\n", "nl": "Handle a request for synthesis of vocalization"}
{"code": "@Override public void startEffect(Effect effect){\n  if (change == null) {\n    return;\n  }\n  Creature effected=effect.getEffected();\n  CreatureGameStats<? extends Creature> cgs=effected.getGameStats();\n  List<IStatFunction> modifiers=getModifiers(effect);\n  if (modifiers.size() > 0) {\n    cgs.addEffect(effect,modifiers);\n  }\n  if (maxstat) {\n    effected.getLifeStats().increaseHp(TYPE.HP,effected.getGameStats().getMaxHp().getCurrent());\n    effected.getLifeStats().increaseMp(TYPE.HEAL_MP,effected.getGameStats().getMaxMp().getCurrent());\n  }\n}\n", "nl": "Will be called from effect controller when effect starts"}
{"code": "public SerialMessage removeAssociationMessage(int group,int node,int endpoint){\n  logger.debug(\"NODE {}: Creating new message for command MULTI_ASSOCIATIONCMD_REMOVE node {}, endpoint {}, group {}\",getNode().getNodeId(),node,endpoint,group);\n  SerialMessage result=new SerialMessage(getNode().getNodeId(),SerialMessageClass.SendData,SerialMessageType.Request,SerialMessageClass.SendData,SerialMessagePriority.Set);\n  ByteArrayOutputStream outputData=new ByteArrayOutputStream();\n  outputData.write(this.getNode().getNodeId());\n  outputData.write(6);\n  outputData.write(getCommandClass().getKey());\n  outputData.write(MULTI_ASSOCIATIONCMD_REMOVE);\n  outputData.write(group);\n  outputData.write(0);\n  outputData.write(node);\n  outputData.write(endpoint);\n  result.setMessagePayload(outputData.toByteArray());\n  return result;\n}\n", "nl": "Gets a SerialMessage with the MULTI_ASSOCIATIONCMD_REMOVE command"}
{"code": "public static Connection enlistConnection(XAConnection xacon) throws GenericTransactionException {\n  if (xacon == null) {\n    return null;\n  }\n  try {\n    XAResource resource=xacon.getXAResource();\n    TransactionUtil.enlistResource(resource);\n    return xacon.getConnection();\n  }\n catch (  SQLException e) {\n    throw new GenericTransactionException(\"SQL error, could not enlist connection in transaction even though transactions are available\",e);\n  }\n}\n", "nl": "Enlists the given XAConnection and if a transaction is active in the current thread, returns a plain JDBC Connection"}
{"code": "private void handleDefaultTopBar(){\n  ViewGroup.LayoutParams params=new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);\n  setLayoutParams(params);\n  topBarView=iTopBarInterface.getDefaultTopBarView();\n  topBarView.setBackgroundColor(getColor(XUIConfig.getTopBarBgColor()));\n  topBarView.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,(int)getDefaultTopBarHeight()));\n  addView(topBarView);\n  FrameLayout.LayoutParams userViewParams=new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);\n  userViewParams.topMargin=(int)getContentTopMargin();\n  addView(mContentView,userViewParams);\n  initLoadContainer((int)getContentTopMargin());\n  addView(loadContainer);\n  handleTopBarShadow();\n}\n", "nl": "package content layout"}
{"code": "public Boolean deleteSupplier(EntityManager em,String id){\n  Boolean status=true;\n  Supplier supplier=null;\n  try {\n    if (!em.getTransaction().isActive()) {\n      em.getTransaction().begin();\n    }\n    supplier=em.find(Supplier.class,id);\n    em.remove(supplier);\n    em.getTransaction().commit();\n  }\n catch (  Exception e) {\n    status=false;\n    logger.error(\"Error occured during delete of Supplier. Detailed info: \" + e);\n  }\n  return status;\n}\n", "nl": "Helper method to delete Supplier"}
{"code": "@Override public long limit(){\n  try {\n    return length() >>> 2;\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n    return 0;\n  }\n}\n", "nl": "length of array"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set fillColor=\");\n  Color color=null;\n  if (np.peekMatchIgnoreCase(\"null\"))   np.matchIgnoreCase(\"null\");\n else   color=np.getColor();\n  np.matchIgnoreCase(\";\");\n  if (getViewer() instanceof GraphView) {\n    boolean changed=false;\n    GraphView viewer=(GraphView)getViewer();\n    for (    Node v : viewer.getSelectedNodes()) {\n      viewer.setBackgroundColor(v,color);\n      changed=true;\n    }\n    if (changed) {\n      viewer.repaint();\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private void drawScale(Graphics2D gc,double drawWidth,int boxValue){\n  int x=20;\n  int y=topMargin - 30;\n  Rectangle rect=new Rectangle(x,y,(int)drawWidth,(int)drawWidth);\n  gc.setColor(Color.LIGHT_GRAY);\n  gc.fill(rect);\n  gc.setColor(Color.DARK_GRAY);\n  gc.draw(rect);\n  gc.setFont(getFont(ChartViewer.FontKeys.LegendFont.toString()));\n  gc.drawString(String.format(\" = %,d\",boxValue),(int)(x + rect.getWidth()),(int)(y + rect.getHeight()));\n}\n", "nl": "draw scale"}
{"code": "public void sendResumeEvent(PluginResult resumeEvent){\nsynchronized (messageChannelLock) {\n    if (messageChannel != null) {\n      sendEventMessage(resumeEvent);\n    }\n else {\n      this.pendingResume=resumeEvent;\n    }\n  }\n}\n", "nl": "Used to send the resume event in the case that the Activity is destroyed by the OS"}
{"code": "public Matrix minus(Matrix B){\n  checkMatrixDimensions(B);\n  Matrix X=new Matrix(m,n);\n  double[][] C=X.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      C[i][j]=A[i][j] - B.A[i][j];\n    }\n  }\n  return X;\n}\n", "nl": "C = A - B"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"show taxon=\");\n  String name=np.getWordRespectCase();\n  np.matchIgnoreCase(\";\");\n  if (getViewer() instanceof InspectorWindow) {\n    InspectorWindow inspectorWindow=(InspectorWindow)getViewer();\n    int taxId;\n    if (Basic.isInteger(name))     taxId=Integer.parseInt(name);\n else     taxId=TaxonomyData.getName2IdMap().get(name);\n    if (taxId == 0) {\n      NotificationsInSwing.showWarning(inspectorWindow.getFrame(),\"Unknown taxon: \" + name);\n    }\n else     inspectorWindow.addTopLevelNode(name,taxId,Classification.Taxonomy);\n  }\n else   NotificationsInSwing.showError(getViewer().getFrame(),\"Command in invalid context\");\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static DataFrame normalize(DataFrame dataFrame,double min,double max,List<String> skipColumns){\n  String[] columnNames=dataFrame.columns();\n  for (  String columnName : columnNames) {\n    if (skipColumns.contains(columnName))     continue;\n    DataFrame minMax=dataFrame.select(columnName).agg(min(columnName),max(columnName));\n    Row r=minMax.collect()[0];\n    double dMin=((Number)r.get(0)).doubleValue();\n    double dMax=((Number)r.get(1)).doubleValue();\n    double maxSubMin=dMax - dMin;\n    if (maxSubMin == 0)     maxSubMin=1;\n    Column newCol=dataFrame.col(columnName).minus(dMin).divide(maxSubMin).multiply(max - min).plus(min);\n    dataFrame=dataFrame.withColumn(columnName,newCol);\n  }\n  return dataFrame;\n}\n", "nl": "Scale based on min,max"}
{"code": "private void closeWriterExecutionService(ExecutorService service) throws CarbonDataWriterException {\n  try {\n    service.shutdown();\n    service.awaitTermination(1,TimeUnit.DAYS);\n  }\n catch (  InterruptedException e) {\n    LOGGER.error(e,e.getMessage());\n    throw new CarbonDataWriterException(e.getMessage());\n  }\n}\n", "nl": "This method will close writer execution service and get the node holders and add them to node holder list"}
{"code": "private void embedGraph(){\n  FruchtermanReingoldLayout fruchtermanReingoldLayout=new FruchtermanReingoldLayout(graph,null);\n  NodeArray<Point2D> coordinates=new NodeArray<>(graph);\n  fruchtermanReingoldLayout.apply(1000,coordinates);\n  boolean first=true;\n  for (Node v=graph.getFirstNode(); v != null; v=v.getNext()) {\n    NodeData nodeData=(NodeData)v.getData();\n    nodeData.setLocation(coordinates.get(v));\n    if (first) {\n      boundingBox.setRect(coordinates.get(v).getX(),coordinates.get(v).getY(),1,1);\n      first=false;\n    }\n else     boundingBox.add(coordinates.get(v));\n  }\n  boundingBox.setRect(boundingBox.getX() - maxRadius,boundingBox.getY() - maxRadius,boundingBox.getWidth() + 2 * maxRadius,boundingBox.getHeight() + 2 * maxRadius);\n}\n", "nl": "do embedding of graph"}
{"code": "public void registerEvent(Class<? extends Event> event,Listener listener,EventPriority priority,EventExecutor executor,Plugin plugin,boolean ignoreCancelled){\n  Validate.notNull(listener,\"Listener cannot be null\");\n  Validate.notNull(priority,\"Priority cannot be null\");\n  Validate.notNull(executor,\"Executor cannot be null\");\n  Validate.notNull(plugin,\"Plugin cannot be null\");\n  if (!plugin.isEnabled()) {\n    throw new IllegalPluginAccessException(\"Plugin attempted to register \" + event + \" while not enabled\");\n  }\n  getEventListeners(event).register(new RegisteredListener(listener,executor,priority,plugin,ignoreCancelled));\n}\n", "nl": "Registers the given event to the specified listener using a directly passed EventExecutor"}
{"code": "public static java.sql.Timestamp toTimestamp(String date,String time){\n  java.util.Date newDate=toDate(date,time);\n  if (newDate != null) {\n    return new java.sql.Timestamp(newDate.getTime());\n  }\n else {\n    return null;\n  }\n}\n", "nl": "Converts a date String and a time String into a Timestamp"}
{"code": "public void execute(){\n  InputDataItem first=(InputDataItem)dataCBox1.getSelectedItem();\n  InputDataItem second=(InputDataItem)dataCBox2.getSelectedItem();\n  IMethodItem item=(IMethodItem)methodCBox.getSelectedItem();\n  if (item != null && !item.isApplicable()) {\n    NotificationsInSwing.showError(this,\"Statistical method '\" + item.getName() + \"' is not correctly configured\");\n    return;\n  }\n  if (first != null && second != null && item != null) {\n    dir.execute(\"compare\" + \" stats=\" + item.getName() + \" pid1=\"+ first.getPID()+ \" pid2=\"+ second.getPID()+ \" \"+ item.getOptionsString()+ \";\",dir.getMainViewer().getCommandManager());\n  }\n}\n", "nl": "execute the comparison"}
{"code": "public static int[] shuffle(int[] intArray,int shuffleCount){\n  int length;\n  if (intArray == null || shuffleCount < 0 || (length=intArray.length) < shuffleCount) {\n    return null;\n  }\n  int[] out=new int[shuffleCount];\n  for (int i=1; i <= shuffleCount; i++) {\n    int random=getRandom(length - i);\n    out[i - 1]=intArray[random];\n    int temp=intArray[length - i];\n    intArray[length - i]=intArray[random];\n    intArray[random]=temp;\n  }\n  return out;\n}\n", "nl": "Shuffling algorithm, Randomly permutes the specified int array"}
{"code": "public void enableSamples(Collection<String> sampleNames){\n  int size=disabledSamples.size();\n  disabledSamples.removeAll(sampleNames);\n  if (size != disabledSamples.size()) {\n    if (originalData == null) {\n      originalData=new DataTable();\n      originalData.copy(this);\n    }\n    Set<String> newDisabled=new HashSet<>();\n    newDisabled.addAll(disabledSamples);\n    copyEnabled(newDisabled,originalData);\n  }\n}\n", "nl": "enable a set of samples"}
{"code": "public static Transform valueOf(String string){\n  Transform result=new Transform();\n  String[] tokens=StringUtil.split(string,\",\");\n  double x=Double.valueOf(tokens[0]);\n  double y=Double.valueOf(tokens[1]);\n  double angle=Double.valueOf(tokens[2]);\n  result.setTranslation(x,y);\n  result.setRotation(Math.toRadians(angle));\n  return result;\n}\n", "nl": "[x, y, angle]"}
{"code": "private void compareParserResults(String xmlFile,String oldXmlFile) throws IOException {\n  XMLSourceSinkParser newParser=XMLSourceSinkParser.fromFile(xmlFile);\n  PermissionMethodParser oldParser=PermissionMethodParser.fromFile(oldXmlFile);\n  if (newParser != null && oldParser != null) {\n    Assert.assertEquals(oldParser.getSources(),newParser.getSources());\n    Assert.assertEquals(oldParser.getSinks(),newParser.getSinks());\n  }\n else   Assert.fail();\n}\n", "nl": "Compares the new and the old Parser for different xml files"}
{"code": "public static <V>int addDistinctList(List<V> sourceList,List<V> entryList){\n  if (sourceList == null || isEmpty(entryList)) {\n    return 0;\n  }\n  int sourceCount=sourceList.size();\n  for (  V entry : entryList) {\n    if (!sourceList.contains(entry)) {\n      sourceList.add(entry);\n    }\n  }\n  return sourceList.size() - sourceCount;\n}\n", "nl": "add all distinct entry to list1 from list2"}
{"code": "public void resetZoom(){\n  Iterator<FileFragment> entries=mCachedFragments.values().iterator();\n  while (entries.hasNext()) {\n    FileFragment fileFragment=(FileFragment)entries.next();\n    if (fileFragment instanceof PreviewImageFragment) {\n      ((PreviewImageFragment)fileFragment).getImageView().resetZoom();\n    }\n  }\n}\n", "nl": "Reset the image zoom to default value for each CachedFragments"}
{"code": "public void toBufferedImageRGB(INDArray arr,BufferedImage image){\n  if (arr.rank() < 3)   throw new IllegalArgumentException(\"Arr must be 3d\");\n  image=scalingIfNeed(image,arr.size(-2),arr.size(-1),true);\n  for (int i=0; i < image.getWidth(); i++) {\n    for (int j=0; j < image.getHeight(); j++) {\n      int r=arr.slice(0).getInt(i,j);\n      int g=arr.slice(1).getInt(i,j);\n      int b=arr.slice(2).getInt(i,j);\n      int a=1;\n      int col=(a << 24) | (r << 16) | (g << 8)| b;\n      image.setRGB(i,j,col);\n    }\n  }\n}\n", "nl": "Convert the given image to an rgb image"}
{"code": "public ResourcesPoet addAttr(Attr attr){\n  Element element=document.createElement(\"attr\");\n  element.setAttribute(\"name\",attr.name);\n  if (attr.formats != null && !attr.formats.isEmpty()) {\n    String formatString=\"\";\n    for (    Attr.Format format : attr.formats) {\n      formatString=formatString + format.toString() + \"|\";\n    }\n    formatString=formatString.substring(0,formatString.length() - 1);\n    element.setAttribute(\"format\",formatString);\n  }\n  resourceElement.appendChild(element);\n  return this;\n}\n", "nl": "Add an attr to the config"}
{"code": "private void addToken(int token){\n  try {\n    fTokens[fTokenCount]=token;\n  }\n catch (  ArrayIndexOutOfBoundsException ex) {\n    int[] oldList=fTokens;\n    fTokens=new int[fTokenCount << 1];\n    System.arraycopy(oldList,0,fTokens,0,fTokenCount);\n    fTokens[fTokenCount]=token;\n  }\n  fTokenCount++;\n}\n", "nl": "Add the specified int token"}
{"code": "protected void writeImageDesc() throws IOException {\n  out.write(0x2c);\n  writeShort(x);\n  writeShort(y);\n  writeShort(width);\n  writeShort(height);\n  if (firstFrame) {\n    out.write(0);\n  }\n else {\n    out.write(0x80 | 0 | 0| 0| palSize);\n  }\n}\n", "nl": "Writes Image Descriptor"}
{"code": "public void check(){\n  Response<Set<String>> serversResp=clusterService.listOnlineServers();\n  if (!serversResp.isSuccess()) {\n    Logs.error(\"failed to get all online servers, cause: {}\",serversResp.getErr());\n    return;\n  }\n  try {\n    Set<String> allServers=serversResp.getData();\n    final Set<String> failedServers=Sets.newHashSet();\n    doCheck(allServers,failedServers);\n    removeFailedServers(failedServers);\n  }\n catch (  InterruptedException e) {\n    Logs.error(\"failed to check online servers: {}\",Throwables.getStackTraceAsString(e));\n  }\n}\n", "nl": "Check all online servers are health & remove dead online servers"}
{"code": "private void layoutAppearingViews(RecyclerView.Recycler recycler,View referenceView,int referencePosition,int extraCount,int offset){\n  if (extraCount < 1)   return;\n  for (int extra=1; extra <= extraCount; extra++) {\n    final int extraPosition=referencePosition + extra;\n    if (extraPosition < 0 || extraPosition >= getItemCount()) {\n      continue;\n    }\n    View appearing=recycler.getViewForPosition(extraPosition);\n    addView(appearing);\n    final int newRow=getGlobalRowOfPosition(extraPosition + offset);\n    final int rowDelta=newRow - getGlobalRowOfPosition(referencePosition + offset);\n    final int newCol=getGlobalColumnOfPosition(extraPosition + offset);\n    final int colDelta=newCol - getGlobalColumnOfPosition(referencePosition + offset);\n    layoutTempChildView(appearing,rowDelta,colDelta,referenceView);\n  }\n}\n", "nl": "Animation Layout Helpers"}
{"code": "public void testWriteReadEmpty() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(empty);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  NIOConfiguration copy=(NIOConfiguration)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(empty,copy));\n}\n", "nl": "Test read and write empty ClusterPolicy object"}
{"code": "public void changeCenterButtonIcon(int icon){\n  if (fab == null) {\n    Log.e(TAG,\"You should call setCentreButtonIcon() instead, \" + \"changeCenterButtonIcon works if space navigation already set up\");\n  }\n else {\n    fab.setImageResource(icon);\n    centreButtonIcon=icon;\n  }\n}\n", "nl": "Change centre button icon if space navigation already set up"}
{"code": "public static Predictor createPredictor(DataElement writes,String uniqueCharacter,Expression expr,Expression skipTest,PeriodType periodType,OrganisationUnitLevel organisationUnitLevel,int sequentialSampleCount,int sequentialSkipCount,int annualSampleCount){\n  Predictor predictor=new Predictor();\n  Set<OrganisationUnitLevel> orglevels=Sets.newHashSet(organisationUnitLevel);\n  predictor.setAutoFields();\n  predictor.setOutput(writes);\n  predictor.setName(\"Predictor\" + uniqueCharacter);\n  predictor.setDescription(\"Description\" + uniqueCharacter);\n  predictor.setGenerator(expr);\n  predictor.setSampleSkipTest(skipTest);\n  predictor.setPeriodType(periodType);\n  predictor.setOrganisationUnitLevels(orglevels);\n  predictor.setSequentialSampleCount(sequentialSampleCount);\n  predictor.setAnnualSampleCount(annualSampleCount);\n  predictor.setSequentialSkipCount(sequentialSkipCount);\n  return predictor;\n}\n", "nl": "Creates a Predictor"}
{"code": "private void fillLoadedBlocks(AbstractIndex[] loadedBlockArray,List<Future<AbstractIndex>> blocksList) throws IndexBuilderException {\n  int blockCounter=0;\n  for (int i=0; i < loadedBlockArray.length; i++) {\n    if (null == loadedBlockArray[i]) {\n      try {\n        loadedBlockArray[i]=blocksList.get(blockCounter++).get();\n      }\n catch (      InterruptedException|ExecutionException e) {\n        throw new IndexBuilderException(e);\n      }\n    }\n  }\n}\n", "nl": "Below method will be used to fill the loaded blocks to the array which will be used for query execution"}
{"code": "private int measureLong(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=mViewPager.getAdapter().getCount();\n    result=(int)(getPaddingLeft() + getPaddingRight() + (count * 2 * mRadius)+ (count - 1) * mRadius + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the width of this view"}
{"code": "public static void writeAnalysisHTMLToFile(String outputPath,DataAnalysis dataAnalysis,JavaSparkContext sc){\n  try {\n    String analysisAsHtml=HtmlAnalysis.createHtmlAnalysisString(dataAnalysis);\n    writeStringToFile(outputPath,analysisAsHtml,sc);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(\"Error generating or writing HTML analysis file (normalized data)\",e);\n  }\n}\n", "nl": "Write a DataAnalysis to HDFS (or locally) as a HTML file"}
{"code": "public AccessPath mayAlias(AccessPath ap,Value val){\n  if (!AccessPath.canContainValue(val))   return null;\n  if (val instanceof Constant)   return null;\n  if (val instanceof Local)   if (ap.getPlainValue() != val)   return null;\n  if (val instanceof ArrayRef)   if (ap.getPlainValue() != ((ArrayRef)val).getBase())   return null;\n  if (val instanceof InstanceFieldRef) {\n    if (!ap.isLocal() && !ap.isInstanceFieldRef())     return null;\n    if (((InstanceFieldRef)val).getBase() != ap.getPlainValue())     return null;\n  }\n  if (val instanceof StaticFieldRef)   if (!ap.isStaticFieldRef())   return null;\n  SootField[] fields=val instanceof FieldRef ? new SootField[]{((FieldRef)val).getField()} : new SootField[0];\n  return getReferencedAPBase(ap,fields);\n}\n", "nl": "Gets whether a value and an access path may potentially point to the same runtime object"}
{"code": "public static String convertAsciiInputStreamToString(InputStream inputStream,int inputStreamLength) throws IOException {\n  InputStreamReader in=new InputStreamReader(inputStream);\n  StringWriter writer=new StringWriter();\n  int blockSize=DEFAULT_BUFFER_SIZE;\n  char[] buffer=new char[blockSize];\n  int left=inputStreamLength;\n  while (left > 0) {\n    int read=in.read(buffer,0,left > blockSize ? blockSize : left);\n    if (read == -1)     break;\n    writer.write(buffer,0,read);\n    left-=read;\n  }\n  writer.close();\n  return writer.toString();\n}\n", "nl": "Converts an ascii input stream to a string"}
{"code": "protected int addContentSpecNode(short nodeType,int leftNodeIndex,int rightNodeIndex){\n  int contentSpecIndex=createContentSpec();\n  int[] leftIntArray=new int[1];\n  int[] rightIntArray=new int[1];\n  leftIntArray[0]=leftNodeIndex;\n  rightIntArray[0]=rightNodeIndex;\n  fContentSpec.setValues(nodeType,leftIntArray,rightIntArray);\n  setContentSpec(contentSpecIndex,fContentSpec);\n  return contentSpecIndex;\n}\n", "nl": "Create an XMLContentSpec for a two child leaf"}
{"code": "public Matrix copy(){\n  Matrix X=new Matrix(m,n);\n  double[][] C=X.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      C[i][j]=A[i][j];\n    }\n  }\n  return X;\n}\n", "nl": "Make a deep copy of a matrix"}
{"code": "protected boolean newReadableStorageConnection(String group_name,String remote_filename) throws IOException, MyException {\n  if (this.storageServer != null) {\n    return false;\n  }\n else {\n    TrackerClient tracker=new TrackerClient();\n    this.storageServer=tracker.getFetchStorage(this.trackerServer,group_name,remote_filename);\n    if (this.storageServer == null) {\n      throw new MyException(\"getStoreStorage fail, errno code: \" + tracker.getErrorCode());\n    }\n    return true;\n  }\n}\n", "nl": "check storage socket, if null create a new connection"}
{"code": "public FloatArrayList bottom(int n){\n  FloatArrayList bottom=new FloatArrayList();\n  float[] values=data.toFloatArray();\n  FloatArrays.parallelQuickSort(values);\n  for (int i=0; i < n && i < values.length; i++) {\n    bottom.add(values[i]);\n  }\n  return bottom;\n}\n", "nl": "Returns the smallest (\"bottom\") n values in the column"}
{"code": "public static String methodNameToFieldName(String methodPrefix,String methodName,boolean ignoreFirstLetterCase){\n  String fieldName=null;\n  if (methodName != null && methodName.length() > methodPrefix.length()) {\n    int front=methodPrefix.length();\n    if (ignoreFirstLetterCase) {\n      fieldName=methodName.substring(front,front + 1) + methodName.substring(front + 1);\n    }\n else {\n      fieldName=methodName.substring(front,front + 1).toLowerCase() + methodName.substring(front + 1);\n    }\n  }\n  return fieldName;\n}\n", "nl": "method name to field name"}
{"code": "private void createLogDir(){\n  File file;\n  boolean mkOk;\n  if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n    file=new File(LOG_PATH_SDCARD_DIR);\n    if (!file.isDirectory()) {\n      mkOk=file.mkdirs();\n      if (!mkOk) {\n        return;\n      }\n    }\n  }\n}\n", "nl": "make the dir"}
{"code": "public static double max(final double a,final double b){\n  if (a > b) {\n    return a;\n  }\n  if (a < b) {\n    return b;\n  }\n  if (a != b) {\n    return Double.NaN;\n  }\n  long bits=Double.doubleToRawLongBits(a);\n  if (bits == 0x8000000000000000L) {\n    return b;\n  }\n  return a;\n}\n", "nl": "Compute the maximum of two values"}
{"code": "public boolean shippingApplies(){\n  boolean shippingApplies=false;\n  for (  ShoppingCartItem item : this) {\n    if (item.shippingApplies()) {\n      shippingApplies=true;\n      break;\n    }\n  }\n  return shippingApplies;\n}\n", "nl": "Returns true when there are shippable items in the cart"}
{"code": "DavaBody(SootMethod m){\n  super(m);\n  pMap=new HashMap<Integer,Value>();\n  consumedConditions=new HashSet<Object>();\n  thisLocals=new HashSet<Object>();\n  synchronizedBlockFacts=new IterableSet<ExceptionNode>();\n  exceptionFacts=new IterableSet<ExceptionNode>();\n  monitorFacts=new IterableSet<AugmentedStmt>();\n  importList=new IterableSet<String>();\n  caughtrefs=new LinkedList<CaughtExceptionRef>();\n  controlLocal=null;\n  constructorExpr=null;\n}\n", "nl": "Construct an empty DavaBody"}
{"code": "public Matrix(double vals[],int m){\n  this.m=m;\n  n=(m != 0 ? vals.length / m : 0);\n  if (m * n != vals.length) {\n    throw new IllegalArgumentException(\"Array length must be a multiple of m.\");\n  }\n  A=new double[m][n];\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      A[i][j]=vals[i + j * m];\n    }\n  }\n}\n", "nl": "Construct a matrix from a one-dimensional packed array"}
{"code": "public boolean snap(Activity activity){\n  boolean hasPermission=(ContextCompat.checkSelfPermission(activity,Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED);\n  if (!hasPermission) {\n    ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_WRITE_STORAGE);\n    return false;\n  }\n else {\n    return takeScreenShot(activity);\n  }\n}\n", "nl": "Check for permissions and create a snapshot"}
{"code": "public void buildIndex(List<DataFileFooter> footerList){\n  segmentProperties=new SegmentProperties(footerList.get(0).getColumnInTable(),footerList.get(0).getSegmentInfo().getColumnCardinality());\n  BTreeBuilderInfo btreeBuilderInfo=new BTreeBuilderInfo(footerList,null);\n  BtreeBuilder blocksBuilder=new BlockBTreeBuilder();\n  blocksBuilder.build(btreeBuilderInfo);\n  dataRefNode=blocksBuilder.get();\n  for (  DataFileFooter footer : footerList) {\n    totalNumberOfRows+=footer.getNumberOfRows();\n  }\n}\n", "nl": "Below method is store the blocks in some data structure"}
{"code": "void openURI(final String uri){\n  try {\n    java.awt.Desktop.getDesktop().browse(new URI(uri));\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  URISyntaxException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Open webpage in default web browser"}
{"code": "CanonicalCookie(String url,String name,String value,String domain,String path,long creation,long expiration,long lastAccess,boolean secure,boolean httpOnly,boolean firstPartyOnly,int priority){\n  mUrl=url;\n  mName=name;\n  mValue=value;\n  mDomain=domain;\n  mPath=path;\n  mCreation=creation;\n  mExpiration=expiration;\n  mLastAccess=lastAccess;\n  mSecure=secure;\n  mHttpOnly=httpOnly;\n  mFirstPartyOnly=firstPartyOnly;\n  mPriority=priority;\n}\n", "nl": "Constructs a CanonicalCookie"}
{"code": "protected Map<String,Object> filterItemValue(String entityName,Map<String,Object> itemValues){\n  ClassMetadata classMetadata=getSessionFactory().getClassMetadata(entityName);\n  String[] propertyNames=classMetadata.getPropertyNames();\n  List<String> names=Arrays.asList(propertyNames);\n  HashMap<String,Object> filteredItems=new HashMap<String,Object>();\n  Iterator<Entry<String,Object>> iterator=itemValues.entrySet().iterator();\n  while (iterator.hasNext()) {\n    Entry<String,Object> next=iterator.next();\n    if (names.contains(next.getKey())) {\n      filteredItems.put(next.getKey(),next.getValue());\n    }\n  }\n  return filteredItems;\n}\n", "nl": "Filter from the input map the unmapped field of this entity"}
{"code": "public static String parse(String s,Map<String,Object> m) throws Exception {\n  log.debug(\"vengine.parse ...\");\n  if (X.isEmpty(s)) {\n    return s;\n  }\n  try {\n    VelocityContext context=new VelocityContext(m);\n    StringWriter out=new StringWriter();\n    Velocity.evaluate(context,out,\"ve\",s);\n    log.debug(\"s=\" + s + \", out=\"+ out);\n    return out.toString();\n  }\n catch (  Exception e) {\n    log.error(s,e);\n    throw e;\n  }\n}\n", "nl": "Parses the string with the model"}
{"code": "private List<DavaFlowSet<T>> addIfNotDuplicate(List<DavaFlowSet<T>> into,DavaFlowSet<T> addThis){\n  Iterator<DavaFlowSet<T>> it=into.iterator();\n  boolean found=false;\n  while (it.hasNext()) {\n    DavaFlowSet<T> temp=it.next();\n    if (temp.equals(addThis) && temp.internalDataMatchesTo(addThis)) {\n      found=true;\n      break;\n    }\n  }\n  if (!found)   into.add(addThis);\n  return into;\n}\n", "nl": "A private method used to add an element into a List if it is NOT a duplicate"}
{"code": "public ArenaRewardCursor queryArenaRewardItem(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Columns=null;\n  qh.Table=S.TABLE_ARENA_REWARDS;\n  qh.Selection=\"ar.\" + S.COLUMN_ARENA_REWARDS_ITEM_ID + \" = ? \";\n  qh.SelectionArgs=new String[]{\"\" + id};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=\"ar.\" + S.COLUMN_ARENA_REWARDS_PERCENTAGE + \" DESC\";\n  qh.Limit=null;\n  return new ArenaRewardCursor(wrapJoinHelper(builderArenaReward(),qh));\n}\n", "nl": "****************************** ARENA REWARD QUERIES"}
{"code": "public IntArrayList bottom(int n){\n  IntArrayList bottom=new IntArrayList();\n  int[] values=data.toIntArray();\n  IntArrays.parallelQuickSort(values);\n  for (int i=0; i < n && i < values.length; i++) {\n    bottom.add(values[i]);\n  }\n  return bottom;\n}\n", "nl": "Returns the smallest (\"bottom\") n values in the column"}
{"code": "public XSNamedMapImpl(XSObject[] array,int length){\n  if (length == 0) {\n    fNamespaces=null;\n    fMaps=null;\n    fNSNum=0;\n    fArray=array;\n    fLength=0;\n    return;\n  }\n  fNamespaces=new String[]{array[0].getNamespace()};\n  fMaps=null;\n  fNSNum=1;\n  fArray=array;\n  fLength=length;\n}\n", "nl": "Construct an XSNamedMap implementation one namespace from an array"}
{"code": "private static void popTransactionStartStamp(){\n  ListOrderedMap map=(ListOrderedMap)suspendedTxStartStamps.get();\n  if (map.size() > 0) {\n    transactionStartStamp.set((Timestamp)map.remove(map.lastKey()));\n  }\n else {\n    Debug.logError(\"Error in transaction handling - no saved start stamp found - using NOW.\",module);\n    transactionStartStamp.set(UtilDateTime.nowTimestamp());\n  }\n}\n", "nl": "Remove the stamp from stack (when resuming)"}
{"code": "public void actionPerformed(ActionEvent ev){\n  ClusterViewer viewer=getViewer();\n  PageFormat pageFormat=ProgramProperties.getPageFormat();\n  PrinterJob job=PrinterJob.getPrinterJob();\n  if (pageFormat != null)   job.setPrintable(viewer,pageFormat);\n else   job.setPrintable(viewer);\n  if (job.printDialog()) {\n    try {\n      job.print();\n    }\n catch (    Exception ex) {\n      Basic.caught(ex);\n      NotificationsInSwing.showError(viewer.getFrame(),\"Print failed: \" + ex);\n    }\n  }\n}\n", "nl": "action to be performed"}
{"code": "public void cancel(Account account){\n  Log_OC.d(TAG,\"Account= \" + account.name);\n  if (mCurrentUpload != null) {\n    Log_OC.d(TAG,\"Current Upload Account= \" + mCurrentUpload.getAccount().name);\n    if (mCurrentUpload.getAccount().name.equals(account.name)) {\n      mCurrentUpload.cancel();\n    }\n  }\n  cancelUploadsForAccount(account);\n}\n", "nl": "Cancels all the uploads for an account"}
{"code": "public static int calculateInSampleSize(BitmapFactory.Options options,int rqsW,int rqsH){\n  final int height=options.outHeight;\n  final int width=options.outWidth;\n  int inSampleSize=1;\n  if (rqsW == 0 || rqsH == 0)   return 1;\n  if (height > rqsH || width > rqsW) {\n    final int heightRatio=Math.round((float)height / (float)rqsH);\n    final int widthRatio=Math.round((float)width / (float)rqsW);\n    inSampleSize=heightRatio < widthRatio ? heightRatio : widthRatio;\n  }\n  return inSampleSize;\n}\n", "nl": "calculate the bitmap sampleSize"}
{"code": "private void calculateUniqueValue(Object[] minValue,Object[] uniqueValue){\n  for (int i=0; i < measureCount; i++) {\n    if (type[i] == CarbonCommonConstants.BIG_INT_MEASURE) {\n      uniqueValue[i]=(long)minValue[i] - 1;\n    }\n else     if (type[i] == CarbonCommonConstants.BIG_DECIMAL_MEASURE) {\n      BigDecimal val=(BigDecimal)minValue[i];\n      uniqueValue[i]=(val.subtract(new BigDecimal(1.0)));\n    }\n else {\n      uniqueValue[i]=(double)minValue[i] - 1;\n    }\n  }\n}\n", "nl": "This method will calculate the unique value which will be used as storage key for null values of measures"}
{"code": "public void draw(Canvas c,Rect bounds){\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mPaint.setColor(mColors[mColorIndex]);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n  if (mAlpha < 255) {\n    mCirclePaint.setColor(mBackgroundColor);\n    mCirclePaint.setAlpha(255 - mAlpha);\n    c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  }\n}\n", "nl": "Draw the progress spinner"}
{"code": "private static void ldlFactorization(double[][] mywuw){\n  for (int t=0; t < mywuw.length; t++) {\n    for (int i=1; (i < WIDTH) && (t - i >= 0); i++)     mywuw[t][0]-=mywuw[t - i][i] * mywuw[t - i][i] * mywuw[t - i][0];\n    for (int i=2; i <= WIDTH; i++) {\n      for (int j=1; (i + j <= WIDTH) && (t - j >= 0); j++)       mywuw[t][i - 1]-=mywuw[t - j][j] * mywuw[t - j][i + j - 1] * mywuw[t - j][0];\n      mywuw[t][i - 1]/=mywuw[t][0];\n    }\n  }\n}\n", "nl": "ldlFactorization: Factorize W'*U^{-1}*W to L*D*L' (L: lower triangular, D: diagonal)"}
{"code": "public void createLegion(Player activePlayer,String legionName){\n  if (legionRestrictions.canCreateLegion(activePlayer,legionName)) {\n    Legion legion=new Legion(IDFactory.getInstance().nextId(),legionName);\n    legion.addLegionMember(activePlayer.getObjectId());\n    activePlayer.getInventory().decreaseKinah(LegionConfig.LEGION_CREATE_REQUIRED_KINAH);\n    storeLegion(legion,true);\n    Timestamp currentTime=new Timestamp(System.currentTimeMillis());\n    storeNewAnnouncement(legion.getLegionId(),currentTime,\"\");\n    legion.addAnnouncementToList(currentTime,\"\");\n    addLegionMember(legion,activePlayer,LegionRank.BRIGADE_GENERAL);\n    PacketSendUtility.broadcastPacketToLegion(legion,new SM_LEGION_EDIT(0x05,(int)(System.currentTimeMillis() / 1000),\"\"));\n    addHistory(legion,\"\",LegionHistoryType.CREATE);\n    addHistory(legion,activePlayer.getName(),LegionHistoryType.JOIN);\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_CREATED(legion.getLegionName()));\n  }\n}\n", "nl": "This method will handle the creation of a legion"}
{"code": "public void remove(String key,String value){\n  if (key == null) {\n    throw new NullPointerException(\"key\");\n  }\n  if (value == null) {\n    throw new NullPointerException(\"value\");\n  }\nsynchronized (contexts) {\n    contexts.removeIf(null);\n  }\n}\n", "nl": "Remove a key value pair from this set"}
{"code": "@Override public int read() throws IOException {\n  if (this.remaining == 0) {\n    return -1;\n  }\n else {\n    int var1=this.in.read();\n    if (var1 >= 0) {\n      --this.remaining;\n    }\n    return var1;\n  }\n}\n", "nl": "Below method will be used to read the data from file"}
{"code": "private boolean checkDuelCondition(Effect effect){\n  Creature creature=effect.getEffector();\n  if (creature instanceof Player) {\n    if (!getOwner().isEnemy(creature) && effect.getTargetSlot() == SkillTargetSlot.DEBUFF.ordinal()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Effect of DEBUFF should not be added if duel ended (friendly unit)"}
{"code": "protected Map<String,String> process(Map<String,String> propertyMap){\n  Map<String,String> newPropertyMap=new LinkedHashMap<String,String>();\n  for (  String esriField : translationMap.keySet()) {\n    String value=propertyMap.get(esriField);\n    newPropertyMap.put(translationMap.get(esriField),value);\n  }\n  for (  String field : defaultsMap.keySet()) {\n    newPropertyMap.put(field,defaultsMap.get(field));\n  }\n  return newPropertyMap;\n}\n", "nl": "Process the data source properties by translating them and adding default values"}
{"code": "private void subscribeRecord(){\n  for (  Subscription subscription : this.subscriptions) {\n    if (subscription.recordPathChangedCallback != null) {\n      this.record.subscribe(subscription.path,subscription.recordPathChangedCallback,true);\n    }\n else     if (subscription.recordChangedCallback != null) {\n      this.record.subscribe(subscription.recordChangedCallback,true);\n    }\n  }\n}\n", "nl": "Subscribe all callbacks to current record"}
{"code": "public static void initAllResources(){\n  if (!isLoaded) {\n    databaseManager=new SQLdatabaseManager(applicationContext);\n    SettingsManager.getInstace().init();\n    Category.initPodcastsCatrgories();\n    SimpleCacheManager.getInstance().removeExpiredCache();\n    runMainService();\n    setAlarmManagerTasks();\n    isLoaded=true;\n  }\n}\n", "nl": "All resources which can be loaded not in onCreate(), should be load here, this function called while splash screen is active"}
{"code": "public static Matrix identity(int m,int n){\n  Matrix A=new Matrix(m,n);\n  double[][] X=A.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      X[i][j]=(i == j ? 1.0 : 0.0);\n    }\n  }\n  return A;\n}\n", "nl": "Generate identity matrix"}
{"code": "void afterUnmarshal(Unmarshaller u,Object parent){\n  chestData.clear();\n  instancesMap.clear();\n  namedChests.clear();\n  for (  ChestTemplate chest : chests) {\n    chestData.put(chest.getNpcId(),chest);\n    if (chest.getName() != null && !chest.getName().isEmpty()) {\n      namedChests.put(chest.getName(),chest);\n    }\n  }\n}\n", "nl": "- Inititialize all maps for subsequent use - Don't nullify initial chest list as it will be used during reload"}
{"code": "public CategoryColumn tokenizeAndSort(){\n  CategoryColumn newColumn=CategoryColumn.create(name() + \"[sorted]\",this.size());\n  for (int r=0; r < size(); r++) {\n    String value=get(r);\n    Splitter splitter=Splitter.on(CharMatcher.WHITESPACE);\n    splitter=splitter.trimResults();\n    splitter=splitter.omitEmptyStrings();\n    List<String> tokens=new ArrayList<>(splitter.splitToList(value));\n    Collections.sort(tokens);\n    value=String.join(\" \",tokens);\n    newColumn.add(value);\n  }\n  return newColumn;\n}\n", "nl": "Splits on Whitespace and returns the lexicographically sorted result"}
{"code": "public File[] filterHiddenFiles(File[] files){\n  List<File> ret=new ArrayList<>();\n  for (  File file : files) {\n    if (!file.isHidden()) {\n      ret.add(file);\n    }\n  }\n  return ret.toArray(new File[ret.size()]);\n}\n", "nl": "Filter for hidden files"}
{"code": "public static List<File> walk(String path){\n  LinkedList<File> output=new LinkedList<File>();\n  File root=new File(path);\n  File[] list=root.listFiles();\n  if (list == null) {\n    return output;\n  }\n  for (  File f : list) {\n    if (f.isDirectory()) {\n      output.addAll(walk(f.getAbsolutePath()));\n    }\n else {\n      output.addLast(f);\n    }\n  }\n  return output;\n}\n", "nl": "Recursively walk through the path and return all found files (not directory)"}
{"code": "public int compare(MatchData o1,MatchData o2){\n  if (o1.firstPosInRef < o2.firstPosInRef)   return -1;\n  if (o1.firstPosInRef > o2.firstPosInRef)   return 1;\n  if (o1.lastPosInRef < o2.lastPosInRef)   return 1;\n  if (o1.lastPosInRef > o2.lastPosInRef)   return -1;\n  if (o1.read.getId() < o2.read.getId())   return -1;\n  if (o1.read.getId() > o2.read.getId())   return 1;\n  return 0;\n}\n", "nl": "sort by ascending start position and descending end position"}
{"code": "private Map<Metrics,List<ManagedLedgerImpl>> groupLedgersByDimension(){\n  Map<Metrics,List<ManagedLedgerImpl>> ledgersByDimensionMap=Maps.newHashMap();\n  Map<String,ManagedLedgerImpl> ledgersMap=getManagedLedgers();\n  for (  Entry<String,ManagedLedgerImpl> e : ledgersMap.entrySet()) {\n    String ledgerName=e.getKey();\n    ManagedLedgerImpl ledger=e.getValue();\n    String namespace=parseNamespaceFromLedgerName(ledgerName);\n    Metrics metrics=createMetricsByDimension(namespace);\n    populateDimensionMap(ledgersByDimensionMap,metrics,ledger);\n  }\n  return ledgersByDimensionMap;\n}\n", "nl": "Build a map of dimensions key to list of destination stats <p>"}
{"code": "private int klattRule8(Element segment){\n  Element syllable=getSyllable(segment);\n  if (hasAccent(syllable)) {\n    if (isInNucleus(segment)) {\n      return getPropertyAsInteger(\"rule8.accent\");\n    }\n  }\n  return 100;\n}\n", "nl": "Klatt Rule 8: Lengthening for emphasis"}
{"code": "public static int binomial(RandomGenerator rng,int n,double p){\n  if ((p < 0) || (p > 1)) {\n    return 0;\n  }\n  int c=0;\n  for (int i=0; i < n; i++) {\n    if (rng.nextDouble() < p) {\n      c++;\n    }\n  }\n  return c;\n}\n", "nl": "Generates a binomial distributed number using the given rng"}
{"code": "public final void load(String locale){\n  if (locale != null)   locale=locale.replace('-','_');\n  try {\n    URL url=locale == null ? this.getDefaultLanguageFile() : this.getClass().getResource(\"/assets/rewimod/lang/\" + locale + \".lang\");\n    if (url == null) {\n      url=this.getDefaultLanguageFile();\n    }\n    InputStreamReader reader=new InputStreamReader(url.openStream(),StandardCharsets.UTF_8);\n    this.parse(new BufferedReader(reader));\n  }\n catch (  IOException ex) {\n    RewiMod.LOGGER.fatal(\"Error while loading Language File\",ex);\n  }\n}\n", "nl": "Loads the given Language"}
{"code": "@Subscribe public void onEvent(SearchInPosition event){\n  List<LatLng> list=MapHelper.getSearchArea(event.getSteps(),new LatLng(event.getPosition().latitude,event.getPosition().longitude));\n  snackMe(getString(R.string.toast_searching));\n  nianticManager.getGyms(event.getPosition().latitude,event.getPosition().longitude,0D);\n  nianticManager.getPokeStops(event.getPosition().latitude,event.getPosition().longitude,0D);\n  nianticManager.getLuredPokemon(event.getPosition().latitude,event.getPosition().longitude,0D);\n  for (  LatLng p : list) {\n    nianticManager.getCatchablePokemon(p.latitude,p.longitude,0D);\n  }\n}\n", "nl": "Called whenever a use whats to search pokemons on a different position"}
{"code": "private ReggieStat removeReggieStat(ServiceID id){\n  if (id == null)   throw new NullPointerException(\"id is null\");\n  ReggieStat rStat=null;\nsynchronized (discoveryTimes) {\n    for (Iterator it=discoveryTimes.iterator(); it.hasNext(); ) {\n      ReggieStat rt=(ReggieStat)it.next();\n      if (rt.serviceID.equals(id)) {\n        rStat=rt;\n        discoveryTimes.remove(rt);\n        break;\n      }\n    }\n  }\n  return (rStat);\n}\n", "nl": "Find and remove a ReggieStat based on the provided ServiceID"}
{"code": "public void finishGathering(Player player){\n  if (currentGatherer == player.getObjectId()) {\n    if (state == GatherState.GATHERING) {\n      task.abort();\n    }\n    currentGatherer=0;\n    state=GatherState.IDLE;\n  }\n}\n", "nl": "Called by client when some action is performed or on finish gathering Called by move observer on player move"}
{"code": "public CommitJob(Transaction tr,TaskManager pool,WakeupManager wm,ClientLog log,ParticipantHandle[] handles,Object xid){\n  super(pool,wm,false);\n  if (log == null)   throw new IllegalArgumentException(\"CommitJob: CommitJob: \" + \"log is null\");\n  this.log=log;\n  if (!(tr instanceof ServerTransaction))   throw new IllegalArgumentException(\"PrepareJob: PrepareJob: \" + \"must be a ServerTransaction\");\n  this.tr=(ServerTransaction)tr;\n  if (handles == null)   throw new IllegalArgumentException(\"PrepareJob: PrepareJob: \" + \"must have participants\");\n  if (handles.length == 0)   throw new IllegalArgumentException(\"PrepareJob: PrepareJob: \" + \"must have participants\");\n  this.handles=handles;\n  _xid=xid;\n}\n", "nl": "Constructs an <code>CommitJob</code>"}
{"code": "@Override public void onSensorsFromAllNodesSelected(Map<String,List<DeviceSensor>> selectedSensors){\n  Log.d(TAG,\"Sensors from all nodes selected\");\n  this.selectedSensors=selectedSensors;\n  for (  Map.Entry<String,List<DeviceSensor>> selectedSensorsEntry : selectedSensors.entrySet()) {\n    for (    DeviceSensor deviceSensor : selectedSensorsEntry.getValue()) {\n      Bundle bundle=new Bundle();\n      bundle.putString(FirebaseAnalytics.Param.ITEM_ID,String.valueOf(deviceSensor.getType()));\n      bundle.putString(FirebaseAnalytics.Param.ITEM_NAME,deviceSensor.getName());\n      bundle.putString(FirebaseAnalytics.Param.ITEM_CATEGORY,deviceSensor.getStringType());\n      app.getAnalytics().logEvent(FirebaseAnalytics.Event.VIEW_ITEM,bundle);\n    }\n  }\n}\n", "nl": "Will be called when the sensor selection dialog has been closed after sensors from all nodes have been selected"}
{"code": "@Override public AudioInputStream synthesize(int backchannelNumber,AudioFileFormat aft) throws SynthesisException {\n  if (backchannelNumber > vMLSAFeaturesReader.getNumberOfUnits()) {\n    throw new IllegalArgumentException(\"requesting unit should not be more than number of units\");\n  }\n  if (backchannelNumber < 0) {\n    throw new IllegalArgumentException(\"requesting unit index should not be less than zero\");\n  }\n  double[] lf0=vMLSAFeaturesReader.getUnitLF0(backchannelNumber);\n  boolean[] voiced=vMLSAFeaturesReader.getVoicedFrames(backchannelNumber);\n  double[][] mgc=vMLSAFeaturesReader.getUnitMGCs(backchannelNumber);\n  double[][] strengths=vMLSAFeaturesReader.getUnitStrengths(backchannelNumber);\n  return synthesizeUsingMLSAVocoder(mgc,strengths,lf0,voiced,aft);\n}\n", "nl": "Synthesize given vocalization using MLSA vocoder"}
{"code": "private Bitmap drawOnFace(SparseArray<Face> faceArray,int stroke,int color){\n  Bitmap outBitmap=Bitmap.createBitmap(getMyPhoto().getWidth(),getMyPhoto().getHeight(),Bitmap.Config.RGB_565);\n  Canvas canvas=new Canvas(outBitmap);\n  canvas.drawBitmap(getMyPhoto(),0,0,null);\n  for (int i=0; i < faceArray.size(); i++) {\n    int key=faceArray.keyAt(i);\n    Face face=faceArray.get(key);\n    drawRectangle(canvas,face.getPosition(),face.getWidth(),face.getHeight(),stroke,color);\n    this.listLandMarkPhoto=face.getLandmarks();\n  }\n  return outBitmap;\n}\n", "nl": "Method to do some drawing on faces"}
{"code": "public void addValue(double value){\n  secondMoment.increment(value);\n  minImpl.increment(value);\n  maxImpl.increment(value);\n  sumImpl.increment(value);\n  sumOfSquaresImpl.increment(value);\n  sumOfLogsImpl.increment(value);\n  n++;\n}\n", "nl": "Add a value to the data"}
{"code": "@Override public byte process(Target target){\n  Element segment=navigator.getElement(target);\n  if (segment == null)   return values.get(\"0\");\n  if (!segment.getTagName().equals(MaryXML.PHONE))   return 0;\n  String ph=segment.getAttribute(\"p\");\n  String phoneClass=phones2Classes.get(ph);\n  if (phoneClass == null) {\n    return values.get(\"0\");\n  }\n  return values.get(phoneClass);\n}\n", "nl": "Give back the phone class of the target"}
{"code": "public static Boolean toBoolean(String value){\n  if (\"Y\".equalsIgnoreCase(value)) {\n    return true;\n  }\n else   if (\"N\".equalsIgnoreCase(value)) {\n    return false;\n  }\n else {\n    return null;\n  }\n}\n", "nl": "SCIPIO: Type conversion of Strings that resemble \"Y\" or \"N\" values to Boolean"}
{"code": "public List<String> top(int n){\n  List<String> top=new ArrayList<>();\n  CategoryColumn copy=this.copy();\n  copy.sortDescending();\n  for (int i=0; i < n; i++) {\n    top.add(copy.get(i));\n  }\n  return top;\n}\n", "nl": "Returns the largest (\"top\") n values in the column"}
{"code": "public static String describeElements(@Nullable PsiElement[] elements){\n  if (elements == null) {\n    return \"Empty\";\n  }\n  StringBuilder sb=new StringBuilder();\n  for (  PsiElement target : elements) {\n    appendElementDescription(sb,target);\n  }\n  return sb.toString();\n}\n", "nl": "Returns a description of the given elements, suitable as unit test golden file output"}
{"code": "public static Table read(ResultSet resultSet,String tableName) throws SQLException {\n  ResultSetMetaData metaData=resultSet.getMetaData();\n  Table table=Table.create(tableName);\n  for (int i=1; i <= metaData.getColumnCount(); i++) {\n    String name=metaData.getColumnName(i);\n    ColumnType type=SQL_TYPE_TO_TABLESAW_TYPE.get(metaData.getColumnType(i));\n    Preconditions.checkState(type != null,\"No column type found for %s as specified for column %s\",metaData.getColumnType(i),name);\n    Column newColumn=TypeUtils.newColumn(name,type);\n    table.addColumn(newColumn);\n  }\n  while (resultSet.next()) {\n    for (int i=1; i <= metaData.getColumnCount(); i++) {\n      Column column=table.column(i - 1);\n      column.addCell(resultSet.getString(i));\n    }\n  }\n  return table;\n}\n", "nl": "Returns a new table with the given tableName, constructed from the given result set"}
{"code": "void callUserDataHandlers(Node n,Node c,short operation,Hashtable userData){\n  if (userData == null || userData.isEmpty()) {\n    return;\n  }\n  Iterator entries=userData.entrySet().iterator();\n  while (entries.hasNext()) {\n    Map.Entry entry=(Map.Entry)entries.next();\n    String key=(String)entry.getKey();\n    UserDataRecord r=(UserDataRecord)entry.getValue();\n    if (r.fHandler != null) {\n      r.fHandler.handle(operation,key,r.fData,n,c);\n    }\n  }\n}\n", "nl": "Call user data handlers when a node is deleted (finalized)"}
{"code": "@SafeVarargs public static <K,V>Map<K,V> Map(Tuple2<K,V>... kvs){\n  if ((kvs == null) || (kvs.length == 0)) {\n    return Collections.emptyMap();\n  }\n  Map<K,V> map=new HashMap<>(kvs.length);\n  for (  Tuple2<K,V> t : kvs) {\n    map.put(t._1,t._2);\n  }\n  return Collections.unmodifiableMap(map);\n}\n", "nl": "Return a new immutable map consisting of keys,values using the given pairs"}
{"code": "private TestItem verifyTestItem(final String testItemId,FinishTestItemRQ finishExecutionRQ,Optional<Status> actualStatus){\n  TestItem testItem=testItemRepository.findOne(testItemId);\n  try {\n    expect(testItem,notNull()).verify(TEST_ITEM_NOT_FOUND,testItemId);\n    expect(testItem,not(Preconditions.TEST_ITEM_FINISHED)).verify(REPORTING_ITEM_ALREADY_FINISHED,testItem.getId());\n    boolean statusProvided=actualStatus.isPresent();\n    List<TestItem> descendants=testItemRepository.findDescendants(testItem.getId());\n    boolean hasDescendants=!descendants.isEmpty();\n    expect(!statusProvided && !hasDescendants,Predicates.equalTo(Boolean.FALSE),formattedSupplier(\"There is no status provided from request and there are no descendants to check statistics for test item id '{}'\",testItemId)).verify();\n    expect(descendants,not(Preconditions.HAS_IN_PROGRESS_ITEMS)).verify(FINISH_ITEM_NOT_ALLOWED,formattedSupplier(\"Test item '{}' has descendants with '{}' status. All descendants '{}'\",testItemId,IN_PROGRESS.name(),descendants));\n    expect(finishExecutionRQ,Preconditions.finishSameTimeOrLater(testItem.getStartTime())).verify(FINISH_TIME_EARLIER_THAN_START_TIME,finishExecutionRQ.getEndTime(),testItem.getStartTime(),testItemId);\n  }\n catch (  BusinessRuleViolationException e) {\n    fail().withError(AMBIGUOUS_TEST_ITEM_STATUS,e.getMessage());\n  }\n  return testItem;\n}\n", "nl": "Validation procedure for specified test item"}
{"code": "public static boolean openEditor(@NotNull Project project,@NotNull VirtualFile vFile){\n  OpenFileDescriptor descriptor;\n  if (vFile.getFileType() == StdFileTypes.XML && AndroidEditorSettings.getInstance().getGlobalState().isPreferXmlEditor()) {\n    descriptor=new OpenFileDescriptor(project,vFile,0);\n  }\n else {\n    descriptor=new OpenFileDescriptor(project,vFile);\n  }\n  return !FileEditorManager.getInstance(project).openEditor(descriptor,true).isEmpty();\n}\n", "nl": "Opens the specified file in the editor"}
{"code": "public void writeLong(long a) throws IOException {\n  io.write((byte)(a >> 56));\n  io.write((byte)(a >> 48));\n  io.write((byte)(a >> 40));\n  io.write((byte)(a >> 32));\n  io.write((byte)(a >> 24));\n  io.write((byte)(a >> 16));\n  io.write((byte)(a >> 8));\n  io.write((byte)(a));\n}\n", "nl": "write a long"}
{"code": "public static void writeResultFile(String filename,Map<String,List<QueryResponseJSON>> resultMap) throws IOException {\n  try (BufferedWriter bw=new BufferedWriter(new FileWriter(new File(filename)))){\n    for (    Entry<String,List<QueryResponseJSON>> entry : resultMap.entrySet()) {\n      for (      QueryResponseJSON hitJSON : entry.getValue()) {\n        bw.write(hitJSON.getJSONString());\n        bw.newLine();\n      }\n    }\n  }\n }\n", "nl": "Writes elements of the resultMap to output file, one line for each element, where each line is a string representation of the corresponding QueryResponseJSON object"}
{"code": "public TrackReads(String bam,GenomicCoords gc,int maxReadStack) throws IOException {\n  if (!Utils.bamHasIndex(bam)) {\n    System.err.println(\"\\nAlignment file \" + bam + \" has no index.\\n\");\n    throw new RuntimeException();\n  }\n  this.setFilename(bam);\n  this.setGc(gc);\n  this.maxReadStack=maxReadStack;\n  this.update();\n}\n", "nl": "Create read track"}
{"code": "private String flattenComment(String string){\n  StringBuffer buffer=new StringBuffer(string.length() + 20);\n  boolean skipAdjacentLineSeparator=true;\n  for (int i=0; i < string.length(); i++) {\n    char c=string.charAt(i);\n    if (c == '\\r' || c == '\\n') {\n      if (!skipAdjacentLineSeparator)       buffer.append(Policy.bind(\"separator\"));\n      skipAdjacentLineSeparator=true;\n    }\n else {\n      buffer.append(c);\n      skipAdjacentLineSeparator=false;\n    }\n  }\n  return buffer.toString();\n}\n", "nl": "Flatten the given string so it contains no more line breaks"}
{"code": "public static int decodeVIntSize(byte value){\n  if (value >= -112) {\n    return 1;\n  }\n else   if (value < -120) {\n    return -119 - value;\n  }\n  return -111 - value;\n}\n", "nl": "Parse the first byte of a vint/vlong to determine the number of bytes"}
{"code": "public static void showProfile(Activity activity,String pilotId,@Nullable HashMap<String,String> extras){\n  if ((pilotId == null || pilotId.isEmpty()) && AirMap.hasValidAuthenticatedUser()) {\n    pilotId=AirMap.getUserId();\n  }\n  Intent intent=new Intent(activity,ProfileActivity.class);\n  intent.putExtra(ProfileActivity.ARG_PILOT_ID,pilotId);\n  if (extras != null) {\n    intent.putExtra(CreateFlightActivity.KEY_VALUE_EXTRAS,extras);\n  }\n  activity.startActivity(intent);\n}\n", "nl": "Display the authenticated pilot's profile"}
{"code": "protected void spawnHelpers(int npcId,int count,int distance){\n  if (!isAlreadyDead()) {\n    for (int i=0; i < count; i++) {\n      SpawnTemplate summon=null;\n      summon=rndSpawnInRange(npcId,distance);\n      VisibleObject npc=SpawnEngine.spawnObject(summon,getPosition().getInstanceId());\n      PacketSendUtility.broadcastPacket(getOwner(),new SM_NPC_INFO((Npc)npc,\"\"));\nsynchronized (spawnedNpc) {\n        spawnedNpc.add(npc.getObjectId());\n      }\n    }\n  }\n}\n", "nl": "Spawn Helpers in Range"}
{"code": "public static byte[] packHeader(byte cmd,long pkg_len,byte errno) throws UnsupportedEncodingException {\n  byte[] header;\n  byte[] hex_len;\n  header=new byte[FDFS_PROTO_PKG_LEN_SIZE + 2];\n  Arrays.fill(header,(byte)0);\n  hex_len=ProtoCommon.long2buff(pkg_len);\n  System.arraycopy(hex_len,0,header,0,hex_len.length);\n  header[PROTO_HEADER_CMD_INDEX]=cmd;\n  header[PROTO_HEADER_STATUS_INDEX]=errno;\n  return header;\n}\n", "nl": "pack header by FastDFS transfer protocol"}
{"code": "public Requestor(String[] groups,int port,boolean delayFlag) throws IOException {\n  super(\"GS-multicast-discovery-request\");\n  setDaemon(true);\n  sock=new MulticastSocket(Constants.getDiscoveryPort());\n  sock.setTimeToLive(multicastRequestConstraints.getMulticastTimeToLive(Constants.getTtl()));\n  responsePort=port;\n  this.groups=groups == null ? new String[0] : groups;\n  this.delayFlag=delayFlag;\n}\n", "nl": "Create a daemon thread"}
{"code": "private void initResourcesIfNecessary(){\n  if (centerDrawable == null) {\n    centerDrawable=getContext().getResources().getDrawable(wheelForeground);\n  }\n  if (topShadow == null) {\n    topShadow=new GradientDrawable(Orientation.TOP_BOTTOM,SHADOWS_COLORS);\n  }\n  if (bottomShadow == null) {\n    bottomShadow=new GradientDrawable(Orientation.BOTTOM_TOP,SHADOWS_COLORS);\n  }\n  setBackgroundResource(wheelBackground);\n}\n", "nl": "Initializes resources"}
{"code": "public static String removeAccesTrackingCodeCookie(HttpServletRequest request,HttpServletResponse response){\n  Cookie[] cookies=request.getCookies();\n  if (cookies != null) {\n    for (    Cookie cookie : cookies) {\n      if (cookie.getName().endsWith(\"_ACCESS\")) {\n        cookie.setMaxAge(0);\n        response.addCookie(cookie);\n      }\n    }\n  }\n  return \"success\";\n}\n", "nl": "Removes the ACCESS tracking code cookie"}
{"code": "private void checkCallingPackage() throws SecurityException {\n  String callingPkg=null;\n  if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {\n    callingPkg=getCallingPackage();\n  }\n  if (\"org.kustom.wallpaper\".equals(callingPkg))   return;\n  if (\"org.kustom.widget\".equals(callingPkg))   return;\n  throw new SecurityException(\"Unauthorized\");\n}\n", "nl": "Will check weather or not calling pkg is authorized to talk with this provider"}
{"code": "private void fillTableMenu(IMenuManager manager){\n  manager.add(getRefreshAction());\n  Action action=getAddPropertyAction();\n  try {\n    if (resource != null)     action.setEnabled(resource.isManaged());\n else     action.setEnabled(false);\n  }\n catch (  SVNException e) {\n    action.setEnabled(false);\n  }\n  manager.add(action);\n  manager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));\n}\n", "nl": "fill the popup menu for the table"}
{"code": "public void updateClassification(ClassificationType classificationType,Map<Integer,ListOfLongs> classId2locations) throws IOException {\n  getClassificationsFooter().setStart(classificationType,io.getPosition());\n  getClassificationsFooter().setDo(classificationType);\n  final ClassificationBlockRMA3 classificationBlock=new ClassificationBlockRMA3(classificationType);\n  for (  Integer classId : classId2locations.keySet()) {\n    classificationBlock.setSum(classId,classId2locations.get(classId).size());\n  }\n  classificationBlock.write(io,classId2locations);\n  getClassificationsFooter().setEnd(classificationType,io.getPosition());\n}\n", "nl": "rescan a specific classification"}
{"code": "private boolean canAppointBrigadeGeneral(Player activePlayer,Player targetPlayer){\n  Legion legion=activePlayer.getLegion();\n  if (!isBrigadeGeneral(activePlayer)) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_CHANGE_MEMBER_RANK_DONT_HAVE_RIGHT);\n    return false;\n  }\n  if (isSelf(activePlayer,targetPlayer.getObjectId())) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_CHANGE_MASTER_ERROR_SELF);\n    return false;\n  }\n else   if (!legion.isMember(targetPlayer.getObjectId())) {\n    return false;\n  }\n  return true;\n}\n", "nl": "This method checks all restrictions for appointing brigade general"}
{"code": "public void clear(){\n  uid=0;\n  bitScore=0;\n  percentIdentity=0;\n  refSeqId=null;\n  expected=0;\n  length=0;\n  ignore=false;\n  text=null;\n  cName2id.clear();\n}\n", "nl": "erase the block (for reuse)"}
{"code": "private void cleanup(){\n  Iterator<Entry<Byte,Nonce>> iter=table.entrySet().iterator();\n  while (iter.hasNext()) {\n    Nonce nonce=iter.next().getValue();\n    if (nonce.getTimer() != null) {\n      long removeAt=nonce.getTimer().getExpiresAt() + 10000;\n      if (System.currentTimeMillis() > removeAt) {\n        logger.warn(\"NODE {}: Expiring nonce with id={}\",node.getNodeId(),nonce.getNonceId());\n        iter.remove();\n        expiredNonceIdList.add(nonce.getNonceId());\n      }\n    }\n  }\n}\n", "nl": "Remove any expired nonces from our table"}
{"code": "public void install(Intent intentResult,Class<? extends AbstractResultService> serviceClass,AbstractPatch upgradePatch,AbstractPatch repairPatch){\n  sInstalled=true;\n  AbstractResultService.setResultServiceClass(serviceClass);\n  TinkerPatchService.setPatchProcessor(upgradePatch,repairPatch);\n  if (!isTinkerEnabled()) {\n    TinkerLog.e(TAG,\"tinker is disabled\");\n    return;\n  }\n  if (intentResult == null) {\n    throw new TinkerRuntimeException(\"intentResult must not be null.\");\n  }\n  tinkerLoadResult=new TinkerLoadResult();\n  tinkerLoadResult.parseTinkerResult(getContext(),intentResult);\n  loadReporter.onLoadResult(patchDirectory,tinkerLoadResult.loadCode,tinkerLoadResult.costTime);\n  if (!loaded) {\n    TinkerLog.w(TAG,\"tinker load fail!\");\n  }\n}\n", "nl": "you must install tinker first!!"}
{"code": "public static boolean isNamedProcess(Context context,String processName){\n  if (context == null) {\n    return false;\n  }\n  int pid=android.os.Process.myPid();\n  ActivityManager manager=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);\n  List<RunningAppProcessInfo> processInfoList=manager.getRunningAppProcesses();\n  if (ListUtils.isEmpty(processInfoList)) {\n    return false;\n  }\n  for (  RunningAppProcessInfo processInfo : processInfoList) {\n    if (processInfo != null && processInfo.pid == pid && ObjectUtils.isEquals(processName,processInfo.processName)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "whether this process is named with processName"}
{"code": "protected ArrayList computeNames(AbstractTextEditor editor){\n  IJavaElement jElem=getJavaElement(editor);\n  ArrayList names=new ArrayList();\n  if (jElem instanceof ICompilationUnit) {\n    ICompilationUnit cu=(ICompilationUnit)jElem;\n    return getNames(cu);\n  }\n else {\n    return names;\n  }\n}\n", "nl": "compute top-level names"}
{"code": "@Override public void initiaize(File file,int entryCount) throws CarbonSortKeyAndGroupByException {\n  try {\n    stream=new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file),writeBufferSize));\n    stream.writeInt(entryCount);\n  }\n catch (  FileNotFoundException e1) {\n    throw new CarbonSortKeyAndGroupByException(e1);\n  }\ncatch (  IOException e) {\n    throw new CarbonSortKeyAndGroupByException(e);\n  }\n}\n", "nl": "Below method will be used to initialize the stream and write the entry count"}
{"code": "public void execute(InnerQueryNode innerQueryNode,ISpaceProxy space,Transaction txn,int readModifier,int max) throws SQLException {\n  SelectQuery innerQuery=innerQueryNode.getInnerQuery();\n  innerQuery.validateQuery(space);\n  innerQuery.setPreparedValues(query.getPreparedValues());\n  innerQuery.setRouting(query.getRouting());\n  if (!innerQuery.isPrepared() && !innerQuery.containsSubQueries())   innerQuery.build();\n  ResponsePacket innerResponse=innerQuery.executeOnSpace(space,txn);\n  innerQueryNode.setResults(innerResponse.getResultEntry());\n}\n", "nl": "Executes an inner query"}
{"code": "static int[] sortUnique(int[] list){\n  Arrays.sort(list);\n  int count=1;\n  for (int i=1; i < list.length; i++) {\n    if (list[i] != list[i - 1]) {\n      count++;\n    }\n  }\n  int[] ret=new int[count];\n  count=1;\n  ret[0]=list[0];\n  for (int i=1; i < list.length; i++) {\n    if (list[i] != list[i - 1]) {\n      ret[count++]=list[i];\n    }\n  }\n  return ret;\n}\n", "nl": "Sort a list of integers and remove duplicates"}
{"code": "public CombiningCursor queryCombinings(){\n  QueryHelper qh=new QueryHelper();\n  qh.Columns=null;\n  qh.Table=S.TABLE_COMBINING;\n  qh.Selection=null;\n  qh.SelectionArgs=null;\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new CombiningCursor(wrapJoinHelper(builderCursor(),qh));\n}\n", "nl": "****************************** COMBINING QUERIES"}
{"code": "public void invalidateWheel(boolean clearCaches){\n  if (clearCaches) {\n    recycle.clearAll();\n    if (itemsLayout != null) {\n      itemsLayout.removeAllViews();\n    }\n    scrollingOffset=0;\n  }\n else   if (itemsLayout != null) {\n    recycle.recycleItems(itemsLayout,firstItem,new ItemsRange());\n  }\n  invalidate();\n}\n", "nl": "Invalidates wheel"}
{"code": "public static void applyTopPercentFilter(double topPercent,double bestScore,float minPercentIdentity,IReadBlock readBlock,BitSet activeMatches){\n  if (topPercent > 0 && topPercent < 100) {\n    if (bestScore == 0) {\n      for (int i=activeMatches.nextSetBit(0); i != -1; i=activeMatches.nextSetBit(i + 1)) {\n        final IMatchBlock matchBlock=readBlock.getMatchBlock(i);\n        if (matchBlock.getPercentIdentity() >= minPercentIdentity) {\n          bestScore=Math.max(bestScore,matchBlock.getBitScore());\n        }\n      }\n    }\n    final double threshold=(1 - topPercent / 100.0) * bestScore;\n    for (int i=activeMatches.nextSetBit(0); i != -1; i=activeMatches.nextSetBit(i + 1)) {\n      final IMatchBlock matchBlock=readBlock.getMatchBlock(i);\n      if (matchBlock.getBitScore() < threshold && matchBlock.getPercentIdentity() >= minPercentIdentity)       activeMatches.set(i,false);\n    }\n  }\n}\n", "nl": "applies the top percent filter to a set of active matches"}
{"code": "public int reduceFp(int value){\n  fpLock.lock();\n  try {\n    int newFp=this.currentFp - value;\n    if (newFp < 0) {\n      newFp=0;\n    }\n    this.currentFp=newFp;\n  }\n  finally {\n    fpLock.unlock();\n  }\n  onReduceFp();\n  return currentFp;\n}\n", "nl": "This method is called whenever caller wants to reduce creatures's MP"}
{"code": "@Override public Authentication attemptAuthentication(HttpServletRequest request,HttpServletResponse response) throws AuthenticationException, IOException, ServletException {\n  boolean isLogin=StringUtils.getValidString(request.getRequestURI()).contains(USER_LOGIN);\n  if (isLogin) {\n    return new UsernamePasswordAuthenticationToken(null,null);\n  }\n  String header=request.getHeader(HEADER_AUTHORIZATION);\n  if (header == null || !header.startsWith(BEARER_PREFIX))   throw new JwtTokenMissingException(\"Invalid authentication\");\n  String authToken=header.substring(7);\n  JwtAuthenticationToken authRequest=new JwtAuthenticationToken(authToken);\n  return getAuthenticationManager().authenticate(authRequest);\n}\n", "nl": "Authentication logic"}
{"code": "protected void jimplifyVirtual(DexBody body){\n  SootMethodRef ref=getSootMethodRef();\n  if (ref.declaringClass().isInterface()) {\n    methodRef=null;\n    jimplifyInterface(body);\n    return;\n  }\n  List<Local> parameters=buildParameters(body,false);\n  invocation=Jimple.v().newVirtualInvokeExpr(parameters.get(0),ref,parameters.subList(1,parameters.size()));\n  body.setDanglingInstruction(this);\n}\n", "nl": "Executes the \"jimplify\" operation for a virtual invocation"}
{"code": "public void cancel(Account account){\n  Log_OC.d(TAG,\"Account= \" + account.name);\n  if (mCurrentDownload != null) {\n    Log_OC.d(TAG,\"Current Download Account= \" + mCurrentDownload.getAccount().name);\n    if (mCurrentDownload.getAccount().name.equals(account.name)) {\n      mCurrentDownload.cancel();\n    }\n  }\n  cancelDownloadsForAccount(account);\n}\n", "nl": "Cancels all the downloads for an account"}
{"code": "private boolean invalidate(final TagQualityStatus pQuality,final String pDescription,final Timestamp pTimestamp){\n  if (pQuality == null) {\n    throw new IllegalArgumentException(\"invalidate(..) method called with null TagQualityStatus argument.\");\n  }\n  boolean retval=false;\n  if (this.timestamp.before(pTimestamp) || this.timestamp.equals(pTimestamp)) {\n    this.qualityCollection.add(pQuality);\n    this.qualityDescriptions.put(pQuality,pDescription);\n    this.timestamp=pTimestamp;\n    retval=true;\n  }\n  return retval;\n}\n", "nl": "Updates the values of this <code>BufferObject</code> instance"}
{"code": "@RequestMapping(value=\"/rest/activiti/jobs/{jobId}\",method=RequestMethod.DELETE,produces=\"application/json\") @ResponseStatus(value=HttpStatus.OK) public void deleteJob(@PathVariable String jobId) throws BadRequestException {\n  ServerConfig serverConfig=retrieveServerConfig();\n  try {\n    clientService.deleteJob(serverConfig,jobId);\n  }\n catch (  ActivitiServiceException e) {\n    throw new BadRequestException(e.getMessage());\n  }\n}\n", "nl": "DELETE /rest/activiti/jobs/{jobId} -> delete job"}
{"code": "public void fetchEvents(String date){\n  boolean flag=false;\n  int pos=0;\n  for (int i=0; i < Singleton.getInstance().getEventManager().size(); i++) {\n    if (Singleton.getInstance().getEventManager().get(i).getDate().equalsIgnoreCase(date)) {\n      flag=true;\n      pos=i;\n    }\n  }\n  ArrayList<EventData> eventDataArrayList=new ArrayList();\n  if (flag) {\n    if (Singleton.getInstance().getEventManager().get(pos).getEventData() != null) {\n      eventDataArrayList=Singleton.getInstance().getEventManager().get(pos).getEventData();\n    }\n  }\n  if (mCustomCalendar != null)   mCustomCalendar.setDateSelectionData(eventDataArrayList);\n}\n", "nl": "check if date has event or not, then"}
{"code": "@NotNull private static ImmutableSet<ImmutableMap<String,Boolean>> removeState(@NotNull StateListState state,@NotNull ImmutableSet<ImmutableMap<String,Boolean>> allowedStates){\n  ImmutableSet.Builder<ImmutableMap<String,Boolean>> remainingStates=ImmutableSet.builder();\n  Map<String,Boolean> stateAttributes=state.getAttributes();\n  for (  String attribute : stateAttributes.keySet()) {\n    for (    ImmutableMap<String,Boolean> allowedState : allowedStates) {\n      if (!allowedState.containsKey(attribute)) {\n        ImmutableMap.Builder<String,Boolean> newAllowedState=ImmutableMap.builder();\n        newAllowedState.putAll(allowedState).put(attribute,!stateAttributes.get(attribute));\n        remainingStates.add(newAllowedState.build());\n      }\n else       if (allowedState.get(attribute) != stateAttributes.get(attribute)) {\n        remainingStates.add(allowedState);\n      }\n    }\n  }\n  return remainingStates.build();\n}\n", "nl": "Returns a representation of all the object states that were in allowed states but do not match the state list state"}
{"code": "public void filter(QuestionsFilter questionFilter,Comparator<Question> sorter){\n  filterdQuestions=new ArrayList<Question>(apiResult.getQuestions().size());\n  for (  Question q : apiResult.getQuestions()) {\n    if (questionFilter.isAccepted(q)) {\n      if (!filterdQuestions.contains(q)) {\n        filterdQuestions.add(q);\n      }\n    }\n  }\n  Collections.sort(filterdQuestions,sorter);\n  if (filterdQuestions.size() > questionFilter.getNumberOfQuestions()) {\n    filterdQuestions.subList(questionFilter.getNumberOfQuestions(),filterdQuestions.size()).clear();\n  }\n}\n", "nl": "Filter and sort"}
{"code": "private void spawnShieldControlRoomTeleporter(){\n  deleteNpc(702010);\n  deleteNpc(702011);\n  deleteNpc(702012);\n  deleteNpc(702013);\n  spawn(730886,255.47392f,293.56177f,321.18497f,(byte)89);\n  spawn(730886,255.55742f,216.03549f,321.21344f,(byte)30);\n  spawn(730886,294.20718f,254.60352f,295.7729f,(byte)60);\n  spawn(730886,216.97739f,254.4616f,295.77353f,(byte)0);\n}\n", "nl": "Shield Control Room Teleporter"}
{"code": "public void stopAutoCycle(){\n  if (mCycleTask != null) {\n    mCycleTask.cancel();\n  }\n  if (mCycleTimer != null) {\n    mCycleTimer.cancel();\n  }\n  if (mResumingTimer != null) {\n    mResumingTimer.cancel();\n  }\n  if (mResumingTask != null) {\n    mResumingTask.cancel();\n  }\n  mAutoCycle=false;\n  mCycling=false;\n}\n", "nl": "stop the auto circle"}
{"code": "public void registerPlayerConnection(int playerId,byte[] token,byte[] identifier,ClientChannelHandler channelHandler,String realName) throws UnsupportedEncodingException {\n  ChatClient chatClient=players.get(playerId);\n  if (chatClient != null) {\n    byte[] regToken=chatClient.getToken();\n    chatClient.same(realName);\n    if (Arrays.equals(regToken,token)) {\n      String sreal=chatClient.getRealName() + \"@\" + new String(identifier);\n      chatClient.setIdentifier(sreal.getBytes(\"utf-16le\"));\n      chatClient.setChannelHandler(channelHandler);\n      channelHandler.sendPacket(new SM_PLAYER_AUTH_RESPONSE());\n      channelHandler.setState(State.AUTHED);\n      channelHandler.setChatClient(chatClient);\n      broadcastService.addClient(chatClient);\n    }\n  }\n}\n", "nl": "Player registered from client request"}
{"code": "public String readNullTerminatedBytes() throws IOException {\n  StringBuilder buf=new StringBuilder();\n  while (true) {\n    byte letter=(byte)ins.read();\n    if (letter == -1)     throw new IOException(\"readNullTerminatedBytes(): failed (EOF)\");\n    if (letter == 0)     break;\n else     buf.append((char)letter);\n  }\n  return buf.toString();\n}\n", "nl": "reads a null-terminated string"}
{"code": "private boolean isSyncComplete(JSONObject taskStatus,JSONObject taskDetails){\n  try {\n    if (taskStatus.getBoolean(\"complete\")) {\n      return true;\n    }\n    if (taskDetails.has(\"error\")) {\n      throw new RuntimeException(\"Sync failed with error: '\" + taskDetails.getString(\"error\") + \"'!\");\n    }\n    return false;\n  }\n catch (  JSONException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Check if the sync is complete from a task status"}
{"code": "public ResultSet executeQuery() throws GenericDataSourceException {\n  try {\n    _rs=_ps.executeQuery();\n  }\n catch (  SQLException sqle) {\n    this.checkLockWaitInfo(sqle);\n    throw new GenericDataSourceException(\"SQL Exception while executing the following:\" + _sql,sqle);\n  }\n  return _rs;\n}\n", "nl": "Execute a query based on the prepared statement"}
{"code": "@RequestMapping(value=\"/locationWithinOrgUnitBoundary\",method=RequestMethod.GET,produces={\"*/*\",\"application/json\"}) public void checkLocationWithinOrgUnit(@RequestParam String orgUnitUid,@RequestParam Double longitude,@RequestParam Double latitude,HttpServletResponse response) throws Exception {\n  boolean withinOrgUnit=false;\n  List<OrganisationUnit> organisationUnits=new ArrayList<>();\n  organisationUnits.add(organisationUnitService.getOrganisationUnit(orgUnitUid));\n  FilterUtils.filter(organisationUnits,new OrganisationUnitPolygonCoveringCoordinateFilter(longitude,latitude));\n  if (!organisationUnits.isEmpty()) {\n    withinOrgUnit=true;\n  }\n  renderService.toJson(response.getOutputStream(),withinOrgUnit);\n}\n", "nl": "Check if the location lies within the organisation unit boundary"}
{"code": "public static void init() throws GeneralSecurityException {\n  log.info(\"Initializing Key Generator...\");\n  blowfishKeyGen=KeyGenerator.getInstance(\"Blowfish\");\n  KeyPairGenerator rsaKeyPairGenerator=KeyPairGenerator.getInstance(\"RSA\");\n  RSAKeyGenParameterSpec spec=new RSAKeyGenParameterSpec(1024,RSAKeyGenParameterSpec.F4);\n  rsaKeyPairGenerator.initialize(spec);\n  encryptedRSAKeyPairs=new EncryptedRSAKeyPair[10];\n  for (int i=0; i < 10; i++) {\n    encryptedRSAKeyPairs[i]=new EncryptedRSAKeyPair(rsaKeyPairGenerator.generateKeyPair());\n  }\n  Cipher rsaCipher=Cipher.getInstance(\"RSA/ECB/nopadding\");\n  rsaCipher.init(Cipher.DECRYPT_MODE,encryptedRSAKeyPairs[0].getRSAKeyPair().getPrivate());\n}\n", "nl": "Initialize Key Generator (Blowfish keygen and RSA keygen)"}
{"code": "private static String buildMd5AuthParameter(long timeStamp){\n  try {\n    MessageDigest md=MessageDigest.getInstance(\"MD5\");\n    byte[] messageDigest=md.digest((timeStamp + BuildConfig.PRIVATE_KEY + BuildConfig.PUBLIC_KEY).getBytes());\n    BigInteger number=new BigInteger(1,messageDigest);\n    String md5=number.toString(16);\n    while (md5.length() < 32) {\n      md5=0 + md5;\n    }\n    return md5;\n  }\n catch (  NoSuchAlgorithmException e) {\n    Log.e(\"DataManager\",\"Error hashing required parameters: \" + e.getMessage());\n    return \"\";\n  }\n}\n", "nl": "Builds the required API \"hash\" parameter (timeStamp + privateKey + publicKey)"}
{"code": "public DOTInteroperator() throws IOException {\n  Process p=Runtime.getRuntime().exec(\"dot -V\");\n  try {\n    p.waitFor();\n  }\n catch (  InterruptedException iee) {\n    return;\n  }\n}\n", "nl": "Creates a new instance of DOTInteroperator"}
{"code": "private boolean confirmQuit() throws CanceledException {\n  if (ProgramProperties.isUseGUI()) {\n    getFrame().toFront();\n    int result=JOptionPane.showConfirmDialog(getLastActiveFrame(),\"Quit \" + ProgramProperties.getProgramName() + \"?\",ProgramProperties.getProgramVersion() + \" - Quit?\",JOptionPane.YES_NO_CANCEL_OPTION);\n    if (result == JOptionPane.CANCEL_OPTION) {\n      throw new CanceledException();\n    }\n else     return result != JOptionPane.NO_OPTION;\n  }\n else   return true;\n}\n", "nl": "ask whether user wants to quit"}
{"code": "private static void copyFile(File file,InputStream is,String mode) throws IOException, InterruptedException {\n  final String abspath=file.getAbsolutePath();\n  final FileOutputStream out=new FileOutputStream(file);\n  byte buf[]=new byte[1024];\n  int len;\n  while ((len=is.read(buf)) > 0) {\n    out.write(buf,0,len);\n  }\n  out.close();\n  is.close();\n  Runtime.getRuntime().exec(\"chmod \" + mode + \" \"+ abspath).waitFor();\n}\n", "nl": "copy file to destination"}
{"code": "public boolean hasUnalignedCharAt(int col){\n  if (col < getFirstNonGapPosition()) {\n    int firstUnalignedPrefixPos=getFirstNonGapPosition() - unalignedPrefix.length();\n    if (col > firstUnalignedPrefixPos)     return true;\n  }\n else   if (col >= getLastNonGapPosition()) {\n    int lastUnalignedSuffixPos=getLastNonGapPosition() + unalignedSuffix.length();\n    if (col < lastUnalignedSuffixPos)     return true;\n  }\n  return false;\n}\n", "nl": "is there an unaligned character at this position?"}
{"code": "public static int hash(String key,int bitSize,String input,String hashType){\n  int bitLimitedHash;\n  try {\n    MessageDigest md=MessageDigest.getInstance(hashType);\n    byte[] array=md.digest(input.getBytes());\n    int hashInt=fromByteArray(array);\n    bitLimitedHash=hashInt;\n    if (bitSize < 32) {\n      bitLimitedHash=(0xFFFFFFFF >>> (32 - bitSize)) & hashInt;\n    }\n    logger.debug(\"hashInt = \" + hashInt + \" bitLimitedHash = \"+ bitLimitedHash);\n  }\n catch (  NoSuchAlgorithmException e) {\n    logger.info(e.toString());\n    bitLimitedHash=hash(key,bitSize,input);\n  }\n  return bitLimitedHash;\n}\n", "nl": "Hash method to optionally specify a hash type other than the default java hashCode() hashType must be MD5, SHA-1, or SHA-256"}
{"code": "public static void installApk(Context context,String filename){\n  Intent intent=new Intent();\n  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n  intent.setAction(Intent.ACTION_VIEW);\n  String type=\"application/vnd.android.package-archive\";\n  File pluginfile=new File(filename);\n  intent.setDataAndType(Uri.fromFile(pluginfile),type);\n  if (context instanceof Activity) {\n    ((Activity)context).startActivityForResult(intent,REQUEST_INSTALL);\n  }\n  context.startActivity(intent);\n}\n", "nl": "install apk"}
{"code": "private void drawCenterRect(Canvas canvas){\n  int center=getHeight() / 2;\n  int offset=(int)(getItemHeight() / 2 * 1.2);\n  Paint paint=new Paint();\n  paint.setColor(getResources().getColor(R.color.province_line_border));\n  paint.setStrokeWidth((float)3);\n  canvas.drawLine(0,center - offset,getWidth(),center - offset,paint);\n  canvas.drawLine(0,center + offset,getWidth(),center + offset,paint);\n}\n", "nl": "Draws rect for current value"}
{"code": "private static void loadTargets(){\n  ourTargets.clear();\n  IAndroidTarget[] targets=getCompilationTargets();\n  if (AndroidSdkUtils.isAndroidSdkAvailable()) {\n    String[] knownVersions=TemplateUtils.getKnownVersions();\n    for (int i=0; i < knownVersions.length; i++) {\n      AndroidTargetComboBoxItem targetInfo=new AndroidTargetComboBoxItem(knownVersions[i],i + 1);\n      ourTargets.add(targetInfo);\n    }\n  }\n  for (  IAndroidTarget target : targets) {\n    if (target.getVersion().isPreview() || !target.getAdditionalLibraries().isEmpty()) {\n      AndroidTargetComboBoxItem targetInfo=new AndroidTargetComboBoxItem(target);\n      ourTargets.add(targetInfo);\n    }\n  }\n}\n", "nl": "Load the definitions of the android compilation targets"}
{"code": "private boolean isConfigurationPluginAvailable(){\n  if (configurationPluginAvailable == null) {\n    try {\n      String value=APILocator.getPluginAPI().loadProperty(pluginName,\"environment\");\n      configurationPluginAvailable=(value != null);\n    }\n catch (    Exception e) {\n      Logger.warn(this,\"Exception while trying to get property 'environment' \",e);\n      configurationPluginAvailable=false;\n    }\n    Logger.info(this,\"Configuration plugin available: \" + configurationPluginAvailable);\n  }\n  return configurationPluginAvailable;\n}\n", "nl": "Check for the \"environment\" key in the pluginAPI"}
{"code": "boolean isAlive(){\n  if (vertex == null)   return false;\n  try {\n    return vertex.property(Schema.BaseType.TYPE.name()).isPresent();\n  }\n catch (  IllegalStateException e) {\n    return false;\n  }\n}\n", "nl": "Checks if the underlaying vertex has not been removed and if it is not a ghost"}
{"code": "public JavaStreamingAudioPlayer(){\n  debug=Utilities.getBoolean(\"com.sun.speech.freetts.audio.AudioPlayer.debug\");\n  cancelDelay=Utilities.getLong(\"com.sun.speech.freetts.audio.AudioPlayer.cancelDelay\",0L).longValue();\n  drainDelay=Utilities.getLong(\"com.sun.speech.freetts.audio.AudioPlayer.drainDelay\",150L).longValue();\n  openFailDelayMs=Utilities.getLong(\"com.sun.speech.freetts.audio.AudioPlayer.openFailDelayMs\",0L).longValue();\n  totalOpenFailDelayMs=Utilities.getLong(\"com.sun.speech.freetts.audio.AudioPlayer.totalOpenFailDelayMs\",0L).longValue();\n  audioMetrics=Utilities.getBoolean(\"com.sun.speech.freetts.audio.AudioPlayer.showAudioMetrics\");\n  line=null;\n  setPaused(false);\n}\n", "nl": "Constructs a default JavaStreamingAudioPlayer"}
{"code": "public int recv(long fileSize,byte[] data,int bytes){\n  try {\n    out.write(data,0,bytes);\n  }\n catch (  IOException ex) {\n    ex.printStackTrace();\n    return -1;\n  }\n  currentBytes+=bytes;\n  if (this.currentBytes == fileSize) {\n    this.currentBytes=0;\n  }\n  return 0;\n}\n", "nl": "recv file content callback function, may be called more than once when the file downloaded"}
{"code": "private File[] listFiles(File file){\n  File[] children=null;\n  if (file.isDirectory()) {\n    children=fileFilter == null ? file.listFiles() : file.listFiles(fileFilter);\n  }\n  if (children == null) {\n    children=FileUtils.EMPTY_FILE_ARRAY;\n  }\n  if (comparator != null && children.length > 1) {\n    Arrays.sort(children,comparator);\n  }\n  return children;\n}\n", "nl": "List the contents of a directory"}
{"code": "public static String optimizedPathFor(File path,File optimizedDirectory){\n  String fileName=path.getName();\n  if (!fileName.endsWith(ShareConstants.DEX_SUFFIX)) {\n    int lastDot=fileName.lastIndexOf(\".\");\n    if (lastDot < 0) {\n      fileName+=ShareConstants.DEX_SUFFIX;\n    }\n else {\n      StringBuilder sb=new StringBuilder(lastDot + 4);\n      sb.append(fileName,0,lastDot);\n      sb.append(ShareConstants.DEX_SUFFIX);\n      fileName=sb.toString();\n    }\n  }\n  File result=new File(optimizedDirectory,fileName);\n  return result.getPath();\n}\n", "nl": "change the jar file path as the makeDexElements do"}
{"code": "public void testWriteReadFull() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(replicationPolicyDesc);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  ReplicationPolicyDescription copy=(ReplicationPolicyDescription)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(replicationPolicyDesc,copy));\n}\n", "nl": "Test read and write full ClusterPolicy object"}
{"code": "public void addPages(){\n  mainPage=new MoveRemoteResourceWizardMainPage(\"newRemoteFolderPage1\",Policy.bind(\"MoveRemoteFolderWizard.heading\"),SVNUIPlugin.getPlugin().getImageDescriptor(ISVNUIConstants.IMG_WIZBAN_NEW_FOLDER));\n  mainPage.setRemoteResource(selection);\n  addPage(mainPage);\n  String pageTitle=Policy.bind(\"CommentCommitWizardPage.pageTitle\");\n  String pageDescription=Policy.bind(\"CommentCommitWizardPage.pageDescription\");\n  ImageDescriptor image=SVNUIPlugin.getPlugin().getImageDescriptor(ISVNUIConstants.IMG_WIZBAN_NEW_FOLDER);\n  commitCommentPage=new CommentCommitWizardPage(parentDialog,pageTitle,pageTitle,image,pageDescription);\n  addPage(commitCommentPage);\n}\n", "nl": "Creates the wizard pages"}
{"code": "static Map<Integer,Integer> computeInputMapFromLeaves(Director dir,boolean useInternal,boolean useUnassigned){\n  Map<Integer,Integer> map=new TreeMap<>();\n  PhyloTree tree=dir.getMainViewer().getTree();\n  for (Node v=tree.getFirstNode(); v != null; v=v.getNext()) {\n    if (useInternal || v.getDegree() == 1) {\n      Integer taxId=(Integer)v.getInfo();\n      if (taxId != null && (useUnassigned || !(taxId.equals(IdMapper.NOHITS_ID) || taxId.equals(IdMapper.UNASSIGNED_ID) || taxId.equals(IdMapper.LOW_COMPLEXITY_ID)))) {\n        int count=((NodeData)v.getData()).getCountSummarized();\n        map.put(taxId,count);\n      }\n    }\n  }\n  return map;\n}\n", "nl": "compute the input map from all nodes of the input taxonomy"}
{"code": "public boolean hasSelectedSubTree(){\n  boolean foundASelectedRoot=false;\n  if (treeView.getNumberSelectedNodes() > 1) {\n    for (    Node v : treeView.getSelectedNodes()) {\n      if (v.getInDegree() == 0 || !treeView.getSelected(v.getFirstInEdge().getSource())) {\n        if (foundASelectedRoot)         return false;\n else         foundASelectedRoot=true;\n      }\n    }\n  }\n  return foundASelectedRoot;\n}\n", "nl": "does the tree have exactly one selected subtree?"}
{"code": "public SiteAdminPage open(String nodePath){\n  webDriver.get(authorDomain + WCM_PATH + \"#\"+ nodePath);\n  String wcmTitle=getWcmTitle();\n  if (StringUtils.isNotBlank(nodePath)) {\n    bobcatWait.withTimeout(Timeouts.BIG).until(not(titleIs(wcmTitle)));\n  }\n else {\n    bobcatWait.withTimeout(Timeouts.BIG).until(titleIs(wcmTitle));\n  }\n  grid.getActionBar().waitToBeDisplayed();\n  grid.waitForLoaderNotPresent();\n  return this;\n}\n", "nl": "Opens Site Admin at specified node: http://domain/siteadmin#/nodePath"}
{"code": "private static ScoutWidget[] removeGuidelines(ScoutWidget[] list){\n  ArrayList<ScoutWidget> al=new ArrayList<>();\n  for (  ScoutWidget aList : list) {\n    if (aList.mConstraintWidget instanceof Guideline) {\n      continue;\n    }\n    al.add(aList);\n  }\n  return al.toArray(new ScoutWidget[al.size()]);\n}\n", "nl": "Filter ScoutWidget's of GuideLine objects"}
{"code": "public int convert(String value){\n  if (Strings.isNullOrEmpty(value) || TypeUtils.MISSING_INDICATORS.contains(value) || value.equals(\"-1\")) {\n    return (int)ColumnType.LOCAL_TIME.getMissingValue();\n  }\n  value=Strings.padStart(value,4,'0');\n  if (selectedFormatter == null) {\n    selectedFormatter=TypeUtils.getTimeFormatter(value);\n  }\n  LocalTime time;\n  try {\n    time=LocalTime.parse(value,selectedFormatter);\n  }\n catch (  DateTimeParseException e) {\n    selectedFormatter=TypeUtils.TIME_FORMATTER;\n    time=LocalTime.parse(value,selectedFormatter);\n  }\n  return PackedLocalTime.pack(time);\n}\n", "nl": "Returns a PackedTime as converted from the given string"}
{"code": "public CartPaymentInfo makePaymentInfo(String id,String refNum,String authCode,BigDecimal amount){\n  CartPaymentInfo inf=new CartPaymentInfo();\n  inf.refNum[0]=refNum;\n  inf.refNum[1]=authCode;\n  inf.amount=amount;\n  inf.origAmount=amount;\n  if (!isPaymentMethodType(id)) {\n    inf.paymentMethodTypeId=this.getPaymentMethodTypeId(id);\n    inf.paymentMethodId=id;\n  }\n else {\n    inf.paymentMethodTypeId=id;\n  }\n  return inf;\n}\n", "nl": "Creates a CartPaymentInfo object with a possible authCode (may be null)"}
{"code": "public DivIconOptions build(){\n  DivIconOptions options=new DivIconOptions();\n  options.iconSize=this.iconSize;\n  options.iconAnchor=this.iconAnchor;\n  options.popUpAnchor=this.popUpAnchor;\n  options.className=this.className;\n  options.html=this.html;\n  return options;\n}\n", "nl": "Builds th DivIconOptions new instance"}
{"code": "private int measureShort(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(2 * mRadius + getPaddingTop() + getPaddingBottom() + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the height of this view"}
{"code": "public CacheHeader(String key,Entry entry){\n  this.key=key;\n  this.size=entry.data.length;\n  this.etag=entry.etag;\n  this.serverDate=entry.serverDate;\n  this.lastModified=entry.lastModified;\n  this.ttl=entry.ttl;\n  this.softTtl=entry.softTtl;\n  this.responseHeaders=entry.responseHeaders;\n}\n", "nl": "Instantiates a new CacheHeader object"}
{"code": "public static String toJson(Map<String,String> map){\n  if (map == null || map.size() == 0) {\n    return null;\n  }\n  StringBuilder paras=new StringBuilder();\n  paras.append(\"{\");\n  Iterator<Map.Entry<String,String>> ite=map.entrySet().iterator();\n  while (ite.hasNext()) {\n    Map.Entry<String,String> entry=(Map.Entry<String,String>)ite.next();\n    paras.append(\"\\\"\").append(entry.getKey()).append(\"\\\":\\\"\").append(entry.getValue()).append(\"\\\"\");\n    if (ite.hasNext()) {\n      paras.append(\",\");\n    }\n  }\n  paras.append(\"}\");\n  return paras.toString();\n}\n", "nl": "join map"}
{"code": "public boolean testCssMinifier(){\n  StringBuilder sbCss1=new StringBuilder();\n  sbCss1.append(\"body {\");\n  sbCss1.append(\"\\n\\tbackground-color: black;\");\n  sbCss1.append(\"\\n\\tfont-size: Arial;\");\n  sbCss1.append(\"\\n}\");\n  StringBuilder sbCss2=new StringBuilder();\n  sbCss2.append(\"div {\");\n  sbCss2.append(\"\\n\\tcolor: red;\");\n  sbCss2.append(\"\\n\\tpadding: 10px;\");\n  sbCss2.append(\"\\n}\");\n  MinifierAPI minAPI=new MinifierAPI();\n  String minifiedCss1=minAPI.getMinfiedCss(sbCss1.toString());\n  String minifiedCss2=minAPI.getMinfiedCss(sbCss2.toString());\n  String actualMinifiedCss=minifiedCss1 + minifiedCss2;\n  String expectedMinifiedCssResult=\"body{background-color:black;font-size:Arial}div{color:red;padding:10px}\";\n  return actualMinifiedCss.equals(expectedMinifiedCssResult);\n}\n", "nl": "Test the CSS Minifier API"}
{"code": "public MonsterCursor queryMonsters(){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=true;\n  qh.Table=S.TABLE_MONSTERS;\n  qh.Columns=null;\n  qh.Selection=null;\n  qh.SelectionArgs=null;\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=S.COLUMN_MONSTERS_SORT_NAME;\n  qh.Limit=null;\n  return new MonsterCursor(wrapHelper(qh));\n}\n", "nl": "****************************** MONSTER QUERIES"}
{"code": "private static void assertJsonObjectEquals(String expected,String actual){\n  ObjectMapper mapper=new ObjectMapper();\n  TypeReference<Map<String,Object>> ref=new TypeReference<Map<String,Object>>(){\n  }\n;\n  try {\n    Map<String,Object> em=mapper.readValue(expected,ref);\n    Map<String,Object> am=mapper.readValue(actual,ref);\n    assertEquals(em,am);\n  }\n catch (  IOException e) {\n    throw new IllegalStateException(e);\n  }\n}\n", "nl": "Assert that two JSON objects are equal"}
{"code": "public boolean drain(){\n  if (line != null) {\n    debugPrint(\"started draining...\");\n    if (line.isOpen()) {\n      line.drain();\n      if (drainDelay > 0L) {\n        try {\n          Thread.sleep(drainDelay);\n        }\n catch (        InterruptedException ie) {\n        }\n      }\n    }\n    debugPrint(\"...finished draining\");\n  }\n  timer.stop(\"audioOut\");\n  return !isCancelled();\n}\n", "nl": "Waits for all queued audio to be played"}
{"code": "private void initialise(){\n  try {\n    maskByteRange=new int[noOfCol][];\n    maxKeys=new byte[noOfCol][];\n    for (int i=0; i < noOfCol; i++) {\n      maskByteRange[i]=getMaskByteRange(i);\n      long[] maxKey=new long[noOfCol];\n      maxKey[i]=Long.MAX_VALUE;\n      maxKeys[i]=keyGenerator.generateKey(maxKey);\n    }\n  }\n catch (  KeyGenException e) {\n    LOGGER.error(e,\"Key generation failed while evaulating column group min max\");\n  }\n}\n", "nl": "intitialising data required for min max calculation"}
{"code": "public void save(Boolean isCreate,Config config){\n  configDao.save(config);\n  if (isCreate) {\n    configDao.index(config);\n    if (!configDao.bindApp(config)) {\n      Logs.error(\"failed to bind app of config({})\",config);\n    }\n  }\n}\n", "nl": "Save the config"}
{"code": "private boolean tryToNotifyReset(){\n  if ((mStatus == PTR_STATUS_COMPLETE || mStatus == PTR_STATUS_PREPARE) && mPtrIndicator.isInStartPosition()) {\n    if (mPtrUIHandlerHolder.hasHandler()) {\n      mPtrUIHandlerHolder.onUIReset(this);\n      if (DEBUG) {\n        PtrCLog.i(LOG_TAG,\"PtrUIHandler: onUIReset\");\n      }\n    }\n    mStatus=PTR_STATUS_INIT;\n    clearFlag();\n    return true;\n  }\n  return false;\n}\n", "nl": "If at the top and not in loading, reset"}
{"code": "public static JavaTypeConverter determineCollectionConverter(ParameterizedType ptype){\n  JavaType javaType;\n  Type rawType=ptype.getRawType();\n  if (List.class.equals(rawType)) {\n    Class<?> listGenericType=(Class<?>)ptype.getActualTypeArguments()[0];\n    javaType=JsonUtil.INSTANCE.createCollectionType(List.class,listGenericType);\n  }\n else   if (Set.class.equals(rawType)) {\n    Class<?> setGenericType=(Class<?>)ptype.getActualTypeArguments()[0];\n    javaType=JsonUtil.INSTANCE.createCollectionType(Set.class,setGenericType);\n  }\n else {\n    Class<?> mapKeyType=(Class<?>)ptype.getActualTypeArguments()[0];\n    Class<?> mapValueType=(Class<?>)ptype.getActualTypeArguments()[1];\n    javaType=JsonUtil.INSTANCE.createCollectionType(Map.class,mapKeyType,mapValueType);\n  }\n  return new JavaTypeConverter(javaType);\n}\n", "nl": "Determine the collection type's converter"}
{"code": "public void waitToFinish(){\n  flush();\n  if (future != null) {\n    try {\n      future.get();\n    }\n catch (    InterruptedException|ExecutionException e) {\n      LOG.error(e.getMessage());\n    }\n  }\n  LOG.info(\"All tasks done!\");\n}\n", "nl": "Block the main thread until all of the transactions have finished loading"}
{"code": "public static float readFloat(DataInputStream dis,boolean isBigEndian) throws IOException {\n  float val;\n  if (!isBigEndian) {\n    val=readLittleEndianFloat(dis);\n  }\n else {\n    val=dis.readFloat();\n  }\n  return val;\n}\n", "nl": "Read a float from the input stream, byte-swapping as necessary"}
{"code": "public void accumulate(){\n  for (int i=0; i < iflen; i++)   iforces[i].init(this);\n  for (int i=0; i < sflen; i++)   sforces[i].init(this);\n  Iterator itemIter=items.iterator();\n  while (itemIter.hasNext()) {\n    ForceItem item=(ForceItem)itemIter.next();\n    item.force[0]=0.0f;\n    item.force[1]=0.0f;\n    for (int i=0; i < iflen; i++)     iforces[i].getForce(item);\n  }\n  Iterator springIter=springs.iterator();\n  while (springIter.hasNext()) {\n    Spring s=(Spring)springIter.next();\n    for (int i=0; i < sflen; i++) {\n      sforces[i].getForce(s);\n    }\n  }\n}\n", "nl": "Accumulate all forces acting on the items in this simulation"}
{"code": "public RVController(Npc slave,RiftEnum riftTemplate){\n  this.riftTemplate=riftTemplate;\n  this.isVortex=riftTemplate.isVortex();\n  this.maxEntries=riftTemplate.getEntries();\n  this.minLevel=riftTemplate.getMinLevel();\n  this.maxLevel=riftTemplate.getMaxLevel();\n  this.deSpawnedTime=((int)(System.currentTimeMillis() / 1000)) + (isVortex ? VortexService.getInstance().getDuration() * 3600 : RiftService.getInstance().getDuration() * 3600);\n  if (slave != null) {\n    this.slave=slave;\n    this.slaveSpawnTemplate=slave.getSpawn();\n    isMaster=true;\n    isAccepting=true;\n  }\n}\n", "nl": "Used to create master rifts or slave rifts (slave == null)"}
{"code": "private void init(){\n  mPaint=new Paint();\n  mPath=new Path();\n  startPoint=new Point(300,100);\n  endPoint=new Point(900,100);\n  assistPoint=new Point(600,300);\n  mPaint.setAntiAlias(true);\n  mPaint.setDither(true);\n}\n", "nl": "100         startPoint(300,100)               endPoint(900,100) 300                      assistPoint(600,300)"}
{"code": "private static double mlsafir(double x,double b[],int m,double a,double d[],int _pt3){\n  d[_pt3 + 0]=x;\n  d[_pt3 + 1]=(1 - a * a) * d[_pt3 + 0] + (a * d[_pt3 + 1]);\n  for (int i=2; i <= m; i++) {\n    d[_pt3 + i]+=a * (d[_pt3 + i + 1] - d[_pt3 + i - 1]);\n  }\n  double y=0.0;\n  for (int i=2; i <= m; i++) {\n    y+=d[_pt3 + i] * b[i];\n  }\n  for (int i=m + 1; i > 1; i--) {\n    d[_pt3 + i]=d[_pt3 + i - 1];\n  }\n  return y;\n}\n", "nl": "mlsafir: sub functions for MLSA filter"}
{"code": "public void testWriteReadEmpty() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(empty);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  FailOverPolicy.FailOverPolicyDescription copy=(FailOverPolicy.FailOverPolicyDescription)is.readObject();\n  is.close();\n  os.close();\n  assertNull(copy.m_BackupMemberNames);\n  assertNull(copy.m_BackupOnly);\n  assertEquals(-1,copy.m_PolicyType);\n}\n", "nl": "Test read and write empty ClusterPolicy object"}
{"code": "@Override protected void loadData() throws IOException, MaryConfigurationException {\n  cart=new DirectedGraphReader().load(dataStream);\n  try {\n    predictionFeatureNames=cart.getFeatureDefinition().getFeatureNames();\n  }\n catch (  NullPointerException e) {\n    throw new IOException(\"Could not get FeatureDefinition from CART\",e);\n  }\n  if (predictionFeatureNames.length() == 0) {\n    throw new IOException(\"Could not get prediction feature names\");\n  }\n}\n", "nl": "Load CART from file for this Model"}
{"code": "private Map<String,List<ChartObject>> mapRevert(Map<String,List<ChartObject>> input){\n  Map<String,List<ChartObject>> result=new LinkedHashMap<>();\n  for (  Map.Entry<String,List<ChartObject>> entry : input.entrySet()) {\n    List<ChartObject> newOrder=Lists.newArrayList();\n    List<ChartObject> data=entry.getValue();\n    for (int i=(data.size() - 1); i >= 0; i--)     newOrder.add(data.get(i));\n    result.put(entry.getKey(),newOrder);\n  }\n  return result;\n}\n", "nl": "Transformation function for avoidance of truncated results by filter"}
{"code": "public static BufferedImage toImage(INDArray matrix){\n  BufferedImage img=new BufferedImage(matrix.rows(),matrix.columns(),BufferedImage.TYPE_INT_ARGB);\n  WritableRaster r=img.getRaster();\n  int[] equiv=new int[matrix.length()];\n  for (int i=0; i < equiv.length; i++) {\n    equiv[i]=(int)matrix.getDouble(i);\n  }\n  r.setDataElements(0,0,matrix.rows(),matrix.columns(),equiv);\n  return img;\n}\n", "nl": "Convert a matrix in to a buffereed image"}
{"code": "public CacheHeader(String key,Entry entry){\n  this.key=key;\n  this.size=entry.data.length;\n  this.etag=entry.etag;\n  this.serverDate=entry.serverDate;\n  this.lastModified=entry.lastModified;\n  this.ttl=entry.ttl;\n  this.softTtl=entry.softTtl;\n  this.responseHeaders=entry.responseHeaders;\n}\n", "nl": "Instantiates a new CacheHeader object"}
{"code": "public INDArray toBgr(File file){\n  try {\n    BufferedInputStream bis=new BufferedInputStream(new FileInputStream(file));\n    INDArray ret=toBgr(bis);\n    bis.close();\n    return ret;\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Convert an input stream to an bgr spectrum image"}
{"code": "public void removeItem(int itemObjId){\n  if (items.containsKey(itemObjId)) {\n    LinkedHashMap<Integer,TradePSItem> newItems=new LinkedHashMap<Integer,TradePSItem>();\n    for (    int itemObjIds : items.keySet()) {\n      if (itemObjId != itemObjIds) {\n        newItems.put(itemObjIds,items.get(itemObjIds));\n      }\n    }\n    this.items=newItems;\n  }\n}\n", "nl": "This method will remove an item from the list"}
{"code": "@deprecated public boolean hasDateAndTimeFields(){\n  int foundMask=0;\n  for (  Object item : this.items) {\n    if ((item instanceof DateTimePatternGenerator.VariableField)) {\n      int type=((DateTimePatternGenerator.VariableField)item).getType();\n      foundMask|=1 << type;\n    }\n  }\n  boolean isDate=(foundMask & 0x3FF) != 0;\n  boolean isTime=(foundMask & 0xFC00) != 0;\n  return (isDate) && (isTime);\n}\n", "nl": "/*     "}
{"code": "public static void main(String[] args){\n  try {\n    ProgramProperties.setProgramName(\"SAM2RMA6\");\n    ProgramProperties.setProgramVersion(megan.main.Version.SHORT_DESCRIPTION);\n    PeakMemoryUsageMonitor.start();\n    (new SAM2RMA6()).run(args);\n    System.err.println(\"Total time:  \" + PeakMemoryUsageMonitor.getSecondsSinceStartString());\n    System.err.println(\"Peak memory: \" + PeakMemoryUsageMonitor.getPeakUsageString());\n    System.exit(0);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n    System.exit(1);\n  }\n}\n", "nl": "merge RMA files"}
{"code": "public static void paintClipped(@NotNull Graphics2D g,@NotNull BufferedImage image,@Nullable Device device,int x,int y,boolean withRetina){\n  Shape prevClip=null;\n  Shape clip=getClip(device,x,y,image.getWidth(),image.getHeight());\n  if (clip != null) {\n    prevClip=g.getClip();\n    g.setClip(clip);\n  }\n  if (withRetina) {\n    UIUtil.drawImage(g,image,x,y,null);\n  }\n else {\n    g.drawImage(image,x,y,null);\n  }\n  if (clip != null) {\n    g.setClip(prevClip);\n  }\n}\n", "nl": "Paints a rendered device image into the given graphics context "}
{"code": "public void applyOnMembers(Predicate<M> predicate){\n  lock();\n  try {\n    for (    TM member : members.values()) {\n      if (!predicate.apply(member.getObject())) {\n        return;\n      }\n    }\n  }\n  finally {\n    unlock();\n  }\n}\n", "nl": "Apply some predicate on all group member's objects<br> Should be used only to change state of the group or its members"}
{"code": "public synchronized void recordStatisticsForDriver(QueryStatistic statistic,String queryId){\n  if (queryStatisticsMap.get(queryId) != null) {\n    queryStatisticsMap.get(queryId).add(statistic);\n  }\n else {\n    List<QueryStatistic> newQueryStatistics=new ArrayList<QueryStatistic>();\n    newQueryStatistics.add(statistic);\n    queryStatisticsMap.put(queryId,newQueryStatistics);\n  }\n}\n", "nl": "Below method will be used to add the statistics"}
{"code": "@Override public boolean onOptionsItemSelected(MenuItem item){\nswitch (item.getItemId()) {\ncase R.id.task_delete_multi:\n    ArrayList<Selectable> list=new ArrayList<>(mTaskAdapter.getItemCount());\n  for (  Task task : mTaskAdapter.getDateSet()) {\n    list.add(new Selectable(false,false,task.getTitle()));\n  }\nSelectDialogFragment fragment=SelectDialogFragment.newInstance(list,R.string.task_delete_multi);\nfragment.show(getFragmentManager(),null);\nbreak;\n}\nreturn super.onOptionsItemSelected(item);\n}\n", "nl": "delete task"}
{"code": "public void saveFingerprintAsFile(byte[] fingerprint,String filename){\n  FileOutputStream fileOutputStream;\n  try {\n    fileOutputStream=new FileOutputStream(filename);\n    fileOutputStream.write(fingerprint);\n    fileOutputStream.close();\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Save fingerprint to a file"}
{"code": "public void registerBootstrapNamespaces() throws PulsarServerException {\n  if (registerNamespace(getHeartbeatNamespace(host,config),true)) {\n    this.uncountedNamespaces++;\n    LOG.info(\"added heartbeat namespace name in local cache: ns={}\",getHeartbeatNamespace(host,config));\n  }\n  for (  String namespace : config.getBootstrapNamespaces()) {\n    if (registerNamespace(namespace,false)) {\n      LOG.info(\"added bootstrap namespace name in local cache: ns={}\",namespace);\n    }\n  }\n}\n", "nl": "Register all the bootstrap name spaces including the heartbeat namespace"}
{"code": "public static int toRealPosition(int position,int count){\n  position=position - 1;\n  if (position < 0) {\n    position+=count;\n  }\n else {\n    position=position % count;\n  }\n  return position;\n}\n", "nl": "helper function which may be used when implementing FragmentPagerAdapter"}
{"code": "private static void deleteRecursiveSilent(CarbonFile f){\n  if (f.isDirectory()) {\n    if (f.listFiles() != null) {\n      for (      CarbonFile c : f.listFiles()) {\n        deleteRecursiveSilent(c);\n      }\n    }\n  }\n  if (f.exists() && !f.delete()) {\n    return;\n  }\n}\n", "nl": "this method will delete the folders recursively"}
{"code": "public boolean last() throws GenericEntityException {\n  try {\n    return resultSet.last();\n  }\n catch (  SQLException e) {\n    if (!closed) {\n      this.close();\n      Debug.logWarning(\"Warning: auto-closed EntityListIterator because of exception: \" + e.toString(),module);\n    }\n    throw new GenericEntityException(\"Error setting the cursor to last\",e);\n  }\n}\n", "nl": "Sets the cursor position to last result; if result set is empty returns false"}
{"code": "public void unify(String from,String to){\n  Set<Atomic> toRemove=new HashSet<>();\n  Set<Atomic> toAdd=new HashSet<>();\n  atomSet.stream().filter(null).forEach(null);\n  toRemove.forEach(null);\n  toRemove.forEach(null);\n  toAdd.forEach(null);\n  toAdd.forEach(null);\n  Map<String,String> mapping=new HashMap<>();\n  mapping.put(from,to);\n  updateSelectedVars(mapping);\n}\n", "nl": "change each variable occurrence in the query (apply unifier [from/to])"}
{"code": "public double norm1(){\n  double f=0;\n  for (int j=0; j < n; j++) {\n    double s=0;\n    for (int i=0; i < m; i++) {\n      s+=Math.abs(A[i][j]);\n    }\n    f=Math.max(f,s);\n  }\n  return f;\n}\n", "nl": "One norm"}
{"code": "public boolean gotoFirst(){\n  countCurrent=0;\n  if (!searchInCollapsed) {\n    final List<Integer> list=classificationViewer.computeDisplayedIdsInSearchOrder();\n    currentIterator=list.iterator();\n    numberOfObjects=list.size();\n  }\n else {\n    final List<Integer> list=classificationViewer.computeAllIdsInSearchOrder();\n    currentIterator=list.iterator();\n    numberOfObjects=list.size();\n  }\n  currentId=(currentIterator.hasNext() ? currentIterator.next() : null);\n  return isCurrentSet();\n}\n", "nl": "goto the first object"}
{"code": "private void onCreateFolderOperationFinish(CreateFolderOperation operation,RemoteOperationResult result){\n  if (result.isSuccess()) {\n    String remotePath=operation.getRemotePath().substring(0,operation.getRemotePath().length() - 1);\n    String newFolder=remotePath.substring(remotePath.lastIndexOf(\"/\") + 1);\n    mParents.push(newFolder);\n    populateDirectoryList();\n  }\n else {\n    try {\n      Toast msg=Toast.makeText(this,ErrorMessageAdapter.getErrorCauseMessage(result,operation,getResources()),Toast.LENGTH_LONG);\n      msg.show();\n    }\n catch (    NotFoundException e) {\n      Log_OC.e(TAG,\"Error while trying to show fail message \",e);\n    }\n  }\n}\n", "nl": "Updates the view associated to the activity after the finish of an operation trying create a new folder"}
{"code": "private void putLocalVersioned(SpaceMapEntry newEnvelope,Object key,Object value,CacheEntry cacheEntry){\n  VersionCacheEntry versionEntry=new VersionCacheEntry(newEnvelope.getVersion());\n  boolean replaced=_cache.replace(key,versionEntry,cacheEntry);\n  if (!versionEntry.isChecked() && _putFirst) {\n    if (_cache.size() >= _sizeLimit)     _evictionStrategy.evict(this);\n    Object old=_cache.putIfAbsent(key,cacheEntry);\n    if (old != null) {\n      replaced=_cache.replace(key,versionEntry,cacheEntry);\n    }\n  }\n  if (replaced) {\n    Object entry=versionEntry.getOldEntry();\n    if (!(entry instanceof DummyCacheEntry))     _evictionStrategy.discardEntry((CacheEntry)entry);\n  }\n}\n", "nl": "Save version value in local cache"}
{"code": "private boolean push(byte mode){\n  ++top;\n  if (top >= stack.length) {\n    if (top >= depth) {\n      return false;\n    }\n    stack=Arrays.copyOf(stack,Math.min(stack.length * 2,depth));\n  }\n  stack[top]=mode;\n  return true;\n}\n", "nl": "Push a mode onto the stack"}
{"code": "public void close(){\n  if (textStorageReader != null)   textStorageReader.closeAllFiles();\n  if (dataIndexReader != null)   try {\n    dataIndexReader.close();\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n}\n", "nl": "closes the accessor"}
{"code": "public int addAll(SplitSystem splits){\n  int count=0;\n  for (Iterator it=splits.iterator(); it.hasNext(); ) {\n    Split split=(Split)it.next();\n    if (!split2index.keySet().contains(split)) {\n      addSplit(split);\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "add all given splits that are not already present (as splits, ignoring weights etc)"}
{"code": "public M best(final G game,final IMoveGenerator<M,G> generator,int depthmax) throws TimeoutException {\n  try {\n    this.depthmax=depthmax;\n    final MinMaxEvaluatedMove best=minimax(game,generator,depthmax,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,game.currentPlayer() == 0,killer);\n    killer=best;\n    return best.getMove();\n  }\n catch (  final AlphaBetaPrunningException e) {\n    throw new RuntimeException(\"evaluated move found with value not between + infinity and - infinity...\");\n  }\n}\n", "nl": "Search in the game tree the best move using minimax with alpha beta pruning"}
{"code": "@RequestMapping(value=ClientUris.CONFIG_FETCHES,method=RequestMethod.GET) public List<ConfigItem> fetches(@RequestParam(\"names\") String names){\n  ClientSession client=ClientContext.get();\n  assert client != null;\n  List<String> nameList=Splitters.COMMA.splitToList(names);\n  Response<List<Config>> configsResp=configService.findByNames(client.getAppId(),nameList);\n  if (!configsResp.isSuccess()) {\n    Logs.error(\"failed to fetch configs(names={}), cause: {}\",names,configsResp.getErr());\n    return Collections.emptyList();\n  }\n  return ConfigItemFactory.creates(configsResp.getData());\n}\n", "nl": "Fetch some configs"}
{"code": "public static void writeResultFile(File file,Map<String,List<QueryResponseJSON>> resultMap) throws IOException {\n  try (BufferedWriter bw=new BufferedWriter(new FileWriter(file))){\n    for (    Entry<String,List<QueryResponseJSON>> entry : resultMap.entrySet()) {\n      for (      QueryResponseJSON hitJSON : entry.getValue()) {\n        bw.write(hitJSON.getJSONString());\n        bw.newLine();\n      }\n    }\n  }\n }\n", "nl": "Writes elements of the resultMap to output file, one line for each element, where each line is a string representation of the corresponding QueryResponseJSON object"}
{"code": "public static int confirmValues(String confirmTitle,String[] titles,String[] values){\n  if (titles.length == 0 || (titles.length != values.length)) {\n    return -1;\n  }\n  JTable table=new JTable();\n  table.setModel(new DefaultTableModel(new Object[][]{},new String[]{\" \",\" \"}));\n  SwingUtil.TableUtil.ensureRowNumber(table,titles.length);\n  for (int i=0; i < titles.length; i++) {\n    table.setValueAt(titles[i],i,0);\n    table.setValueAt(values[i],i,1);\n  }\n  JScrollPane mainPanel=new JScrollPane(table);\n  return JOptionPane.showConfirmDialog(null,mainPanel,confirmTitle,JOptionPane.YES_NO_OPTION);\n}\n", "nl": "Show a list of fields and values of them for user to confirm"}
{"code": "public void updateFloatingActionButton(View dependency){\n  if (dependency != null && dependency instanceof FloatingActionButton) {\n    floatingActionButton=(FloatingActionButton)dependency;\n    if (!fabBottomMarginInitialized && dependency.getLayoutParams() instanceof ViewGroup.MarginLayoutParams) {\n      fabBottomMarginInitialized=true;\n      ViewGroup.MarginLayoutParams p=(ViewGroup.MarginLayoutParams)dependency.getLayoutParams();\n      fabDefaultBottomMargin=p.bottomMargin;\n    }\n  }\n}\n", "nl": "Update floating action button bottom margin"}
{"code": "private void addShadowView(){\n  if (mShadowView == null) {\n    mShadowView=new ShadowView(getContext());\n    mShadowView.setX(-SHADOW_WIDTH);\n  }\n  final FrameLayout.LayoutParams layoutParams=new FrameLayout.LayoutParams(SHADOW_WIDTH,FrameLayout.LayoutParams.MATCH_PARENT);\n  final FrameLayout contentView=mCurrentContentView;\n  contentView.addView(mShadowView,1,layoutParams);\n}\n", "nl": "add shadow view on the left of content view"}
{"code": "public void clearOnlyItems(){\n  List<Insertion> insertions=new ArrayList<>();\n  insertions.addAll(getHeaders());\n  insertions.addAll(getOnlyInsertions());\n  insertions.addAll(getFooters());\n  mInserts.clear();\n  getItems().clear();\n  mOnlyItemsCount=0;\n  reAddAllInserts(insertions);\n  notifyIfNeed();\n}\n", "nl": "Clear only items (exclude all insertions)"}
{"code": "static Object newInstance(String className,ClassLoader cl,boolean doFallback) throws ConfigurationError {\n  try {\n    Class providerClass=findProviderClass(className,cl,doFallback);\n    Object instance=providerClass.newInstance();\n    if (DEBUG)     debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \"+ cl);\n    return instance;\n  }\n catch (  ClassNotFoundException x) {\n    throw new ConfigurationError(\"Provider \" + className + \" not found\",x);\n  }\ncatch (  Exception x) {\n    throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \"+ x,x);\n  }\n}\n", "nl": "Create an instance of a class using the specified ClassLoader"}
{"code": "@Override public void processUtterance(Utterance utterance) throws ProcessException {\n  Relation tokenRelation;\n  if ((tokenRelation=utterance.getRelation(Relation.TOKEN)) == null) {\n    throw new IllegalStateException(\"TokenToWords: Token relation does not exist\");\n  }\n  WordRelation wordRelation=WordRelation.createWordRelation(utterance,this);\n  for (Item tokenItem=tokenRelation.getHead(); tokenItem != null; tokenItem=tokenItem.getNext()) {\n    FeatureSet featureSet=tokenItem.getFeatures();\n    String tokenVal=featureSet.getString(\"name\");\n    tokenToWords(wordRelation,tokenItem,tokenVal);\n  }\n}\n", "nl": "process the utterance"}
{"code": "public WishlistComponentCursor queryWishlistsComponent(SQLiteDatabase db){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=false;\n  qh.Table=S.TABLE_WISHLIST_COMPONENT;\n  qh.Columns=null;\n  qh.Selection=null;\n  qh.SelectionArgs=null;\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  SQLiteQueryBuilder qb=builderWishlistComponent();\n  Cursor cursor=qb.query(db,qh.Columns,qh.Selection,qh.SelectionArgs,qh.GroupBy,qh.Having,qh.OrderBy,qh.Limit);\n  return new WishlistComponentCursor(cursor);\n}\n", "nl": "Get all wishlist components using a specific db instance"}
{"code": "private void readFromVersion2Stream(StatusFromBytesStream dis) throws IOException {\n  readFromVersion1Stream(dis);\n  lockOwner=dis.readUTF();\n  if (lockOwner.equals(\"\"))   lockOwner=null;\n  lockCreationDate=dis.readLong();\n  lockComment=dis.readUTF();\n  if (lockComment.equals(\"\"))   lockComment=null;\n  readOnly=dis.readBoolean();\n}\n", "nl": "Just for backwards compatibility with workspaces stored with previous version"}
{"code": "private void checkUnsymmetricMatrix(final RealMatrix m){\n  try {\n    EigenDecomposition ed=new EigenDecomposition(m);\n    RealMatrix d=ed.getD();\n    RealMatrix v=ed.getV();\n    RealMatrix x=m.multiply(v);\n    RealMatrix y=v.multiply(d);\n    double diffNorm=x.subtract(y).getNorm();\n    Assert.assertTrue(\"The norm of (X-Y) is too large: \" + diffNorm + \", matrix=\"+ m.toString(),x.subtract(y).getNorm() < 1000 * Precision.EPSILON * FastMath.max(x.getNorm(),y.getNorm()));\n    RealMatrix invV=new LUDecomposition(v).getSolver().getInverse();\n    double norm=v.multiply(d).multiply(invV).subtract(m).getNorm();\n    Assert.assertEquals(0.0,norm,1.0e-10);\n  }\n catch (  Exception e) {\n    Assert.fail(\"Failed to create EigenDecomposition for matrix \" + m.toString() + \", ex=\"+ e.toString());\n  }\n}\n", "nl": "Checks that the eigen decomposition of a general (unsymmetric) matrix is valid by checking: A*V = V*D"}
{"code": "protected RequestHandle sendRequest(DefaultHttpClient client,HttpContext httpContext,HttpUriRequest uriRequest,String contentType,ResponseHandlerInterface responseHandler,Context context){\n  if (contentType != null) {\n    uriRequest.addHeader(\"Content-Type\",contentType);\n  }\n  responseHandler.setRequestHeaders(uriRequest.getAllHeaders());\n  responseHandler.setRequestURI(uriRequest.getURI());\n  Future<?> request=threadPool.submit(new AsyncHttpRequest(client,httpContext,uriRequest,responseHandler));\n  if (context != null) {\n    List<WeakReference<Future<?>>> requestList=requestMap.get(context);\n    if (requestList == null) {\n      requestList=new LinkedList<WeakReference<Future<?>>>();\n      requestMap.put(context,requestList);\n    }\n    requestList.add(new WeakReference<Future<?>>(request));\n  }\n  return new RequestHandle(request);\n}\n", "nl": "Puts a new request in queue as a new thread in pool to be executed"}
{"code": "private static TransferTagImpl createTagForValue(final Object tagValue){\n  DataTagQualityImpl tagQuality=new DataTagQualityImpl(TagQualityStatus.PROCESS_DOWN,\"Process Down\");\n  Timestamp sourceTimestamp=new Timestamp(System.currentTimeMillis());\n  Timestamp daqTimestamp=new Timestamp(System.currentTimeMillis());\n  Timestamp serverTimestamp=new Timestamp(System.currentTimeMillis());\n  String descr=\"Test transfer tag\";\n  String valDesc=\"Test val desc \\n \\t { \\\"test\\\" : \\\"1212\\\"}\\n}\";\n  String tagName=\"tag:name\";\n  String topicName=\"topic:name\";\n  TransferTagImpl transferTag=new TransferTagImpl(1234L,tagValue,valDesc,tagQuality,TagMode.TEST,sourceTimestamp,daqTimestamp,serverTimestamp,descr,tagName,topicName);\n  transferTag.addEquipmentIds(Arrays.asList(234L,4234L,234L));\n  transferTag.addSubEquipmentIds(Arrays.asList(1234L,14234L,1234L));\n  transferTag.addProcessIds(Arrays.asList(123L,3214L,123L));\n  transferTag.setValueClassName(tagValue.getClass().getName());\n  return transferTag;\n}\n", "nl": "Helper method to create a <code>TransferTagImpl</code> test object"}
{"code": "private void startPeerSync(String peer,int port){\n  boolean isDone=false;\n  localRedisConnect();\n  while (!isDone) {\n    try {\n      isDone=(this.localJedis.slaveof(peer,port) != null);\n      sleeper.sleepQuietly(1000);\n    }\n catch (    Exception e) {\n      localRedisConnect();\n    }\n  }\n}\n", "nl": "Connect to the peer with the same token, in order to start the warm up process"}
{"code": "public void removeUnusedTransaction(XtnEntry xtnEntry,boolean needLock){\n  try {\n    if (needLock)     xtnEntry.lock();\n    if (((ConcurrentHashMap<ServerTransaction,XtnEntry>)getXtnTable()).remove(xtnEntry.m_Transaction,xtnEntry))     m_TimedXtns.remove(xtnEntry.m_Transaction);\n  }\n  finally {\n    if (needLock)     xtnEntry.unlock();\n  }\n}\n", "nl": "Remove an unused transaction from handled transactions"}
{"code": "public static void createSAM(DAAParser daaParser,DAAMatchRecord matchRecord,ByteOutputBuffer buffer,byte[] queryAlphabet){\n  buffer.write(matchRecord.getQueryRecord().getQueryName());\n  buffer.writeString(\"\\t0\\t\");\n  buffer.write(matchRecord.getSubjectName());\n  buffer.writeString(String.format(\"\\t%d\\t255\\t\",matchRecord.getSubjectBegin() + 1));\n  writeCigar(matchRecord,buffer);\n  buffer.writeString(\"\\t*\\t0\\t0\\t\");\n  buffer.write(Translator.translate(matchRecord.getQuery(),queryAlphabet,matchRecord.getTranslatedQueryBegin(),matchRecord.getTranslatedQueryLen()));\n  buffer.writeString(\"\\t*\\t\");\n  float bitScore=daaParser.getHeader().computeAlignmentBitScore(matchRecord.getScore());\n  float evalue=daaParser.getHeader().computeAlignmentExpected(matchRecord.getQuery().length,matchRecord.getScore());\n  int percentIdentity=Utilities.computePercentIdentity(matchRecord);\n  int blastFrame=computeBlastFrame(matchRecord.getFrame());\n  buffer.writeString(String.format(\"AS:i:%d\\tNM:i:%d\\tZL:i:%d\\tZR:i:%d\\tZE:f:%.1e\\tZI:i:%d\\tZF:i:%d\\tZS:i:%d\\tMD:Z:\",(int)bitScore,matchRecord.getLen() - matchRecord.getIdentities(),matchRecord.getTotalSubjectLen(),matchRecord.getScore(),evalue,percentIdentity,blastFrame,matchRecord.getQueryBegin() + 1));\n  writeMD(matchRecord,buffer,queryAlphabet);\n  buffer.write((byte)'\\n');\n}\n", "nl": "create a sam line"}
{"code": "private ArrayList createParameters(polyglot.ast.ProcedureDecl procedure){\n  ArrayList parameters=new ArrayList();\n  Iterator formalsIt=procedure.formals().iterator();\n  while (formalsIt.hasNext()) {\n    polyglot.ast.Formal next=(polyglot.ast.Formal)formalsIt.next();\n    parameters.add(Util.getSootType(next.type().type()));\n  }\n  return parameters;\n}\n", "nl": "creates soot params from polyglot formals"}
{"code": "private static String parseRefSeqId(String aLine){\n  int pos=aLine.indexOf(IdParser.REFSEQ_TAG);\n  if (pos != -1) {\n    int start=pos + IdParser.REFSEQ_TAG.length();\n    int end=start;\n    while (end < aLine.length() && (Character.isLetterOrDigit(aLine.charAt(end)) || aLine.charAt(end) == '_'))     end++;\n    if (end > start)     return aLine.substring(start,end);\n  }\n  return null;\n}\n", "nl": "parses a Accession id"}
{"code": "private void remove(String world,PermissionHolder holder,String permission){\n  try {\n    if (world != null && !world.equals(\"\")) {\n      holder.unsetPermission(permission,server,world);\n    }\n else {\n      holder.unsetPermission(permission,server);\n    }\n  }\n catch (  ObjectLacksException ignored) {\n  }\n  save(holder);\n}\n", "nl": "Generic method to remove a permission from a holder"}
{"code": "private void initDictionaryDirPaths() throws IOException {\n  CarbonTablePath carbonTablePath=CarbonStorePath.getCarbonTablePath(this.carbonStorePath,carbonTableIdentifier);\n  String dictionaryLocation=carbonTablePath.getMetadataDirectoryPath();\n  FileFactory.FileType fileType=FileFactory.getFileType(dictionaryLocation);\n  if (!FileFactory.isFileExist(dictionaryLocation,fileType)) {\n    FileFactory.mkdirs(dictionaryLocation,fileType);\n  }\n  this.dictionaryFilePath=carbonTablePath.getDictionaryFilePath(columnIdentifier.getColumnId());\n  this.dictionaryMetaFilePath=carbonTablePath.getDictionaryMetaFilePath(columnIdentifier.getColumnId());\n}\n", "nl": "this method will form the dictionary directory paths"}
{"code": "public void showLoadingDialog(){\n  Fragment frag=getActivity().getSupportFragmentManager().findFragmentByTag(DIALOG_WAIT_TAG);\n  LoadingDialog loading=null;\n  if (frag == null) {\n    loading=new LoadingDialog(getResources().getString(R.string.wait_a_moment));\n    FragmentManager fm=getActivity().getSupportFragmentManager();\n    FragmentTransaction ft=fm.beginTransaction();\n    loading.show(ft,DIALOG_WAIT_TAG);\n  }\n else {\n    loading=(LoadingDialog)frag;\n    loading.setShowsDialog(true);\n  }\n}\n", "nl": "Show loading dialog"}
{"code": "private static String findMatchInArray(String strToMatch,String[] matchInArray,String[] returnInArray){\n  for (int i=0; i < matchInArray.length; i++) {\n    if (strToMatch.equals(matchInArray[i])) {\n      if (i < returnInArray.length) {\n        return returnInArray[i];\n      }\n else {\n        return null;\n      }\n    }\n  }\n  return null;\n}\n", "nl": "Finds a match of the given string in the given array, and returns the element at the same index in the returnInArray"}
{"code": "private void regulateAverageAngle(double endAngleRadians,int expandButtonCount){\n  if (!angleStartEqualsEnd && startAngleRadians == endAngleRadians) {\n    double tmp=2 * Math.PI / expandButtonCount;\n    if (averageAngleRadians < 0) {\n      averageAngleRadians=-tmp;\n    }\n else {\n      averageAngleRadians=tmp;\n    }\n  }\n}\n", "nl": "regulate averageAngleRadians if endAngleDegree - startAngleDegree = 360 to avoid the first button covers the last button"}
{"code": "@Override public int read() throws IOException {\n  if (this.remaining == 0) {\n    return -1;\n  }\n else {\n    int var1=this.in.read();\n    if (var1 >= 0) {\n      --this.remaining;\n    }\n    return var1;\n  }\n}\n", "nl": "Below method will be used to read the data from file"}
{"code": "public void put(long index,int value){\n  final int segment=(int)(index >>> SEGMENT_BITS);\n  final int position=(int)(index & SEGMENT_MASK);\n  final int old=segments[segment][position];\n  if (old == 0) {\n    if (value != 0) {\n      segments[segment][position]=value;\n      numberOfNonZeroEntries++;\n    }\n  }\n else {\n    segments[segment][position]=value;\n    if (value == 0)     numberOfNonZeroEntries--;\n  }\n  maxIndex=Math.max(maxIndex,index);\n}\n", "nl": "put a value"}
{"code": "private void unsubscribeRecord(){\n  if (this.record == null || this.record.isDestroyed()) {\n    return;\n  }\n  for (  Subscription subscription : this.subscriptions) {\n    if (subscription.recordPathChangedCallback != null) {\n      this.record.unsubscribe(subscription.path,subscription.recordPathChangedCallback);\n    }\n else     if (subscription.recordChangedCallback != null) {\n      this.record.unsubscribe(subscription.recordChangedCallback);\n    }\n  }\n  this.record.discard();\n}\n", "nl": "Unsubscribe all callbacks from current record"}
{"code": "@Override public String toString(){\n  StringBuilder str=new StringBuilder();\n  str.append(\"class = \\\"\" + getTierClass() + \"\\\" \\n\");\n  str.append(\"name = \\\"\" + getName() + \"\\\" \\n\");\n  str.append(\"xmin = \" + getXmin() + \" \\n\");\n  str.append(\"xmax = \" + getXmax() + \" \\n\");\n  str.append(\"intervals: size = \" + getNumberOfIntervals() + \" \\n\");\n  for (int i=0; i < getNumberOfIntervals(); i++) {\n    str.append(\"intervals [\" + (i + 1) + \"]:\\n\");\n    str.append(getInterval(i).toString());\n  }\n  return str.toString();\n}\n", "nl": "string representation, used for TextGrid output"}
{"code": "private Control createGeneralDecoratorPage(Composite parent){\n  Composite composite=new Composite(parent,SWT.NULL);\n  GridLayout layout=new GridLayout();\n  composite.setLayout(layout);\n  GridData data=new GridData();\n  data.horizontalAlignment=GridData.FILL;\n  composite.setLayoutData(data);\n  SWTUtils.createPreferenceLink((IWorkbenchPreferenceContainer)getContainer(),composite,\"org.eclipse.ui.preferencePages.Decorators\",Policy.bind(\"SVNDecoratorPreferencesPage.labelDecorationsLink\"));\n  showDirty=createCheckBox(composite,Policy.bind(\"SVNDecoratorPreferencesPage.computeDeep\"));\n  enableFontDecorators=createCheckBox(composite,Policy.bind(\"SVNDecoratorPreferencesPage.useFontDecorators\"));\n  SWTUtils.createPreferenceLink((IWorkbenchPreferenceContainer)getContainer(),composite,\"org.eclipse.ui.preferencePages.ColorsAndFonts\",Policy.bind(\"SVNDecoratorPreferencesPage.colorsAndFontsLink\"));\n  return composite;\n}\n", "nl": "create the Label Decoration/general page"}
{"code": "void saveRotationState(@NonNull ContentResolver contentResolver){\n  try {\n    originalAccelerometer=Settings.System.getInt(contentResolver,Settings.System.ACCELEROMETER_ROTATION);\n  }\n catch (  Settings.SettingNotFoundException e) {\n    Log.d(TAG,\"Could not read accelerometer rotation setting: \" + e.getMessage());\n  }\n  try {\n    originalUserRotation=Settings.System.getInt(contentResolver,Settings.System.USER_ROTATION);\n  }\n catch (  Settings.SettingNotFoundException e) {\n    Log.d(TAG,\"Could not read user rotation setting: \" + e.getMessage());\n  }\n  Settings.System.putInt(contentResolver,Settings.System.USER_ROTATION,Surface.ROTATION_0);\n  Settings.System.putInt(contentResolver,Settings.System.ACCELEROMETER_ROTATION,0);\n}\n", "nl": "Should be called before starting tests, to save original rotation values"}
{"code": "public static String replaceUnicodeEmojis(String s){\n  if (TextUtils.isEmpty(s)) {\n    return \"\";\n  }\n  for (int i=0; i < s.length(); i++) {\n    String key=s.substring(i,i + 1);\n    if ((Character.isLowSurrogate(key.charAt(0)) || Character.isHighSurrogate(key.charAt(0))) && s.length() > i + 1) {\n      key=s.substring(i,i + 2);\n    }\n    String emoji=UNICODE_TO_CHEAT_SHEET.get(key);\n    if (null != emoji) {\n      s=s.replace(key,emoji);\n    }\n  }\n  return s;\n}\n", "nl": "Replaces instances of Emoji unicode characters with their Emoji-Cheat sheet key"}
{"code": "public IEntryPacket toEntry(Object object) throws RemoteException, UnusableEntryException, UnknownTypeException {\n  if (object == null)   return null;\n  if (object instanceof SpaceMapEntry)   return _converter.toInternal(object);\n  if (object instanceof Map.Entry) {\n    Map.Entry entry=(Map.Entry)object;\n    SpaceMapEntry envelope=MapEntryFactory.create(entry.getKey(),entry.getValue());\n    return _converter.toInternal(envelope);\n  }\n  if (_converter != null)   return _converter.toInternal(object);\n  return null;\n}\n", "nl": "Converts given object to IGSEntry"}
{"code": "private void widgetModified(){\n  if (mWidget == null) {\n    return;\n  }\n  if (!mWidgetModified) {\n    mConstraintModel.getSelection().addModifiedWidget(mWidget);\n  }\n  mWidgetModified=true;\n  mConstraintModel.getDrawConstraintModels().forEach(null);\n  saveWidget();\n}\n", "nl": "Method is called when ever we modify the widget"}
{"code": "public App(final CharSequence caller,final Boolean debug,final CharSequence applicationId,final Integer versionCode,final CharSequence flavor,final CharSequence buildType,final CharSequence versionName){\n  this.caller=caller;\n  this.debug=debug;\n  this.applicationId=applicationId;\n  this.versionCode=versionCode;\n  this.flavor=flavor;\n  this.buildType=buildType;\n  this.versionName=versionName;\n}\n", "nl": "Build an immutable App Info object"}
{"code": "public String toString(){\n  final IOutputWriter w=new OutputWriterHumanReadable(new StringWriter());\n  try {\n    write(w,null);\n  }\n catch (  IOException e) {\n  }\n  return w.toString();\n}\n", "nl": "human readable representation"}
{"code": "public static List<String> readFileLines(String filePath,int maxFileLineDepth) throws FileNotFoundException {\n  List<String> lines=new ArrayList<>();\n  Scanner input=new Scanner(new File(filePath));\n  int counter=0;\n  while (input.hasNextLine() && counter < maxFileLineDepth) {\n    lines.add(input.nextLine());\n    counter++;\n  }\n  return lines;\n}\n", "nl": "Reads a certain amount of lines deep into a file to save on memory"}
{"code": "public void drawHeader(RecyclerView recyclerView,Canvas canvas,View header,Rect offset){\n  canvas.save();\n  if (recyclerView.getLayoutManager().getClipToPadding()) {\n    initClipRectForHeader(mTempRect,recyclerView,header);\n    canvas.clipRect(mTempRect);\n  }\n  canvas.translate(offset.left,offset.top);\n  header.draw(canvas);\n  canvas.restore();\n}\n", "nl": "Draws a header to a canvas, offsetting by some x and y amount"}
{"code": "public static List<String> parseRegexGroup(final String string,final String regex){\n  List<String> groupList=null;\n  if (string != null && regex != null) {\n    Pattern pattern=Pattern.compile(regex);\n    Matcher matcher=pattern.matcher(string);\n    int groupCount=matcher.groupCount();\n    int count=1;\n    groupList=new ArrayList<String>();\n    if (matcher.find()) {\n      while (count <= groupCount) {\n        groupList.add(matcher.group(count));\n        count++;\n      }\n    }\n  }\n  return groupList;\n}\n", "nl": "<p>Method:only for regex,parse regex group when regex include group</p>"}
{"code": "public static int calculateSampleSize(int srcWidth,int srcHeight,int dstWidth,int dstHeight){\n  final float srcAspect=(float)srcWidth / (float)srcHeight;\n  final float dstAspect=(float)dstWidth / (float)dstHeight;\n  if (srcAspect > dstAspect) {\n    return srcWidth / dstWidth;\n  }\n else {\n    return srcHeight / dstHeight;\n  }\n}\n", "nl": "Figure out what ratio we can load our image into memory at while still being bigger than our desired width and height"}
{"code": "@Override protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  int end=getDate(str,0,len,date);\n  parseTimeZone(str,end,len,date);\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != 'Z') {\n    normalize(date);\n  }\n  return date;\n}\n", "nl": "Parses, validates and computes normalized version of dateTime object"}
{"code": "private void load(VocalizationFeatureFileReader ffr,FeatureDefinition fDef){\n  this.featureVectors=ffr.featureVectorMapping(fDef);\n  this.featureDefinition=fDef;\n  weightFunction=new WeightFunc[featureDefinition.getNumberOfContinuousFeatures()];\n  WeightFunctionManager wfm=new WeightFunctionManager();\n  int nDiscreteFeatures=featureDefinition.getNumberOfByteFeatures() + featureDefinition.getNumberOfShortFeatures();\n  for (int i=0; i < weightFunction.length; i++) {\n    String weightFunctionName=featureDefinition.getWeightFunctionName(nDiscreteFeatures + i);\n    if (\"\".equals(weightFunctionName))     weightFunction[i]=wfm.getWeightFunction(\"linear\");\n else     weightFunction[i]=wfm.getWeightFunction(weightFunctionName);\n  }\n  rememberWhichWeightsAreNonZero();\n}\n", "nl": "load feature file reader and  feature definition for a cost function"}
{"code": "public void draw(Canvas c,Rect bounds){\n  mCirclePaint.setColor(mBackgroundColor);\n  mCirclePaint.setAlpha(mAlpha);\n  c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mArcPaint.setColor(mColors[mColorIndex]);\n  mArcPaint.setAlpha(mAlpha);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mArcPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n}\n", "nl": "Draw the progress spinner"}
{"code": "private void fileSetBuildingTime(String contents,String fileName){\n  try {\n    File file=new File(fileName + \".log\");\n    FileWriter fw=new FileWriter(file,false);\n    fw.write(contents);\n    fw.flush();\n    fw.close();\n  }\n catch (  FileNotFoundException e) {\n    e.printStackTrace();\n    System.out.println(fileName + \".log file do not exist\");\n  }\ncatch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "write contents to file"}
{"code": "public void activate(){\n  getViewer().getSearchManager().setSearcher(getSearcher());\n  getViewer().getSearchManager().getFindDialogAsToolBar().clearMessage();\n  if (!inSelection) {\n    inSelection=true;\n    try {\n      chartSelection.clearSelectionClasses();\n      chartSelection.setSelectedClass(getSelectedLabels(),true);\n      this.repaint();\n    }\n  finally {\n      inSelection=false;\n    }\n  }\n}\n", "nl": "call this when tab containing list is activated"}
{"code": "private void drawCenterRect(Canvas canvas){\n  int center=getHeight() / 2;\n  int offset=(int)(getItemHeight() / 2 * 1.2);\n  Paint paint=new Paint();\n  paint.setColor(getResources().getColor(R.color.province_line_border));\n  paint.setStrokeWidth((float)3);\n  canvas.drawLine(0,center - offset,getWidth(),center - offset,paint);\n  canvas.drawLine(0,center + offset,getWidth(),center + offset,paint);\n}\n", "nl": "Draws rect for current value"}
{"code": "public void actionPerformed(ActionEvent ev){\n  if (isSelected())   execute(\"set idParsing=false cName=\" + cName + \";\");\n else {\n    String idTags=Basic.toString(ProgramProperties.get(cName + \"Tags\",IdMapper.createTags(cName)),\" \");\n    final JFrame frame=((getParent() instanceof IDirectableViewer) ? ((IDirectableViewer)getParent()).getFrame() : null);\n    idTags=JOptionPane.showInputDialog(frame,\"Enter tag(s) used to identify ids (separated by spaces):\",idTags);\n    if (idTags != null)     execute(\"set idParsing=true cName=\" + cName + \" prefix='\"+ idTags+ \"';\");\n else     execute(\"set idParsing=false cName=\" + cName + \";\");\n  }\n}\n", "nl": "action to be performed"}
{"code": "public static Map<String,Object> alwaysBadExpireProcessor(DispatchContext dctx,Map<String,? extends Object> context){\n  Locale locale=(Locale)context.get(\"locale\");\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  BigDecimal processAmount=(BigDecimal)context.get(\"processAmount\");\n  Debug.logInfo(\"Test Processor Bad Expire Date Credit Card\",module);\n  String refNum=UtilDateTime.nowAsString();\n  result.put(\"authResult\",Boolean.FALSE);\n  result.put(\"resultBadExpire\",Boolean.TRUE);\n  result.put(\"processAmount\",processAmount);\n  result.put(\"authRefNum\",refNum);\n  result.put(\"authAltRefNum\",refNum);\n  result.put(\"authFlag\",\"E\");\n  result.put(\"authMessage\",UtilProperties.getMessage(resource,\"AccountingPaymentTestProcessor\",locale));\n  return result;\n}\n", "nl": "Always fail/bad expire date processor"}
{"code": "public static void main(String[] args){\n  try {\n    ThreadPool tp=new ThreadPool(\"Unit Test Thread Pool\",5,10);\n    ThreadGroup group=tp.getThreadGroup();\n    group.list();\n    tp.destroy();\n    group.list();\n    tp.get();\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n  }\n  System.exit(0);\n}\n", "nl": "Unit Test"}
{"code": "public boolean isScreenOn(){\n  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ECLAIR_MR1) {\n    LogUtils.e(\"can not call isScreenOn if SDK_INT < 7 \");\n    return false;\n  }\n else {\n    return powerManager.isScreenOn();\n  }\n}\n", "nl": "Call requires API level 7"}
{"code": "@Override public void xml(String xml){\n  if (TextUtils.isEmpty(xml)) {\n    d(\"Empty/Null xml content\");\n    return;\n  }\n  try {\n    Source xmlInput=new StreamSource(new StringReader(xml));\n    StreamResult xmlOutput=new StreamResult(new StringWriter());\n    Transformer transformer=TransformerFactory.newInstance().newTransformer();\n    transformer.setOutputProperty(OutputKeys.INDENT,\"yes\");\n    transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\",\"2\");\n    transformer.transform(xmlInput,xmlOutput);\n    d(xmlOutput.getWriter().toString().replaceFirst(\">\",\">\\n\"));\n  }\n catch (  TransformerException e) {\n    e(e.getCause().getMessage() + \"\\n\" + xml);\n  }\n}\n", "nl": "Formats the json content and print it"}
{"code": "public MonsterStatusCursor queryMonsterStatus(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=false;\n  qh.Table=S.TABLE_MONSTER_STATUS;\n  qh.Columns=null;\n  qh.Selection=S.COLUMN_MONSTER_STATUS_MONSTER_ID + \" = ?\";\n  qh.SelectionArgs=new String[]{String.valueOf(id)};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new MonsterStatusCursor(wrapHelper(qh));\n}\n", "nl": "****************************** MONSTER STATUS QUERIES"}
{"code": "private static boolean isJsonString(final Object json){\n  boolean valid=false;\n  try {\n    if (json instanceof String) {\n      final JsonParser parser=mapper.getFactory().createParser((String)json);\n      while (parser.nextToken() != null) {\n      }\n      valid=true;\n    }\n  }\n catch (  IOException ignored) {\n  }\n  return valid;\n}\n", "nl": "Determine if the string is a valid json String"}
{"code": "public boolean removeUndefinedAttributes(){\n  LinkedList<String> undefined=new LinkedList<>();\n  for (  String attribute : getAttributeSet()) {\n    Map<String,Object> sample2values=getSamples2Values(attribute);\n    boolean ok=false;\n    for (    String sample : sample2values.keySet()) {\n      if (sample2values.get(sample) != null) {\n        ok=true;\n        break;\n      }\n    }\n    if (!ok)     undefined.add(attribute);\n  }\n  if (undefined.size() > 0)   removeAttributes(undefined);\n  return undefined.size() > 0;\n}\n", "nl": "removes all attributes for which no sample has a defined value"}
{"code": "public static List<String> toList(String s){\n  List<String> newList=new LinkedList<String>();\n  if (s.startsWith(\"[\") && s.endsWith(\"]\")) {\n    s=s.substring(1,s.length() - 1);\n    String[] entries=s.split(\"\\\\,\\\\s\");\n    for (    String entry : entries) {\n      newList.add(entry);\n    }\n  }\n else {\n    throw new IllegalArgumentException(\"String is not from List.toString()\");\n  }\n  return newList;\n}\n", "nl": "Reads a String version of a List (should contain only strings) and creates a new List"}
{"code": "public static SSLContext createSSLContext(String trustedCert,String clientKey,String clientCert){\n  try {\n    SSLContext ctx=SSLContext.getInstance(\"TLS\");\n    ctx.init(CertificateUtil.getKeyManagers(\"client\",clientKey,clientCert),CertificateUtil.getTrustManagers(\"server\",trustedCert),null);\n    return ctx;\n  }\n catch (  NoSuchAlgorithmException|KeyManagementException e) {\n    throw new RuntimeException(\"Failed to create SSLContext\",e);\n  }\n}\n", "nl": "Create a SSLContext for a given trusted certificate and client key and certificate"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  AttributesWindow viewer=(AttributesWindow)getViewer();\n  if (viewer != null) {\n    viewer.doSortByAlpha=true;\n    viewer.doSortByNrOfReads=false;\n    int div=viewer.getSplitPane().getDividerLocation();\n    viewer.getSplitPane().remove(viewer.getSplitPane().getTopComponent());\n    viewer.getSplitPane().setTopComponent(viewer.getTreePanel());\n    viewer.getSplitPane().setDividerLocation(div);\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public boolean filterOut(final SAMRecord record){\n  if (include) {\n    if (record.getProperPairFlag()) {\n      return false;\n    }\n  }\n else {\n    if (!record.getProperPairFlag()) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "public static void w(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_WARNING) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.w(tag,msg);\n}\n", "nl": "Send a WARNING log message"}
{"code": "public void uploadNewFile(Context context,Account account,String[] localPaths,String[] remotePaths,String[] mimeTypes,Integer behaviour,Boolean createRemoteFolder,int createdBy){\n  Intent intent=new Intent(context,FileUploader.class);\n  intent.putExtra(FileUploader.KEY_ACCOUNT,account);\n  intent.putExtra(FileUploader.KEY_LOCAL_FILE,localPaths);\n  intent.putExtra(FileUploader.KEY_REMOTE_FILE,remotePaths);\n  intent.putExtra(FileUploader.KEY_MIME_TYPE,mimeTypes);\n  intent.putExtra(FileUploader.KEY_LOCAL_BEHAVIOUR,behaviour);\n  intent.putExtra(FileUploader.KEY_CREATE_REMOTE_FOLDER,createRemoteFolder);\n  intent.putExtra(FileUploader.KEY_CREATED_BY,createdBy);\n  context.startService(intent);\n}\n", "nl": "Call to upload several new files"}
{"code": "public static String fieldNameToMethodName(String methodPrefix,String fieldName,boolean ignoreFirstLetterCase){\n  String methodName=null;\n  if (fieldName != null && fieldName.length() > 0) {\n    if (ignoreFirstLetterCase) {\n      methodName=methodPrefix + fieldName;\n    }\n else {\n      methodName=methodPrefix + fieldName.substring(0,1).toUpperCase() + fieldName.substring(1);\n    }\n  }\n else {\n    methodName=methodPrefix;\n  }\n  return methodName;\n}\n", "nl": "field name to method name"}
{"code": "public ItemToMaterialCursor queryItemsForMaterial(long material_item_id){\n  QueryHelper qh=new QueryHelper();\n  qh.Columns=null;\n  qh.Selection=\"itm.\" + S.COLUMN_ITEM_TO_MATERIAL_MATERIAL_ID + \" = ? \";\n  qh.SelectionArgs=new String[]{\"\" + material_item_id};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=\"itm.amount DESC\";\n  qh.Limit=null;\n  return new ItemToMaterialCursor(wrapJoinHelper(builderItemToMaterial(),qh));\n}\n", "nl": "****************************** ITEM TO MATERIAL QUERIES"}
{"code": "synchronized public void saveRobotList(List<RobotUser> robotList){\n  SQLiteDatabase db=dbHelper.getWritableDatabase();\n  if (db.isOpen()) {\n    db.delete(UserDao.ROBOT_TABLE_NAME,null,null);\n    for (    RobotUser item : robotList) {\n      ContentValues values=new ContentValues();\n      values.put(UserDao.ROBOT_COLUMN_NAME_ID,item.getUsername());\n      if (item.getNick() != null)       values.put(UserDao.ROBOT_COLUMN_NAME_NICK,item.getNick());\n      if (item.getAvatar() != null)       values.put(UserDao.ROBOT_COLUMN_NAME_AVATAR,item.getAvatar());\n      db.replace(UserDao.ROBOT_TABLE_NAME,null,values);\n    }\n  }\n}\n", "nl": "Save Robot list"}
{"code": "public SlickForm withDefaultFields(){\n  FormField userField=new FormField(mContext).withType(TEXT).withIcon(R.drawable.ic_slick_user).withHint(mContext.getString(R.string.form_field_username));\n  FormField emailField=new FormField(mContext).withType(TEXT).withIcon(R.drawable.ic_slick_email).withHint(mContext.getString(R.string.form_field_email));\n  FormField passField=new FormField(mContext).withType(PASSWORD).withIcon(R.drawable.ic_slick_lock).withHint(mContext.getString(R.string.form_field_password));\n  this.formFields.add(userField);\n  this.formFields.add(emailField);\n  this.formFields.add(passField);\n  return this;\n}\n", "nl": "Initialize the SlickSignForm with the 3 default steps which are: Username, Email, and Password"}
{"code": "public void loadRefAnnotations() throws IOException {\n  numberOfRefAnnotations=0;\n  refAnnotationIndexForTaxonomy=-1;\n  try (InputReaderLittleEndian ins=new InputReaderLittleEndian(new FileInputStreamAdapter(fileName))){\n    for (int b=0; b < blockTypeRank.length; b++) {\n      if (getBlockType(b) == BlockType.megan_ref_annotations) {\n        ins.seek(getLocationOfBlockInFile(b));\n        refAnnotationNames[numberOfRefAnnotations]=ins.readNullTerminatedBytes();\n        if (refAnnotationNames[numberOfRefAnnotations].equals(Classification.Taxonomy))         refAnnotationIndexForTaxonomy=numberOfRefAnnotations;\n        int[] annotations=refAnnotations[numberOfRefAnnotations]=new int[getNumberOfReferences()];\n        for (int i=0; i < getNumberOfReferences(); i++) {\n          annotations[i]=ins.readInt();\n        }\n        numberOfRefAnnotations++;\n      }\n    }\n  }\n }\n", "nl": "load all reference annotations from file"}
{"code": "public static ServiceClient createServiceClient(SSLContext sslContext,int requestPayloadSizeLimit){\n  ServiceClient serviceClient;\n  try {\n    serviceClient=NettyHttpServiceClient.create(ServiceClientFactory.class.getCanonicalName(),Executors.newFixedThreadPool(4),Executors.newScheduledThreadPool(1));\n    if (requestPayloadSizeLimit > 0) {\n      serviceClient.setRequestPayloadSizeLimit(requestPayloadSizeLimit);\n    }\n    serviceClient.setSSLContext(sslContext);\n    serviceClient.start();\n    return serviceClient;\n  }\n catch (  URISyntaxException e) {\n    throw new RuntimeException(\"Failed to create ServiceClient\",e);\n  }\n}\n", "nl": "Create a ServiceClient instance using the given SSLContext and requestPayloadSizeLimit"}
{"code": "private static int caculateInSampleSize(BitmapFactory.Options options,int rqsW,int rqsH){\n  final int height=options.outHeight;\n  final int width=options.outWidth;\n  int inSampleSize=1;\n  if (rqsW == 0 || rqsH == 0)   return 1;\n  if (height > rqsH || width > rqsW) {\n    final int heightRatio=Math.round((float)height / (float)rqsH);\n    final int widthRatio=Math.round((float)width / (float)rqsW);\n    inSampleSize=heightRatio < widthRatio ? heightRatio : widthRatio;\n  }\n  return inSampleSize;\n}\n", "nl": "caculate the bitmap sampleSize"}
{"code": "@Deployment(resources={\"org/activiti/engine/test/bpmn/callactivity/CallActivity.testTwoSubProcesses.bpmn20.xml\",\"org/activiti/engine/test/bpmn/callactivity/simpleSubProcess.bpmn20.xml\"}) public void testTwoSubProcesses(){\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"callTwoSubProcesses\");\n  List<ProcessInstance> instanceList=runtimeService.createProcessInstanceQuery().list();\n  assertNotNull(instanceList);\n  assertEquals(3,instanceList.size());\n  List<Task> taskList=taskService.createTaskQuery().list();\n  assertNotNull(taskList);\n  assertEquals(2,taskList.size());\n  runtimeService.deleteProcessInstance(processInstance.getId(),\"Test cascading\");\n  instanceList=runtimeService.createProcessInstanceQuery().list();\n  assertNotNull(instanceList);\n  assertEquals(0,instanceList.size());\n  taskList=taskService.createTaskQuery().list();\n  assertNotNull(taskList);\n  assertEquals(0,taskList.size());\n}\n", "nl": "Test case for deleting a sub process"}
{"code": "public ArenaQuestCursor queryArenaQuests(){\n  QueryHelper qh=new QueryHelper();\n  qh.Columns=null;\n  qh.Table=S.TABLE_ARENA_QUESTS;\n  qh.Selection=null;\n  qh.SelectionArgs=null;\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new ArenaQuestCursor(wrapJoinHelper(builderArenaQuest(),qh));\n}\n", "nl": "****************************** ARENA QUEST QUERIES"}
{"code": "public static String addToCartBulkRequirements(HttpServletRequest request,HttpServletResponse response){\n  ShoppingCart cart=getCartObject(request);\n  Delegator delegator=(Delegator)request.getAttribute(\"delegator\");\n  LocalDispatcher dispatcher=(LocalDispatcher)request.getAttribute(\"dispatcher\");\n  ShoppingCartHelper cartHelper=new ShoppingCartHelper(delegator,dispatcher,cart);\n  String controlDirective;\n  Map<String,Object> result;\n  Map<String,Object> paramMap=UtilHttp.getParameterMap(request);\n  String catalogId=CatalogWorker.getCurrentCatalogId(request);\n  result=cartHelper.addToCartBulkRequirements(catalogId,paramMap);\n  controlDirective=processResult(result,request);\n  if (controlDirective.equals(ERROR)) {\n    return \"error\";\n  }\n else {\n    return \"success\";\n  }\n}\n", "nl": "Adds a set of requirements to the cart"}
{"code": "public static void i(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_INFO) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.i(tag,msg);\n}\n", "nl": "Send an INFO log message"}
{"code": "public static void markAll(JTextComponent pane,Pattern pattern,SimpleMarker marker){\n  SyntaxDocument sDoc=ActionUtils.getSyntaxDocument(pane);\n  if (sDoc == null || pattern == null) {\n    return;\n  }\n  Matcher matcher=sDoc.getMatcher(pattern);\n  while (matcher.find()) {\n    markText(pane,matcher.start(),matcher.end(),marker);\n  }\n}\n", "nl": "Mark all text in the document that matches the given pattern"}
{"code": "private void logResponse(MessageResponse response) throws Exception {\n  Logging cloudantLogging=new Logging();\n  String intent=\"<no intent>\";\n  String confidence=\"<no confidence>\";\n  if (!response.getIntents().isEmpty() && response.getIntents().get(0) != null) {\n    intent=response.getIntents().get(0).getIntent();\n    confidence=response.getIntents().get(0).getConfidence().toString();\n  }\n  String entity=response.getEntities().size() > 0 ? \"Entity: \" + response.getEntities().get(0).getEntity() + \" Value:\"+ response.getEntities().get(0).getValue() : \"<no entity>\";\n  String convoOutput=(String)(response.getOutput().get(\"text\") != null ? response.getOutput().get(\"text\").toString() : \"<no response>\");\n  String convoId=(String)(response.getContext().get(\"conversation_id\") != null ? (response.getContext().get(\"conversation_id\")).toString() : \"<no conversation id>\");\n  String retrieveAndRankOutput=(String)(response.getOutput().get(\"CEPayload\") != null ? response.getOutput().get(\"CEPayload\").toString() : \"<no payload>\");\n  cloudantLogging.log(response.getInputText(),intent,confidence,entity,convoOutput,convoId,retrieveAndRankOutput);\n}\n", "nl": "This method takes in the response object and sends in to the cloudant logging class"}
{"code": "public static boolean isValueConstantValued(Value op){\n  if (op instanceof PhiExpr) {\n    Iterator<Value> argsIt=((PhiExpr)op).getValues().iterator();\n    Constant firstConstant=null;\n    while (argsIt.hasNext()) {\n      Value arg=argsIt.next();\n      if (!(arg instanceof Constant))       return false;\n      if (firstConstant == null)       firstConstant=(Constant)arg;\n else       if (!firstConstant.equals(arg))       return false;\n    }\n    return true;\n  }\n  return Evaluator.isValueConstantValued(op);\n}\n", "nl": "Returns true if given value is determined to be constant valued, false otherwise"}
{"code": "public void close() throws IOException {\n  if (io != null) {\n    try {\n      io.close();\n    }\n  finally {\n      io=null;\n    }\n  }\n}\n", "nl": "close the readerWriter/writer, if it is open"}
{"code": "public void connect(){\n  if (listeners.isEmpty()) {\n    AirMapLog.i(\"TrafficService\",\"No listeners, not connecting\");\n    return;\n  }\n  AirMapLog.i(\"TrafficService\",\"Connecting to Traffic Service\");\n  if (connectionState == ConnectionState.Connecting) {\n    return;\n  }\n  connectionState=ConnectionState.Connecting;\n  allTraffic.clear();\n  AirMap.getCurrentFlight(currentFlightCallback);\n}\n", "nl": "Connect to the server to receive updates"}
{"code": "private int measureHeight(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=mPaintSelected.getStrokeWidth() + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)FloatMath.ceil(result);\n}\n", "nl": "Determines the height of this view"}
{"code": "public static boolean shuffle(Object[] objArray,int shuffleCount){\n  int length;\n  if (objArray == null || shuffleCount < 0 || (length=objArray.length) < shuffleCount) {\n    return false;\n  }\n  for (int i=1; i <= shuffleCount; i++) {\n    int random=getRandom(length - i);\n    Object temp=objArray[length - i];\n    objArray[length - i]=objArray[random];\n    objArray[random]=temp;\n  }\n  return true;\n}\n", "nl": "Shuffling algorithm, Randomly permutes the specified array"}
{"code": "private static int writeMatches(IReadBlock readBlock,Writer w) throws IOException {\n  int countMatches=0;\n  String readHeader=readBlock.getReadHeader();\n  if (readHeader.startsWith(\">\"))   readHeader=readHeader.substring(1);\n  w.write(\"\\nQuery=\" + readHeader + \"\\n\");\n  final String readSequence=readBlock.getReadSequence();\n  if (readSequence != null)   w.write(\"\\t(\" + readSequence.length() + \" letters)\\n\");\n  w.write(\"\\n\");\n  if (readBlock.getNumberOfAvailableMatchBlocks() == 0)   w.write(\" ***** No hits found ******\\n\");\n else {\n    for (    IMatchBlock matchBlock : readBlock.getMatchBlocks()) {\n      w.write(matchBlock.getText() + \"\\n\");\n      countMatches++;\n    }\n  }\n  return countMatches;\n}\n", "nl": "write all matches associated with the given read"}
{"code": "private void abortLoading(){\n  if (thread == null)   return;\n  if (thread.isAlive()) {\n    thread.interrupt();\n    try {\n      thread.join();\n    }\n catch (    InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "nl": "Stop loading data task"}
{"code": "public static String elapsedTimeDisplay(Date dateStart,Date dateEnd){\n  long diff=dateEnd.getTime() - dateStart.getTime();\n  long diffMinutes=diff / (60 * 1000) % 60;\n  long diffHours=diff / (60 * 60 * 1000);\n  String mins=Long.toString(diffMinutes);\n  if (mins.length() == 1) {\n    mins=\"0\" + mins;\n  }\n  return Long.toString(diffHours) + \":\" + mins;\n}\n", "nl": "elapsedTimeDisplay Get the elapsed time between two dates in readable format"}
{"code": "public void adjust(boolean horizontal,boolean vertical){\n  if (horizontal) {\n    int newXValue=(int)Math.round(xFactor * (scrollBarX.getMaximum() - scrollBarX.getMinimum()) - xPortionOfVisible * scrollBarX.getVisibleAmount());\n    scrollBarX.setValue(newXValue);\n  }\n  if (vertical) {\n    int newYValue=(int)Math.round(yFactor * (scrollBarY.getMaximum() - scrollBarY.getMinimum()) - yPortionOfVisible * scrollBarY.getVisibleAmount());\n    scrollBarY.setValue(newYValue);\n  }\n}\n", "nl": "adjusts the scroll bars to recenter on world coordinates that were previously in center of window"}
{"code": "private boolean canRecreateLegion(Player activePlayer,Legion legion){\n  if (!isBrigadeGeneral(activePlayer)) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_DISPERSE_ONLY_MASTER_CAN_DISPERSE);\n    return false;\n  }\n else   if (!legion.isDisbanding()) {\n    return false;\n  }\n  return true;\n}\n", "nl": "This method checks all restrictions for recreate legion"}
{"code": "public void testWriteReadEmpty() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(empty);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  ReplicationPolicy copy=(ReplicationPolicy)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(empty,copy));\n}\n", "nl": "Test read and write empty ClusterPolicy object"}
{"code": "public CompletableFuture<Void> clearBacklog(){\n  log.info(\"[{}] Clearing backlog on all cursors in the topic.\",topic);\n  List<CompletableFuture<Void>> futures=Lists.newArrayList();\n  List<String> cursors=getSubscriptions().keys();\n  cursors.addAll(getReplicators().keys());\n  for (  String cursor : cursors) {\n    futures.add(clearBacklog(cursor));\n  }\n  return FutureUtil.waitForAll(futures);\n}\n", "nl": "Clears backlog for all cursors in the topic"}
{"code": "@Override public void innerDelete(){\n  Collection<? extends Concept> subSet=subTypes();\n  Collection<? extends Concept> instanceSet=instances();\n  subSet.remove(this);\n  if (subSet.isEmpty() && instanceSet.isEmpty()) {\n    deleteNode();\n  }\n else {\n    throw new ConceptException(ErrorMessage.CANNOT_DELETE.getMessage(toString()));\n  }\n}\n", "nl": "Deletes the concept as a type"}
{"code": "private void drawText(Canvas canvas,int index,Paint paint,String text){\n  if (isIllegalIndex(index)) {\n    return;\n  }\n  int x=getXByIndex(index);\n  int y=getYByIndex(index);\n  float top=cellHeight + (y - 1) * cellHeight;\n  float bottom=top + cellHeight;\n  float baseline=RenderUtil.getBaseline(top,bottom,paint);\n  float startX=RenderUtil.getStartX(cellWidth * (x - 1) + cellWidth * 0.5f,paint,text);\n  canvas.drawText(text,startX,baseline,paint);\n}\n", "nl": "draw text, around the middle of the cell decided by the index"}
{"code": "public boolean renameSample(String sample,String newName,boolean allowReplaceSample){\n  if (allowReplaceSample || !table.rowKeySet().contains(newName)) {\n    Map<String,Object> row=table.row(sample);\n    if (row != null) {\n      table.rowKeySet().remove(sample);\n      for (      String key : row.keySet()) {\n        table.put(newName,key,row.get(key));\n      }\n    }\n    int pos=Math.max(0,sampleOrder.indexOf(sample));\n    sampleOrder.remove(sample);\n    sampleOrder.add(pos,newName);\n    return true;\n  }\n  return false;\n}\n", "nl": "rename a sample"}
{"code": "public static <V>int addDistinctList(List<V> sourceList,List<V> entryList){\n  if (sourceList == null || isEmpty(entryList)) {\n    return 0;\n  }\n  int sourceCount=sourceList.size();\n  for (  V entry : entryList) {\n    if (!sourceList.contains(entry)) {\n      sourceList.add(entry);\n    }\n  }\n  return sourceList.size() - sourceCount;\n}\n", "nl": "add all distinct entry to list1 from list2"}
{"code": "public static void executeCommand(ProcessBuilder p) throws IOException {\n  Process proc=p.start();\n  try (BufferedReader stdInput=new BufferedReader(new InputStreamReader(proc.getInputStream()));BufferedReader stdError=new BufferedReader(new InputStreamReader(proc.getErrorStream()))){\n    logger.info(\"Standard output of the command:\\n\");\n    String s;\n    while ((s=stdInput.readLine()) != null) {\n      logger.info(s);\n    }\n    logger.info(\"Standard error of the command (if any):\\n\");\n    while ((s=stdError.readLine()) != null) {\n      logger.info(s);\n    }\n  }\n }\n", "nl": "Method to execute process"}
{"code": "public Object readResolve() throws ObjectStreamException {\n  Object stub=LRMIRuntime.getRuntime().getStubCache().getStub(_stubId);\n  if (stub == null) {\n    if (_stubCacheLogger.isLoggable(Level.FINEST))     _stubCacheLogger.finest(\"attempt to get stub from cache by id \" + _stubId + \" no cached stub exist under that id\");\n    throw new MissingCachedStubException(_stubId);\n  }\n  if (_stubCacheLogger.isLoggable(Level.FINEST))   _stubCacheLogger.finest(\"got stub from cache by id \" + _stubId + \" result stub toString() = \"+ stub);\n  return stub;\n}\n", "nl": "DONT REMOVE!!!! Called by the ObjectInputStream on deserialization"}
{"code": "public static boolean isItemRestrictedFrom(Player player,Item item,byte storage){\n  StorageType type=StorageType.getStorageTypeById(storage);\nswitch (type) {\ncase LEGION_WAREHOUSE:\n    if (!LegionService.getInstance().getLegionMember(player.getObjectId()).hasRights(LegionPermissionsMask.WH_WITHDRAWAL) || !LegionConfig.LEGION_WAREHOUSE || !player.isLegionMember()) {\n      PacketSendUtility.sendPacket(player,new SM_SYSTEM_MESSAGE(1300322));\n      return true;\n    }\n  break;\ndefault :\nbreak;\n}\nreturn false;\n}\n", "nl": "Check if item can be moved from storage by player"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"delete attribute=\");\n  Set<String> attributes=new HashSet<>();\n  while (!np.peekMatchIgnoreCase(\";\")) {\n    String attribute=np.getWordRespectCase();\n    attributes.add(attribute);\n  }\n  np.matchIgnoreCase(\";\");\n  if (attributes.size() > 0) {\n    final SamplesViewer viewer=((SamplesViewer)getViewer());\n    viewer.getSamplesTable().deleteColumns(attributes.toArray(new String[attributes.size()]));\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private void updateTreeDataItemsIdAndParentReference(String id){\n  int idCount=sameIdDataItemsMap.get(id);\n  for (  JsTreeDataItem item : this) {\n    if (item.getOriginalId().equals(id) && idCount >= 0) {\n      item.setId(item.getOriginalId() + JSTREE_FIELD_ID_SEPARATOR + idCount);\n      idCount--;\n    }\n    if (item.getParent().equals(id)) {\n      item.setParent(item.getParent() + JSTREE_FIELD_ID_SEPARATOR + idCount);\n    }\n  }\n}\n", "nl": "Updates the dataItemids that matches the id passed and as well as all the parent references"}
{"code": "@Override public boolean equals(Object obj){\n  if (obj instanceof FlexibleServletAccessor<?>) {\n    FlexibleServletAccessor<?> flexibleServletAccessor=(FlexibleServletAccessor<?>)obj;\n    if (this.name == null) {\n      return flexibleServletAccessor.name == null;\n    }\n    return this.name.equals(flexibleServletAccessor.name);\n  }\n else {\n    String str=(String)obj;\n    if (this.name == null) {\n      return str == null;\n    }\n    return this.name.equals(str);\n  }\n}\n", "nl": "The equals and hashCode methods are imnplemented just case this object is ever accidently used as a Map key"}
{"code": "private void printClusterData(){\n  assert clusterList != null;\n  System.out.println(\"Total No of Clusters: \" + clusterList.size());\n  Iterator<Cluster> it=clusterList.iterator();\n  for (int noCluster=1; it.hasNext(); noCluster++) {\n    Cluster aCluster=it.next();\n    ArrayList<String> listPoints=aCluster.getAllDataPoints();\n    System.out.println(\"Cluster Number : \" + noCluster);\n    for (int i=0; i < listPoints.size(); i++) {\n      System.out.print(listPoints.get(i) + \" \");\n    }\n    System.out.println();\n  }\n}\n", "nl": "Print cluster information"}
{"code": "public void changeAlpha(int value){\n  this.alpha+=value;\n  if (alpha > 255) {\n    alpha=255;\n  }\n else   if (alpha < 0) {\n    alpha=0;\n  }\n}\n", "nl": "Changes alpha value by that number"}
{"code": "public static boolean clipRange(double[] x,double minVal,double maxVal){\n  boolean modified=false;\n  if (x == null) {\n    return modified;\n  }\n  for (int i=0; i < x.length; i++) {\n    if (x[i] < minVal) {\n      x[i]=minVal;\n      modified=true;\n    }\n else     if (x[i] > maxVal) {\n      x[i]=maxVal;\n      modified=true;\n    }\n  }\n  return modified;\n}\n", "nl": "Adjust values in x so that all values smaller than minVal are set to minVal, and all values greater than maxVal are set to maxVal"}
{"code": "private void fillNonDictionaryArrayFromRow(CarbonRow row,Object[] outputArray){\n  if (nonDictionaryFieldIndexes.length > 0) {\n    byte[][] nonDictByteArray=new byte[nonDictionaryFieldIndexes.length][];\n    for (int i=0; i < nonDictByteArray.length; i++) {\n      nonDictByteArray[i]=row.getBinary(nonDictionaryFieldIndexes[i]);\n    }\n    byte[] nonDictionaryCols=RemoveDictionaryUtil.packByteBufferIntoSingleByteArray(nonDictByteArray);\n    outputArray[byteArrayIndexInRow]=nonDictionaryCols;\n  }\n}\n", "nl": "collect all non dictionary columns and compose it to single byte array and store it in 1 index of out put array"}
{"code": "public boolean write(byte[] bytes,int offset,int size){\n  if (firstSample) {\n    firstSample=false;\n    timer.stop(\"firstAudio\");\n    if (audioMetrics) {\n      timer.getTimer(\"firstAudio\").showTimesShortTitle(\"\");\n      timer.getTimer(\"firstAudio\").showTimesShort(0);\n    }\n  }\n  System.arraycopy(bytes,offset,outputData,curIndex,size);\n  curIndex+=size;\n  return true;\n}\n", "nl": "Writes the given bytes to the audio stream"}
{"code": "public INDArray asMatrix(InputStream inputStream) throws IOException {\n  if (channels == 3)   return toBgr(inputStream);\n  try {\n    BufferedImage image=ImageIO.read(inputStream);\n    return asMatrix(image);\n  }\n catch (  IOException e) {\n    throw new IOException(\"Unable to load image\",e);\n  }\n}\n", "nl": "Convert an input stream to a matrix"}
{"code": "public boolean hasSelectedMatchLevelNode(){\n  TreePath[] paths=dataTree.getSelectionPaths();\n  if (paths != null) {\n    for (    TreePath path : paths) {\n      if (getMatchLevelNodeFromPath(path) != null)       return true;\n    }\n  }\n  return false;\n}\n", "nl": "does window currently have a selected match node?"}
{"code": "private static void deleteRecursiveSilent(CarbonFile f){\n  if (f.isDirectory()) {\n    if (f.listFiles() != null) {\n      for (      CarbonFile c : f.listFiles()) {\n        deleteRecursiveSilent(c);\n      }\n    }\n  }\n  if (f.exists() && !f.delete()) {\n    return;\n  }\n}\n", "nl": "this method will delete the folders recursively"}
{"code": "public static String routeOrderEntry(HttpServletRequest request,HttpServletResponse response){\n  HttpSession session=request.getSession();\n  if (session.getAttribute(\"orderMode\") == null) {\n    return \"init\";\n  }\n  if (request.getParameter(\"orderMode\") != null) {\n    return \"agreements\";\n  }\n  return \"cart\";\n}\n", "nl": "Route order entry"}
{"code": "public void startIntent(String title,String... filters){\n  if (filters == null || filters.length == 0) {\n    startIntent(title);\n    return;\n  }\n  List<Intent> filteredIntents=getFilteredIntents(filters);\n  if (filteredIntents.size() == 0) {\n    startIntent(title);\n    return;\n  }\n  Intent tIntent=filteredIntents.remove(0);\n  Intent chooser=Intent.createChooser(tIntent,title);\n  chooser.putExtra(Intent.EXTRA_INITIAL_INTENTS,filteredIntents.toArray(new Parcelable[filteredIntents.size()]));\n  mContext.startActivity(chooser);\n}\n", "nl": "Start intent"}
{"code": "public ElasticListView enableLoadFooter(boolean enable){\n  if (enable) {\n    if (!mEnableLoader) {\n      super.addFooterView(mLoadFooter,null,true);\n    }\n  }\n else {\n    if (mEnableLoader) {\n      removeFooterView(mLoadFooter);\n    }\n  }\n  mEnableLoader=enable;\n  return this;\n}\n", "nl": "Enables or disables load footer"}
{"code": "public static Matrix identity(int m,int n,double value){\n  Matrix A=new Matrix(m,n);\n  double[][] X=A.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      X[i][j]=(i == j ? value : 0.0);\n    }\n  }\n  return A;\n}\n", "nl": "Generate identity matrix"}
{"code": "public void paintSelection(Graphics g0){\n  Graphics2D g=(Graphics2D)g0;\n  SelectedBlock selectedBlock=getSelectedBlock();\n  if (selectedBlock.isSelected()) {\n    Rectangle2D rect=new Rectangle2D.Double(0,getY(selectedBlock.getFirstRow() - 1),0,0);\n    rect.add(getSize().getWidth(),Math.min(getSize().height,getY(selectedBlock.getLastRow())));\n    g.setColor(highlightColorSemiTransparent);\n    g.fill(rect);\n  }\n}\n", "nl": "paint the selection rectangle"}
{"code": "private void inflateEmptyText(){\n  if (mEmptyText != R.string.text_empty) {\n    if (mEmptyLayout != R.layout.layout_empty) {\n      throw new RuntimeException(\"Cannot assign the EmptyText attribute. \" + \"You already overridden the entire emptyLayout, no need to specify \" + \"custom color or custom text message\");\n    }\n else {\n      textEmpty.setText(getResources().getString(R.string.text_empty));\n    }\n  }\n}\n", "nl": "Set the empty view text message"}
{"code": "public static boolean isNullEmptyOrWhitespace(String test){\n  if (test == null) {\n    return true;\n  }\n  if (test.trim().length() == 0) {\n    return true;\n  }\n  return false;\n}\n", "nl": "Crappy implementation of the C# is nullEmptyOrWhitespace which is occasionally useful"}
{"code": "private void clearDictionaryFromQueryModel(){\n  if (null != queryModel) {\n    Map<String,Dictionary> columnToDictionaryMapping=queryModel.getColumnToDictionaryMapping();\n    if (null != columnToDictionaryMapping) {\n      for (      Map.Entry<String,Dictionary> entry : columnToDictionaryMapping.entrySet()) {\n        CarbonUtil.clearDictionaryCache(entry.getValue());\n      }\n    }\n  }\n}\n", "nl": "This method will clear the dictionary access count after its usage is complete so that column can be deleted form LRU cache whenever memory reaches threshold"}
{"code": "@Override public int hashCode(){\n  int len=dictionaryKey.length;\n  int result=1;\n  for (int j=0; j < len; j++) {\n    result=31 * result + dictionaryKey[j];\n  }\n  for (  byte[] directSurrogateValue : noDictionaryKeys) {\n    for (int i=0; i < directSurrogateValue.length; i++) {\n      result=31 * result + directSurrogateValue[i];\n    }\n  }\n  for (  byte[] complexTypeKey : complexTypesKeys) {\n    for (int i=0; i < complexTypeKey.length; i++) {\n      result=31 * result + complexTypeKey[i];\n    }\n  }\n  return result;\n}\n", "nl": "to generate the hash code"}
{"code": "public HornMelodiesCursor queryMelodiesFromNotes(String notes){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=false;\n  qh.Table=S.TABLE_HORN_MELODIES;\n  qh.Columns=null;\n  qh.Selection=S.COLUMN_HORN_MELODIES_NOTES + \" = ?\";\n  qh.SelectionArgs=new String[]{notes};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new HornMelodiesCursor(wrapHelper(qh));\n}\n", "nl": "***************************** HORN MELODIES QUERIES"}
{"code": "public void draw(Canvas c,Rect bounds){\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mPaint.setColor(mCurrentColor);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n  if (mAlpha < 255) {\n    mCirclePaint.setColor(mBackgroundColor);\n    mCirclePaint.setAlpha(255 - mAlpha);\n    c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  }\n}\n", "nl": "Draw the progress spinner"}
{"code": "public void handleDecode(Result result,Bitmap barcode){\n  inactivityTimer.onActivity();\n  playBeepSoundAndVibrate();\n  if (result == null || TextUtils.isEmpty(result.getText())) {\n    if (analyzeCallback != null) {\n      analyzeCallback.onAnalyzeFailed();\n    }\n  }\n else {\n    if (analyzeCallback != null) {\n      analyzeCallback.onAnalyzeSuccess(barcode,result.getText());\n    }\n  }\n}\n", "nl": "Handler scan result"}
{"code": "private void updateAnimationTime(){\n  long now=android.os.SystemClock.uptimeMillis();\n  if (mMovieStart == 0) {\n    mMovieStart=now;\n  }\n  int dur=mMovie.duration();\n  if (dur == 0) {\n    dur=DEFAULT_MOVIEW_DURATION;\n  }\n  mCurrentAnimationTime=(int)((now - mMovieStart) % dur);\n}\n", "nl": "Calculate current animation time"}
{"code": "public void putListBoolean(String key,ArrayList<Boolean> boolList){\n  checkForNullKey(key);\n  ArrayList<String> newList=new ArrayList<String>();\n  for (  Boolean item : boolList) {\n    if (item) {\n      newList.add(\"true\");\n    }\n else {\n      newList.add(\"false\");\n    }\n  }\n  putListString(key,newList);\n}\n", "nl": "Put ArrayList of Boolean into SharedPreferences with 'key' and save"}
{"code": "private void animateOffset(final V child,final int offset,boolean forceAnimation,boolean withAnimation){\n  if (!behaviorTranslationEnabled && !forceAnimation) {\n    return;\n  }\n  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {\n    ensureOrCancelObjectAnimation(child,offset,withAnimation);\n    translationObjectAnimator.start();\n  }\n else {\n    ensureOrCancelAnimator(child,withAnimation);\n    translationAnimator.translationY(offset).start();\n  }\n}\n", "nl": "Animate offset"}
{"code": "public void close(){\n  if (this.zip != null) {\n    try {\n      this.zip.close();\n    }\n catch (    IOException e) {\n      System.err.println(\"Could not close apk file: \" + e.getMessage());\n      e.printStackTrace();\n    }\n    this.zip=null;\n  }\n}\n", "nl": "Closes this apk file"}
{"code": "@SuppressWarnings(\"unchecked\") public void merge(SourceSinkDefinition other){\n  if (other.baseObjects != null && !other.baseObjects.isEmpty()) {\n    if (this.baseObjects == null)     this.baseObjects=new HashSet<>();\n    for (    AccessPathTuple apt : other.baseObjects)     this.baseObjects.add(apt);\n  }\n  if (other.parameters != null && other.parameters.length > 0) {\n    if (this.parameters == null)     this.parameters=new Set[this.method.getParameters().size()];\n    for (int i=0; i < other.parameters.length; i++) {\n      this.parameters[i].addAll(other.parameters[i]);\n    }\n  }\n  if (other.returnValues != null && !other.returnValues.isEmpty()) {\n    if (this.returnValues == null)     this.returnValues=new HashSet<>();\n    for (    AccessPathTuple apt : other.returnValues)     this.returnValues.add(apt);\n  }\n}\n", "nl": "Merges the source and sink definitions of the given definition object into this definition object"}
{"code": "public static Date stringToDate(String date,String... datePatterns){\n  for (  String datePattern : datePatterns) {\n    DateFormat format=new SimpleDateFormat(datePattern,Locale.ENGLISH);\n    try {\n      return format.parse(date);\n    }\n catch (    ParseException e) {\n      if (datePatterns.length > 1)       Log.e(\"Trying to parse \",\"Failed, trying next pattern\");\n else       Log.e(\"Trying to parse \",\"Failed to parse\");\n    }\n  }\n  return null;\n}\n", "nl": "Convert date from given Strings to Date format"}
{"code": "@Override public void onTransferProgress(long progressRate,long totalTransferredSoFar,long totalToTransfer,String filePath){\n  int percent=(int)(100.0 * ((double)totalTransferredSoFar) / ((double)totalToTransfer));\n  if (percent != mLastPercent) {\n    mNotificationBuilder.setProgress(100,percent,false);\n    String fileName=filePath.substring(filePath.lastIndexOf(FileUtils.PATH_SEPARATOR) + 1);\n    String text=String.format(getString(R.string.uploader_upload_in_progress_content),percent,fileName);\n    mNotificationBuilder.setContentText(text);\n    mNotificationManager.notify(R.string.uploader_upload_in_progress_ticker,mNotificationBuilder.build());\n  }\n  mLastPercent=percent;\n}\n", "nl": "Callback method to update the progress bar in the status notification"}
{"code": "public FieldMapper(InputStream jConfStream) throws IOException, ParseException {\n  try (InputStreamReader reader=new InputStreamReader(jConfStream)){\n    Yaml yaml=new Yaml();\n    Map jConf=(Map)yaml.load(reader);\n    if (jConf.containsKey(KEY_OVERRIDES)) {\n      ((Map)jConf.get(KEY_OVERRIDES)).forEach(null);\n    }\n    if (jConf.containsKey(KEY_MULTI_VAL_SUFFIX)) {\n      this.multiValSuffix=jConf.getOrDefault(KEY_MULTI_VAL_SUFFIX,DEFAULT_MULTI_VAL_SUFFIX).toString();\n    }\n    if (jConf.containsKey(KEY_TYPE_SUFFIX)) {\n      ((Map)jConf.get(KEY_TYPE_SUFFIX)).forEach(null);\n    }\n  }\n }\n", "nl": "Creates a field name mapper by reading config from the argument conf stream"}
{"code": "public MarketAddQuery(VkApiClient client,UserActor actor,int ownerId,String name,String description,int categoryId,float price,int mainPhotoId){\n  super(client,\"market.add\",AddResponse.class);\n  accessToken(actor.getAccessToken());\n  ownerId(ownerId);\n  name(name);\n  description(description);\n  categoryId(categoryId);\n  price(price);\n  mainPhotoId(mainPhotoId);\n}\n", "nl": "Creates a AbstractQueryBuilder instance that can be used to build api request with various parameters"}
{"code": "public static List<ReadData> apply(final IReadBlockIterator iterator,final ProgressListener progress) throws IOException, CanceledException {\n  progress.setSubtask(\"Collecting reads:\");\n  final List<ReadData> list=new LinkedList<>();\n  int countReads=0;\n{\n    progress.setMaximum(iterator.getMaximumProgress());\n    progress.setProgress(0);\n    while (iterator.hasNext()) {\n      final IReadBlock readBlock=iterator.next();\n      list.add(createReadData(countReads++,readBlock));\n      progress.setProgress(iterator.getProgress());\n    }\n  }\n  if (progress instanceof ProgressPercentage)   ((ProgressPercentage)progress).reportTaskCompleted();\n  return list;\n}\n", "nl": "collect all read data associated with the given iterator"}
{"code": "private boolean isAlwaysNullBefore(Stmt s,Local base,LocalDefs defs){\n  List<Unit> baseDefs=defs.getDefsOfAt(base,s);\n  if (baseDefs.isEmpty())   return true;\n  for (  Unit u : baseDefs) {\n    if (!(u instanceof DefinitionStmt))     return false;\n    DefinitionStmt defStmt=(DefinitionStmt)u;\n    if (defStmt.getRightOp() != NullConstant.v())     return false;\n  }\n  return true;\n}\n", "nl": "Checks whether the given local is guaranteed to be always null at the given statement"}
{"code": "public void markFooterViewHeight(View view){\n  this.mFooterView=view;\n  mFooterViewHeight=mFooterView.getHeight();\n  if (mFooterViewHeight <= 0) {\n    mFooterViewHeight=mFooterView.getLayoutParams().height;\n  }\n else {\n    this.mFooterView.getLayoutParams().height=mFooterViewHeight;\n  }\n}\n", "nl": "mark the footer height"}
{"code": "public Boolean deleteCustomer(EntityManager em,String id){\n  Boolean status=true;\n  Customer bupa=null;\n  try {\n    if (!em.getTransaction().isActive()) {\n      em.getTransaction().begin();\n    }\n    bupa=em.find(Customer.class,id);\n    em.remove(bupa);\n    em.getTransaction().commit();\n  }\n catch (  Exception e) {\n    status=false;\n    logger.error(\"Error occured during delete of Business Partner. Detailed info: \" + e);\n  }\n  return status;\n}\n", "nl": "Helper method to delete Business Partner"}
{"code": "public static int[] deleteDuplicatedPages(int[] pages){\n  List<Integer> result=new ArrayList<>();\n  int lastInt=-1;\n  for (  Integer currentInt : pages) {\n    if (lastInt != currentInt) {\n      result.add(currentInt);\n    }\n    lastInt=currentInt;\n  }\n  int[] arrayResult=new int[result.size()];\n  for (int i=0; i < result.size(); i++) {\n    arrayResult[i]=result.get(i);\n  }\n  return arrayResult;\n}\n", "nl": "Transforms (0,1,2,2,3) to (0,1,2,3)"}
{"code": "private void calcBitePoint(int centerX,int centerY,float circleEdgeX,float circleEdgeY,double biteLine,boolean isFirstBite,boolean isRandomBite){\n  double bitePercent;\n  if (isFirstBite) {\n    biteX=(int)circleEdgeX;\n    biteY=(int)circleEdgeY;\n  }\n else {\n    bitePercent=biteRadius / biteLine;\n    if (isRandomBite) {\n      bitePercent*=bitesTakenMap.get(biteDirection);\n    }\n else {\n      bitePercent*=(numBitesForOneDirection - numBitesForOneDirectionLeft);\n    }\n    biteX=DrawUtils.getPointBetweenTwoPoints(circleEdgeX,centerX,bitePercent);\n    biteY=DrawUtils.getPointBetweenTwoPoints(circleEdgeY,centerY,bitePercent);\n  }\n}\n", "nl": "method for calculating bite point for random & one direction options"}
{"code": "public boolean onBackPressed(){\n  if (drawer.isDrawerOpen(GravityCompat.START)) {\n    drawer.closeDrawer(GravityCompat.START);\n    return true;\n  }\n else {\n    drawer.removeDrawerListener(toggle);\n    return false;\n  }\n}\n", "nl": "On back key pressed, should be call in its parent Activity's onBackPressed"}
{"code": "public void testMissingRequiredProjects() throws IOException {\n  VirtualFile project2=createGradleProjectToImport(dir,module(2),module(1));\n  assert project2 != null : \"Something wrong with the setup\";\n  configureTopLevelProject(dir,Arrays.asList(module(1),module(2)),Collections.<String>emptySet());\n  Map<String,VirtualFile> projects=moduleListToMap(GradleModuleImporter.getRelatedProjects(project2,getProject()));\n  assertEquals(2,projects.size());\n  assertModuleRequiredButNotFound(module(1),projects);\n  assertEquals(project2,projects.get(pathToGradleName(module(2))));\n}\n", "nl": "Test importing a project has source dependency but when that dependency directory is missing"}
{"code": "public boolean gotoNext(){\n  if (isCurrentSet()) {\n    current.set1(current.get1() + 1);\n    if (current.get1() >= table.getGrid().getRowCount()) {\n      current.set1(0);\n      current.set2(current.get2() + 1);\n    }\n  }\n else   gotoFirst();\n  return isCurrentSet();\n}\n", "nl": "goto the next object"}
{"code": "@SuppressLint(\"NewApi\") public void sendText(Context context) throws ActivityNotFoundException {\n  if (Utils.hasKitKat()) {\n    String defaultSmsPackageName=Telephony.Sms.getDefaultSmsPackage(context);\n    Intent sendIntent=new Intent(Intent.ACTION_SENDTO,Uri.parse(\"smsto:\" + Uri.encode(getNumber())));\n    if (defaultSmsPackageName != null) {\n      sendIntent.setPackage(defaultSmsPackageName);\n    }\n    context.startActivity(sendIntent);\n  }\n else {\n    Intent textIntent=new Intent();\n    textIntent.setAction(Intent.ACTION_VIEW);\n    textIntent.setData(Uri.fromParts(\"sms\",getNumber(),null));\n    context.startActivity(textIntent);\n  }\n}\n", "nl": "Fires up an intent with the request to send an sms to the msisdn that of this Phone"}
{"code": "public static String parseCharset(Map<String,String> headers,String defaultCharset){\n  String contentType=headers.get(HTTP.CONTENT_TYPE);\n  if (contentType != null) {\n    String[] params=contentType.split(\";\");\n    for (int i=1; i < params.length; i++) {\n      String[] pair=params[i].trim().split(\"=\");\n      if (pair.length == 2) {\n        if (pair[0].equals(\"charset\")) {\n          return pair[1];\n        }\n      }\n    }\n  }\n  return defaultCharset;\n}\n", "nl": "Retrieve a charset from headers"}
{"code": "public static int toDecimal(String binary){\n  long num=Long.parseLong(binary);\n  long rem;\n  while (num > 0) {\n    rem=num % 10;\n    num=num / 10;\n    if (rem != 0 && rem != 1) {\n      System.out.println(\"This is not a binary number.\");\n      System.out.println(\"Please try once again.\");\n      return -1;\n    }\n  }\n  return Integer.parseInt(binary,2);\n}\n", "nl": "This will convert the given binary string to a decimal based integer"}
{"code": "public boolean isSharedBroker(String host){\n  for (  NamespaceIsolationData policyData : this.policies.values()) {\n    NamespaceIsolationPolicyImpl policy=new NamespaceIsolationPolicyImpl(policyData);\n    if (policy.isPrimaryBroker(host)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Check to see whether a broker is in the shared broker pool or not"}
{"code": "public BaseAlertDialog(Context context){\n  super(context);\n  widthScale(0.88f);\n  mLlContainer=new LinearLayout(context);\n  mLlContainer.setOrientation(LinearLayout.VERTICAL);\n  mTvTitle=new TextView(context);\n  mTvContent=new TextView(context);\n  mLlBtns=new LinearLayout(context);\n  mLlBtns.setOrientation(LinearLayout.HORIZONTAL);\n  mTvBtnLeft=new TextView(context);\n  mTvBtnLeft.setGravity(Gravity.CENTER);\n  mTvBtnMiddle=new TextView(context);\n  mTvBtnMiddle.setGravity(Gravity.CENTER);\n  mTvBtnRight=new TextView(context);\n  mTvBtnRight.setGravity(Gravity.CENTER);\n}\n", "nl": "method execute order: show:constrouctor---show---oncreate---onStart---onAttachToWindow dismiss:dismiss---onDetachedFromWindow---onStop"}
{"code": "public static final void main(String[] argv){\n  Logger.getLogger(\"prefuse\").setLevel(Level.WARNING);\n  FisheyeMenu fm=demo();\n  JFrame f=new JFrame(\"p r e f u s e  |  f i s h e y e\");\n  f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n  f.getContentPane().add(fm);\n  f.pack();\n  f.setVisible(true);\n}\n", "nl": "Run a demonstration of the FisheyeMenu"}
{"code": "private String findLastStringAssignment(Stmt stmt,Local local,BiDiInterproceduralCFG<Unit,SootMethod> cfg){\n  if (stmt instanceof AssignStmt) {\n    AssignStmt assign=(AssignStmt)stmt;\n    if (assign.getLeftOp() == local) {\n      if (assign.getRightOp() instanceof StringConstant)       return ((StringConstant)assign.getRightOp()).value;\n    }\n  }\n  for (  Unit pred : cfg.getPredsOf(stmt)) {\n    if (!(pred instanceof Stmt))     continue;\n    String lastAssignment=findLastStringAssignment((Stmt)pred,local,cfg);\n    if (lastAssignment != null)     return lastAssignment;\n  }\n  return null;\n}\n", "nl": "Finds the last assignment to the given String local by searching upwards from the given statement"}
{"code": "public boolean selectServiceTab(String url){\n  url=url.replaceAll(\".*://\",\"\");\n  for (int i=0; i < tabbedPane.getTabCount(); i++) {\n    if (tabbedPane.getTitleAt(i).equalsIgnoreCase(url)) {\n      tabbedPane.setSelectedIndex(i);\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "select the given service tab, if present"}
{"code": "@Override public void clusterOffline(ClusterNode clusterNode){\n  LOGGER.warn(\"Detected Terracotta cluster offline event for node: \" + clusterNode.getId());\n  String hostname;\n  try {\n    hostname=InetAddress.getLocalHost().getHostName();\n  }\n catch (  Exception e) {\n    LOGGER.error(\"Unable to get local hostname\",e);\n    hostname=\"#unknown host#\";\n  }\n  SMS_LOGGER.warn(\"Initiating C2MON server shutdown of \" + System.getProperty(\"c2mon.server.name\") + \" on \"+ hostname);\n}\n", "nl": "This node has lost contact (possibly temporarily) with the cluster and cannot execute clustered operations"}
{"code": "private static float computeSimilarity(Lane a,Lane b){\n  int same=0;\n  int diff=0;\n  int firstCoordinate=Math.max(a.getFirstNonGapPosition(),b.getFirstNonGapPosition());\n  int lastCoordinate=Math.min(a.getLastNonGapPosition(),b.getLastNonGapPosition());\n  for (int i=firstCoordinate; i <= lastCoordinate; i++) {\n    char cha=a.charAt(i);\n    char chb=b.charAt(i);\n    if (Character.isLetter(cha) && Character.isLetter(chb)) {\n      if (Character.toLowerCase(cha) == Character.toLowerCase((chb)))       same++;\n else       diff++;\n    }\n  }\n  return Math.max(same > 0 ? 1 : 0,same - 3 * diff);\n}\n", "nl": "computes the similarity of two sequences"}
{"code": "private static void drawShadowedArrow(Graphics2D g,ColorSet colorSet,Polygon arrow,int x,int y){\n  Color pre=g.getColor();\n  Stroke s=g.getStroke();\n  if (colorSet.getStyle() == WidgetDecorator.BLUEPRINT_STYLE) {\n    g.setPaint(colorSet.getBackgroundPaint());\n    g.setStroke(sLineShadowStroke);\n  }\n else {\n    g.setColor(sShadowColor);\n    g.setStroke(sShadowStroke);\n  }\n  ConnectionDraw.drawArrow(g,arrow,x,y);\n  g.setColor(pre);\n  g.setStroke(s);\n  ConnectionDraw.drawArrow(g,arrow,x,y);\n}\n", "nl": "Utility to draw a shadowed arrow"}
{"code": "public boolean run(String allowed,String option){\n  if (!hasOption(option)) {\n    return true;\n  }\n  String selection=getOptionValue(option);\n  String[] selectionList=selection.split(\",\");\n  for (  String selectionItem : selectionList) {\n    if (selectionItem.equals(allowed)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Determine if the argument was provided for the selected option, which determines if a test should or should not be run"}
{"code": "private void initFilter(ReplicationFilterWrapper filterHolder,String url) throws SpaceComponentsInitializeException {\n  try {\n    filterHolder.init(_space,url,_replicationPolicy);\n  }\n catch (  RuntimeException re) {\n    if (_shutdownSpaceOnInitFailure) {\n      throw new SpaceComponentsInitializeException(\"Failed to initialize replication filter - \" + filterHolder.getClassName(),re);\n    }\n  }\n}\n", "nl": "initialize given replication filter"}
{"code": "protected Future<Void> closeNoThrow(){\n  Promise<Void> closeFuture;\nsynchronized (this) {\n    if (null != closePromise) {\n      return closePromise;\n    }\n    closeFuture=closePromise=new Promise<Void>();\n  }\n  cancelTruncation();\n  Utils.closeSequence(bkDistributedLogManager.getScheduler(),true,getCachedLogWriter(),getAllocatedLogWriter(),getCachedWriteHandler()).proxyTo(closeFuture);\n  return closeFuture;\n}\n", "nl": "Close the writer and release all the underlying resources"}
{"code": "public long time(int i){\n  long offset=0;\n  for (int j=indices.length - 1; j >= 0; j--) {\n    if (i >= indices[j]) {\n      offset=offsets[j];\n      break;\n    }\n  }\n  return offset + rtimes[i];\n}\n", "nl": "Returns the time stamp for index i"}
{"code": "public static double[] invert(double[] a) throws IllegalArgumentException {\n  if (a == null) {\n    throw new IllegalArgumentException(\"Argument cannot be null\");\n  }\n  double[] c=new double[a.length];\n  for (int i=0; i < a.length; i++) {\n    c[i]=1.0 / a[i];\n  }\n  return c;\n}\n", "nl": "Returns the multiplicative inverse (element-wise 1/x) of an array"}
{"code": "public PrepareJob(Transaction tr,TaskManager pool,WakeupManager wm,ClientLog log,ParticipantHandle[] handles,Object xid,ConcurrentMap<String,IDirectSpaceProxy> proxiesMap){\n  super(pool,wm,false);\n  if (log == null)   throw new IllegalArgumentException(\"PrepareJob: PrepareJob: \" + \"log is null\");\n  this.log=log;\n  if (!(tr instanceof ServerTransaction))   throw new IllegalArgumentException(\"PrepareJob: PrepareJob: \" + \"must be a ServerTransaction\");\n  this.tr=(ServerTransaction)tr;\n  if (handles == null)   throw new IllegalArgumentException(\"PrepareJob: PrepareJob: \" + \"must have participants\");\n  if (handles.length == 0)   throw new IllegalArgumentException(\"PrepareJob: PrepareJob: \" + \"must have participants\");\n  this.handles=handles;\n  _xid=xid;\n  _proxiesMap=proxiesMap;\n}\n", "nl": "Constructs an <code>PrepareJob</code>"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set colorMatchesVsReference=\");\n  boolean value=np.getBoolean();\n  np.matchIgnoreCase(\";\");\n  AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  viewer.getAlignmentViewerPanel().getAlignmentPanel().setColorMatchesVsReference(value);\n  ProgramProperties.put(\"ColorMatchesVsReference\",value);\n  viewer.repaint();\n}\n", "nl": "parses the given command and executes it"}
{"code": "private boolean update(final Object pValue,final String pValueDesc,final Timestamp pTimestamp){\n  boolean retval=false;\nsynchronized (BUFFER_LOCK) {\n    if (this.timestamp.before(pTimestamp) || this.timestamp.equals(pTimestamp)) {\n      this.value=pValue;\n      this.qualityCollection.clear();\n      this.qualityDescriptions.clear();\n      this.valueDesc=pValueDesc;\n      this.timestamp=pTimestamp;\n      retval=true;\n    }\n  }\n  return retval;\n}\n", "nl": "Updates the values of this <code>BufferObject</code> instance (all invalid status' are removed)"}
{"code": "public static void process(List<Packages> pkgList) throws Exception {\n  init();\n  String[] temps=templates.split(\",\");\n  String[] vmFiles=new String[temps.length];\n  for (int i=0; i < temps.length; i++) {\n    vmFiles[i]=temps[i] + \".vm\";\n  }\n  for (  Packages pkg : pkgList) {\n    for (    String vmFile : vmFiles) {\n      generator(vmFile,pkg);\n    }\n  }\n}\n", "nl": "process main logic for create file"}
{"code": "static Object newInstance(String className,ClassLoader cl,boolean doFallback) throws ConfigurationError {\n  try {\n    Class providerClass=findProviderClass(className,cl,doFallback);\n    Object instance=providerClass.newInstance();\n    if (DEBUG)     debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \"+ cl);\n    return instance;\n  }\n catch (  ClassNotFoundException x) {\n    throw new ConfigurationError(\"Provider \" + className + \" not found\",x);\n  }\ncatch (  Exception x) {\n    throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \"+ x,x);\n  }\n}\n", "nl": "Create an instance of a class using the specified ClassLoader"}
{"code": "public void readAuxBlocks(FileFooterRMA3 fileFooter,IInputReader reader,Map<String,byte[]> name2AuxBlock) throws IOException {\n  reader.seek(fileFooter.getAuxStart());\n  for (int i=0; i < count && reader.getPosition() < fileFooter.getAuxFooter(); i++) {\n    String name=reader.readString();\n    int length=reader.readInt();\n    byte[] bytes=new byte[length];\n    reader.read(bytes,0,length);\n    name2AuxBlock.put(name,bytes);\n  }\n}\n", "nl": "read the aux blocks from a file"}
{"code": "public static final void expelAlliance(Player expelledPlayer,Player expelGiver){\n  Preconditions.checkNotNull(expelledPlayer,\"Expelled player should not be null\");\n  Preconditions.checkNotNull(expelGiver,\"ExpelGiver player should not be null\");\n  Preconditions.checkArgument(expelGiver.isInLeague(),\"Expelled player should be in league\");\n  Preconditions.checkArgument(expelledPlayer.isInLeague(),\"ExpelGiver should be in league\");\n  Preconditions.checkArgument(expelGiver.getPlayerAlliance2().getLeague().isLeader(expelGiver.getPlayerAlliance2()),\"ExpelGiver alliance should be the leader of league\");\n  Preconditions.checkArgument(expelGiver.getPlayerAlliance2().isLeader(expelGiver),\"ExpelGiver should be the leader of alliance\");\n  PlayerAlliance alliance=expelGiver.getPlayerAlliance2();\n  League league=alliance.getLeague();\n  league.onEvent(new LeagueLeftEvent(league,expelledPlayer.getPlayerAlliance2(),LeaveReson.EXPEL));\n}\n", "nl": "Remove alliance from league (expel)"}
{"code": "private static boolean checkNullForMeasures(Object object){\n  Object[] measures=(Object[])object;\n  for (  Object measure : measures) {\n    if (null != measure) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "To check whether the measures are empty/null"}
{"code": "private void eliminateFallthroughIfs(Body body){\n  boolean changed=false;\n  do {\n    changed=false;\n    IfStmt ifs=null;\n    Iterator<Unit> unitIt=body.getUnits().snapshotIterator();\n    while (unitIt.hasNext()) {\n      Unit u=unitIt.next();\n      if (ifs != null && ifs.getTarget() == u) {\n        body.getUnits().remove(ifs);\n        changed=true;\n      }\n      ifs=null;\n      if (u instanceof IfStmt)       ifs=(IfStmt)u;\n    }\n  }\n while (changed);\n}\n", "nl": "Removes if statements that jump to the fall-through successor"}
{"code": "public final void testWriteLine(){\n  FallbackFileController fFileController=new FallbackFileController(PATH);\n  FallbackImpl fallbackImpl=new FallbackImpl();\n  try {\n    fFileController.openFallbackOutputStream();\n    fFileController.writeLine(fallbackImpl);\n    fFileController.closeFallbackOutputStream();\n  }\n catch (  DataFallbackException e) {\n    fail(\"An error has ocurred while trying to write in the fallback log file\");\n  }\n  assertFalse(fFileController.isFallBackFileEmpty());\n}\n", "nl": "Tests that a new ShortTermLog object is correctly logged in the fallback log file"}
{"code": "private static double calculateAngle(SensorEvent event,GeomagneticField magneticField){\n  float azimuth=getAzimuth(event);\n  double angle;\n  if (magneticField != null) {\n    angle=Math.toDegrees(azimuth) + magneticField.getDeclination();\n  }\n else {\n    angle=Math.toDegrees(azimuth);\n  }\n  angle=(angle + 360) % 360;\n  return angle;\n}\n", "nl": "Calculate angle to north depending on SensorEvent data"}
{"code": "public static int extractReadsByTaxonomy(final ProgressListener progressListener,final Set<Integer> taxIds,final String outDirectory,final String outFileName,final Document doc,final boolean summarized) throws IOException, CanceledException {\n  Map<Integer,String> classId2Name=new HashMap<>();\n  Map<Integer,Collection<Integer>> classId2Descendants=new HashMap<>();\n  for (  Integer id : taxIds) {\n    classId2Name.put(id,TaxonomyData.getName2IdMap().get(id));\n    if (summarized)     classId2Descendants.put(id,TaxonomyData.getTree().getAllDescendants(id));\n  }\n  return extractReads(progressListener,ClassificationType.Taxonomy.toString(),taxIds,classId2Name,classId2Descendants,outDirectory,outFileName,doc,summarized);\n}\n", "nl": "extract all reads belonging to a given set of taxon ids"}
{"code": "synchronized void undo(RTEditText editor){\n  Stack<Operation> undoStack=getUndoStack(editor);\n  if (!undoStack.empty()) {\n    Stack<Operation> redoStack=getRedoStack(editor);\n    Operation op=undoStack.pop();\n    push(op,redoStack);\n    op.undo(editor);\n    while (!undoStack.empty() && op.canMerge(undoStack.peek())) {\n      op=undoStack.pop();\n      push(op,redoStack);\n      op.undo(editor);\n    }\n  }\n}\n", "nl": "Undo the last operation for a specific rich text editor"}
{"code": "public static <T>Type<T> valueOf(final WildcardType var){\n  Set<Type<?>> bounds=new HashSet<Type<?>>(var.getUpperBounds().length + var.getLowerBounds().length);\n  for (int i=0, len=var.getUpperBounds().length; i < len; ++i) {\n    bounds.add(valueOf(var.getUpperBounds()[i]));\n  }\n  for (int i=0, len=var.getLowerBounds().length; i < len; ++i) {\n    bounds.add(valueOf(var.getLowerBounds()[i]));\n  }\n  return (Type<T>)refineBounds(bounds);\n}\n", "nl": "Finds the Type value of the given wildcard type"}
{"code": "private void Hunter_SniperSkills(){\n  if (getOwner().isCasting() || isAlreadyDead()) {\n    return;\n  }\n  int rand=Rnd.get(1,2);\nswitch (rand) {\ncase 1:\n    useSkill(21292);\n  break;\ncase 2:\nuseSkill(21293);\nbreak;\n}\n}\n", "nl": "Select Random Skills for: Sheban Intelligent Unit Hunter Sheban Elite Sniper"}
{"code": "private boolean isConfigurationPluginAvailable(){\n  if (configurationPluginAvailable == null) {\n    try {\n      String value=APILocator.getPluginAPI().loadProperty(pluginName,\"environment\");\n      configurationPluginAvailable=(value != null);\n    }\n catch (    Exception e) {\n      Logger.warn(this,\"Exception while trying to get property 'environment' \",e);\n      configurationPluginAvailable=false;\n    }\n    Logger.info(this,\"Configuration plugin available: \" + configurationPluginAvailable);\n  }\n  return configurationPluginAvailable;\n}\n", "nl": "Check for the \"environment\" key in the pluginAPI"}
{"code": "public void showSvnProperties(ISVNLocalResource resource) throws SVNException {\n  this.resource=resource;\n  if (resource != null) {\n    setContentDescription(Policy.bind(\"SvnPropertiesView.titleWithArgument\",resource.getName()));\n  }\n else {\n    setContentDescription(\"\");\n  }\n  refresh();\n}\n", "nl": "Shows the properties for the given resource"}
{"code": "private void tryLoadData(){\n  if (books.size() != 0) {\n    onLoadBooksSuccess(books);\n  }\n else   if (isSubscriptionInactive(loadBookSubscription)) {\n    getView().showLoading();\n    loadData();\n  }\n else {\n    getView().showLoading();\n  }\n}\n", "nl": "example of request, which load main data for screen"}
{"code": "static boolean isSuccessRateEnough(Launch launch,SendCase option){\nswitch (option) {\ncase ALWAYS:\n    return true;\ncase FAILED:\n  return launch.getStatus().equals(Status.FAILED);\ncase TO_INVESTIGATE:\nreturn launch.getStatistics().getIssueCounter().getToInvestigateTotal() > 0;\ncase MORE_10:\nreturn getSuccessRate(launch) > 0.1;\ncase MORE_20:\nreturn getSuccessRate(launch) > 0.2;\ncase MORE_50:\nreturn getSuccessRate(launch) > 0.5;\ndefault :\nreturn false;\n}\n}\n", "nl": "Check if success rate is enough for notification"}
{"code": "@Override public void initTrigger(){\n  Calendar calendar=Calendar.getInstance();\n  calendar.set(Calendar.HOUR_OF_DAY,hour);\n  calendar.set(Calendar.MINUTE,minute);\n  calendar.set(Calendar.SECOND,second);\n  long delay=calendar.getTimeInMillis() - System.currentTimeMillis();\n  if (delay < 0) {\n    delay+=DAY_IN_MSEC;\n  }\n  ThreadPoolManager.getInstance().scheduleAtFixedRate(this,delay,DAY_IN_MSEC);\n}\n", "nl": "Run a fixed in the time (HH:MM:SS) task"}
{"code": "public static <V>List<V> invertList(List<V> sourceList){\n  if (isEmpty(sourceList)) {\n    return sourceList;\n  }\n  List<V> invertList=new ArrayList<V>(sourceList.size());\n  for (int i=sourceList.size() - 1; i >= 0; i--) {\n    invertList.add(sourceList.get(i));\n  }\n  return invertList;\n}\n", "nl": "invert list"}
{"code": "protected void callUserDataHandlers(Node n,Node c,short operation){\n  if (userData == null) {\n    return;\n  }\n  if (n instanceof NodeImpl) {\n    Hashtable t=((NodeImpl)n).getUserDataRecord();\n    if (t == null || t.isEmpty()) {\n      return;\n    }\n    callUserDataHandlers(n,c,operation,t);\n  }\n}\n", "nl": "Call user data handlers when a node is deleted (finalized)"}
{"code": "public static boolean isServiceRunning(Context context,String className){\n  boolean isRunning=false;\n  ActivityManager activityManager=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);\n  List<ActivityManager.RunningServiceInfo> serviceInfos=activityManager.getRunningServices(Integer.MAX_VALUE);\n  for (  ActivityManager.RunningServiceInfo si : serviceInfos) {\n    if (className.equals(si.service.getClassName())) {\n      isRunning=true;\n    }\n  }\n  return isRunning;\n}\n", "nl": "Judge whether a service is running"}
{"code": "public LongArrayList top(int n){\n  LongArrayList top=new LongArrayList();\n  long[] values=data.toLongArray();\n  LongArrays.parallelQuickSort(values,ReverseLongComparator.instance());\n  for (int i=0; i < n && i < values.length; i++) {\n    top.add(values[i]);\n  }\n  return top;\n}\n", "nl": "Returns the largest (\"top\") n values in the column"}
{"code": "public static String utf8Encode(String str,String defultReturn){\n  if (!isEmpty(str) && str.getBytes().length != str.length()) {\n    try {\n      return URLEncoder.encode(str,\"UTF-8\");\n    }\n catch (    UnsupportedEncodingException e) {\n      return defultReturn;\n    }\n  }\n  return str;\n}\n", "nl": "encoded in utf-8, if exception, return defultReturn"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"hide attribute=\");\n  Set<String> attributes=new HashSet<>();\n  while (!np.peekMatchIgnoreCase(\";\")) {\n    String attribute=np.getWordRespectCase();\n    attributes.add(attribute);\n  }\n  np.matchIgnoreCase(\";\");\n  if (attributes.size() > 0) {\n    final SamplesViewer viewer=((SamplesViewer)getViewer());\n    viewer.getSamplesTable().hideColumns(attributes.toArray(new String[attributes.size()]));\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private String convertTimeStampToString(String factTimeStamp){\n  SimpleDateFormat parser=new SimpleDateFormat(CarbonCommonConstants.CARBON_TIMESTAMP);\n  Date dateToStr=null;\n  try {\n    dateToStr=parser.parse(factTimeStamp);\n    return Long.toString(dateToStr.getTime());\n  }\n catch (  ParseException e) {\n    LOGGER.error(\"Cannot convert\" + factTimeStamp + \" to Time/Long type value\"+ e.getMessage());\n    return null;\n  }\n}\n", "nl": "This method will convert a given timestamp to long value and then to string back"}
{"code": "public SwapReadOnlyIterator(long inSwapStartIndex){\n  _memoryIteratorExhausted=true;\n  _memoryIterator=null;\n  try {\n    _externalIterator=_externalStorage.readOnlyIterator(inSwapStartIndex);\n  }\n catch (  StorageException e) {\n    throw new SwapStorageException(e);\n  }\n}\n", "nl": "Create an iterator which starts directly iterating over the storage, thus skipping the memory redo log file"}
{"code": "private void createVirtualDisplay(){\n  Point size=new Point();\n  display.getSize(size);\n  width=size.x;\n  height=size.y;\n  imageReader=ImageReader.newInstance(width,height,PixelFormat.RGBA_8888,2);\n  virtualDisplay=mediaProjection.createVirtualDisplay(SCREENCAP_NAME,width,height,density,VIRTUAL_DISPLAY_FLAGS,imageReader.getSurface(),null,handler);\n  handler.postDelayed(getRunnableThatTakesScreenshot(),2);\n}\n", "nl": "Factoring Virtual Display creation"}
{"code": "@Override public void actionPerformed(AnActionEvent e){\n  ScreenView screenView=mySurface.getCurrentScreenView();\n  if (screenView != null) {\n    LintAnnotationsModel lintModel=screenView.getModel().getLintAnnotationsModel();\n    if (lintModel != null && lintModel.getIssueCount() > 0) {\n      new LintNotificationPanel(screenView,lintModel).show(e);\n    }\n  }\n}\n", "nl": "Shows list of warnings/errors"}
{"code": "public SerialMessage removeAssociationMessage(int group,int node){\n  logger.debug(\"NODE {}: Creating new message for application command ASSOCIATIONCMD_REMOVE group={}, node={}\",getNode().getNodeId(),group,node);\n  SerialMessage result=new SerialMessage(getNode().getNodeId(),SerialMessageClass.SendData,SerialMessageType.Request,SerialMessageClass.SendData,SerialMessagePriority.Config);\n  ByteArrayOutputStream outputData=new ByteArrayOutputStream();\n  outputData.write(this.getNode().getNodeId());\n  outputData.write(4);\n  outputData.write(getCommandClass().getKey());\n  outputData.write(ASSOCIATIONCMD_REMOVE);\n  outputData.write(group);\n  outputData.write(node);\n  result.setMessagePayload(outputData.toByteArray());\n  return result;\n}\n", "nl": "Gets a SerialMessage with the ASSOCIATIONCMD_REMOVE command"}
{"code": "public static void d(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_DEBUG) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.d(tag,msg);\n}\n", "nl": "Send a DEBUG log message"}
{"code": "private void checkCreateTemplate(String category,String name,boolean createWithProject) throws Exception {\n  if (DISABLED) {\n    return;\n  }\n  File templateFile=findTemplate(category,name);\n  assertNotNull(templateFile);\n  if (haveChecked(templateFile,createWithProject)) {\n    return;\n  }\n  if (KNOWN_BROKEN.contains(templateFile.getName())) {\n    return;\n  }\n  markChecked(templateFile,createWithProject);\n  Stopwatch stopwatch=Stopwatch.createStarted();\n  checkTemplate(templateFile,createWithProject);\n  stopwatch.stop();\n  System.out.println(\"Checked \" + templateFile.getName() + \" successfully in \"+ stopwatch.toString());\n}\n", "nl": "Checks the given template in the given category"}
{"code": "@Override public int fillConvertedChunkData(int rowId,int columnIndex,int[] row,KeyStructureInfo info){\n  int start=rowId * chunkAttributes.getColumnValueSize();\n  long[] keyArray=info.getKeyGenerator().getKeyArray(dataChunk,start);\n  int[] ordinal=info.getMdkeyQueryDimensionOrdinal();\n  for (int i=0; i < ordinal.length; i++) {\n    row[columnIndex++]=(int)keyArray[ordinal[i]];\n  }\n  return columnIndex;\n}\n", "nl": "Converts to column dictionary integer value"}
{"code": "static public void createOutputFilesReverse(Result[] result,String fileDst,boolean bAppend) throws IOException {\n  BufferedWriter output=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileDst,bAppend)));\n  for (int i=(result.length - 1); i >= 0; i--) {\n    output.write(\"Gen\" + result[i].getGenNum() + \":  scale of \"+ result[i].getScale()+ \"  \"+ result[i].getRemark()+ \"\\n\");\n  }\n  output.close();\n  System.err.println();\n  System.err.println(fileDst + \" is generated!\");\n}\n", "nl": "create output files with data in reverse order"}
{"code": "private void writeDomainSpec(DomainSpec spec,Document document,Element parentElement){\n  if (spec instanceof TopDomain) {\n    Element topDomain=document.createElement(\"top\");\n    parentElement.appendChild(topDomain);\n  }\n else   if (spec instanceof BottomDomain) {\n    Element bottomDomain=document.createElement(\"bottom\");\n    parentElement.appendChild(bottomDomain);\n  }\n else   if (spec instanceof Category) {\n    Element categoryDomain=document.createElement(\"category\");\n    parentElement.appendChild(categoryDomain);\n    Category cat=(Category)spec;\n    categoryDomain.setAttribute(\"value\",cat.getValue());\n  }\n else   throw new RuntimeException(\"Unsupported source or sink specification type\");\n}\n", "nl": "Writes out a domain specification object"}
{"code": "public static boolean isUpgradeble(Item item){\n  if (item.getItemTemplate().isNoEnchant()) {\n    return false;\n  }\n  if (item.getItemTemplate().isWeapon()) {\n    return true;\n  }\n  if (item.getItemTemplate().getCategory() == ItemCategory.STIGMA) {\n    return false;\n  }\n  if (item.getItemTemplate().isArmor()) {\n    int at=item.getItemTemplate().getItemSlot();\n    if (at == 1 || at == 2 || at == 8 || at == 16 || at == 32 || at == 2048 || at == 4096 || at == 131072 || at == 262144) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Verify if the item is enchantble and/or socketble"}
{"code": "public IObjectInfo<T> add(T subject){\n  lock.lock();\n  try {\n    return store_impl(subject);\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "store an element"}
{"code": "public void unlock(Object key){\n  String uid=String.valueOf(key);\n  Transaction tr=lockedUIDHashMap.get(uid);\n  if (tr == null) {\n    return;\n  }\n  try {\n    tr.commit();\n  }\n catch (  Exception e) {\n    logger.warn(\"Failed to commit transaction and unlocking the object, ignoring\",e);\n  }\n finally {\n    lockedUIDHashMap.remove(uid);\n  }\n}\n", "nl": "Unlocks the given lock on the key"}
{"code": "public static String md5(byte[] source) throws NoSuchAlgorithmException {\n  char hexDigits[]={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n  java.security.MessageDigest md=java.security.MessageDigest.getInstance(\"MD5\");\n  md.update(source);\n  byte tmp[]=md.digest();\n  char str[]=new char[32];\n  int k=0;\n  for (int i=0; i < 16; i++) {\n    str[k++]=hexDigits[tmp[i] >>> 4 & 0xf];\n    str[k++]=hexDigits[tmp[i] & 0xf];\n  }\n  return new String(str);\n}\n", "nl": "md5 function"}
{"code": "private void updatePressPosition(int buttonIndex,RectF rectF){\n  if (buttonIndex < 0) {\n    return;\n  }\n  if (isPointInRectF(pressPointF,rectF)) {\n    if (!pressInButton) {\n      updatePressState(buttonIndex,true);\n      pressInButton=true;\n    }\n  }\n else {\n    if (pressInButton) {\n      updatePressState(buttonIndex,false);\n      pressInButton=false;\n    }\n  }\n}\n", "nl": "used for update press effect when finger move"}
{"code": "private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,ContrastMethod contrastMethod){\n  ContrastEnhancement contrastEnhancement=(ContrastEnhancement)styleFactory.contrastEnhancement(null,contrastMethod.name());\n  FilterFactory ff=CommonFactoryFinder.getFilterFactory();\n  Map<String,Expression> options=contrastEnhancement.getOptions();\n  options.put(\"algorithm\",ff.literal(\"StretchToMinimumMaximum\"));\n  options.put(\"minValue\",ff.literal(\"1\"));\n  options.put(\"maxValue\",ff.literal(\"5\"));\n  SelectedChannelType channelType=styleFactory.createSelectedChannelType(\"channel name\",contrastEnhancement);\n  SelectedChannelType[] channels=new SelectedChannelType[3];\n  channels[0]=channelType;\n  channels[1]=channelType;\n  channels[2]=channelType;\n  ChannelSelection channelSelection=styleFactory.createChannelSelection(channels);\n  return channelSelection;\n}\n", "nl": "Creates the channel selection object"}
{"code": "public String stringToConstant(String string){\n  int length=string.length();\n  for (int i=0; i < length; i++) {\n    char character=string.charAt(i);\n    if (character != \"_\".charAt(0) && Character.isUpperCase(character) && i != 0) {\n      String firstPart=string.substring(0,i);\n      String secondPart=string.substring(i,length);\n      String newFirstPart=firstPart + \"_\";\n      string=newFirstPart + secondPart;\n      i=newFirstPart.length();\n      length++;\n    }\n  }\n  return string;\n}\n", "nl": "convert a string to a constant schema"}
{"code": "public void registerEvent(Class<? extends Event> event,Listener listener,EventPriority priority,EventExecutor executor,Plugin plugin,boolean ignoreCancelled){\n  Validate.notNull(listener,\"Listener cannot be null\");\n  Validate.notNull(priority,\"Priority cannot be null\");\n  Validate.notNull(executor,\"Executor cannot be null\");\n  Validate.notNull(plugin,\"Plugin cannot be null\");\n  if (!plugin.isEnabled()) {\n    throw new IllegalPluginAccessException(\"Plugin attempted to register \" + event + \" while not enabled\");\n  }\n  if (useTimings) {\n    getEventListeners(event).register(new TimedRegisteredListener(listener,executor,priority,plugin,ignoreCancelled));\n  }\n else {\n    getEventListeners(event).register(new RegisteredListener(listener,executor,priority,plugin,ignoreCancelled));\n  }\n}\n", "nl": "Registers the given event to the specified listener using a directly passed EventExecutor"}
{"code": "public DirectedGraph load(String fileName) throws IOException, MaryConfigurationException {\n  InputStream is=new FileInputStream(fileName);\n  try {\n    return load(is);\n  }\n  finally {\n    is.close();\n  }\n}\n", "nl": "Load the directed graph from the given file"}
{"code": "public static java.sql.Timestamp monthBegin(){\n  Calendar mth=Calendar.getInstance();\n  mth.set(Calendar.DAY_OF_MONTH,1);\n  mth.set(Calendar.HOUR_OF_DAY,0);\n  mth.set(Calendar.MINUTE,0);\n  mth.set(Calendar.SECOND,0);\n  mth.set(Calendar.MILLISECOND,0);\n  mth.set(Calendar.AM_PM,Calendar.AM);\n  return new java.sql.Timestamp(mth.getTime().getTime());\n}\n", "nl": "Makes a Timestamp for the beginning of the month"}
{"code": "public DateColumn date(){\n  DateColumn newColumn=DateColumn.create(this.name() + \" date\");\n  for (int r=0; r < this.size(); r++) {\n    long c1=this.getLong(r);\n    if (c1 == MISSING_VALUE) {\n      newColumn.add(DateColumn.MISSING_VALUE);\n    }\n else {\n      newColumn.add(PackedLocalDateTime.date(c1));\n    }\n  }\n  return newColumn;\n}\n", "nl": "Returns a DateColumn containing the date portion of each dateTime in this DateTimeColumn"}
{"code": "public static void stopGatherableTask(Player player,boolean save){\n  Future<?> gatherableTask=player.getController().getTask(TaskId.GATHERABLE);\n  if (gatherableTask != null) {\n    if (save) {\n      long delay=player.getGatherableTimer();\n      if (delay < 0) {\n        delay=0;\n      }\n      player.setGatherableTimer(delay);\n    }\n    player.getController().cancelTask(TaskId.GATHERABLE);\n  }\n}\n", "nl": "This method will stop the gathering task"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  final ChartColorManager chartColorManager=((Director)getDir()).getDocument().getChartColorManager();\n  np.matchIgnoreCase(\"set color=\");\n  Color color=np.getColor();\n  np.matchIgnoreCase(\"attribute=\");\n  String attribute=np.getLabelRespectCase();\n  np.matchIgnoreCase(\";\");\n  np.matchIgnoreCase(\"state=\");\n  String state=np.getLabelRespectCase();\n  if (attribute != null && state != null) {\n    chartColorManager.setAttributeStateColor(attribute,state,color);\n    ((Director)getDir()).getDocument().setDirty(true);\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private void inflateEmptyTextColor(){\n  if (mEmptyTextColor != R.color.text_empty_color) {\n    if (mEmptyLayout != R.layout.layout_empty) {\n      throw new RuntimeException(\"Cannot assign the emptyTextColor attribute. \" + \"You already overridden the entire empty view, no need to specify \" + \"custom color or custom text message\");\n    }\n else {\n      textEmpty.setTextColor(ColorUtil.getColorWrapper(mContext,mEmptyTextColor));\n    }\n  }\n}\n", "nl": "Set the empty view text color"}
{"code": "@Override public ILongPutter put(long index,long value){\n  if (index < limit()) {\n    index<<=3;\n    final ByteBuffer buf=buffers[getWhichBuffer(index)];\n    int indexBuffer=getIndexInBuffer(index);\n    buf.put(indexBuffer++,(byte)(value >> 56));\n    buf.put(indexBuffer++,(byte)(value >> 48));\n    buf.put(indexBuffer++,(byte)(value >> 40));\n    buf.put(indexBuffer++,(byte)(value >> 32));\n    buf.put(indexBuffer++,(byte)(value >> 24));\n    buf.put(indexBuffer++,(byte)(value >> 16));\n    buf.put(indexBuffer++,(byte)(value >> 8));\n    buf.put(indexBuffer,(byte)(value));\n  }\n else   throw new ArrayIndexOutOfBoundsException(\"\" + index);\n  return this;\n}\n", "nl": "puts value for given index"}
{"code": "private void startHotRefresh(){\n  try {\n    String host=new URL(mUri.toString()).getHost();\n    String wsUrl=\"ws://\" + host + \":8082\";\n    mWXHandler.obtainMessage(Constants.HOT_REFRESH_CONNECT,0,0,wsUrl).sendToTarget();\n  }\n catch (  MalformedURLException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "hot refresh"}
{"code": "@Override public void refresh0(int year,int month){\n  if (mode == Constant.MODE_CALENDAR) {\n    selectedYear=year;\n    selectedMonth=month;\n    selectedIndex=-1;\n    calendar.set(Calendar.YEAR,selectedYear);\n    calendar.set(Calendar.MONTH,selectedMonth - 1);\n    calendar.set(Calendar.DAY_OF_MONTH,1);\n    initial();\n    invalidate();\n    if (onRefreshListener != null) {\n      onRefreshListener.onRefresh();\n    }\n  }\n}\n", "nl": "used for MODE_CALENDAR legal values of month: 1-12"}
{"code": "boolean updateValueType(Object value){\n  if (_valueTypeFinallySet || value == null)   return _valueTypeFinallySet;\n  Class<?> type=value.getClass();\n  if (_valueType == null) {\nsynchronized (this) {\n      if (_valueType == null)       _valueType=type;\n    }\n  }\n else   if (_valueType != type && !_valueType.isAssignableFrom(type)) {\nsynchronized (this) {\n      _valueType=TypeDataIndex.getCommonSuperType(type,_valueType);\n    }\n  }\n  if (_valueType == Object.class)   _valueTypeFinallySet=true;\n  return _valueTypeFinallySet;\n}\n", "nl": "set the value type if needed, returns true if the type is finally set"}
{"code": "private void drawAllComponents(Graphics2D gc,NlComponent component,@Nullable ScreenView blueprintView){\n  Color color=gc.getColor();\n  if (myComponent != null && component.getId() != null && component.getId().equals(myComponent.getId())) {\n    gc.setColor(myColorSet.getSelectedFrames());\n  }\n  drawComponent(gc,component,blueprintView);\n  gc.setColor(color);\n  int childCount=component.getChildCount();\n  for (int i=0; i < childCount; i++) {\n    drawAllComponents(gc,component.getChild(i),blueprintView);\n  }\n}\n", "nl": "Recursively draw all components  by finding the root of component then find all its children and grandchildren (BFS)"}
{"code": "public static String utf8Encode(String str,String defultReturn){\n  if (!isEmpty(str) && str.getBytes().length != str.length()) {\n    try {\n      return URLEncoder.encode(str,\"UTF-8\");\n    }\n catch (    UnsupportedEncodingException e) {\n      return defultReturn;\n    }\n  }\n  return str;\n}\n", "nl": "encoded in utf-8, if exception, return defultReturn"}
{"code": "public SQLModel(Connection connection){\n  this.connection=connection;\n  this.tables=new ArrayList<>();\n  ResultSet results=null;\n  try {\n    results=connection.getMetaData().getTables(null,null,null,new String[]{\"TABLE\"});\n    while (results.next()) {\n      String tableName=results.getString(\"TABLE_NAME\");\n      tables.add(new SQLTable(tableName,connection));\n    }\n  }\n catch (  SQLException e) {\n    throw new RuntimeException(e);\n  }\n finally {\n    closeQuietly(results);\n  }\n}\n", "nl": "Initialize data structures containing SQL data"}
{"code": "private void calculateVolumeLevel(byte[] buffer,float[] spectrum){\n  long currentMaxDb=getMaxDecibels(buffer);\n  float coefficient=(float)currentMaxDb / maxVolumeDb;\n  float maxCoefficient=0;\n  for (int i=0; i < NUMBER_OF_FREQ_BARS; i++) {\n    if (maxCoefficient < spectrum[i]) {\n      maxCoefficient=spectrum[i];\n    }\n  }\n  if (maxCoefficient > 0) {\n    coefficient/=maxCoefficient;\n    for (int i=0; i < NUMBER_OF_FREQ_BARS; i++) {\n      spectrum[i]*=coefficient;\n    }\n  }\n}\n", "nl": "Changes spectrum values according to volume level"}
{"code": "public String readString() throws IOException {\n  int size=readInt();\n  if (Math.abs(size) > 100000000)   throw new IOException(\"Unreasonable string length: \" + Math.abs(size));\n  byte[] bytes=new byte[Math.abs(size)];\n  int got=in.read(bytes,0,Math.abs(size));\n  if (got != Math.abs(size))   throw new IOException(\"Bytes read: \" + got + \", expected: \"+ Math.abs(size));\n  if (size < 0) {\n    try {\n      return compressor.inflateByteArray2String(-size,bytes);\n    }\n catch (    DataFormatException e) {\n      throw new IOException(e.getMessage());\n    }\n  }\n else {\n    return Compressor.convertUncompressedByteArray2String(size,bytes);\n  }\n}\n", "nl": "reads an archived string"}
{"code": "public void removeFence(@NonNull String id){\n  Set<String> fenceIdSet=mPrefs.getStringSet(mPrefix + FENCE_ID_SET_KEY,null);\n  if ((fenceIdSet != null) && fenceIdSet.contains(id)) {\n    SharedPreferences.Editor editor=mPrefs.edit();\n    editor.remove(mPrefix + id);\n    fenceIdSet.remove(id);\n    editor.putStringSet(FENCE_ID_SET_KEY,fenceIdSet);\n    editor.apply();\n  }\n}\n", "nl": "Remove a fence from the store based on its id"}
{"code": "@Override public void xml(String xml){\n  if (TextUtils.isEmpty(xml)) {\n    d(\"Empty/Null xml content\");\n    return;\n  }\n  try {\n    Source xmlInput=new StreamSource(new StringReader(xml));\n    StreamResult xmlOutput=new StreamResult(new StringWriter());\n    Transformer transformer=TransformerFactory.newInstance().newTransformer();\n    transformer.setOutputProperty(OutputKeys.INDENT,\"yes\");\n    transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\",\"2\");\n    transformer.transform(xmlInput,xmlOutput);\n    d(xmlOutput.getWriter().toString().replaceFirst(\">\",\">\\n\"));\n  }\n catch (  TransformerException e) {\n    e(e.getCause().getMessage() + \"\\n\" + xml);\n  }\n}\n", "nl": "Formats the json content and print it"}
{"code": "public MapleQuestStatus(final MapleQuest quest,final int status){\n  this.quest=quest;\n  this.setStatus((byte)status);\n  this.completionTime=System.currentTimeMillis();\n  if (status == 1) {\n    if (!quest.getRelevantMobs().isEmpty()) {\n      registerMobs();\n    }\n  }\n}\n", "nl": "Creates a new instance of MapleQuestStatus"}
{"code": "public void updateUnreadLabel(){\n  int count=getUnreadMsgCountTotal();\n  if (count > 0) {\n    unreadLabel.setText(String.valueOf(count));\n    unreadLabel.setVisibility(View.VISIBLE);\n  }\n else {\n    unreadLabel.setVisibility(View.INVISIBLE);\n  }\n}\n", "nl": "update unread message count"}
{"code": "public V put(R rowKey,C columnKey,V value){\n  if (rowKey != null && columnKey != null) {\n    Map<C,V> row=row(rowKey);\n    if (row == null) {\n      row=new HashMap<>();\n      dataMap.put(rowKey,row);\n    }\n    V oldValue=row.get(columnKey);\n    row.put(columnKey,value);\n    if (oldValue != null)     return oldValue;\n else     return value;\n  }\n  return null;\n}\n", "nl": "put the value for a cell"}
{"code": "private boolean isContainedInRectangles(SegmentNode pnew){\n  SegmentNode p=header[GeometricManager.MANY_TO_MANY];\n  while (p != null) {\n    if (pnew.I1 >= p.I1 && pnew.I2 >= p.I2) {\n      if ((pnew.I1 + pnew.L) <= (p.I1 + p.L) && (pnew.I2 + pnew.L) <= (p.I2 + ((RectangleNode)p).L_prime))       return true;\n    }\n    p=p.next;\n  }\n  return false;\n}\n", "nl": "Is the input line covered by any rectangle?"}
{"code": "public int read(long position,InputReader reader,int classId) throws IOException {\n  reader.seek(position);\n  map2Weight.clear();\n  final int numberOfClasses=reader.readInt();\n  for (int i=0; i < numberOfClasses; i++) {\n    final int currentId=reader.readInt();\n    final int weight=reader.readInt();\n    final int count=reader.readInt();\n    reader.skipBytes(count * 8);\n    if (currentId == classId) {\n      map2Weight.put(currentId,weight);\n      break;\n    }\n  }\n  return map2Weight.size();\n}\n", "nl": "reads the named classification block"}
{"code": "public static Window windowForWordInPosition(int windowSize,int wordPos,List<String> sentence){\n  List<String> window=new ArrayList<>();\n  List<String> onlyTokens=new ArrayList<>();\n  int contextSize=(int)Math.floor((windowSize - 1) / 2);\n  for (int i=wordPos - contextSize; i <= wordPos + contextSize; i++) {\n    if (i < 0)     window.add(\"<s>\");\n else     if (i >= sentence.size())     window.add(\"</s>\");\n else {\n      onlyTokens.add(sentence.get(i));\n      window.add(sentence.get(i));\n    }\n  }\n  String wholeSentence=StringUtils.join(sentence);\n  String window2=StringUtils.join(onlyTokens);\n  int begin=wholeSentence.indexOf(window2);\n  int end=begin + window2.length();\n  return new Window(window,begin,end);\n}\n", "nl": "Creates a sliding window from text"}
{"code": "private boolean containsBlackPoint(int a,int b,int fixed,boolean horizontal){\n  if (horizontal) {\n    for (int x=a; x <= b; x++) {\n      if (image.get(x,fixed)) {\n        return true;\n      }\n    }\n  }\n else {\n    for (int y=a; y <= b; y++) {\n      if (image.get(fixed,y)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Determines whether a segment contains a black point"}
{"code": "@Override public void validate(ValidationContext context,ValidatedInfo validatedInfo) throws InvalidDatatypeValueException {\n  if (context == null)   context=fEmptyContext;\n  if (context.needFacetChecking() && (fFacetsDefined != 0 && fFacetsDefined != FACET_WHITESPACE)) {\n    checkFacets(validatedInfo);\n  }\n  if (context.needExtraChecking()) {\n    checkExtraRules(context,validatedInfo);\n  }\n}\n", "nl": "validate an actual value against this DV"}
{"code": "@Override public void close(){\n  if (mustWriteOnClose) {\n    System.err.println(\"Writing file: \" + file);\n    try (BufferedWriter w=new BufferedWriter(new FileWriter(file))){\n      for (      Long key : map.keySet()) {\n        w.write(key + \"\\t\" + map.get(key)+ \"\\n\");\n      }\n    }\n catch (    IOException ex) {\n      Basic.caught(ex);\n    }\n  }\n}\n", "nl": "close the array"}
{"code": "@Override public String toString(){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"Point3D\");\n  sb.append(\"{x=\").append(x);\n  sb.append(\", y=\").append(y);\n  sb.append(\", z=\").append(z);\n  sb.append('}');\n  return sb.toString();\n}\n", "nl": "Formatted string representation of this point"}
{"code": "private void gauss(int size){\n  int start=(windowFunction.length - size) / 2;\n  int stop=(windowFunction.length + size) / 2;\n  double delta=5.0 / size;\n  double x=(1 - size) / 2.0 * delta;\n  double c=-Math.PI * Math.exp(1.0) / 10.0;\n  double sum=0;\n  for (int i=start; i < stop; i++) {\n    windowFunction[i]=Math.exp(c * x * x);\n    x+=delta;\n    sum+=windowFunction[i];\n  }\n  for (int i=start; i < stop; i++)   windowFunction[i]/=sum;\n}\n", "nl": "Fill an array with the values of a Gaussian window function"}
{"code": "@Override public void onCreate(){\n  super.onCreate();\n  Log_OC.d(TAG,\"Creating service\");\n  mNotificationManager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);\n  HandlerThread thread=new HandlerThread(\"FileDownloaderThread\",Process.THREAD_PRIORITY_BACKGROUND);\n  thread.start();\n  mServiceLooper=thread.getLooper();\n  mServiceHandler=new ServiceHandler(mServiceLooper,this);\n  mBinder=new FileDownloaderBinder();\n  AccountManager am=AccountManager.get(getApplicationContext());\n  am.addOnAccountsUpdatedListener(this,null,false);\n}\n", "nl": "Service initialization"}
{"code": "public static boolean applyCount(Context context,int badgeCount){\n  try {\n    applyCountOrThrow(context,badgeCount);\n    return true;\n  }\n catch (  ShortcutBadgeException e) {\n    Log.e(LOG_TAG,\"Unable to execute badge\",e);\n    return false;\n  }\n}\n", "nl": "Tries to update the notification count"}
{"code": "public static String toString(Bundle bundle){\n  if (bundle == null) {\n    return null;\n  }\n  StringBuilder stringBuilder=new StringBuilder();\n  for (  String key : bundle.keySet()) {\n    Object value=bundle.get(key);\n    stringBuilder.append(String.format(\"%s %s (%s)\\n\",key,value,value == null ? \"null\" : value.getClass().getName()));\n  }\n  return stringBuilder.substring(0,stringBuilder.length() - 1);\n}\n", "nl": "Convert bundle to readable string"}
{"code": "private void initView(GLSurfaceView glSurfaceView,@ColorInt int backgroundColor){\n  Context context=glSurfaceView.getContext();\n  final ActivityManager activityManager=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);\n  final ConfigurationInfo configurationInfo=activityManager.getDeviceConfigurationInfo();\n  final boolean supportsEs2=configurationInfo.reqGlEsVersion >= 0x20000;\n  if (supportsEs2) {\n    glSurfaceView.setEGLContextClientVersion(2);\n    mRenderer=new BezierRenderer(glSurfaceView,backgroundColor);\n    glSurfaceView.setRenderer(mRenderer);\n    glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);\n  }\n else {\n    throw new UnsupportedOperationException();\n  }\n}\n", "nl": "Basic settings for component"}
{"code": "@Nullable public static String extractId(@Nullable String str){\n  if (str == null) {\n    return null;\n  }\n  int index=str.lastIndexOf(\"@id/\");\n  if (index != -1) {\n    return str.substring(index + 4);\n  }\n  index=str.lastIndexOf(\"@+id/\");\n  if (index != -1) {\n    return str.substring(index + 5);\n  }\n  return null;\n}\n", "nl": "Utility function to extract the id"}
{"code": "@Override public boolean equals(Object o){\n  if (o instanceof RepoResult == false) {\n    return false;\n  }\n  RepoResult rr=(RepoResult)o;\n  if (this.getName().equals(rr.getName())) {\n    return true;\n  }\n  return false;\n}\n", "nl": "Required becuse we use this in the UniqueRepoQueue and in a few other places to ensure we don't add multiples of the same repo"}
{"code": "@Override public void clear(){\n  queryName=null;\n  flag=0;\n  refName=null;\n  pos=0;\n  mapQuality=0;\n  cigarString=null;\n  RNext=null;\n  PNext=0;\n  TLength=0;\n  sequence=null;\n  quality=null;\n  optionalFields.clear();\n  cigar=null;\n}\n", "nl": "erase the match"}
{"code": "static int currentUserCheck(String stmt,int offset){\n  int length=offset + _CURRENT_USER.length;\n  if (stmt.length() >= length) {\n    if (ParseUtil.compare(stmt,offset,_CURRENT_USER)) {\n      if (stmt.length() > length && stmt.charAt(length) != ' ') {\n        return OTHER;\n      }\n      return USER;\n    }\n  }\n  return OTHER;\n}\n", "nl": "SELECT USER()"}
{"code": "public void saveToXML(boolean forceSave){\n  Selection selection=getSelection();\n  if (forceSave || !selection.getModifiedWidgets().isEmpty()) {\n    ourLock.lock();\n    myModificationCount++;\n    ourLock.unlock();\n    if (DEBUG) {\n      System.out.println(\"Model Saved to XML -> \" + myModificationCount + \"(\"+ selection.getModifiedWidgets().size()+ \" elements modified)\");\n    }\n    ConstraintUtilities.saveModelToXML(myNlModel,true);\n    selection.clearModifiedWidgets();\n    requestRender();\n  }\n}\n", "nl": "Always save the model to xml"}
{"code": "public static DockerPortMapping fromMap(Map.Entry<String,List<Map<String,String>>> entry){\n  DockerPortMapping portMapping=new DockerPortMapping();\n  if (entry.getValue() == null) {\n    return null;\n  }\n  portMapping.containerPort=entry.getKey();\n  int protocolSeparatorIndex=portMapping.containerPort.indexOf(\"/\");\n  if (protocolSeparatorIndex != -1) {\n    portMapping.protocol=Protocol.fromString(portMapping.containerPort.substring(protocolSeparatorIndex + 1));\n    portMapping.containerPort=portMapping.containerPort.substring(0,protocolSeparatorIndex);\n  }\n  Map<String,String> hostMap=entry.getValue().get(0);\n  portMapping.hostIp=hostMap.get(HOST_IP);\n  portMapping.hostPort=hostMap.get(HOST_PORT);\n  return portMapping;\n}\n", "nl": "Convert a map generated by the toMap() method back to a DockerPortMapping"}
{"code": "private void initAttrs(Context context,FieldsType type,int resId,String hint){\n  try {\n    this.mRootView=(RelativeLayout)inflate(context,R.layout.library_form_field_layout,this);\n    this.mIconView=(ImageView)mRootView.findViewById(R.id.slick_form_text_icon);\n    this.mFieldInput=(EditText)mRootView.findViewById(R.id.slick_form_text_input);\n    LayoutParams params=new LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT);\n    params.addRule(RelativeLayout.RIGHT_OF,mIconView.getId());\n    this.mIconView.setImageResource(resId);\n    this.mFieldInput.setLayoutParams(params);\n    this.mFieldInput.setHint(hint);\n    this.formFieldType=type;\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Method that initializes this custom view's default values and sets listeners"}
{"code": "private void handshake(SocketAddress address,ProxyClient sc,FutureEventListener<ServerInfo> listener,boolean logging,boolean getOwnerships){\n  if (clientConfig.getHandshakeWithClientInfo()) {\n    ClientInfo clientInfo=new ClientInfo();\n    clientInfo.setGetOwnerships(getOwnerships);\n    clientInfo.setStreamNameRegex(clientConfig.getStreamNameRegex());\n    if (logging) {\n      logger.info(\"Handshaking with {} : {}\",address,clientInfo);\n    }\n    sc.getService().handshakeWithClientInfo(clientInfo).addEventListener(listener);\n  }\n else {\n    if (logging) {\n      logger.info(\"Handshaking with {}\",address);\n    }\n    sc.getService().handshake().addEventListener(listener);\n  }\n}\n", "nl": "Handshake with a given proxy"}
{"code": "private void createBlock(polyglot.ast.Block block){\n  if (block == null)   return;\n  Iterator it=block.statements().iterator();\n  while (it.hasNext()) {\n    Object next=it.next();\n    if (next instanceof polyglot.ast.Stmt) {\n      createStmt((polyglot.ast.Stmt)next);\n    }\n else {\n      throw new RuntimeException(\"Unexpected - Unhandled Node\");\n    }\n  }\n}\n", "nl": "Block creation"}
{"code": "public boolean paint(@NotNull Graphics2D gc,ConstraintWidget component,int width,int height,boolean showAllConstraints){\n  Graphics2D g=(Graphics2D)gc.create();\n  WidgetDecorator.setShowFakeUI(mShowFakeUI);\n  if (mySceneDraw.getCurrentStyle() == WidgetDecorator.BLUEPRINT_STYLE) {\n    mySceneDraw.drawBackground(myConstraintModel.getScene().getWidget(component),myViewTransform,g,width,height);\n  }\n  if (myConstraintModel.getNeedsAnimateConstraints() != -1) {\n    mySceneDraw.animateConstraints(myConstraintModel.getNeedsAnimateConstraints());\n    myConstraintModel.setNeedsAnimateConstraints(-1);\n  }\n  boolean ret=mySceneDraw.paintWidgets(component,width,height,myViewTransform,g,showAllConstraints,myMouseInteraction);\n  g.dispose();\n  return ret;\n}\n", "nl": "Paint ourselves and our children"}
{"code": "public void removeSubFilterWithTag(String tag){\n  Iterator<SubFilter> iterator=subFilters.iterator();\n  while (iterator.hasNext()) {\n    SubFilter subFilter=iterator.next();\n    if (subFilter.getTag().equals(tag)) {\n      iterator.remove();\n    }\n  }\n}\n", "nl": "Removes the subfilter containing Tag from the Parent Filter"}
{"code": "protected void increaseBufferSize(int minSize){\n  int newLength=buf.length;\n  while (newLength < minSize)   newLength*=2;\n  double[] newBuf=new double[newLength];\n  int avail=currentlyInBuffer();\n  System.arraycopy(buf,readPos,newBuf,0,avail);\n  buf=newBuf;\n  readPos=0;\n  writePos=avail;\n}\n", "nl": "Increase the underlying buffer array in size, so that the new size is at least minSize"}
{"code": "private void swap(byte[] bytes,int len){\n  int top=len / 2;\n  int j=len - 1;\n  for (int i=0; i < top; i++, j--) {\n    byte b=bytes[i];\n    bytes[i]=bytes[j];\n    bytes[j]=b;\n  }\n}\n", "nl": "swap order of bytes"}
{"code": "public double normF(){\n  double f=0;\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      f=Maths.hypot(f,A[i][j]);\n    }\n  }\n  return f;\n}\n", "nl": "Frobenius norm"}
{"code": "public static ImageView asImageViewFX(ImageIcon imageIcon){\n  java.awt.Image awtImage=imageIcon.getImage();\n  if (awtImage != null) {\n    final BufferedImage bImg;\n    if (awtImage instanceof BufferedImage) {\n      bImg=(BufferedImage)awtImage;\n    }\n else {\n      bImg=new BufferedImage(awtImage.getWidth(null),awtImage.getHeight(null),BufferedImage.TYPE_INT_ARGB);\n      Graphics2D graphics=bImg.createGraphics();\n      graphics.drawImage(awtImage,0,0,null);\n      graphics.dispose();\n    }\n    return new ImageView(SwingFXUtils.toFXImage(bImg,null));\n  }\n else   return null;\n}\n", "nl": "convert AWT imageIcon to JavaFX image"}
{"code": "public static boolean moveUp(Alignment alignment,int firstRow,int lastRow){\n  lastRow=Math.min(lastRow,alignment.getNumberOfSequences());\n  if (firstRow <= 0 || firstRow > lastRow)   return false;\n else {\n    Integer[] array=new Integer[alignment.getNumberOfSequences()];\n    for (int i=0; i < alignment.getNumberOfSequences(); i++)     array[i]=alignment.getOrder(i);\n    int replaced=array[firstRow - 1];\n    System.arraycopy(array,firstRow,array,firstRow - 1,lastRow + 1 - firstRow);\n    array[lastRow]=replaced;\n    alignment.setOrder(Arrays.asList(array));\n    return true;\n  }\n}\n", "nl": "move the selected interval of sequences up one"}
{"code": "protected void prepareWriterAndWriteData(List<String> data,String columnId) throws IOException {\n  ColumnIdentifier columnIdentifier=new ColumnIdentifier(columnId,null,null);\n  CarbonDictionaryWriter carbonDictionaryWriter=new CarbonDictionaryWriterImpl(carbonStorePath,carbonTableIdentifier,columnIdentifier);\n  CarbonTablePath carbonTablePath=CarbonStorePath.getCarbonTablePath(carbonStorePath,carbonTableIdentifier);\n  CarbonUtil.checkAndCreateFolder(carbonTablePath.getMetadataDirectoryPath());\n  List<byte[]> valueList=convertStringListToByteArray(data);\n  try {\n    carbonDictionaryWriter.write(valueList);\n  }\n  finally {\n    carbonDictionaryWriter.close();\n    carbonDictionaryWriter.commit();\n  }\n}\n", "nl": "write dictionary data"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set nodeSize=\");\n  int width=np.getInt(0,1000);\n  np.matchIgnoreCase(\";\");\n  if (getViewer() instanceof GraphView) {\n    boolean changed=false;\n    GraphView viewer=(GraphView)getViewer();\n    for (    Node v : viewer.getSelectedNodes()) {\n      viewer.setHeight(v,width);\n      viewer.setWidth(v,width);\n      changed=true;\n    }\n    if (changed) {\n      viewer.repaint();\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public void write(IOutputWriter writer) throws IOException {\n  writer.writeInt(RMA2File.MAGIC_NUMBER);\n  writer.writeInt(3);\n  writer.writeString(getFormatDef());\n  FormatDefinition formatDefinition=FormatDefinition.fromString(getFormatDef());\n  formatDefinition.startWrite();\n  for (  Pair<String,FormatDefinition.Type> pair : formatDefinition.getList()) {\n    if (pair.getFirst().equals(\"Creator\"))     formatDefinition.write(writer,\"Creator\",getCreator());\n else     if (pair.getFirst().equals(\"CreationDate\"))     formatDefinition.write(writer,\"CreationDate\",getCreationDate());\n  }\n  formatDefinition.finishWrite();\n}\n", "nl": "write the current header data"}
{"code": "public ItemStack(final ItemStack stack) throws IllegalArgumentException {\n  Validate.notNull(stack,\"Cannot copy null stack\");\n  this.type=stack.getTypeId();\n  this.amount=stack.getAmount();\n  this.durability=stack.getDurability();\n  this.data=stack.getData();\n  if (stack.hasItemMeta()) {\n    setItemMeta0(stack.getItemMeta(),getType0());\n  }\n}\n", "nl": "Creates a new item stack derived from the specified stack"}
{"code": "private int visitNodesRec(Node v,EdgeMap<Integer> edgeWeight){\n  int maxValue=0;\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    if (edgeWeight.get(e) == null) {\n      edgeWeight.set(e,visitNodesRec(e.getTarget(),edgeWeight) + 1);\n    }\n    maxValue=Math.max(maxValue,edgeWeight.get(e));\n  }\n  return maxValue;\n}\n", "nl": "recursively visit all nodes and set edge weights"}
{"code": "public void parse(byte[] aLine,int length) throws IOException {\n  int numberOfTokens=0;\n  int start=0;\n  while (start < length) {\n    int end=start;\n    while (aLine[end] != '\\t' && end < length)     end++;\n    if (numberOfTokens == tokens.length) {\n      String[] tmp=new String[2 * tokens.length];\n      System.arraycopy(tokens,0,tmp,0,tokens.length);\n      tokens=tmp;\n    }\n    tokens[numberOfTokens++]=Basic.toString(aLine,start,end - start);\n    start=end + 1;\n  }\n  parse(tokens,numberOfTokens);\n}\n", "nl": "parse a line of SAM format"}
{"code": "public void performQuery() throws IOException, PIRException {\n  logger.info(\"Performing query: \");\n  JavaRDD<MapWritable> inputRDD;\nswitch (dataInputFormat) {\ncase InputFormatConst.BASE_FORMAT:\n    inputRDD=readData();\n  break;\ncase InputFormatConst.ES:\ninputRDD=readDataES();\nbreak;\ndefault :\nthrow new PIRException(\"Unknown data input format \" + dataInputFormat);\n}\nperformQuery(inputRDD);\n}\n", "nl": "Method to read in data from an allowed input source/format and perform the query"}
{"code": "private Set<String> loadAndroidCallbacks() throws IOException {\n  Set<String> androidCallbacks=new HashSet<String>();\n  BufferedReader rdr=null;\n  try {\n    String fileName=JadeCfg.getCallback_file();\n    if (!new File(fileName).exists()) {\n      fileName=\"../soot-infoflow-android/AndroidCallbacks.txt\";\n      if (!new File(fileName).exists())       throw new RuntimeException(\"Callback definition file not found\");\n    }\n    rdr=new BufferedReader(new FileReader(fileName));\n    String line;\n    while ((line=rdr.readLine()) != null)     if (!line.isEmpty())     androidCallbacks.add(line);\n  }\n  finally {\n    if (rdr != null)     rdr.close();\n  }\n  return androidCallbacks;\n}\n", "nl": "Loads the set of interfaces that are used to implement Android callback handlers from a file on disk"}
{"code": "TestItem awareTestItemIssueTypeFromStatus(final TestItem testItem,final Issue providedIssue,final Project project){\n  if (FAILED.equals(testItem.getStatus()) || SKIPPED.equals(testItem.getStatus())) {\n    if (null != providedIssue) {\n      verifyIssue(testItem.getId(),providedIssue,project.getConfiguration());\n      String issueType=providedIssue.getIssueType();\n      if (!issueType.equalsIgnoreCase(NOT_ISSUE_FLAG.getValue())) {\n        testItem.setIssue(new TestItemIssue(project.getConfiguration().getByLocator(issueType).getLocator(),providedIssue.getComment()));\n      }\n    }\n else {\n      testItem.setIssue(new TestItemIssue());\n      Launch launch=launchRepository.findOne(testItem.getLaunchRef());\n      expect(launch,notNull()).verify(LAUNCH_NOT_FOUND,testItem.getLaunchRef());\n      if (Mode.DEFAULT.equals(launch.getMode()) && project.getConfiguration().getIsAutoAnalyzerEnabled())       finalizeFailed(testItem);\n    }\n  }\n  return testItem;\n}\n", "nl": "Issue type recognition for specified test item from"}
{"code": "private void findRepeatedDataItems(){\n  for (  JsTreeDataItem dataItem : this) {\n    Integer timesRepeated=0;\n    if (hasTreeDataItem(dataItem)) {\n      if (sameIdDataItemsMap.containsKey(dataItem.getOriginalId()))       timesRepeated=sameIdDataItemsMap.get(dataItem.getOriginalId());\n      timesRepeated++;\n      sameIdDataItemsMap.put(dataItem.getOriginalId(),timesRepeated);\n    }\n  }\n}\n", "nl": "Finds all repeated elements, or basically the ones with the same id so they can be treated later on"}
{"code": "public static String md5File(String fullFilename){\n  String result=null;\n  if (fullFilename != null) {\n    try {\n      result=md5File(new FileInputStream(fullFilename));\n    }\n catch (    Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  return result;\n}\n", "nl": "md5 file"}
{"code": "public long queryCount() throws GenericEntityException {\n  if (dynamicViewEntity != null) {\n    EntityListIterator iterator=null;\n    try {\n      iterator=queryIterator();\n      return iterator.getResultsSizeAfterPartialList();\n    }\n  finally {\n      if (iterator != null) {\n        iterator.close();\n      }\n    }\n  }\n  return delegator.findCountByCondition(entityName,makeWhereCondition(false),havingEntityCondition,makeEntityFindOptions());\n}\n", "nl": "Executes the EntityQuery and returns the result count If the query generates more than a single result then an exception is thrown"}
{"code": "private void validateAndUpdate(UpdateOneIssueSubTypeRQ one,Project.Configuration settings){\n  TestItemIssueType expectedType=fromValue(one.getTypeRef());\n  expect(expectedType,notNull()).verify(ISSUE_TYPE_NOT_FOUND,one.getTypeRef());\n  StatisticSubType exist=settings.getByLocator(one.getId());\n  expect(exist,notNull()).verify(ISSUE_TYPE_NOT_FOUND,one.getId());\n  expect(exist.getTypeRef().equals(expectedType.getValue()) || exist.getTypeRef().equals(IssueCounter.GROUP_TOTAL),equalTo(true)).verify(FORBIDDEN_OPERATION,\"You cannot change sub-type references to global type.\");\n  if (Sets.newHashSet(AUTOMATION_BUG.getLocator(),PRODUCT_BUG.getLocator(),SYSTEM_ISSUE.getLocator(),NO_DEFECT.getLocator(),TO_INVESTIGATE.getLocator(),IssueCounter.GROUP_TOTAL).contains(exist.getLocator())) {\n    fail().withError(FORBIDDEN_OPERATION,\"You cannot edit predefined global issue types.\");\n  }\n  StatisticSubType type=new StatisticSubType(one.getId(),one.getTypeRef(),one.getLongName(),one.getShortName(),one.getColor());\n  settings.setByLocator(type);\n}\n", "nl": "Validate provided issue sub-type from RQ and update project settings object if validations are OK"}
{"code": "private static <T>List<T> asList(Set<T> a,Set<T> b){\n  if (a == null || b == null || a.isEmpty() || b.isEmpty()) {\n    return Collections.<T>emptyList();\n  }\n  if (a.size() < b.size()) {\n    List<T> c=new ArrayList<T>(a);\n    c.retainAll(b);\n    return c;\n  }\n else {\n    List<T> c=new ArrayList<T>(b);\n    c.retainAll(a);\n    return c;\n  }\n}\n", "nl": "Intersects 2 sets and returns the result as a list"}
{"code": "public static void toggleViewVisibility(View view,boolean setVisible){\n  if (view == null) {\n    return;\n  }\n  int visibility=View.GONE;\n  if (setVisible) {\n    visibility=View.VISIBLE;\n  }\n  view.setVisibility(visibility);\n}\n", "nl": "Sets the visiblity of the view"}
{"code": "@Override protected void onScrollChanged(int l,int t,int oldl,int oldt){\n  super.onScrollChanged(l,t,oldl,oldt);\n  if (mHeaderView == null)   return;\n  if (mHeaderView.getTop() < 0 && mHeaderView.getLayoutParams().height > mHeaderViewHeight) {\n    mHeaderView.getLayoutParams().height+=mHeaderView.getTop();\n    mOnRefreshDistanceListener.refreshDistance(mHeaderView.getTop());\n    mHandler.obtainMessage(1,mHeaderView.getTop(),0,mHeaderView).sendToTarget();\n  }\n}\n", "nl": "head view to back"}
{"code": "public static long delete(String collection,Bson query){\n  try {\n    MongoCollection<Document> db=MongoHelper.getCollection(collection);\n    if (db != null) {\n      DeleteResult r=db.deleteMany(query);\n      return r.getDeletedCount();\n    }\n    return -1;\n  }\n catch (  Exception e) {\n    if (log.isErrorEnabled())     log.error(e.getMessage(),e);\n  }\n  return -1;\n}\n", "nl": "Delete the data in mongo by the query"}
{"code": "public void writeStringNoCompression(String str) throws IOException {\n  if (str == null) {\n    writeInt(0);\n  }\n else {\n    writeInt(str.length());\n    for (int i=0; i < str.length(); i++)     io.write((byte)str.charAt(i));\n  }\n}\n", "nl": "Write a string without compression"}
{"code": "protected void dispatchJobCanceledEvents(ExecutionEntity activityExecution){\n  if (activityExecution != null) {\n    List<JobEntity> jobs=activityExecution.getJobs();\n    for (    JobEntity job : jobs) {\n      if (Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) {\n        Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.JOB_CANCELED,job));\n      }\n    }\n    List<TimerJobEntity> timerJobs=activityExecution.getTimerJobs();\n    for (    TimerJobEntity job : timerJobs) {\n      if (Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) {\n        Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.JOB_CANCELED,job));\n      }\n    }\n  }\n}\n", "nl": "dispatch job canceled event for job associated with given execution entity"}
{"code": "private String makeAbsolute(String uri){\n  if (uri == null) {\n    uri=\"\";\n  }\n  try {\n    URL url=new URL(uri);\n    return url.toString();\n  }\n catch (  MalformedURLException mue) {\n    try {\n      URL fileURL=FileURL.makeURL(uri);\n      return fileURL.toString();\n    }\n catch (    MalformedURLException mue2) {\n      return uri;\n    }\n  }\n}\n", "nl": "Attempt to construct an absolute URI"}
{"code": "public SamLocusIterator(final SamReader samReader,final IntervalList intervalList,final boolean useIndex){\n  this.samReader=samReader;\n  this.useIndex=useIndex;\n  if (intervalList != null) {\n    intervals=intervalList.uniqued().getIntervals();\n    this.referenceSequenceMask=new IntervalListReferenceSequenceMask(intervalList);\n  }\n else {\n    intervals=null;\n    this.referenceSequenceMask=new WholeGenomeReferenceSequenceMask(samReader.getFileHeader());\n  }\n}\n", "nl": "Prepare to iterate through the given SAM records, skipping non-primary alignments"}
{"code": "@SuppressWarnings(\"deprecation\") void saveLocationServicesState(@NonNull ContentResolver contentResolver){\n  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {\n    originalLocationProviders=Settings.Secure.getString(contentResolver,Settings.Secure.LOCATION_PROVIDERS_ALLOWED);\n  }\n else {\n    try {\n      originalLocationMode=Settings.Secure.getInt(contentResolver,Settings.Secure.LOCATION_MODE);\n    }\n catch (    Settings.SettingNotFoundException e) {\n      Log.e(TAG,\"Error reading location mode settings!\",e);\n    }\n  }\n}\n", "nl": "Should be called before starting tests, to save original location services values"}
{"code": "public void testListOfStringsField() throws Exception {\n  AnObject empty=new AnObject();\n  AnObject full=helper.fill(new AnObject());\n  Object value=getPropertyValue(full,\"listOfStringsField\");\n  assertTrue(value instanceof List);\n  assertFalse(((List)value).isEmpty());\n  assertTrue(helper.areEquals(full,full));\n  assertFalse(helper.areEquals(empty,full));\n}\n", "nl": "List field should always assigned new list with one elment 1L"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set colorMismatchesVsReference=\");\n  boolean value=np.getBoolean();\n  np.matchIgnoreCase(\";\");\n  AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  viewer.getAlignmentViewerPanel().getAlignmentPanel().setColorMismatchesVsReference(value);\n  ProgramProperties.put(\"ColorMismatches\",value);\n  viewer.repaint();\n}\n", "nl": "parses the given command and executes it"}
{"code": "private void storeLegion(Legion legion,boolean newLegion){\n  if (newLegion) {\n    addCachedLegion(legion);\n    DAOManager.getDAO(LegionDAO.class).saveNewLegion(legion);\n  }\n else {\n    DAOManager.getDAO(LegionDAO.class).storeLegion(legion);\n    DAOManager.getDAO(LegionDAO.class).storeLegionEmblem(legion.getLegionId(),legion.getLegionEmblem());\n  }\n}\n", "nl": "Stores legion data into db"}
{"code": "private void rotationArrow(ItemCompanyBinding binding,boolean expanded){\n  float start, target;\n  if (expanded) {\n    start=0f;\n    target=90f;\n  }\n else {\n    start=90f;\n    target=0f;\n  }\n  ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(binding.arrow,View.ROTATION,start,target);\n  objectAnimator.setDuration(300);\n  objectAnimator.start();\n}\n", "nl": "play arrow animation"}
{"code": "public void load(String fileName) throws IOException {\n  BufferedReader bfr=new BufferedReader(new InputStreamReader(new FileInputStream(fileName),\"UTF-8\"));\n  if (bList == null)   bList=new Vector(DEFAULT_INCREMENT,DEFAULT_INCREMENT);\n  String line=bfr.readLine();\n  if (line.indexOf(\"FROM: \") != -1) {\n    line=line.substring(6);\n    String[] parts=new String[2];\n    parts=line.split(\"\\\\*\",2);\n    fromDir=parts[0];\n    fromExt=parts[1];\n  }\n else   if (!(line.matches(\"^\\\\s*$\")))   add(line);\n  while ((line=bfr.readLine()) != null) {\n    if (!(line.matches(\"^\\\\s*$\")))     add(line);\n  }\n}\n", "nl": "Read the basenameList from a file"}
{"code": "public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"new attribute=\");\n  String attribute=np.getWordRespectCase();\n  np.matchIgnoreCase(\"position=\");\n  int position=np.getInt();\n  np.matchIgnoreCase(\";\");\n  final SamplesViewer viewer=((SamplesViewer)getViewer());\n  viewer.getSamplesTable().addNewColumn(position,attribute);\n}\n", "nl": "parses the given command and executes it"}
{"code": "public void clearAllBetweenHeadersAndFooters(){\n  List<Insertion> headersAndFooters=new ArrayList<>();\n  headersAndFooters.addAll(getHeaders());\n  headersAndFooters.addAll(getFooters());\n  mInserts.clear();\n  getItems().clear();\n  mOnlyInsertsCount=0;\n  mOnlyItemsCount=0;\n  reAddAllInserts(headersAndFooters);\n  notifyIfNeed();\n}\n", "nl": "Clear items and inserts between headers and footers"}
{"code": "private void handleDefaultTopBar(){\n  ViewGroup.LayoutParams params=new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);\n  setLayoutParams(params);\n  topBarView=iTopBarInterface.getDefaultTopBarView();\n  topBarView.setBackgroundColor(getColor(XUIConfig.getTopBarBgColor()));\n  topBarView.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,(int)getDefaultTopBarHeight()));\n  addView(topBarView);\n  FrameLayout.LayoutParams userViewParams=new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);\n  userViewParams.topMargin=(int)getContentTopMargin();\n  addView(mContentView,userViewParams);\n  initLoadContainer((int)getContentTopMargin());\n  addView(loadContainer);\n  handleTopBarShadow();\n}\n", "nl": "package content layout"}
{"code": "public String toString(){\n  StringBuilder buf=new StringBuilder();\n  buf.append(\" taxa=\").append(A.cardinality() + B.cardinality());\n  buf.append(\" weight=\").append((float)weight);\n  buf.append(\" confidence=\").append((float)confidence);\n  buf.append(\":\");\n  for (int a=A.nextSetBit(0); a != -1; a=A.nextSetBit(a + 1))   buf.append(\" \").append(a);\n  buf.append(\" |\");\n  for (int b=B.nextSetBit(0); b != -1; b=B.nextSetBit(b + 1))   buf.append(\" \").append(b);\n  return buf.toString();\n}\n", "nl": "gets a string representation"}
{"code": "public void createDatabase() throws Exception {\n  boolean dbExists=checkDatabase();\n  if (!dbExists) {\n    this.getReadableDatabase();\n    try {\n      copyDatabase();\n    }\n catch (    Exception e) {\n      Log.e(\"DB_ERROR\",\"createDatabase(): Could not copy DB\");\n      throw new Error(\"Could not copy DB'\");\n    }\n  }\n}\n", "nl": "database creating process"}
{"code": "public void loadPages(){\n  if (optimalPageWidth == 0 || optimalPageHeight == 0) {\n    return;\n  }\n  renderingAsyncTask.removeAllTasks();\n  cacheManager.makeANewSet();\n  pagesLoader.loadPages();\n  redraw();\n}\n", "nl": "Load all the parts around the center of the screen, taking into account X and Y offsets, zoom level, and the current page displayed"}
{"code": "private boolean selectByMouseInLegendPanel(LegendPanel legendPanel,Point point,ChartSelection chartSelection){\n  SelectionGraphics<String[]> selectionGraphics=new SelectionGraphics<>(getGraphics());\n  selectionGraphics.setMouseLocation(point);\n  legendPanel.paint(selectionGraphics);\n  Set<String> seriesToSelect=new HashSet<>();\n  Set<String> classesToSelect=new HashSet<>();\n  for (  String[] pair : selectionGraphics.getSelectedItems()) {\n    if (pair[0] != null) {\n      seriesToSelect.add(pair[0]);\n    }\n    if (pair[1] != null) {\n      classesToSelect.add(pair[1]);\n    }\n  }\n  if (seriesToSelect.size() > 0)   chartSelection.setSelectedSeries(seriesToSelect,true);\n  if (classesToSelect.size() > 0)   chartSelection.setSelectedClass(classesToSelect,true);\n  return seriesToSelect.size() > 0 || classesToSelect.size() > 0;\n}\n", "nl": "performs selection in legend panel"}
{"code": "@Override public void onRequestPermissionsResult(int requestCode,String permissions[],int[] grantResults){\n  try {\n    cordovaInterface.onRequestPermissionResult(requestCode,permissions,grantResults);\n  }\n catch (  JSONException e) {\n    LOG.d(TAG,\"JSONException: Parameters fed into the method are not valid\");\n    e.printStackTrace();\n  }\n}\n", "nl": "Called by the system when the user grants permissions"}
{"code": "public int diff_commonSuffix(String text1,String text2){\n  int text1_length=text1.length();\n  int text2_length=text2.length();\n  int n=Math.min(text1_length,text2_length);\n  for (int i=1; i <= n; i++) {\n    if (text1.charAt(text1_length - i) != text2.charAt(text2_length - i)) {\n      return i - 1;\n    }\n  }\n  return n;\n}\n", "nl": "Determine the common suffix of two strings"}
{"code": "@Nullable public static String readTextFileFromRawResource(@NonNull final Context context,@RawRes final int resId){\n  final BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(context.getResources().openRawResource(resId)));\n  String line;\n  final StringBuilder body=new StringBuilder();\n  try {\n    while ((line=bufferedReader.readLine()) != null) {\n      body.append(line).append('\\n');\n    }\n  }\n catch (  IOException e) {\n    return null;\n  }\n  return body.toString();\n}\n", "nl": "Reads a raw resource text file into a String"}
{"code": "private String unshortenUrl(String shortURL){\n  if (!shortURL.startsWith(HTTP_PROTOCOL) && !shortURL.startsWith(HTTPS_PROTOCOL))   return \"\";\n  URLConnection urlConn=connectURL(shortURL);\n  urlConn.getHeaderFields();\n  String finalResult=urlConn.getURL().toString();\n  urlConn=connectURL(finalResult);\n  urlConn.getHeaderFields();\n  shortURL=urlConn.getURL().toString();\n  while (!shortURL.equals(finalResult)) {\n    finalResult=unshortenUrl(finalResult);\n  }\n  return finalResult;\n}\n", "nl": "Unshortens a short url"}
{"code": "protected void init(Delegator delegator,ModelEntity modelEntity,Map<String,? extends Object> fields){\n  assertIsMutable();\n  if (modelEntity == null) {\n    throw new IllegalArgumentException(\"Cannot create a GenericEntity with a null modelEntity parameter\");\n  }\n  this.modelEntity=modelEntity;\n  this.entityName=modelEntity.getEntityName();\n  this.delegatorName=delegator.getDelegatorName();\n  this.internalDelegator=delegator;\n  this.observable=new Observable();\n  setFields(fields);\n  if (this.entityName == null) {\n    throw new IllegalArgumentException(\"Cannot create a GenericEntity with a null entityName in the modelEntity parameter\");\n  }\n}\n", "nl": "Creates new GenericEntity from existing Map"}
{"code": "public CustomConfiguration tryGetHostConfiguration(String hostName,HttpServletRequest request){\n  try {\n    return ConfigurationService.getHostConfiguration(hostName,request.getRemoteAddr(),request.getSession().getId());\n  }\n catch (  ConfigurationException e) {\n    Logger.debug(getClass(),\"Failed to retrieve host configuration: \" + hostName);\n    return null;\n  }\n}\n", "nl": "This attempts to retrieve a specific host configuration, if an exception occurs then null is returned"}
{"code": "public static short ulawToShort(byte ulaw){\n  short ulawbyte=(short)(ulaw + 128);\n  final int[] exp_lut={0,132,396,924,1980,4092,8316,16764};\n  int sign, exponent, mantissa;\n  short sample;\n  ulawbyte=(short)(ulawbyte & 0x00FF);\n  ulawbyte=(short)(~ulawbyte);\n  sign=(ulawbyte & ((short)0x80));\n  exponent=(ulawbyte & (short)0x00FF) >> 4 & 0x07;\n  mantissa=ulawbyte & (short)0x0F;\n  sample=(short)(exp_lut[exponent] + (mantissa << (exponent + 3)));\n  if (sign != 0)   sample=(short)(-sample);\n  return sample;\n}\n", "nl": "Convert a ulaw format to short"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  final megan.remote.RemoteServiceBrowser remoteServiceBrowser=(megan.remote.RemoteServiceBrowser)getViewer();\n  final megan.remote.ServicePanel servicePanel=remoteServiceBrowser.getServicePanel();\n  if (servicePanel != null) {\n    final Collection<String> selectedFiles=remoteServiceBrowser.getServicePanel().getSelectedFiles();\n    if (selectedFiles.size() > 1) {\n      CompareWindow compareWindow=new CompareWindow(getViewer().getFrame(),remoteServiceBrowser.getDir(),selectedFiles);\n      if (!compareWindow.isCanceled()) {\n        final Director newDir=Director.newProject();\n        newDir.getMainViewer().getFrame().setVisible(true);\n        newDir.getMainViewer().setDoReInduce(true);\n        newDir.getMainViewer().setDoReset(true);\n        final String command=compareWindow.getCommand();\n        if (command != null)         newDir.execute(command,newDir.getCommandManager());\n      }\n    }\n  }\n}\n", "nl": "action to be performed"}
{"code": "private byte[] MonoToStereo(byte[] input){\n  byte[] output=new byte[input.length * 2];\n  int outputIndex=0;\n  for (int n=0; n < input.length; n+=2) {\n    output[outputIndex++]=input[n];\n    output[outputIndex++]=input[n + 1];\n    output[outputIndex++]=input[n];\n    output[outputIndex++]=input[n + 1];\n  }\n  return output;\n}\n", "nl": "Part of the Chinese mobile phone does not support mono"}
{"code": "public int deflateString2ByteArray(byte[] input,int inputOffset,int inputLength,byte[] bytes){\n  if (inputLength >= MIN_SIZE_FOR_DEFLATION) {\n    deflater.setInput(input,inputOffset,inputLength);\n    deflater.finish();\n    int compressedDataLength=deflater.deflate(bytes);\n    deflater.reset();\n    return -compressedDataLength;\n  }\n else {\n    System.arraycopy(input,inputOffset,bytes,0,inputLength);\n    return inputLength;\n  }\n}\n", "nl": "compresses a string to an array of bytes"}
{"code": "private String preprocessToJs(byte[] loader) throws Exception {\n  Pair<ArrayList<Integer>,List<Byte>> data=preprocessRop(loader);\n  List<Long> longList=new ArrayList<>();\n  for (  Integer i : data.first) {\n    longList.add(i & 0xFFFFFFFFL);\n  }\n  String payload=TextUtils.join(\",\",longList);\n  String relocations=TextUtils.join(\",\",data.second);\n  return String.format(\"\\npayload = [%1$s];\\nrelocs = [%2$s];\\n\",payload,relocations);\n}\n", "nl": "Convert the loader code to shellcode embedded in js"}
{"code": "public void deregister(LocalDispatcher local){\n  if (Debug.infoOn())   Debug.logInfo(\"De-Registering dispatcher: \" + local.getName(),module);\n  localContext.remove(local.getName());\n  if (localContext.size() == 0) {\n    try {\n      this.shutdown();\n    }\n catch (    GenericServiceException e) {\n      Debug.logError(e,\"Trouble shutting down ServiceDispatcher!\",module);\n    }\n  }\n}\n", "nl": "De-Registers the loader with this ServiceDispatcher"}
{"code": "public static void main(String[] args){\n  if (args.length != 1) {\n    System.err.println(\"Usage : URLUtil <url>\");\n    return;\n  }\n  String url=args[0];\n  try {\n    System.out.println(URLUtil.getDomainName(new URL(url)));\n  }\n catch (  MalformedURLException ex) {\n    ex.printStackTrace();\n  }\n}\n", "nl": "For testing"}
{"code": "private static void removeAbsolutePositionAndSizes(NlComponent component){\n  for (  NlComponent child : component.getChildren()) {\n    child.setAttribute(TOOLS_URI,ATTR_LAYOUT_CONVERSION_ABSOLUTE_X,null);\n    child.setAttribute(TOOLS_URI,ATTR_LAYOUT_CONVERSION_ABSOLUTE_Y,null);\n    child.setAttribute(TOOLS_URI,ATTR_LAYOUT_CONVERSION_ABSOLUTE_WIDTH,null);\n    child.setAttribute(TOOLS_URI,ATTR_LAYOUT_CONVERSION_ABSOLUTE_HEIGHT,null);\n    removeAbsolutePositionAndSizes(child);\n  }\n}\n", "nl": "Removes absolute x/y/width/height conversion attributes"}
{"code": "public void propertiesToContainerState(ContainerState containerState,Map<String,Object> properties){\n  AssertUtil.assertNotNull(containerState,\"containerState\");\n  AssertUtil.assertNotNull(properties,\"properties\");\n  containerState.id=(String)properties.get(DOCKER_CONTAINER_ID_PROP_NAME);\n  String name=(String)properties.get(DOCKER_CONTAINER_NAME_PROP_NAME);\n  if (name != null && name.startsWith(\"/\")) {\n    name=name.substring(1);\n  }\n  containerState.names=Collections.singletonList(name);\n  containerState.created=parseDate(properties.get(DOCKER_CONTAINER_CREATED_PROP_NAME));\n  mapStateProperties(containerState,getMap(properties,DOCKER_CONTAINER_STATE_PROP_NAME));\n  mapConfigProperties(containerState,getMap(properties,DOCKER_CONTAINER_CONFIG_PROP_NAME));\n  mapPortBindingProperties(containerState,getMap(properties,DOCKER_CONTAINER_NETWORK_SETTINGS_PROP_NAME));\n  mapContainerIPAddress(containerState,getMap(properties,DOCKER_CONTAINER_NETWORK_SETTINGS_PROP_NAME));\n}\n", "nl": "Convert generic properties from the given map to modeled properties in the given ContainerState"}
{"code": "@Override public void handleUseItemFinish(Player player,Npc npc){\nswitch (npc.getNpcId()) {\ncase 701001:\n    SkillEngine.getInstance().getSkill(npc,19316,60,player).useNoAnimationSkill();\n  break;\ncase 701002:\nSkillEngine.getInstance().getSkill(npc,19317,60,player).useNoAnimationSkill();\nbreak;\ncase 701003:\nSkillEngine.getInstance().getSkill(npc,19318,60,player).useNoAnimationSkill();\nbreak;\ncase 701004:\nSkillEngine.getInstance().getSkill(npc,19319,60,player).useNoAnimationSkill();\nbreak;\n}\n}\n", "nl": "Elemental Iron Prison Ai"}
{"code": "public boolean filterOut(final SAMRecord record){\n  if (include) {\n    if (record.getNotPrimaryAlignmentFlag()) {\n      return false;\n    }\n  }\n else {\n    if (!record.getNotPrimaryAlignmentFlag()) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "public void scaleToSamples(int usrSamples){\n  double ratio;\n  ratio=(double)usrSamples / count;\n  count=0;\n  for (int i=0; i <= limits.length; ++i) {\n    results[i]=(int)Math.round(results[i] * ratio);\n    count+=results[i];\n  }\n}\n", "nl": "Use the current distribution but scale the samples close to the user specified one "}
{"code": "public static byte[] hexStringToBytes(String hexString){\n  if (hexString == null || hexString.equals(\"\")) {\n    return null;\n  }\n  hexString=hexString.toUpperCase();\n  int length=hexString.length() / 2;\n  char[] hexChars=hexString.toCharArray();\n  byte[] d=new byte[length];\n  for (int i=0; i < length; i++) {\n    int pos=i * 2;\n    d[i]=(byte)(charToByte(hexChars[pos]) << 4 | charToByte(hexChars[pos + 1]));\n  }\n  return d;\n}\n", "nl": "Convert hex string to byte[]"}
{"code": "public void testWriteReadFull() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(replicationTransmissionPolicy);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  ReplicationTransmissionPolicy copy=(ReplicationTransmissionPolicy)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(replicationTransmissionPolicy,copy));\n}\n", "nl": "Test read and write full ClusterPolicy object"}
{"code": "private void callMain() throws ForkProcessException {\n  try {\n    Object objectParameters[]={getProcessArgs().getMainArgs()};\n    Class<?> classParameters[]={objectParameters[0].getClass()};\n    Class<?> c=Class.forName(_procArg.getMainClass());\n    Method m=c.getDeclaredMethod(\"main\",classParameters);\n    m.invoke(null,objectParameters);\n  }\n catch (  InvocationTargetException invte) {\n    throw newForkProcessException(invte.getTargetException());\n  }\ncatch (  Throwable t) {\n    throw newForkProcessException(t);\n  }\n}\n", "nl": "carry out the main sequence - 'public static void main(String[] args)'"}
{"code": "private void unifyViaAtom(Atomic parentAtom){\n  Atomic childAtom=getRuleConclusionAtom();\n  Query parent=parentAtom.getParentQuery();\n  Map<String,String> unifiers=childAtom.getUnifiers(parentAtom);\n  head.unify(unifiers);\n  body.unify(unifiers);\n  Set<String> childFVs=body.getVarSet();\n  Set<String> parentBVs=parentAtom.getVarNames();\n  Set<String> parentVars=parent.getVarSet();\n  parentBVs.forEach(null);\n  childFVs.forEach(null);\n}\n", "nl": "propagate variables to child via a relation atom (atom variables are bound)"}
{"code": "public static boolean isPojo(Object object){\n  if (object == null)   return false;\n  if (object instanceof Object[]) {\n    if (object instanceof Entry[])     return false;\n    if (Array.getLength(object) == 0)     return false;\n    Object value=Array.get(object,0);\n    if (value == null || value instanceof Entry)     return false;\n  }\n else   if (object instanceof Entry)   return false;\n  return true;\n}\n", "nl": "Check if the Object is pojo"}
{"code": "public CustomConfiguration tryGetPluginConfiguration(String hostName,String pluginName,HttpServletRequest request){\n  try {\n    return ConfigurationService.getPluginConfiguration(pluginName,hostName,request.getRemoteAddr(),request.getSession().getId());\n  }\n catch (  ConfigurationException e) {\n    Logger.debug(getClass(),\"Failed to retrieve plugin configuration: \" + hostName + \":\"+ pluginName);\n    return null;\n  }\n}\n", "nl": "This attempts to retrieve a specific plugin configuration, if an exception occurs then null is returned"}
{"code": "@deprecated protected int handleGetExtendedYear(){\n  int eyear;\n  int eyear;\n  if (newerField(19,1) == 19) {\n    eyear=internalGet(19,1);\n  }\n else {\n    int era=internalGet(0,1);\n    int eyear;\n    if (era == 0) {\n      eyear=1 - internalGet(1,1);\n    }\n else {\n      eyear=internalGet(1,1);\n    }\n  }\n  return eyear;\n}\n", "nl": "/*    "}
{"code": "private float computeCorrelationCoefficentTransposed(String seriesNameX,String seriesNameY){\n  final ArrayList<Double> xValues=new ArrayList<>(getChartData().getClassNames().size());\n  final ArrayList<Double> yValues=new ArrayList<>(getChartData().getClassNames().size());\n  for (  String className : getChartData().getClassNames()) {\n    xValues.add(getChartData().getValueAsDouble(seriesNameX,className));\n    yValues.add(getChartData().getValueAsDouble(seriesNameY,className));\n  }\n  return (float)Correlation.computePersonsCorrelationCoefficent(xValues.size(),xValues,yValues);\n}\n", "nl": "return Pearson's correlation coefficient"}
{"code": "public boolean filterOut(final SAMRecord record){\n  boolean isTopStrand=((!record.getReadNegativeStrandFlag() && !record.getReadPairedFlag()) || (!record.getReadNegativeStrandFlag() && record.getReadPairedFlag() && record.getFirstOfPairFlag()) || (record.getReadNegativeStrandFlag() && record.getReadPairedFlag() && record.getSecondOfPairFlag()));\n  if (include) {\n    if (isTopStrand) {\n      return false;\n    }\n  }\n else {\n    if (!isTopStrand) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "public static void deleteESTestIndex(String index){\n  logger.info(\"Deleting index:\");\n  ProcessBuilder pDelete=new ProcessBuilder(\"curl\",\"-XDELETE\",index);\n  try {\n    executeCommand(pDelete);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Method to delete an ES index"}
{"code": "@Override public void initTrigger(){\n  Calendar calendar=Calendar.getInstance();\n  calendar.set(Calendar.HOUR_OF_DAY,hour);\n  calendar.set(Calendar.MINUTE,minute);\n  calendar.set(Calendar.SECOND,second);\n  long delay=calendar.getTimeInMillis() - System.currentTimeMillis();\n  if (delay < 0) {\n    delay+=DAY_IN_MSEC;\n  }\n  ThreadPoolManager.getInstance().scheduleAtFixedRate(this,delay,DAY_IN_MSEC);\n}\n", "nl": "Run a fixed in the time (HH:MM:SS) task"}
{"code": "@SuppressWarnings(\"restriction\") public synchronized String decrypt(String str){\n  byte[] dec;\n  try {\n    dec=decoder.decodeBuffer(str);\n    byte[] utf8=decrypter.doFinal(dec);\n    return new String(utf8,\"UTF-8\");\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  IllegalBlockSizeException e) {\n    e.printStackTrace();\n  }\ncatch (  BadPaddingException e) {\n    e.printStackTrace();\n  }\n  return str;\n}\n", "nl": "Decrypt a string"}
{"code": "static Object newInstance(String className,ClassLoader cl,boolean doFallback) throws ConfigurationError {\n  try {\n    Class providerClass=findProviderClass(className,cl,doFallback);\n    Object instance=providerClass.newInstance();\n    if (DEBUG)     debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \"+ cl);\n    return instance;\n  }\n catch (  ClassNotFoundException x) {\n    throw new ConfigurationError(\"Provider \" + className + \" not found\",x);\n  }\ncatch (  Exception x) {\n    throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \"+ x,x);\n  }\n}\n", "nl": "Create an instance of a class using the specified ClassLoader"}
{"code": "public DataStorage(Object store){\n  if (store instanceof DataProvider)   _saDataProvider=(DataProvider<T>)store;\n else   _saDataProvider=null;\n  if (store instanceof DataPersister)   _saDataPersister=(DataPersister<T>)store;\n else   _saDataPersister=null;\n  if (store instanceof SQLDataProvider)   _saSQLDataProvider=(SQLDataProvider<T>)store;\n else   _saSQLDataProvider=null;\n  if (store instanceof BulkDataPersister)   _saBulkDataPersister=(BulkDataPersister)store;\n else   _saBulkDataPersister=null;\n  if (store instanceof ManagedDataSource)   _saManagedDataSource=(ManagedDataSource)store;\n else   _saManagedDataSource=null;\n  if (_logger.isLoggable(Level.CONFIG)) {\n    _logger.config(\"\\n\\t Space Data Storage <\" + store + \"> Loaded\"+ \"\\n\\t\\t \"+ DataProvider.class.getSimpleName()+ \"              : \"+ (isDataProvider() ? \"Implemented\" : \"-\")+ \"\\n\\t\\t \"+ DataPersister.class.getSimpleName()+ \"             : \"+ (isDataPersister() ? \"Implemented\" : \"-\")+ \"\\n\\t\\t \"+ BulkDataPersister.class.getSimpleName()+ \"         : \"+ (isBulkDataPersister() ? \"Implemented\" : \"-\")+ \"\\n\\t\\t \"+ SQLDataProvider.class.getSimpleName()+ \"           : \"+ (isSQLDataProvider() ? \"Implemented\" : \"-\")+ \"\\n\\t\\t \"+ ManagedDataSource.class.getSimpleName()+ \"         : \"+ (isManagedDataSource() ? \"Implemented\" : \"-\")+ \"\\n\");\n  }\n}\n", "nl": "DataStorage instantiation of cache and space data interfaces implementation,"}
{"code": "@Nullable public byte[] findClassDefinition(@NotNull String name,@NotNull AppResourceRepository appRepo){\n  int index=name.lastIndexOf('.');\n  if (index != -1 && name.charAt(index + 1) == 'R' && (index == name.length() - 2 || name.charAt(index + 2) == '$') && index > 1) {\n    String pkg=name.substring(0,index);\n    if (myPackages != null && myPackages.contains(pkg)) {\n      AarResourceClassGenerator generator=myGeneratorMap.get(appRepo);\n      if (generator != null) {\n        return generator.generate(name);\n      }\n    }\n  }\n  return null;\n}\n", "nl": "Looks up a class definition for the given name, if possible"}
{"code": "private int visitNodesRec(Node v,EdgeMap<Integer> edgeWeights){\n  int maxValue=0;\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    if (edgeWeights.get(e) == null) {\n      edgeWeights.set(e,visitNodesRec(e.getTarget(),edgeWeights) + (Integer)e.getInfo());\n    }\n    maxValue=Math.max(maxValue,edgeWeights.get(e));\n  }\n  return maxValue;\n}\n", "nl": "recursively visit all nodes and set edge weights The weight of an edge e is the maximum sum of overlaps on any outgoing path from e"}
{"code": "private void postInit(){\n  isConnected=NetworkUtil.getConnectivityStatus(mContext);\n  LayoutInflater.from(mContext).inflate(R.layout.layout_flow,this);\n  contentView=(FrameLayout)findViewById(R.id.content_view);\n  emptyView=(FrameLayout)findViewById(R.id.empty_view);\n  progressView=(FrameLayout)findViewById(R.id.progress_view);\n  connectivityView=(FrameLayout)findViewById(R.id.connectivity_view);\n  inflateLayouts();\n}\n", "nl": "Inflate the custom view default layout"}
{"code": "@Override public int compare(CarbonFile o1,CarbonFile o2){\n  String firstFileName=o1.getName();\n  String secondFileName=o2.getName();\n  int lastIndexOfO1=firstFileName.lastIndexOf('_');\n  int lastIndexOfO2=secondFileName.lastIndexOf('_');\n  int file1=0;\n  int file2=0;\n  try {\n    file1=Integer.parseInt(firstFileName.substring(lastIndexOfO1 + 1));\n    file2=Integer.parseInt(secondFileName.substring(lastIndexOfO2 + 1));\n  }\n catch (  NumberFormatException e) {\n    return -1;\n  }\n  return (file1 < file2) ? -1 : (file1 == file2 ? 0 : 1);\n}\n", "nl": "Below method will be used to compare two file"}
{"code": "private Label createLabel(Composite parent,String text,int span){\n  Label label=new Label(parent,SWT.LEFT);\n  label.setText(text);\n  GridData data=new GridData();\n  data.horizontalSpan=span;\n  data.horizontalAlignment=GridData.FILL;\n  label.setLayoutData(data);\n  return label;\n}\n", "nl": "creates a label"}
{"code": "public void changeItemIconAtPosition(int itemIndex,int newIcon){\n  if (itemIndex < 0 || itemIndex > spaceItems.size()) {\n    throwArrayIndexOutOfBoundsException(itemIndex);\n  }\n else {\n    SpaceItem spaceItem=spaceItems.get(itemIndex);\n    RelativeLayout textAndIconContainer=(RelativeLayout)spaceItemList.get(itemIndex);\n    ImageView spaceItemIcon=(ImageView)textAndIconContainer.findViewById(R.id.space_icon);\n    spaceItemIcon.setImageResource(newIcon);\n    spaceItem.setItemIcon(newIcon);\n    changedItemAndIconHashMap.put(itemIndex,spaceItem);\n  }\n}\n", "nl": "Change item icon if space navigation already set up"}
{"code": "public int send(OutputStream out) throws IOException {\n  FileInputStream fis;\n  int readBytes;\n  byte[] buff=new byte[256 * 1024];\n  fis=new FileInputStream(this.local_filename);\n  try {\n    while ((readBytes=fis.read(buff)) >= 0) {\n      if (readBytes == 0) {\n        continue;\n      }\n      out.write(buff,0,readBytes);\n    }\n  }\n  finally {\n    fis.close();\n  }\n  return 0;\n}\n", "nl": "send file content callback function, be called only once when the file uploaded"}
{"code": "private MarshObject compressObject(Object objToCompress) throws IOException {\n  CompressedMarshObjectConvertor cv=null;\n  try {\n    cv=_compressedConvertorPool.getResource();\n    MarshObject cmo=cv.getMarshObject(objToCompress);\n    return cmo;\n  }\n  finally {\n    if (cv != null) {\n      _compressedConvertorPool.freeResource(cv);\n    }\n  }\n}\n", "nl": "Compress the desired object using GigaSpaces compression facility"}
{"code": "public static int extractReadsByFViewer(final String cName,final ProgressListener progressListener,final Collection<Integer> classIds,final String outDirectory,final String outFileName,final Document doc) throws IOException, CanceledException {\n  final Classification classification=ClassificationManager.get(cName,true);\n  Map<Integer,String> classId2Name=new HashMap<>();\n  Map<Integer,Collection<Integer>> classId2Descendants=new HashMap<>();\n  for (  Integer id : classIds) {\n    classId2Name.put(id,classification.getName2IdMap().get(id));\n    classId2Descendants.put(id,classification.getFullTree().getAllDescendants(id));\n  }\n  return extractReads(progressListener,cName,classIds,classId2Name,classId2Descendants,outDirectory,outFileName,doc,true);\n}\n", "nl": "extract all reads belonging to a given set of  ids"}
{"code": "public static void closeWriter(){\n  try {\n    if (writer != null) {\n      writer.flush();\n      writer.close();\n      writer=null;\n    }\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Close the writer"}
{"code": "public boolean containsPairWithAllFourIntersections(){\n  for (int s=1; s <= size(); s++) {\n    Split S=getSplit(s);\n    for (int t=s + 1; t <= size(); t++) {\n      Split T=getSplit(t);\n      if (S.getA().intersects(T.getA()) && S.getA().intersects(T.getB()) && S.getB().intersects(T.getA())&& S.getB().intersects(T.getB()))       return true;\n    }\n  }\n  return false;\n}\n", "nl": "determines whether these splits contains a pair with all four intersections"}
{"code": "public Matrix plusEquals(Matrix B){\n  checkMatrixDimensions(B);\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      A[i][j]=A[i][j] + B.A[i][j];\n    }\n  }\n  return this;\n}\n", "nl": "A = A + B"}
{"code": "public static void drawSnapIndicator(ViewTransform transform,Graphics2D g,SnapCandidate candidate){\n  if (candidate.source == null || candidate.target == null) {\n    return;\n  }\n  if (candidate.source.isVerticalAnchor()) {\n    drawSnapVerticalIndicator(transform,g,candidate);\n  }\n else {\n    drawSnapHorizontalIndicator(transform,g,candidate);\n  }\n}\n", "nl": "Draw a snap indicator for the snap candidate"}
{"code": "@Override public void innerDelete(){\n  InstanceImpl<?,?> parent=this;\n  Set<CastingImpl> castings=parent.castings();\n  deleteNode();\n  for (  CastingImpl casting : castings) {\n    Set<RelationImpl> relations=casting.getRelations();\n    getMindmapsGraph().getConceptLog().putConcept(casting);\n    for (    RelationImpl relation : relations) {\n      getMindmapsGraph().getConceptLog().putConcept(relation);\n      relation.cleanUp();\n    }\n    casting.deleteNode();\n  }\n}\n", "nl": "Deletes the concept as an Instance"}
{"code": "public void remove(int offset,int length){\n  if (offset < 0 || offset >= _pos) {\n    throw new ArrayIndexOutOfBoundsException(offset);\n  }\n  if (offset == 0) {\n    System.arraycopy(_data,length,_data,0,_pos - length);\n  }\n else   if (_pos - length == offset) {\n  }\n else {\n    System.arraycopy(_data,offset + length,_data,offset,_pos - (offset + length));\n  }\n  _pos-=length;\n}\n", "nl": "Removes <tt>length</tt> values from the list, starting at <tt>offset</tt>"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  InspectorWindow inspectorWindow=(InspectorWindow)getViewer();\n  String name=ProgramProperties.get(MeganProperties.FINDTAXON,\"\");\n  name=JOptionPane.showInputDialog(inspectorWindow.getFrame(),\"Enter taxon name or Id\",name);\n  if (name != null && name.trim().length() > 0) {\n    name=name.trim();\n    ProgramProperties.put(MeganProperties.FINDTAXON,name);\n    executeImmediately(\"show taxon='\" + name + \"';\");\n  }\n}\n", "nl": "action to be performed"}
{"code": "public boolean isDirty() throws SVNException {\n  if (getStatusFromCache().isDirty()) {\n    return true;\n  }\n  ISVNLocalResource[] children=(ISVNLocalResource[])members(new NullProgressMonitor(),ALL_UNIGNORED_MEMBERS);\n  for (int i=0; i < children.length; i++) {\n    if (children[i].isDirty() || children[i].getStatusFromCache().isMissing() || (children[i].exists() && !children[i].isManaged())) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "A folder is considered dirty if its status is dirty or if one of its children is dirty"}
{"code": "static public Text createTextField(Composite parent){\n  Text text=new Text(parent,SWT.SINGLE | SWT.BORDER);\n  GridData data=new GridData(GridData.FILL_HORIZONTAL);\n  data.verticalAlignment=GridData.CENTER;\n  data.grabExcessVerticalSpace=false;\n  data.widthHint=IDialogConstants.ENTRY_FIELD_WIDTH;\n  text.setLayoutData(data);\n  return text;\n}\n", "nl": "Create a text field specific for this application"}
{"code": "@SuppressWarnings(\"unchecked\") private String addKeyToCacheAndReturnKey(String key,String languageId){\n  List<String> keyList=(List<String>)LanguageListCacheGroupHandler.getInstance().get(Configuration.CacheListKeysWithoutValue + languageId);\n  if (!keyList.contains(key)) {\n    keyList.add(key);\n  }\n  if (!Configuration.isValueOfKeyEmptyShowKey()) {\n    if (Configuration.isReplacementValueAnEmptyString()) {\n      key=\"\";\n    }\n else {\n      key=Configuration.getReplacementValueIfValueIsEmpty();\n    }\n  }\n  return key;\n}\n", "nl": "Add key without value to a cache list per language, so it can be displayed on the portlet"}
{"code": "private void removeUnneededVisualizationCards(){\n  Map<String,VisualizationCardData> removableVisualizationCards=new HashMap<>();\n  Map<String,VisualizationCardData> visualizationCards=cardListAdapter.getVisualizationCards();\n  for (  Map.Entry<String,VisualizationCardData> visualizationCardDataEntry : visualizationCards.entrySet()) {\n    String nodeId=visualizationCardDataEntry.getKey();\n    VisualizationCardData visualizationCard=visualizationCardDataEntry.getValue();\n    if (!isRequestingSensorEventData(nodeId,visualizationCard.getDataBatch().getSource())) {\n      removableVisualizationCards.put(nodeId,visualizationCard);\n      continue;\n    }\n  }\n  for (  Map.Entry<String,VisualizationCardData> visualizationCardDataEntry : removableVisualizationCards.entrySet()) {\n    Log.d(TAG,\"Removing unneeded visualization card: \" + visualizationCardDataEntry.getValue().getHeading());\n    cardListAdapter.remove(visualizationCardDataEntry.getValue());\n  }\n}\n", "nl": "Removes all visualizations from the card list adapter that are currently not requested"}
{"code": "private static void start(Context context,Class<?> daemonClazzName,int interval){\n  String cmd=context.getDir(BIN_DIR_NAME,Context.MODE_PRIVATE).getAbsolutePath() + File.separator + DAEMON_BIN_NAME;\n  StringBuilder cmdBuilder=new StringBuilder();\n  cmdBuilder.append(cmd);\n  cmdBuilder.append(\" -p \");\n  cmdBuilder.append(context.getPackageName());\n  cmdBuilder.append(\" -s \");\n  cmdBuilder.append(daemonClazzName.getName());\n  cmdBuilder.append(\" -t \");\n  cmdBuilder.append(interval);\n  try {\n    Runtime.getRuntime().exec(cmdBuilder.toString()).waitFor();\n  }\n catch (  IOException|InterruptedException e) {\n    Log.e(TAG,\"start daemon error: \" + e.getMessage());\n  }\n}\n", "nl": "start daemon"}
{"code": "public void internalize(byte[] optionsArray){\n  int pos=4;\n  byte code, length;\n  byte value[];\n  while (optionsArray[pos] != (byte)255) {\n    code=optionsArray[pos++];\n    length=optionsArray[pos++];\n    value=getArrayOption(length,pos,optionsArray);\n    setOption(code,value);\n    pos+=length;\n  }\n}\n", "nl": "Converts an options byte array to a linked list"}
{"code": "@Override public boolean equals(Object other){\n  if (this == other) {\n    return true;\n  }\n  if (other == null || getClass() != other.getClass()) {\n    return false;\n  }\n  DictionaryByteArrayWrapper otherObjectToCompare=(DictionaryByteArrayWrapper)other;\n  if (data.length != otherObjectToCompare.data.length) {\n    return false;\n  }\n  return ByteUtil.UnsafeComparer.INSTANCE.equals(data,otherObjectToCompare.data);\n}\n", "nl": "This method will compare 2 DictionaryByteArrayWrapper objects"}
{"code": "public void apply(){\n  assert useWeight;\n  String value=mWeight > 0 ? formatFloatAttribute(mWeight) : null;\n  component.setAttribute(ANDROID_URI,ATTR_LAYOUT_WEIGHT,value);\n  if (mClearWeights != null) {\n    for (    NlComponent n : mClearWeights) {\n      if (getWeight(n) > 0.0f) {\n        n.setAttribute(ANDROID_URI,ATTR_LAYOUT_WEIGHT,null);\n      }\n    }\n  }\n  if (mNewWeightSum > 0.0) {\n    layout.setAttribute(ANDROID_URI,ATTR_WEIGHT_SUM,formatFloatAttribute(mNewWeightSum));\n  }\n}\n", "nl": "Applies the state to the nodes"}
{"code": "public void abortIfRunning(){\n  if (mRunning) {\n    if (!mScroller.isFinished()) {\n      mAbort=true;\n      mScroller.forceFinished(true);\n    }\n    finish();\n    mAbort=false;\n  }\n}\n", "nl": "abort scroll if it is scrolling"}
{"code": "protected void removeContainer() throws Throwable {\n  if (containerId == null) {\n    return;\n  }\n  sendDeleteContainerRequest();\n  waitForPropertyValue(provisioningTaskLink,MockTaskState.class,\"taskInfo.stage\",TaskState.TaskStage.FINISHED);\n  if (!isMockTarget()) {\n    Thread.sleep(2000L);\n  }\n  verifyContainerDoesNotExist(containerId);\n}\n", "nl": "Remove the container previously created using createContainer()"}
{"code": "public static Map<String,Object> alwaysNsfProcessor(DispatchContext dctx,Map<String,? extends Object> context){\n  Locale locale=(Locale)context.get(\"locale\");\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  BigDecimal processAmount=(BigDecimal)context.get(\"processAmount\");\n  Debug.logInfo(\"Test Processor NSF Credit Card\",module);\n  String refNum=UtilDateTime.nowAsString();\n  result.put(\"authResult\",Boolean.FALSE);\n  result.put(\"resultNsf\",Boolean.TRUE);\n  result.put(\"processAmount\",processAmount);\n  result.put(\"authRefNum\",refNum);\n  result.put(\"authAltRefNum\",refNum);\n  result.put(\"authFlag\",\"N\");\n  result.put(\"authMessage\",UtilProperties.getMessage(resource,\"AccountingPaymentTestProcessor\",locale));\n  return result;\n}\n", "nl": "Always NSF (not sufficient funds) processor"}
{"code": "public final void writeLine(final IFallback object) throws DataFallbackException {\n  String str=object.toString();\n  try {\n    output.write(str);\n    output.newLine();\n    output.flush();\n  }\n catch (  IOException e) {\n    throw new DataFallbackException(\"writeLine() : An error has ocurred while trying to write in the \" + getDataFile().getName() + \" file \"+ e.getMessage());\n  }\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"writeLine() - The object with id \" + object.getId() + \" has been logged to the \"+ dataFile.getPath()+ \" file\");\n  }\n}\n", "nl": "It writes an object into one of the fallback files"}
{"code": "public static byte[] int32RGBBufferedImageToByteArray(BufferedImage img){\n  int[] pixels=null;\n  DataBuffer db=img.getRaster().getDataBuffer();\n  if (db instanceof DataBufferInt)   pixels=((DataBufferInt)db).getData();\n else   throw new RuntimeException(\"Format not supported...\");\n  byte[] ret=new byte[pixels.length * 4];\n  for (int i=0; i < pixels.length; i++) {\n    ret[4 * i]=(byte)(pixels[i] & 0xff000000);\n    ret[4 * i + 1]=(byte)(pixels[i] & 0x00ff0000);\n    ret[4 * i + 2]=(byte)(pixels[i] & 0x0000ff00);\n    ret[4 * i + 3]=(byte)(pixels[i] & 0x000000ff);\n  }\n  return ret;\n}\n", "nl": "Converts a standard 32 bit/pixel RGB image into a byte array"}
{"code": "public int generateDirectSurrogateKey(String memberStr,String format){\n  if (null == format) {\n    return generateDirectSurrogateKeyForNonTimestampType(memberStr);\n  }\n else {\n    SimpleDateFormat timeParser=new SimpleDateFormat(format);\n    timeParser.setLenient(false);\n    if (null == memberStr || memberStr.trim().isEmpty() || memberStr.equals(CarbonCommonConstants.MEMBER_DEFAULT_VAL)) {\n      return 1;\n    }\n    return getDirectSurrogateForMember(memberStr,timeParser);\n  }\n}\n", "nl": "The method take member String as input and converts and returns the dictionary key"}
{"code": "public static Map<String,Object> entityFailTest(DispatchContext dctx,Map<String,?> context){\n  Delegator delegator=dctx.getDelegator();\n  Locale locale=(Locale)context.get(\"locale\");\n  GenericValue newEntity=delegator.makeValue(\"DataSource\");\n  newEntity.set(\"dataSourceId\",\"ENTITY_FAIL_TEST\");\n  newEntity.set(\"dataSourceTypeId\",\"ENTITY_FAIL_TEST\");\n  newEntity.set(\"description\",\"Entity Fail Test - Delete me if I am here\");\n  try {\n    delegator.create(newEntity);\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEntityTestFailure\",locale));\n  }\n  return ServiceUtil.returnSuccess();\n}\n", "nl": "Cause a Referential Integrity Error"}
{"code": "private void createMapWhenNeeded(){\n  if (isMapInitialized) {\n    return;\n  }\n  if (resourceBundle != null) {\n    Set<String> set=resourceBundle.keySet();\n    topLevelMap=new HashMap<String,Object>(set.size());\n    for (    String key : set) {\n      Object value=resourceBundle.getObject(key);\n      topLevelMap.put(key,value);\n    }\n  }\n else {\n    topLevelMap=new HashMap<String,Object>(1);\n  }\n  topLevelMap.put(\"_RESOURCE_BUNDLE_\",resourceBundle);\n  isMapInitialized=true;\n}\n", "nl": "Creates the topLevelMap only when it is required"}
{"code": "public boolean addTable(SampleAttributeTable sampleAttributeTable,boolean allowReplaceSample,boolean allowAddAttribute){\n  boolean changed=false;\n  for (  String sample : sampleAttributeTable.getSampleSet()) {\n    if (allowReplaceSample || !table.rowKeySet().contains(sample)) {\n      if (addSample(sample,sampleAttributeTable.getAttributesToValues(sample),true,allowAddAttribute))       changed=true;\n    }\n  }\n  return changed;\n}\n", "nl": "add a metadata table"}
{"code": "public void destroyView() throws CanceledException {\n  locked=true;\n  ProgramProperties.put(\"SampleViewerGeometry\",new int[]{frame.getLocation().x,frame.getLocation().y,frame.getSize().width,frame.getSize().height});\n  searchManager.getFindDialogAsToolBar().close();\n  doc.getSampleSelection().removeSampleSelectionListener(selectionListener);\n  frame.setVisible(false);\n  MeganProperties.removePropertiesListListener(menuBar.getRecentFilesListener());\n  dir.removeViewer(this);\n  frame.dispose();\n}\n", "nl": "ask view to destroy itself"}
{"code": "public void startEnqueueJob(){\n  try {\n    Scheduler scheduler=Singleton.getScheduler();\n    JobDetail job=newJob(EnqueueRepositoryJob.class).withIdentity(\"enqueuejob\").build();\n    SimpleTrigger trigger=newTrigger().withIdentity(\"enqueuejob\").withSchedule(simpleSchedule().withIntervalInSeconds(this.UPDATETIME).repeatForever()).build();\n    scheduler.scheduleJob(job,trigger);\n    scheduler.start();\n    Scheduler scheduler2=Singleton.getScheduler();\n    JobDetail job2=newJob(EnqueueFileRepositoryJob.class).withIdentity(\"enqueuefilejob\").build();\n    SimpleTrigger trigger2=newTrigger().withIdentity(\"enqueuefilejob\").withSchedule(simpleSchedule().withIntervalInSeconds(this.FILEINDEXUPDATETIME).repeatForever()).build();\n    scheduler2.scheduleJob(job2,trigger2);\n    scheduler2.start();\n  }\n catch (  SchedulerException ex) {\n    LOGGER.severe(\" caught a \" + ex.getClass() + \"\\n with message: \"+ ex.getMessage());\n  }\n}\n", "nl": "Starts a background job which pulls all repositories from the database and adds them to the queue to be indexed"}
{"code": "protected void addLink(String field,int len,int n,int e){\n  int[] array=(int[])m_links.get(n,field);\n  if (array == null) {\n    array=new int[]{e};\n    m_links.set(n,field,array);\n    return;\n  }\n else   if (len == array.length) {\n    int[] narray=new int[Math.max(3 * array.length / 2,len + 1)];\n    System.arraycopy(array,0,narray,0,array.length);\n    array=narray;\n    m_links.set(n,field,array);\n  }\n  array[len]=e;\n}\n", "nl": "Internal method for adding a link to an adjacency list"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"compute wordCount kmer=\");\n  int kmer=np.getInt(1,Integer.MAX_VALUE);\n  np.matchIgnoreCase(\"step=\");\n  int step=np.getInt(1,Integer.MAX_VALUE);\n  np.matchIgnoreCase(\"mindepth=\");\n  int mindepth=np.getInt(1,Integer.MAX_VALUE);\n  np.matchIgnoreCase(\";\");\n  AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  LinkedList<Pair<Number,Number>> depthVsDifferences=new LinkedList<>();\n  SortedMap<Number,Number> rank2percentage=new TreeMap<>();\n  WordCountAnalysis.apply(viewer.getAlignment(),kmer,step,mindepth,((Director)getDir()).getDocument().getProgressListener(),depthVsDifferences,rank2percentage);\n  System.out.println(\"Depth vs Differences (\" + depthVsDifferences.size() + \"):\");\n  for (  Pair<Number,Number> pair : depthVsDifferences) {\n    System.out.println(pair.get1() + \" \" + pair.get2());\n  }\n  System.out.println(\"done\");\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static int toRealPosition(int position,int count){\n  position=position - 1;\n  if (position < 0) {\n    position+=count;\n  }\n else {\n    position=position % count;\n  }\n  return position;\n}\n", "nl": "helper function which may be used when implementing FragmentPagerAdapter"}
{"code": "public static Bitmap decodeSampledBitmapFromFile(String srcPath,int reqWidth,int reqHeight){\n  final Options options=new Options();\n  options.inScaled=true;\n  options.inPurgeable=true;\n  if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.GINGERBREAD_MR1) {\n    options.inPreferQualityOverSpeed=false;\n  }\n  if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.HONEYCOMB) {\n    options.inMutable=false;\n  }\n  options.inJustDecodeBounds=true;\n  BitmapFactory.decodeFile(srcPath,options);\n  options.inSampleSize=calculateSampleFactor(options,reqWidth,reqHeight);\n  options.inJustDecodeBounds=false;\n  return BitmapFactory.decodeFile(srcPath,options);\n}\n", "nl": "Decodes a bitmap from a file containing it minimizing the memory use, known that the bitmap will be drawn in a surface of reqWidth x reqHeight"}
{"code": "@Bean public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(){\n  MappingJackson2HttpMessageConverter mjhmc=new MappingJackson2HttpMessageConverter();\n  Jackson2ObjectMapperFactoryBean jomfb=new Jackson2ObjectMapperFactoryBean();\n  jomfb.setAutoDetectFields(false);\n  jomfb.setIndentOutput(shouldIndentJacksonOutput);\n  jomfb.afterPropertiesSet();\n  mjhmc.setObjectMapper(jomfb.getObject());\n  return mjhmc;\n}\n", "nl": "Configuration Jackson ObjectMapper"}
{"code": "private void updateTexts(DocumentEvent e){\n  Document doc=e.getDocument();\n  if (doc == projectNameTextField.getDocument() || doc == projectLocationTextField.getDocument()) {\n    String projectName=projectNameTextField.getText();\n    String projectFolder=projectLocationTextField.getText();\n    createdFolderTextField.setText(projectFolder + File.separatorChar + projectName);\n  }\n  panel.fireChangeEvent();\n}\n", "nl": "Handles changes in the Project name and project directory,"}
{"code": "private void loadListFromOpenDocuments(){\n  java.util.List<IDirector> projects=ProjectManager.getProjects();\n  for (  IDirector project : projects) {\n    if (project instanceof Director) {\n      Director dir=(Director)project;\n      if (!dir.getMainViewer().isLocked() && dir.getDocument().getNumberOfReads() > 0) {\n        listModel.addElement(new MyListItem(dir));\n      }\n    }\n  }\n}\n", "nl": "setup the list"}
{"code": "private void rehash(final int newCapacity){\n  m_threshold=(int)(newCapacity / 2 * m_fillFactor);\n  m_mask=newCapacity / 2 - 1;\n  m_mask2=newCapacity - 1;\n  final int oldCapacity=m_data.length;\n  final int[] oldData=m_data;\n  m_data=new int[newCapacity];\n  m_size=m_hasFreeKey ? 1 : 0;\n  for (int i=0; i < oldCapacity; i+=2) {\n    final int oldKey=oldData[i];\n    if (oldKey != FREE_KEY)     put(oldKey,oldData[i + 1]);\n  }\n}\n", "nl": "Taken from FastUtil implementation"}
{"code": "public static String[] grabNext3(String text,String key,String key2){\n  int pos=text.indexOf(key);\n  int length=key.length();\n  if (pos == -1 && key2 != null) {\n    pos=text.indexOf(key2);\n    length=key2.length();\n  }\n  if (pos == -1)   return null;\n else {\n    String[] result=new String[3];\n    StringTokenizer st=new StringTokenizer(text.substring(pos + length).trim());\n    for (int i=0; i < 3; i++) {\n      if (st.hasMoreTokens())       result[i]=st.nextToken();\n else       return null;\n    }\n    return result;\n  }\n}\n", "nl": "grab the next three tokens after the one in key"}
{"code": "public static void makeFriends(Player friend1,Player friend2){\n  DAOManager.getDAO(FriendListDAO.class).addFriends(friend1,friend2);\n  friend1.getFriendList().addFriend(new Friend(friend2.getCommonData()));\n  friend2.getFriendList().addFriend(new Friend(friend1.getCommonData()));\n  friend1.getClientConnection().sendPacket(new SM_FRIEND_LIST());\n  friend2.getClientConnection().sendPacket(new SM_FRIEND_LIST());\n  friend1.getClientConnection().sendPacket(new SM_FRIEND_RESPONSE(friend2.getName(),SM_FRIEND_RESPONSE.TARGET_ADDED));\n  friend2.getClientConnection().sendPacket(new SM_FRIEND_RESPONSE(friend1.getName(),SM_FRIEND_RESPONSE.TARGET_ADDED));\n}\n", "nl": "Adds two players to each others friend lists, and updates the database<br />"}
{"code": "public List<LocalDateTime> top(int n){\n  List<LocalDateTime> top=new ArrayList<>();\n  long[] values=data.toLongArray();\n  LongArrays.parallelQuickSort(values,ReverseLongComparator.instance());\n  for (int i=0; i < n && i < values.length; i++) {\n    top.add(PackedLocalDateTime.asLocalDateTime(values[i]));\n  }\n  return top;\n}\n", "nl": "Returns the largest (\"top\") n values in the column"}
{"code": "public boolean languageCostIgnore(String languagename){\n  boolean ignore;\nswitch (languagename) {\ncase \"Unknown\":\ncase \"Text\":\ncase \"JSON\":\ncase \"Markdown\":\ncase \"INI File\":\ncase \"ReStructuredText\":\ncase \"Configuration\":\n    ignore=true;\n  break;\ndefault :\nignore=false;\nbreak;\n}\nreturn ignore;\n}\n", "nl": "List of languages to ignore displaying the cost for"}
{"code": "private void drawPrepare(Canvas canvas){\n  publicPaint.setColor(getProgressColor());\n  if (mArrow_center_effect != null) {\n    publicPaint.setPathEffect(mArrow_center_effect);\n  }\n  canvas.drawPath(path1,publicPaint);\n  if (mArrow_left_effect != null) {\n    publicPaint.setPathEffect(mArrow_left_effect);\n  }\n  canvas.drawPath(path2,publicPaint);\n  if (mArrow_right_effect != null) {\n    publicPaint.setPathEffect(mArrow_right_effect);\n  }\n  canvas.drawPath(path3,publicPaint);\n}\n", "nl": "Draw the Arrow"}
{"code": "private int stateToEvent(){\n  if (state == IN || state == ZE) {\n    return JsonEvent.VALUE_INT;\n  }\n else   if (state >= FR && state <= E3) {\n    return JsonEvent.VALUE_DOUBLE;\n  }\n else   if (state == T3) {\n    return JsonEvent.VALUE_TRUE;\n  }\n else   if (state == F4) {\n    return JsonEvent.VALUE_FALSE;\n  }\n else   if (state == N3) {\n    return JsonEvent.VALUE_NULL;\n  }\n  return JsonEvent.NEED_MORE_INPUT;\n}\n", "nl": "Converts the current parser state to a JSON event"}
{"code": "private void importInitialData(SQLiteDatabase db){\n  final int length=5;\n  final String[] starterTaskTitles=mContext.getResources().getStringArray(R.array.starter_tasks);\n  final int[] starterTaskIntervals={2,5,5,5,3};\n  NagboxDbOps.Transaction transaction=NagboxDbOps.startTransaction(db);\n  Task reusableTask=new Task();\n  for (int i=0; i < length; i++) {\n    reusableTask.title=starterTaskTitles[i];\n    reusableTask.interval=starterTaskIntervals[i];\n    reusableTask.displayOrder=i + 1;\n    transaction.createTask(reusableTask);\n  }\n  transaction.commit();\n}\n", "nl": "Import starter data into the database"}
{"code": "@SuppressWarnings({\"checkstyle:javadocmethod\",\"checkstyle:javadocstyle\"}) public Object parse(Reader reader){\n  Object content;\n  JsonLexer lexer=new JsonLexer(reader);\n  JsonToken token=lexer.nextToken();\n  if (token.getType() == OPEN_CURLY) {\n    content=parseObject(lexer);\n  }\n else   if (token.getType() == OPEN_BRACKET) {\n    content=parseArray(lexer);\n  }\n else {\n    throw new JsonException(\"A JSON payload should start with \" + OPEN_CURLY.getLabel() + \" or \"+ OPEN_BRACKET.getLabel()+ \".\\n\"+ \"Instead, '\"+ token.getText()+ \"' was found \"+ \"on line: \"+ token.getStartLine()+ \", \"+ \"column: \"+ token.getStartColumn());\n  }\n  return content;\n}\n", "nl": "Parse a JSON data structure from content from a reader"}
{"code": "private static boolean rotateIfLandScapeCamera(){\n  if (Build.BRAND.toLowerCase().equals(\"samsung\")) {\n    return true;\n  }\n else   if (Build.BRAND.toLowerCase().equals(\"sony\")) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Rotate the image if the device camera is land scape"}
{"code": "private void closeCounterDataOutputStream() throws DataFallbackException {\n  if (LOG.isDebugEnabled())   LOG.debug(\"Closing the counter file writer for the file \" + counterFile.getName());\n  if (dOutput != null) {\n    try {\n      dOutput.close();\n    }\n catch (    IOException e) {\n      throw new DataFallbackException(e.getMessage());\n    }\n finally {\n      dOutput=null;\n    }\n  }\n}\n", "nl": "The output stream for the counter file is closed"}
{"code": "private ChannelBuffer storeResponse(SpaceCache.StoreResponse storeResponse){\nswitch (storeResponse) {\ncase EXISTS:\n    return EXISTS.duplicate();\ncase NOT_FOUND:\n  return NOT_FOUND.duplicate();\ncase NOT_STORED:\nreturn NOT_STORED.duplicate();\ncase STORED:\nreturn STORED.duplicate();\n}\nthrow new RuntimeException(\"unknown store response from cache: \" + storeResponse);\n}\n", "nl": "Find the string response message which is equivalent to a response to a set/add/replace message in the cache"}
{"code": "public void testTransitiveDependencies() throws IOException {\n  VirtualFile project1=createGradleProjectToImport(dir,module(1));\n  VirtualFile project2=createGradleProjectToImport(dir,module(2),module(1));\n  VirtualFile project3=createGradleProjectToImport(dir,module(3),module(2));\n  configureTopLevelProject(dir,Arrays.asList(module(1),module(2),module(3)),Collections.<String>emptySet());\n  Map<String,VirtualFile> projects=moduleListToMap(GradleModuleImporter.getRelatedProjects(project3,getProject()));\n  assertEquals(3,projects.size());\n  assertEquals(project1,projects.get(pathToGradleName(module(1))));\n  assertEquals(project2,projects.get(pathToGradleName(module(2))));\n  assertEquals(project3,projects.get(pathToGradleName(module(3))));\n}\n", "nl": "Make sure source dependencies are picked recursively"}
{"code": "private static double mlsadf1(double x,double b[],int m,double a,double d[]){\n  double out=0.0;\n  for (int i=PADEORDER; i > 0; i--) {\n    d[i]=(1 - a * a) * d[PADEORDER + i] + a * d[i];\n    d[PADEORDER + 1 + i]=d[i] * b[1];\n    double v=d[PADEORDER + 1 + i] * pade[ppade + i];\n    x+=((1 & i) == 1) ? v : -v;\n    out+=v;\n  }\n  d[PADEORDER + 1]=x;\n  out+=x;\n  return out;\n}\n", "nl": "mlsdaf1:  sub functions for MLSA filter"}
{"code": "public FloatArrayList top(int n){\n  FloatArrayList top=new FloatArrayList();\n  float[] values=data.toFloatArray();\n  FloatArrays.parallelQuickSort(values,reverseFloatComparator);\n  for (int i=0; i < n && i < values.length; i++) {\n    top.add(values[i]);\n  }\n  return top;\n}\n", "nl": "Returns the largest (\"top\") n values in the column"}
{"code": "public double normF(){\n  double f=0;\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      f=Maths.hypot(f,A[i][j]);\n    }\n  }\n  return f;\n}\n", "nl": "Frobenius norm"}
{"code": "protected void unbind(){\n  if (mResolver != null && isNullable) {\n    for (    final Field field : mResolver.getClass().getDeclaredFields()) {\n      try {\n        if (!field.getType().isPrimitive()) {\n          field.setAccessible(true);\n          field.set(mResolver,null);\n        }\n      }\n catch (      IllegalAccessException e) {\n        e.printStackTrace();\n      }\n    }\n    mResolver=null;\n    mAnimationResolver=null;\n  }\n}\n", "nl": "Remove all the references in the original class"}
{"code": "@Override public int countMissing(){\n  int count=0;\n  for (int i=0; i < size(); i++) {\n    if (getInt(i) == MISSING_VALUE) {\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Returns the count of missing values in this column"}
{"code": "public void oneShot(View emiter,int numParticles,Interpolator interpolator){\n  configureEmiter(emiter,Gravity.CENTER);\n  mActivatedParticles=0;\n  mEmittingTime=mTimeToLive;\n  for (int i=0; i < numParticles && i < mMaxParticles; i++) {\n    activateParticle(0);\n  }\n  startAnimator(interpolator,mTimeToLive);\n}\n", "nl": "Launches particles in one Shot using a special Interpolator"}
{"code": "@Override protected float evaluate(Target target){\n  float result=0;\n  if (targetAttributeName.contentEquals(\"f0\")) {\n    result=(float)sopModels.get(\"f0\").interpret(target);\n  }\n else {\n    if (target.getAllophone().isVowel())     result=(float)sopModels.get(\"vowel\").interpret(target);\n else     if (target.getAllophone().isConsonant())     result=(float)sopModels.get(\"consonant\").interpret(target);\n else     if (target.getAllophone().isPause())     result=(float)sopModels.get(\"pause\").interpret(target);\n else {\n      Log.w(Mary.LOG,\"Warning: No SoP model for target \" + target.toString());\n    }\n  }\n  return result;\n}\n", "nl": "Apply the SoP to a Target to get its predicted value"}
{"code": "public static final void banPlayer(Player bannedPlayer,Player banGiver){\n  Preconditions.checkNotNull(bannedPlayer,\"Banned player should not be null\");\n  Preconditions.checkNotNull(banGiver,\"Bangiver player should not be null\");\n  PlayerGroup group=banGiver.getPlayerGroup2();\n  if (group != null) {\n    if (group.hasMember(bannedPlayer.getObjectId())) {\n      group.onEvent(new PlayerGroupLeavedEvent(group,bannedPlayer,LeaveReson.BAN,banGiver.getName()));\n    }\n else {\n      log.warn(\"TEAM2: banning player not in group {}\",group.onlineMembers());\n    }\n  }\n}\n", "nl": "Remove player from group (ban)"}
{"code": "public ImageIcon loadImage(String imageName){\n  try {\n    ClassLoader classloader=getClass().getClassLoader();\n    java.net.URL url=classloader.getResource(imageName);\n    if (url != null) {\n      ImageIcon icon=new ImageIcon(url);\n      return icon;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  throw new IllegalArgumentException(\"Unable to load image: \" + imageName);\n}\n", "nl": "Helper method to load an image file from the CLASSPATH"}
{"code": "protected double computeMaxYAxisValueLogScale(double maxValue){\n  double v=0;\n  int mantisse=0;\n  int exponent=0;\n  while (v < maxValue) {\n    if (mantisse < 9)     mantisse++;\n else {\n      mantisse=1;\n      exponent++;\n    }\n    v=mantisse * Math.pow(10,exponent);\n  }\n  return Math.log10(v);\n}\n", "nl": "compute the maximum value on a log scale"}
{"code": "@Override public String toString(){\n  String string=\"\";\n  if (leftTarget != null) {\n    string+=\" \" + leftTarget.getName();\n  }\n  if (rightTarget != null) {\n    string+=\" \" + rightTarget.getName();\n  }\n  return string;\n}\n", "nl": "for debugging, provide the names of the left and right targets as the string representation of this class"}
{"code": "static boolean turnHuman(){\n  int x, y;\n  do {\n    System.out.print(\"Your turn X Y (1..\" + field_size + \")\\n>\");\n    x=sc.nextInt();\n    y=sc.nextInt();\n    if (x < 0 || y < 0) {\n      return false;\n    }\n  }\n while (!isCellBusy(x - 1,y - 1,dotEmpty));\n  field[x - 1][y - 1]=dotHuman;\n  return true;\n}\n", "nl": "Player Turn - Human"}
{"code": "private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,ContrastMethod contrastMethod){\n  ContrastEnhancement contrastEnhancement=(ContrastEnhancement)styleFactory.contrastEnhancement(null,contrastMethod.name());\n  FilterFactory ff=CommonFactoryFinder.getFilterFactory();\n  Map<String,Expression> options=contrastEnhancement.getOptions();\n  options.put(\"algorithm\",ff.literal(\"TestStretchToMinimumMaximum\"));\n  options.put(\"minValue\",ff.literal(\"1.0\"));\n  options.put(\"maxValue\",ff.literal(\"5.0\"));\n  SelectedChannelType channelType=styleFactory.createSelectedChannelType(\"channel name\",contrastEnhancement);\n  SelectedChannelType[] channels=new SelectedChannelType[3];\n  channels[0]=channelType;\n  channels[1]=channelType;\n  channels[2]=channelType;\n  ChannelSelection channelSelection=styleFactory.createChannelSelection(channels);\n  return channelSelection;\n}\n", "nl": "Creates the channel selection error object"}
{"code": "private int F(int x){\n  int a, b, c, d;\n  d=x & 0xFF;\n  x>>=8;\n  c=x & 0xFF;\n  x>>=8;\n  b=x & 0xFF;\n  x>>=8;\n  a=x & 0xFF;\n  int y=sBoxes[0][a] + sBoxes[1][b];\n  y^=sBoxes[2][c];\n  y+=sBoxes[3][d];\n  return y;\n}\n", "nl": "The round (Feistel) function of Blowfish cipher"}
{"code": "public String upload_file1(String group_name,String local_filename,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String parts[]=this.upload_file(group_name,local_filename,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload file to storage server (by file name)"}
{"code": "public static Rule createSubPropertyRule(String ruleId,RelationType parent,RelationType child,Map<String,String> roleMappings,MindmapsGraph graph){\n  final int parentArity=parent.hasRoles().size();\n  final int childArity=child.hasRoles().size();\n  if (parentArity != childArity || parentArity != roleMappings.size())   throw new IllegalArgumentException(ErrorMessage.RULE_CREATION_ARITY_ERROR.getMessage());\n  Var parentVar=Graql.var().isa(parent.getId());\n  Var childVar=Graql.var().isa(child.getId());\n  Set<String> vars=new HashSet<>();\n  roleMappings.forEach(null);\n  String body=childVar.toString() + \";\";\n  String head=parentVar.toString() + \";\";\n  return graph.putRule(ruleId,body,head,graph.getMetaRuleInference());\n}\n", "nl": "creates rule parent :- child"}
{"code": "private ByteBuffer read(FileChannel channel,int size){\n  ByteBuffer byteBffer=ByteBuffer.allocate(size);\n  try {\n    channel.read(byteBffer);\n  }\n catch (  Exception e) {\n    LOGGER.error(e,e.getMessage());\n  }\n  byteBffer.rewind();\n  return byteBffer;\n}\n", "nl": "This method will be used to read from file based on number of bytes to be read and positon"}
{"code": "private void notifyStart(){\n  if (eventHandler instanceof LifecycleAware) {\n    try {\n      ((LifecycleAware)eventHandler).onStart();\n    }\n catch (    final Throwable ex) {\n      exceptionHandler.handleOnStartException(ex);\n    }\n  }\n}\n", "nl": "Notifies the EventHandler when this processor is starting up"}
{"code": "@NotNull public static String tableToString(@NotNull JTableFixture table,int startRow,int endRow,int startColumn,int endColumn,int cellWidth){\n  String[][] contents=table.contents();\n  StringBuilder sb=new StringBuilder();\n  String formatString=\"%-\" + Integer.toString(cellWidth) + \"s\";\n  for (int row=Math.max(0,startRow); row < Math.min(endRow,contents.length); row++) {\n    for (int column=Math.max(0,startColumn); column < Math.min(contents[0].length,endColumn); column++) {\n      String cell=contents[row][column];\n      if (cell.length() > cellWidth) {\n        cell=cell.substring(0,cellWidth - 3) + \"...\";\n      }\n      sb.append(String.format(formatString,cell));\n    }\n    sb.append('\\n');\n  }\n  return sb.toString();\n}\n", "nl": "Pretty-prints the given table fixture"}
{"code": "private void isaac(){\n  isaacI=0;\n  isaacJ=H_SIZE;\n  isaacB+=++isaacC;\n  while (isaacI < H_SIZE) {\n    isaac2();\n  }\n  isaacJ=0;\n  while (isaacJ < H_SIZE) {\n    isaac2();\n  }\n}\n", "nl": "Generate 256 results"}
{"code": "public static <T>List<T> toList(T obj1,T obj2,T obj3,T obj4,T obj5){\n  List<T> list=new LinkedList<T>();\n  list.add(obj1);\n  list.add(obj2);\n  list.add(obj3);\n  list.add(obj4);\n  list.add(obj5);\n  return list;\n}\n", "nl": "Create a list from passed objX parameters"}
{"code": "public static Document load(String collection,Bson query){\n  try {\n    MongoCollection<Document> c=MongoHelper.getCollection(collection);\n    if (c != null) {\n      return c.find(query).first();\n    }\n  }\n catch (  Exception e) {\n    if (log.isErrorEnabled())     log.error(query,e);\n  }\n  return null;\n}\n", "nl": "Load the data, and return the DBObject"}
{"code": "public void actionPerformed(ActionEvent ev){\n  PCoATab tab=getViewer().getPcoaTab();\n  PCoA PCoA=tab.getPCoA();\n  int numberOfPCs=PCoA.getNumberOfPositiveEigenValues();\n  String value=(tab.getFirstPC() + 1) + \" x \" + (tab.getSecondPC() + 1);\n  value=JOptionPane.showInputDialog(getViewer().getFrame(),\"Enter PCs (range 1-\" + numberOfPCs + \"):\",value);\n  if (value != null) {\n    try {\n      String[] tokens=value.split(\"x\");\n      int pc1=Integer.parseInt(tokens[0].trim());\n      int pc2=Integer.parseInt(tokens[1].trim());\n      execute(\"set pc1=\" + pc1 + \" pc2=\"+ pc2+ \";\");\n    }\n catch (    Exception ex) {\n      NotificationsInSwing.showError(getViewer().getFrame(),\"Expected 'pc1 x pc2', got: \" + value);\n    }\n  }\n}\n", "nl": "action to be performed"}
{"code": "private Text createCopiableLabel(Composite parent,String text,int span,int horizontalIndent){\n  Text textControl=new Text(parent,SWT.READ_ONLY);\n  textControl.setText(text);\n  GridData data=new GridData();\n  data.horizontalAlignment=GridData.FILL;\n  data.horizontalSpan=span;\n  data.horizontalAlignment=GridData.FILL;\n  data.horizontalIndent=horizontalIndent;\n  textControl.setLayoutData(data);\n  return textControl;\n}\n", "nl": "creates a label which the user can copy to clipboard (in fact it is a Text)"}
{"code": "private HttpUrl urlBodyFromMap(String base,Map<String,String> map){\n  HttpUrl.Builder builder=HttpUrl.parse(base).newBuilder(base);\n  for (  Entry<String,String> entry : map.entrySet()) {\n    if (entry.getValue() != null) {\n      builder.addEncodedQueryParameter(entry.getKey(),entry.getValue());\n    }\n  }\n  return builder.build();\n}\n", "nl": "Creates url based on map of params"}
{"code": "public int readPacked(int kind){\nswitch (kind) {\ncase 0:\n    return read();\ncase 1:\n  return readCharLittleEndian();\ncase 2:\nreturn readIntLittleEndian();\ndefault :\nthrow new RuntimeException(\"unknown kind\");\n}\n}\n", "nl": "read packed value"}
{"code": "protected void importServicesAndOperations(Definition definition){\n  for (  Object serviceObject : definition.getServices().values()) {\n    Service service=(Service)serviceObject;\n    WSService wsService=this.importService(service);\n    this.wsServices.put(this.namespace + wsService.getName(),wsService);\n    Port port=(Port)service.getPorts().values().iterator().next();\n    for (    Object bindOperationObject : port.getBinding().getBindingOperations()) {\n      BindingOperation bindOperation=(BindingOperation)bindOperationObject;\n      WSOperation operation=this.processOperation(bindOperation.getOperation(),wsService);\n      wsService.addOperation(operation);\n      this.wsOperations.put(this.namespace + operation.getName(),operation);\n    }\n  }\n}\n", "nl": "Imports services and operations from the WSDL definition"}
{"code": "public void runNeighborNet(ProgressListener progressListener,int ntax,double[][] D,int ordering[]) throws CanceledException {\n  NetNode netNodes=new NetNode();\n  for (int i=ntax; i >= 1; i--) {\n    NetNode taxNode=new NetNode();\n    taxNode.id=i;\n    taxNode.next=netNodes.next;\n    netNodes.next=taxNode;\n  }\n  for (NetNode taxNode=netNodes; taxNode.next != null; taxNode=taxNode.next)   taxNode.next.prev=taxNode;\n  Stack amalgs=new Stack();\n  int num_nodes=ntax;\n  num_nodes=agglomNodes(progressListener,amalgs,D,netNodes,num_nodes);\n  expandNodes(progressListener,num_nodes,ntax,amalgs,netNodes,ordering);\n}\n", "nl": "Run the neighbor net algorithm"}
{"code": "public static void onHelp(NpcAI2 npcAI,Creature creature){\n  Npc npc=npcAI.getOwner();\n  if (npc.getAttackedCount() == 0) {\n    if (DataManager.NPC_SHOUT_DATA.hasAnyShout(npc.getPosition().getMapId(),npc.getNpcId(),ShoutEventType.ATTACKED)) {\n      List<NpcShout> shouts=DataManager.NPC_SHOUT_DATA.getNpcShouts(npc.getPosition().getMapId(),npc.getNpcId(),ShoutEventType.ATTACKED,null,0);\n      NpcShoutsService.getInstance().shout(npc,creature,shouts,0,false);\n      shouts.clear();\n      return;\n    }\n    if (DataManager.NPC_SHOUT_DATA.hasAnyShout(npc.getPosition().getMapId(),npc.getNpcId(),ShoutEventType.HELPCALL)) {\n      List<NpcShout> shouts=DataManager.NPC_SHOUT_DATA.getNpcShouts(npc.getPosition().getMapId(),npc.getNpcId(),ShoutEventType.HELPCALL,null,0);\n      NpcShoutsService.getInstance().shout(npc,creature,shouts,0,false);\n      shouts.clear();\n    }\n  }\n}\n", "nl": "Handle NPC attacked event (when damage was received or not)"}
{"code": "public void sendRoomListPacket(int protocol,List<GameRoom> gameRooms){\n  String packet=new String();\n  int partitionPacketNumber=0;\n  for (int i=0; i < gameRooms.size(); i++)   if (gameRooms.get(i).isGameRunning() == false)   partitionPacketNumber++;\n  packet=packet.concat(Settings.sSenderSplitProtocolToken);\n  packet=packet.concat(protocol + Settings.sSenderSplitProtocolToken);\n  packet=packet.concat(partitionPacketNumber + Settings.sSenderSplitProtocolToken);\n  for (int i=0; i < gameRooms.size(); i++) {\n    if (gameRooms.get(i).isGameRunning() == false)     packet=packet.concat(gameRooms.get(i).getsRoomName() + Settings.sSenderSplitProtocolToken);\n  }\n  packet=packet.concat(Settings.sSenderSplitMultipleToken);\n  send(packet);\n}\n", "nl": "sends packed in the game room people"}
{"code": "public static IRemoteService createService(String remoteURL,String user,String password) throws IOException {\n  final IRemoteService clientNode;\n  if (remoteURL.startsWith(LOCAL)) {\n    clientNode=new LocalService(remoteURL.replaceAll(LOCAL,\"\"));\n  }\n else   clientNode=new RemoteService(remoteURL,user,password);\n  if (url2node.containsKey(clientNode.getShortName()))   System.err.println(\"Warning: node already exists: \" + clientNode.getShortName());\n  url2node.put(clientNode.getShortName(),clientNode);\n  if (ProgramProperties.get(\"SaveRemoteCrendentials\",true))   saveCredentials(clientNode.getShortName(),user,password);\n  return clientNode;\n}\n", "nl": "create a new node"}
{"code": "public Matrix plusEquals(Matrix B){\n  checkMatrixDimensions(B);\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      A[i][j]=A[i][j] + B.A[i][j];\n    }\n  }\n  return this;\n}\n", "nl": "A = A + B"}
{"code": "@Override public int countMissing(){\n  int count=0;\n  for (int i=0; i < size(); i++) {\n    if (get(i) == MISSING_VALUE) {\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Returns the count of missing values in this column"}
{"code": "public final void updateNumberOfProcessedLines() throws DataFallbackException {\n  openCounterDataOutputStream();\n  try {\n    this.getDOutput().write(new Integer(getReadBackLines()).toString());\n    getDOutput().newLine();\n    if (LOG.isDebugEnabled())     LOG.debug(\"removeLines() - The counter file has been updated with the value \" + getReadBackLines());\n  }\n catch (  IOException e) {\n    throw new DataFallbackException(e.getMessage());\n  }\n  closeCounterDataOutputStream();\n}\n", "nl": "It stores the current file counter (indicating the number of lines already processed from the file), so they won't be treated next time"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"select top=\");\n  int number=np.getInt(0,Integer.MAX_VALUE);\n  np.matchIgnoreCase(\";\");\n  final ChartViewer viewer=(ChartViewer)getViewer();\n  final LabelsJList list=viewer.getActiveLabelsJList();\n  list.selectTop(number);\n  viewer.repaint();\n}\n", "nl": "parses the given command and executes it"}
{"code": "public void writeContigs(Writer w,ProgressListener progress) throws CanceledException, IOException {\n  progress.setSubtask(\"Writing contigs\");\n  progress.setMaximum(contigs.size());\n  progress.setProgress(0);\n  for (  Pair<String,String> pair : contigs) {\n    w.write(pair.getFirst().trim());\n    w.write(\"\\n\");\n    w.write(pair.getSecond().trim());\n    w.write(\"\\n\");\n    progress.incrementProgress();\n  }\n  w.flush();\n  if (progress instanceof ProgressPercentage)   ((ProgressPercentage)progress).reportTaskCompleted();\n}\n", "nl": "write contigs"}
{"code": "public static Colour attemptToGetAsColour(String part){\n  Colour col=null;\n  try {\n    col=Colour.valueOf(part.toUpperCase());\n  }\n catch (  Exception e) {\n  }\n  return col;\n}\n", "nl": "Attempt to parse string as a Colour"}
{"code": "protected ZKLogMetadata(URI uri,String logName,String logIdentifier){\n  this.uri=uri;\n  this.logName=logName;\n  this.logIdentifier=logIdentifier;\n  this.logRootPath=getLogRootPath(uri,logName,logIdentifier);\n  this.logSegmentsPath=logRootPath + LOGSEGMENTS_PATH;\n  this.lockPath=logRootPath + LOCK_PATH;\n  this.maxTxIdPath=logRootPath + MAX_TXID_PATH;\n  this.allocationPath=logRootPath + ALLOCATION_PATH;\n}\n", "nl": "metadata representation of a log"}
{"code": "private Date parseDate(String date){\n  try {\n    return DateFormat.getDateInstance(DateFormat.SHORT).parse(date);\n  }\n catch (  ParseException e) {\n    MessageDialog.openError(getShell(),Policy.bind(\"HistorySearchDialog.dateParseErrorTitle\"),Policy.bind(\"HistorySearchDialog.dateParseErrorMessage\"));\n    return null;\n  }\n}\n", "nl": "Parses a date in a string to a Date"}
{"code": "@SuppressWarnings(\"restriction\") public synchronized String encrypt(String str){\n  byte[] utf8;\n  try {\n    utf8=str.getBytes(\"UTF-8\");\n    byte[] enc=encrypter.doFinal(utf8);\n    return encoder.encode(enc);\n  }\n catch (  UnsupportedEncodingException e) {\n    e.printStackTrace();\n  }\ncatch (  IllegalBlockSizeException e) {\n    e.printStackTrace();\n  }\ncatch (  BadPaddingException e) {\n    e.printStackTrace();\n  }\n  return \"\";\n}\n", "nl": "Encrypt a string"}
{"code": "public static void ensureCredentialsHaveBeenLoadedFromProperties(){\n  if (!loaded) {\n    final String[] credentials=ProgramProperties.get(\"MeganServerCredentials\",new String[0]);\n    for (    String line : credentials) {\n      String[] tokens=line.split(\"::\");\n      if (tokens.length > 0) {\n        server2Credentials.put(tokens[0],new Pair<>(tokens.length > 1 ? tokens[1] : \"\",Basic.toString(Base64.decodeBase64((tokens.length > 2 ? tokens[2] : \"\")))));\n      }\n    }\n    loaded=true;\n  }\n}\n", "nl": "load all saved credentials from properties"}
{"code": "private void updateArrow(){\n  path1.reset();\n  path2.reset();\n  path3.reset();\n  path1.moveTo(mRealLeft + radius,mArrowStart);\n  path1.lineTo(mRealLeft + radius,mArrowStart + radius);\n  path2.moveTo(mRealLeft + radius,mArrowStart + radius);\n  path2.lineTo((float)(mRealLeft + radius - Math.tan(Math.toRadians(40)) * radius * 0.46f),mArrowStart + radius - radius * .46f);\n  path3.moveTo(mRealLeft + radius,mArrowStart + radius);\n  path3.lineTo((float)(mRealLeft + radius + Math.tan(Math.toRadians(40)) * radius * 0.46f),mArrowStart + radius - radius * .46f);\n  pathMeasure1.setPath(path1,false);\n  pathMeasure2.setPath(path2,false);\n  pathMeasure3.setPath(path3,false);\n  mArrow_center_length=pathMeasure1.getLength();\n  mArrow_left_length=pathMeasure2.getLength();\n  mArrow_right_length=pathMeasure3.getLength();\n}\n", "nl": "update the Arrow's Status"}
{"code": "private soot.Local createCatchFormal(polyglot.ast.Formal formal){\n  soot.Type sootType=Util.getSootType(formal.type().type());\n  soot.Local formalLocal=createLocal(formal.localInstance());\n  soot.jimple.CaughtExceptionRef exceptRef=soot.jimple.Jimple.v().newCaughtExceptionRef();\n  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(formalLocal,exceptRef);\n  body.getUnits().add(stmt);\n  Util.addLnPosTags(stmt,formal.position());\n  Util.addLnPosTags(((soot.jimple.IdentityStmt)stmt).getRightOpBox(),formal.position());\n  ArrayList<String> names=new ArrayList<String>();\n  names.add(formal.name());\n  stmt.addTag(new soot.tagkit.ParamNamesTag(names));\n  return formalLocal;\n}\n", "nl": "Catch Formal creation - method parameters"}
{"code": "public void dumpBinary(DataOutputStream os) throws IOException {\n  os.writeInt(frameData.length);\n  for (int i=0; i < frameData.length; i++) {\n    os.writeShort(frameData[i]);\n  }\n  os.writeInt(residualData.length);\n  for (int i=0; i < residualData.length; i++) {\n    os.writeByte(residualData[i]);\n  }\n}\n", "nl": "Dumps the samples to the given stream"}
{"code": "Collection<? extends ClientRequestResult> handleDaqXmlRequest(final ClientRequest daqXmlRequest){\n  Collection<ProcessXmlResponse> singleXML=new ArrayList<ProcessXmlResponse>(1);\n  ProcessXmlResponseImpl processXmlResponse;\n  try {\n    String xmlString=processXMLProvider.getProcessConfigXML(daqXmlRequest.getRequestParameter());\n    processXmlResponse=new ProcessXmlResponseImpl();\n    processXmlResponse.setProcessXML(xmlString);\n  }\n catch (  CacheElementNotFoundException cacheEx) {\n    String errorMessage=\"Error while getting Process configruation:\" + cacheEx.getMessage();\n    LOG.warn(errorMessage,cacheEx);\n    processXmlResponse=new ProcessXmlResponseImpl(false,errorMessage);\n  }\n  singleXML.add(processXmlResponse);\n  return singleXML;\n}\n", "nl": "Inner method which handles the Daq Xml Requests"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  ServicePanel servicePanel=((RemoteServiceBrowser)getViewer()).getServicePanel();\n  if (servicePanel != null) {\n    TreePath[] paths=servicePanel.getFileTree().getSelectionPaths();\n    if (paths != null)     servicePanel.collapse(paths);\n else     servicePanel.collapse((DefaultMutableTreeNode)servicePanel.getFileTree().getModel().getRoot());\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "@Override public int countMissing(){\n  int count=0;\n  for (int i=0; i < size(); i++) {\n    if (getLong(i) == MISSING_VALUE) {\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Returns the count of missing values in this column"}
{"code": "@Override protected void createStartDocumentSkeleton(StartDocument startDoc){\n  skel=new GenericSkeleton();\n  if (!params.omitXMLDeclaration) {\n    skel.add(\"<?xml version=\\\"\" + doc.getXmlVersion() + \"\\\"\");\n    skel.add(\" encoding=\\\"\" + doc.getXmlEncoding() + \"\\\"\");\n    if (doc.getXmlStandalone()) {\n      skel.add(\" standalone=\\\"yes\\\"\");\n    }\n    skel.add(\"?>\" + lineBreak);\n  }\n}\n", "nl": "Overriding to use xml encoding from the input xml document"}
{"code": "private void handleEventBusRegistration(IJAssignmentTarget fieldRef,HasLifecycleMethods holderWithLifecycleMethods){\n  JBlock onStartBlock;\n  JBlock onStopBlock;\n  if (holderWithLifecycleMethods instanceof EServiceHolder) {\n    onStartBlock=holderWithLifecycleMethods.getOnCreateAfterSuperBlock();\n    onStopBlock=holderWithLifecycleMethods.getOnDestroyBeforeSuperBlock();\n  }\n else {\n    onStartBlock=holderWithLifecycleMethods.getOnStartAfterSuperBlock();\n    onStopBlock=holderWithLifecycleMethods.getOnStopBeforeSuperBlock();\n  }\n  onStartBlock.invoke(fieldRef,\"register\").arg(JExpr._this());\n  onStopBlock.invoke(fieldRef,\"unregister\").arg(JExpr._this());\n}\n", "nl": "adds register/unregister calls for the EventBus to the onStart/onStop methods"}
{"code": "protected void validateBrokerName(String broker) throws MalformedURLException {\n  String brokerUrl=String.format(\"http://%s\",broker);\n  if (!pulsar().getWebServiceAddress().equals(brokerUrl)) {\n    String[] parts=broker.split(\":\");\n    checkArgument(parts.length == 2);\n    String host=parts[0];\n    int port=Integer.parseInt(parts[1]);\n    URI redirect=UriBuilder.fromUri(uri.getRequestUri()).host(host).port(port).build();\n    log.debug(\"[{}] Redirecting the rest call to {}: broker={}\",clientAppId(),redirect,broker);\n    throw new WebApplicationException(Response.temporaryRedirect(redirect).build());\n  }\n}\n", "nl": "Redirect the call to the specified broker"}
{"code": "private static ResizeHandle findResizeHandleInWidget(ConstraintWidget widget,float x,float y,ViewTransform transform){\n  WidgetCompanion companion=(WidgetCompanion)widget.getCompanionWidget();\n  WidgetDecorator decorator=companion.getWidgetDecorator(WidgetDecorator.BLUEPRINT_STYLE);\n  if (!decorator.isVisible()) {\n    return null;\n  }\n  WidgetInteractionTargets widgetInteraction=companion.getWidgetInteractionTargets();\n  widgetInteraction.updatePosition(transform);\n  ResizeHandle handle=widgetInteraction.findResizeHandle(x,y);\n  if (handle != null) {\n    return handle;\n  }\n  return null;\n}\n", "nl": "Find which ResizeHandle is close to the (x, y) coordinates"}
{"code": "private int measureHeightSize(int measureSpec){\n  int defSize=dp2px(DEFAULT_HEIGHT);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int result=0;\nswitch (specMode) {\ncase MeasureSpec.UNSPECIFIED:\ncase MeasureSpec.AT_MOST:\n    result=Math.min(defSize,specSize);\n  break;\ncase MeasureSpec.EXACTLY:\nresult=specSize;\nbreak;\n}\nreturn result;\n}\n", "nl": "measure height"}
{"code": "private AbstractResource findResource(String resName,String resID,String packageName){\n  for (  ARSCFileParser.ResPackage pkg : this.resourcePackages) {\n    boolean matches=(packageName == null || packageName.isEmpty()) && pkg.getPackageName().equals(this.appPackageName);\n    matches|=pkg.getPackageName().equals(packageName);\n    if (!matches)     continue;\n    for (    ARSCFileParser.ResType type : pkg.getDeclaredTypes())     if (type.getTypeName().equals(resID)) {\n      AbstractResource res=type.getFirstResource(resName);\n      return res;\n    }\n  }\n  return null;\n}\n", "nl": "Finds the given resource in the given package"}
{"code": "private Double readNextNumber(Stack<CalculationToken> calculationStack){\n  CalculationToken calculationToken=calculationStack.pop();\n  DoubleToken doubleToken;\n  Double nextNumber;\n  if (calculationToken instanceof OperationToken) {\n    calculationToken=calculationStack.pop();\n    doubleToken=(DoubleToken)calculationToken;\n    nextNumber=-doubleToken.getNumber();\n  }\n else {\n    doubleToken=(DoubleToken)calculationToken;\n    nextNumber=doubleToken.getNumber();\n  }\n  return nextNumber;\n}\n", "nl": "A function to read the next number on the stack (allows for reading even in cases of unary minuses)"}
{"code": "public void writeSortTempFile(Object[][] records) throws CarbonSortKeyAndGroupByException {\n  int recordCount=0;\n  Object[][] tempRecords;\n  while (recordCount < records.length) {\n    if (records.length - recordCount < recordPerLeaf) {\n      recordPerLeaf=records.length - recordCount;\n    }\n    tempRecords=new Object[recordPerLeaf][];\n    System.arraycopy(records,recordCount,tempRecords,0,recordPerLeaf);\n    recordCount+=recordPerLeaf;\n    this.writer.writeSortTempFile(tempRecords);\n  }\n}\n", "nl": "Below method will be used to write the sort temp file chunk by chunk"}
{"code": "public static final String formatSize(int size){\n  if (size < MB_CONSTANT) {\n    float kSize=(float)size / KB_CONSTANT;\n    kSize=((float)((int)(kSize * 10))) / 10;\n    return kSize + \"K\";\n  }\n else   if (size < GB_CONSTANT) {\n    float kSize=(float)size / MB_CONSTANT;\n    kSize=((float)((int)(kSize * 10))) / 10;\n    return kSize + \"M\";\n  }\n else {\n    float kSize=(float)size / GB_CONSTANT;\n    kSize=((float)((int)(kSize * 100))) / 100;\n    return kSize + \"G\";\n  }\n}\n", "nl": "Format the download progress"}
{"code": "public void discardRecording(){\n  if (recorder != null) {\n    try {\n      recorder.stop();\n      recorder.release();\n      recorder=null;\n      if (file != null && file.exists() && !file.isDirectory()) {\n        file.delete();\n      }\n    }\n catch (    IllegalStateException e) {\n    }\ncatch (    RuntimeException e) {\n    }\n    isRecording=false;\n  }\n}\n", "nl": "stop the recoding"}
{"code": "public static String baseTypeName(String s){\n  int index=s.indexOf(\"[\");\n  if (index < 0) {\n    return s;\n  }\n else {\n    return s.substring(0,index);\n  }\n}\n", "nl": "strips suffix for indicating an array type"}
{"code": "public void cancelCallWithTag(String tag){\n  for (  Call call : client.dispatcher().queuedCalls()) {\n    if (call.request().tag().equals(tag)) {\n      call.cancel();\n    }\n  }\n  for (  Call call : client.dispatcher().runningCalls()) {\n    if (call.request().tag().equals(tag)) {\n      call.cancel();\n    }\n  }\n}\n", "nl": "Cancels requests with the given tag"}
{"code": "public static void showValues(String[] titles,String[] values){\n  if (titles.length == 0 || (titles.length != values.length)) {\n    return;\n  }\n  JTable table=new JTable();\n  table.setModel(new DefaultTableModel(new Object[][]{},new String[]{\" \",\" \"}));\n  SwingUtil.TableUtil.ensureRowNumber(table,titles.length);\n  for (int i=0; i < titles.length; i++) {\n    table.setValueAt(titles[i],i,0);\n    table.setValueAt(values[i],i,1);\n  }\n  JScrollPane mainPanel=new JScrollPane(table);\n  JOptionPane.showMessageDialog(null,mainPanel,\"Enter values\",JOptionPane.OK_OPTION);\n}\n", "nl": "Show a list of values to user"}
{"code": "public static String currentPlatformName(){\n  String os=System.getProperty(\"os.name\");\n  if (os.startsWith(\"Mac OS\")) {\n    return \"Mac OS X\";\n  }\n else   if (os.startsWith(\"Windows\")) {\n    return \"Windows\";\n  }\n else   if (os.startsWith(\"Linux\")) {\n    return \"Linux\";\n  }\n  return \"Other\";\n}\n", "nl": "Returns current platform's UI name"}
{"code": "public static boolean matches(IIngredient ingredient,IItemStack itemStack){\n  if (ingredient == null) {\n    return false;\n  }\n  if (!ingredient.matches(itemStack)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Adds extra check to IIngredient matches() for Botania special flowers"}
{"code": "public final boolean isDiskSpaceCheckDone(final int minimumFreeSpace) throws SystemDiskSpaceException {\n  final FallbackProperties fProperties=FallbackProperties.getInstance();\n  boolean checkDone=false;\n  if (fFileController.getNumberOfLines() > nextCheckFallbackData) {\n    checkDone=true;\n    if (LOG.isDebugEnabled())     LOG.debug(\"isDiskSpaceCheckDone() : Doing the check since the number of lines are \" + fFileController.getNumberOfLines() + \" and the current value for nextcheck is \"+ nextCheckFallbackData);\n    long freeSpace=SystemResourcesParameters.getFreeSpace();\n    if (freeSpace < minimumFreeSpace && freeSpace != FallbackProperties.CMD_FREE_SPACE_ERROR) {\n      throw new SystemDiskSpaceException(\"Reached the limit of free space of \" + minimumFreeSpace + \", current free space is \"+ freeSpace);\n    }\n else {\n      nextCheckFallbackData=fFileController.getNumberOfLines() + fProperties.getFreeSpaceCheckFrequency();\n      if (LOG.isDebugEnabled())       LOG.debug(\"isDiskSpaceCheckDone() : New value of nextCheckDataTags is \" + nextCheckFallbackData);\n    }\n  }\n  return checkDone;\n}\n", "nl": "Checks the free disc space every time a determined number of lines are written to the file"}
{"code": "protected String skipEmptyLines(){\n  while (true) {\n    if (hasNextLine()) {\n      String next=nextLine().trim();\n      if (next.length() > 0)       return next;\n    }\n else     return null;\n  }\n}\n", "nl": "skips empty lines and returns the next non-empty one or null"}
{"code": "public static String[] toStringArray(Object value){\n  if (value instanceof String[]) {\n    return (String[])value;\n  }\n else {\n    Object[] valueArray=(Object[])value;\n    return Arrays.stream(valueArray).map(null).toArray(null);\n  }\n}\n", "nl": "Convert an Object array to a String array by invoking toString on each element"}
{"code": "public void testWriteReadEmpty() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(empty);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  ReplicationPolicyDescription copy=(ReplicationPolicyDescription)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(empty,copy));\n}\n", "nl": "Test read and write empty ClusterPolicy object"}
{"code": "public static String clearGuestShoppingListCookies(HttpServletRequest request,HttpServletResponse response){\n  Properties systemProps=System.getProperties();\n  String guestShoppingUserName=\"GuestShoppingListId_\" + systemProps.getProperty(\"user.name\").replace(\" \",\"_\");\n  Cookie guestShoppingListCookie=new Cookie(guestShoppingUserName,null);\n  guestShoppingListCookie.setMaxAge(0);\n  guestShoppingListCookie.setPath(\"/\");\n  response.addCookie(guestShoppingListCookie);\n  return \"success\";\n}\n", "nl": "Clear the guest cookies for a shopping list"}
{"code": "protected void fireGraphEvent(Table t,int first,int last,int col,int type){\n  String table=(t == getNodeTable() ? NODES : EDGES);\n  if (type != EventConstants.UPDATE) {\n    fireTupleEvent(t,first,last,type);\n  }\n  if (!m_listeners.isEmpty()) {\n    Object[] lstnrs=m_listeners.getArray();\n    for (int i=0; i < lstnrs.length; ++i) {\n      ((GraphListener)lstnrs[i]).graphChanged(this,table,first,last,col,type);\n    }\n  }\n}\n", "nl": "Fire a graph change event"}
{"code": "@deprecated public Object clone(){\n  try {\n    CompactCharArray other=(CompactCharArray)super.clone();\n    other.values=((char[])this.values.clone());\n    other.indices=((char[])this.indices.clone());\n    if (this.hashes != null)     other.hashes=((int[])this.hashes.clone());\n    return other;\n  }\n catch (  CloneNotSupportedException e) {\n    throw new IllegalStateException();\n  }\n}\n", "nl": "/*    "}
{"code": "public void removeClassLoader(ClassLoader classLoader){\n  if (_logger.isLoggable(Level.FINE))   _logger.fine(\"removing class loader from cache [\" + ClassLoaderHelper.getClassLoaderLogName(classLoader) + \"]\");\n  Long removedClassLoadedId=_classLoaderToIdMap.remove(classLoader);\n  if (removedClassLoadedId != null) {\n    ClassLoaderContext removedContext=_classLoaders.put(removedClassLoadedId,new ClassLoaderContext(null,Represent.REMOVED_EXPLICIT));\n    if (removedContext.getRepresents() == Represent.REMOVED_EXPLICIT || removedContext.getRepresents() == Represent.REMOVED_IMPLICIT)     return;\n    dispatchClassLoaderRemovedEvent(removedClassLoadedId,removedContext,true);\n  }\n else {\n    _logger.fine(\"class loader [\" + ClassLoaderHelper.getClassLoaderLogName(classLoader) + \"] is not present in cache\");\n  }\n}\n", "nl": "Remove the specified class loader"}
{"code": "private void promptSpeechInput(){\n  Intent intent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);\n  intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);\n  intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE,Locale.getDefault());\n  intent.putExtra(RecognizerIntent.EXTRA_PROMPT,getString(R.string.speech_prompt));\n  try {\n    startActivityForResult(intent,REQ_CODE_SPEECH_INPUT);\n  }\n catch (  ActivityNotFoundException a) {\n    Toast.makeText(getApplicationContext(),getString(R.string.speech_not_supported),Toast.LENGTH_SHORT).show();\n  }\n}\n", "nl": "Showing google speech input dialog"}
{"code": "@Override public int countMissing(){\n  int count=0;\n  for (int i=0; i < size(); i++) {\n    if (get(i) == MISSING_VALUE) {\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Returns the count of missing values in this column"}
{"code": "public BrokerItem(Item item,long price,String seller,int sellerId,BrokerRace itemBrokerRace,boolean partSale){\n  this.item=item;\n  this.itemId=item.getItemTemplate().getTemplateId();\n  this.itemUniqueId=item.getObjectId();\n  this.itemCount=item.getItemCount();\n  this.itemCreator=item.getItemCreator();\n  this.price=price;\n  this.seller=seller;\n  this.sellerId=sellerId;\n  this.itemBrokerRace=itemBrokerRace;\n  this.isSold=false;\n  this.isSettled=false;\n  this.expireTime=new Timestamp(Calendar.getInstance().getTimeInMillis() + 691200000);\n  this.settleTime=new Timestamp(Calendar.getInstance().getTimeInMillis());\n  this.partSale=partSale;\n  this.state=PersistentState.NEW;\n}\n", "nl": "Used where registering item"}
{"code": "protected boolean baseMatches(final Value baseValue,Abstraction source){\n  if (baseValue instanceof Local) {\n    if (baseValue.equals(source.getAccessPath().getPlainValue()))     return true;\n  }\n else   if (baseValue instanceof InstanceFieldRef) {\n    InstanceFieldRef ifr=(InstanceFieldRef)baseValue;\n    if (ifr.getBase().equals(source.getAccessPath().getPlainValue()) && source.getAccessPath().firstFieldMatches(ifr.getField()))     return true;\n  }\n else   if (baseValue instanceof StaticFieldRef) {\n    StaticFieldRef sfr=(StaticFieldRef)baseValue;\n    if (source.getAccessPath().firstFieldMatches(sfr.getField()))     return true;\n  }\n  return false;\n}\n", "nl": "Checks whether the given base value matches the base of the given taint abstraction"}
{"code": "public static float max(final float a,final float b){\n  if (a > b) {\n    return a;\n  }\n  if (a < b) {\n    return b;\n  }\n  if (a != b) {\n    return Float.NaN;\n  }\n  int bits=Float.floatToRawIntBits(a);\n  if (bits == 0x80000000) {\n    return b;\n  }\n  return a;\n}\n", "nl": "Compute the maximum of two values"}
{"code": "private Grammar removeEntry(Entry entry){\n  if (entry.prev != null) {\n    entry.prev.next=entry.next;\n  }\n else {\n    fGrammars[entry.bucket]=entry.next;\n  }\n  if (entry.next != null) {\n    entry.next.prev=entry.prev;\n  }\n  --fGrammarCount;\n  entry.grammar.entry=null;\n  return (Grammar)entry.grammar.get();\n}\n", "nl": "Removes the given entry from the pool"}
{"code": "public static DataFileFooter readMetadatFile(String filePath,long blockOffset,long blockLength) throws CarbonUtilException {\n  DataFileFooterConverter fileFooterConverter=new DataFileFooterConverter();\n  try {\n    return fileFooterConverter.readDataFileFooter(filePath,blockOffset,blockLength);\n  }\n catch (  IOException e) {\n    throw new CarbonUtilException(\"Problem while reading the file metadata\",e);\n  }\n}\n", "nl": "Below method will be used to read the data file matadata"}
{"code": "private static boolean throwsException(IMethod method,Class<?> exceptionClass){\n  Class<?>[] exceptionClasses=method.getExceptionTypes();\n  for (  Class<?> c : exceptionClasses) {\n    if (exceptionClass.isAssignableFrom(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks if the given method throws the given exception"}
{"code": "private void initResourcesIfNecessary(){\n  if (centerDrawable == null) {\n    centerDrawable=getContext().getResources().getDrawable(wheelForeground);\n  }\n  if (topShadow == null) {\n    topShadow=new GradientDrawable(Orientation.TOP_BOTTOM,SHADOWS_COLORS);\n  }\n  if (bottomShadow == null) {\n    bottomShadow=new GradientDrawable(Orientation.BOTTOM_TOP,SHADOWS_COLORS);\n  }\n  setBackgroundResource(wheelBackground);\n}\n", "nl": "Initializes resources"}
{"code": "private static byte[][] rotateArray(byte[][] bitarray){\n  byte[][] temp=new byte[bitarray[0].length][bitarray.length];\n  for (int ii=0; ii < bitarray.length; ii++) {\n    int inverseii=bitarray.length - ii - 1;\n    for (int jj=0; jj < bitarray[0].length; jj++) {\n      temp[jj][inverseii]=bitarray[ii][jj];\n    }\n  }\n  return temp;\n}\n", "nl": "Takes and rotates the it 90 degrees"}
{"code": "private float computeCorrelationCoefficent(String classNameX,String attributeNameY){\n  ArrayList<Double> xValues=new ArrayList<>(getChartData().getSeriesNames().size());\n  ArrayList<Double> yValues=new ArrayList<>(getChartData().getSeriesNames().size());\n  for (  String sample : getChartData().getSeriesNames()) {\n    final double x=getChartData().getValueAsDouble(sample,classNameX);\n    final double y;\n    Object obj=viewer.getDir().getDocument().getSampleAttributeTable().get(sample,attributeNameY);\n    if (obj instanceof Number)     y=((Number)obj).doubleValue();\n else     throw new IllegalArgumentException(\"Attribute '\" + attributeNameY + \"': has non-numerical value: \"+ obj);\n    xValues.add(x);\n    yValues.add(y);\n  }\n  return (float)Correlation.computePersonsCorrelationCoefficent(xValues.size(),xValues,yValues);\n}\n", "nl": "return Pearson's correlation coefficient"}
{"code": "private void writeDictionaryFile(CarbonDictionaryWriterImpl writer,List<String> list) throws IOException {\n  try {\n    for (    String value : list) {\n      writer.write(value);\n    }\n  }\n  finally {\n    writer.close();\n    writer.commit();\n  }\n}\n", "nl": "this method will write the data into a file"}
{"code": "public boolean isComponentPresent(String componentName,String groupName){\n  if (isComponentGroupPresent(groupName)) {\n    if (!SidekickActions.isSectionExpanded(getSectionByName(groupName))) {\n      clickComponentGroupToggle(groupName);\n    }\n    return getComponentNames(groupName).contains(componentName);\n  }\n  throw new IllegalArgumentException(\"Group name \" + groupName + \" does not exist\");\n}\n", "nl": "This method checks if specified component is present selected group in Sidekick"}
{"code": "public ImageIcon loadImage(String imageName){\n  try {\n    ClassLoader classloader=getClass().getClassLoader();\n    java.net.URL url=classloader.getResource(imageName);\n    if (url != null) {\n      ImageIcon icon=new ImageIcon(url);\n      return icon;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  throw new IllegalArgumentException(\"Unable to load image: \" + imageName);\n}\n", "nl": "Helper method to load an image file from the CLASSPATH"}
{"code": "public static List<Target> createTargetsWithPauses(List<Element> segmentsAndBoundaries,String silenceSymbol){\n  List<Target> targets=new ArrayList<Target>();\n  if (segmentsAndBoundaries.size() == 0)   return targets;\n  Element last=segmentsAndBoundaries.get(segmentsAndBoundaries.size() - 1);\n  if (!last.getTagName().equals(MaryXML.BOUNDARY)) {\n    Element finalPause=MaryXML.createElement(last.getOwnerDocument(),MaryXML.BOUNDARY);\n    Element token=(Element)DomUtils.getAncestor(last,MaryXML.TOKEN);\n    Element parent=(Element)token.getParentNode();\n    parent.appendChild(finalPause);\n    segmentsAndBoundaries.add(finalPause);\n  }\n  for (  Element sOrB : segmentsAndBoundaries) {\n    String phone=UnitSelector.getPhoneSymbol(sOrB);\n    targets.add(new HalfPhoneTarget(phone + \"_L\",sOrB,true));\n    targets.add(new HalfPhoneTarget(phone + \"_R\",sOrB,false));\n  }\n  return targets;\n}\n", "nl": "Create the list of targets from the segments to be synthesized Prepend and append pauses if necessary"}
{"code": "public static String convertToJavaClassName(String name){\n  int dotIndex=name.indexOf('.');\n  if (dotIndex >= 0) {\n    name=name.substring(0,dotIndex);\n  }\n  String[] split=name.split(\"[_-]\");\n  StringBuilder out=new StringBuilder();\n  for (  String section : split) {\n    out.append(StringUtil.capitalize(section));\n  }\n  return out.toString();\n}\n", "nl": "Utility method that implements Data Binding's logic to convert a file name to a Java Class name"}
{"code": "public static Map<String,Object> testXmlRpcAdd(DispatchContext dctx,Map<String,?> context){\n  Locale locale=(Locale)context.get(\"locale\");\n  Map<String,Object> response=ServiceUtil.returnSuccess();\n  Integer num1=(Integer)context.get(\"num1\");\n  Integer num2=(Integer)context.get(\"num2\");\n  if (UtilValidate.isEmpty(num1) || UtilValidate.isEmpty(num2)) {\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"ServiceTestXmlRpcMissingParameters\",locale));\n  }\n  Integer res=num1 + num2;\n  response.put(\"resulting\",res);\n  return response;\n}\n", "nl": "Service to receive information from xml-rpc call"}
{"code": "public void startInitialisation(ZWaveNodeInitStage startStage){\n  logger.debug(\"NODE {}: Starting initialisation from {}\",node.getNodeId(),startStage);\n  currentStage=startStage;\n  queryStageTimeStamp=Calendar.getInstance().getTime();\n  retryTimer=BACKOFF_TIMER_START;\n  wakeupCount=0;\n  controller.addEventListener(this);\n  advanceNodeStage(null);\n}\n", "nl": "Start the initialisation from a specific stage"}
{"code": "public final boolean equals(Object obj){\n  if (toString() == null) {\n    return (obj != null) && (obj.toString() == null);\n  }\n  if (obj instanceof Encoding) {\n    return toString().equals(obj.toString());\n  }\n  return false;\n}\n", "nl": "Finalizes the equals method"}
{"code": "private int readAndCompareBytes0Terminated(byte[] key,int keyLength,long pos,ByteFileGetterMappedMemory byteBuffer) throws IOException {\n  int i=0;\n  boolean equal=true;\n  while (true) {\n    final byte b=(byte)byteBuffer.get(pos++);\n    if (b == 0)     break;\n    if (i < keyLength) {\n      if (equal && b != key[i]) {\n        equal=false;\n      }\n    }\n    i++;\n  }\n  return (equal && i == keyLength) ? i : -i;\n}\n", "nl": "read and compare 0-terminated bytes,"}
{"code": "public static final void sendStorageUpdatePacket(Player player,StorageType storageType,Item item,ItemAddType addType){\nswitch (storageType) {\ncase CUBE:\n    PacketSendUtility.sendPacket(player,new SM_INVENTORY_ADD_ITEM(Collections.singletonList(item),player,addType));\n  break;\ncase LEGION_WAREHOUSE:\nif (item.getItemTemplate().isKinah()) {\n  PacketSendUtility.sendPacket(player,new SM_LEGION_EDIT(0x04,player.getLegion()));\n  break;\n}\ndefault :\nPacketSendUtility.sendPacket(player,new SM_WAREHOUSE_ADD_ITEM(item,storageType.getId(),player,addType));\n}\nPacketSendUtility.sendPacket(player,SM_CUBE_UPDATE.cubeSize(storageType,player));\n}\n", "nl": "New item will be displayed in storage"}
{"code": "public static String parseValue(String value,CarbonDimension dimension){\n  try {\nswitch (dimension.getDataType()) {\ncase DECIMAL:\n      return parseStringToBigDecimal(value,dimension);\ndefault :\n    return value;\n}\n}\n catch (Exception e) {\nreturn null;\n}\n}\n", "nl": "This method will parse a value to its datatype if datatype is decimal else will return the value passed"}
{"code": "void applyFacets1(XSFacets facets,short presentFacet,short fixedFacet,short patternType){\n  try {\n    applyFacets(facets,presentFacet,fixedFacet,patternType,fDummyContext);\n  }\n catch (  InvalidDatatypeFacetException e) {\n    throw new RuntimeException(\"internal error\");\n  }\n  fIsImmutable=true;\n}\n", "nl": "built-in derived types by restriction"}
{"code": "public void draw(Canvas c,RectF bounds){\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mPaint.setColor(mColor);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n}\n", "nl": "Draw the progress spinner"}
{"code": "protected T deserialize(HttpServletRequest request) throws IOException {\n  String type=request.getContentType();\n  type=!StringUtils.isEmpty(type) ? type : MediaType.APPLICATION_JSON_VALUE;\n  if (request.getPathInfo().endsWith(\".json\")) {\n    type=MediaType.APPLICATION_JSON_VALUE;\n  }\n else   if (request.getPathInfo().endsWith(\".xml\")) {\n    type=MediaType.APPLICATION_XML_VALUE;\n  }\n  if (isCompatibleWith(type,MediaType.APPLICATION_JSON)) {\n    return renderService.fromJson(request.getInputStream(),getEntityClass());\n  }\n else   if (isCompatibleWith(type,MediaType.APPLICATION_XML)) {\n    return renderService.fromXml(request.getInputStream(),getEntityClass());\n  }\n  return null;\n}\n", "nl": "Deserializes a payload from the request, handles JSON/XML payloads"}
{"code": "public static void embedTree(PhyloTreeView treeView){\n  treeView.removeAllInternalPoints();\n  Node root=treeView.getPhyloTree().getRoot();\n  if (root != null)   computeEmbeddingRec(treeView,root,null,0,0,true);\n  treeView.resetViews();\n  for (Node v=treeView.getPhyloTree().getFirstNode(); v != null; v=v.getNext()) {\n    treeView.setLabel(v,treeView.getPhyloTree().getLabel(v));\n    treeView.setLabelLayout(v,NodeView.EAST);\n  }\n  treeView.trans.setCoordinateRect(treeView.getBBox());\n  treeView.fitGraphToWindow();\n}\n", "nl": "embed the tree"}
{"code": "private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,ContrastMethod contrastMethod){\n  ContrastEnhancement contrastEnhancement=(ContrastEnhancement)styleFactory.contrastEnhancement(null,contrastMethod.name());\n  FilterFactory ff=CommonFactoryFinder.getFilterFactory();\n  Map<String,Expression> options=contrastEnhancement.getOptions();\n  options.put(\"algorithm\",ff.literal(\"StretchToMinimumMaximum\"));\n  options.put(\"minValue\",ff.literal(\"1\"));\n  options.put(\"maxValue\",ff.literal(\"5\"));\n  SelectedChannelType channelType=styleFactory.createSelectedChannelType(\"channel name\",contrastEnhancement);\n  SelectedChannelType[] channels=new SelectedChannelType[3];\n  channels[0]=channelType;\n  channels[1]=channelType;\n  channels[2]=channelType;\n  ChannelSelection channelSelection=styleFactory.createChannelSelection(channels);\n  return channelSelection;\n}\n", "nl": "Creates the channel selection object"}
{"code": "protected void handleSourceTextUnit(ITextUnit textUnit){\n  if (!textUnit.isTranslatable()) {\n    return;\n  }\n  String name=textUnit.getName();\n  String sourceContent=textUnit.getSource().toString();\n  ImportExportNote importExportNote=textUnitUtils.getImportExportNote(textUnit);\n  tmService.addTMTextUnit(asset.getRepository().getTm().getId(),asset.getId(),name,sourceContent,importExportNote.getSourceComment(),importExportNote.getCreatedDate());\n}\n", "nl": "Import source text units into the TM"}
{"code": "@Override public void actionPerformed(ActionEvent event){\n  ImportBlastDialog importBlastDialog=(ImportBlastDialog)getParent();\n  File lastOpenFile;\n  String name=importBlastDialog.getBlastFileName();\n  if (name.length() > 0)   lastOpenFile=new File(Basic.replaceFileSuffix(name,\".rma6\"));\n else   lastOpenFile=new File(ProgramProperties.getFile(MeganProperties.SAVEFILE),\"Untitled.rma6\");\n  File file=ChooseFileDialog.chooseFileToSave(importBlastDialog,lastOpenFile,new RMAFileFilter(),new RMAFileFilter(),event,\"Save MEGAN file\",\".rma6\");\n  if (file != null) {\n    ProgramProperties.put(MeganProperties.SAVEFILE,file);\n    importBlastDialog.setMeganFileName(file.getPath());\n    importBlastDialog.getMeganFileNameField().setText(file.getPath());\n  }\n}\n", "nl": "action to be performed"}
{"code": "private void drawSun(Canvas canvas){\n  final Matrix matrix=mMatrix;\n  matrix.reset();\n  float dragPercent=Math.min(1f,Math.abs(mPercent));\n  final float offsetX=isRefreshing ? mScreenWidth / 2 * (2 - dragPercent) - mSunWidth / 2 : (mScreenWidth * dragPercent - mSunWidth) / 2;\n  final float offsetY=totalDistance * func(dragPercent);\n  matrix.preRotate(mSunRotateAngle == 0.0f ? (360 * dragPercent) : mSunRotateAngle,mSunWidth / 2,mSunHeight / 2);\n  matrix.postTranslate(offsetX,offsetY);\n  canvas.drawBitmap(mSun,matrix,null);\n}\n", "nl": "Draw sun"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"unhide attribute=\");\n  Set<String> attributes=new HashSet<>();\n  while (!np.peekMatchIgnoreCase(\";\")) {\n    String attribute=np.getWordRespectCase();\n    attributes.add(attribute);\n  }\n  np.matchIgnoreCase(\";\");\n  if (attributes.size() > 0) {\n    final SamplesViewer viewer=((SamplesViewer)getViewer());\n    viewer.getSamplesTable().unhideColumns(attributes.toArray(new String[attributes.size()]));\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public boolean matches(EventDescriptor template){\n  if (template == null)   throw new NullPointerException(\"template is null\");\n  boolean matches=false;\n  if (template.eventID == null) {\n    if (template.eventClass == null)     matches=true;\n else     if (this.eventClass != null)     matches=this.eventClass.equals(template.eventClass);\n  }\n else {\n    if (this.eventID != null)     matches=this.eventID.equals(template.eventID);\n  }\n  return (matches);\n}\n", "nl": "Determine whether the provided EventDescriptor matches properties of this EventDescriptor"}
{"code": "public void actionPerformed(ActionEvent ev){\n  ClusterViewer viewer=getViewer();\n  String name=Basic.replaceFileSuffix(((Director)getDir()).getDocument().getMeganFile().getName(),\".nex\");\n  File lastOpenFile=new File(name);\n  String lastDir=ProgramProperties.get(MeganProperties.NETWORK_DIRECTORY,\"\");\n  if (lastDir.length() > 0) {\n    lastOpenFile=new File(lastDir,lastOpenFile.getName());\n  }\n  getDir().notifyLockInput();\n  File file=ChooseFileDialog.chooseFileToSave(viewer.getFrame(),lastOpenFile,new TextFileFilter(),new NexusFileFilter(),ev,\"Save as Nexus file\",\".nexus\");\n  getDir().notifyUnlockInput();\n  if (file != null) {\n    execute(\"export data=distances file='\" + file.getPath() + \"' replace=true;\");\n    ProgramProperties.put(MeganProperties.NETWORK_DIRECTORY,file.getParent());\n  }\n}\n", "nl": "action to be performed"}
{"code": "public void close() throws IOException {\n  if (io != null) {\n    try {\n      io.close();\n    }\n  finally {\n      io=null;\n    }\n  }\n}\n", "nl": "close the readerWriter/writer, if it is open"}
{"code": "@deprecated public LanguageMatcherData cloneAsThawed(){\n  try {\n    LanguageMatcherData result=(LanguageMatcherData)clone();\n    result.languageScores=this.languageScores.cloneAsThawed();\n    result.scriptScores=this.scriptScores.cloneAsThawed();\n    result.regionScores=this.regionScores.cloneAsThawed();\n    result.frozen=false;\n    return result;\n  }\n catch (  CloneNotSupportedException e) {\n    throw new IllegalArgumentException(e);\n  }\n}\n", "nl": "/*    "}
{"code": "protected void processEventSupportedReport(SerialMessage serialMessage,int offset,int endpoint) throws ZWaveSerialMessageException {\n  int notificationType=serialMessage.getMessagePayloadByte(offset + 1);\n  int numBytes=serialMessage.getMessagePayloadByte(offset + 2) & 0x1f;\n  List<Integer> types=new ArrayList<>();\n  for (int i=0; i < numBytes; ++i) {\n    for (int bit=0; bit < 8; ++bit) {\n      if (((serialMessage.getMessagePayloadByte(offset + i + 3)) & (1 << bit)) == 0) {\n        continue;\n      }\n      int index=(i << 3) + bit;\n      types.add(index);\n      getAlarm(notificationType).getReportedEvents().add(index);\n    }\n  }\n  logger.debug(\"NODE {}: AlarmType: {} reported events -> {}\",getNode().getNodeId(),AlarmType.getAlarmType(notificationType),types);\n  eventsSupportedInitialised=true;\n}\n", "nl": "Process EVENT_SUPPORTED_REPORT"}
{"code": "public void testWithScore2() throws Exception {\n  deleteAllDocs();\n  send(\"addDocument\",\"{fields: {text: 'the wind is howling like this swirling storm inside', id: 0, boost: 1.0}}\");\n  send(\"addDocument\",\"{fields: {text: 'I am one with the wind and sky', id: 1, boost: 2.0}}\");\n  send(\"search\",\"{queryText: wind, sort: {fields: [{field: scoreboost, reverse: true}]}, retrieveFields: [id, scoreboost, logboost]}\");\n  assertEquals(2,getInt(\"totalHits\"));\n  assertEquals(1,getInt(\"hits[0].fields.id\"));\n  assertEquals(0,getInt(\"hits[1].fields.id\"));\n  assertEquals(0.861380339f,getFloat(\"hits[0].fields.scoreboost\"),.0001f);\n  assertEquals(0.16823316f,getFloat(\"hits[1].fields.scoreboost\"),.0001f);\n  assertEquals(.6931f,getFloat(\"hits[0].fields.logboost\"),.0001f);\n  assertEquals(0.0f,getFloat(\"hits[1].fields.logboost\"),.0001f);\n}\n", "nl": "Also tries to retrieve the scoreboost"}
{"code": "public void deactivate(){\n  if (!inSelection) {\n    inSelection=true;\n    try {\n      chartSelection.clearSelectionClasses();\n      this.repaint();\n    }\n  finally {\n      inSelection=false;\n    }\n  }\n}\n", "nl": "call this when tab containing list is deactivated"}
{"code": "public void addAll(Iterable<Map.Entry<String,String>> iterable){\n  if (iterable == null) {\n    throw new NullPointerException(\"contexts\");\n  }\nsynchronized (this.contexts) {\n    for (    Map.Entry<String,String> e : iterable) {\n      this.contexts.add(Maps.immutableEntry(e.getKey(),e.getValue()));\n    }\n  }\n}\n", "nl": "Adds an iterable containing contexts to the set"}
{"code": "private int measureLong(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=InfiniteViewPager.FakePositionHelper.getAdapterSize(mViewPager);\n    ;\n    result=(int)(getPaddingLeft() + getPaddingRight() + (count * 2 * mRadius)+ (count - 1) * mRadius + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the width of this view"}
{"code": "public static String convertByteToReadable(long sizeInbyte){\n  String readableSize;\n  if (sizeInbyte < CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR) {\n    readableSize=sizeInbyte + \" Byte\";\n  }\n else   if (sizeInbyte < CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR * CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR) {\n    readableSize=sizeInbyte / CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR + \" KB\";\n  }\n else {\n    readableSize=sizeInbyte / CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR / CarbonCommonConstants.BYTE_TO_KB_CONVERSION_FACTOR + \" MB\";\n  }\n  return readableSize;\n}\n", "nl": "convert number in byte to more readable format"}
{"code": "@Override public void close(){\n  try {\n    if (connection != null) {\n      connection.close();\n    }\n  }\n catch (  SQLException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Close the JDBC connection"}
{"code": "public void invalidateWheel(boolean clearCaches){\n  if (clearCaches) {\n    recycle.clearAll();\n    if (itemsLayout != null) {\n      itemsLayout.removeAllViews();\n    }\n    scrollingOffset=0;\n  }\n else   if (itemsLayout != null) {\n    recycle.recycleItems(itemsLayout,firstItem,new ItemsRange());\n  }\n  invalidate();\n}\n", "nl": "Invalidates wheel"}
{"code": "private static boolean checkKinahForTransportation(TeleportLocation location,Player player){\n  Storage inventory=player.getInventory();\n  int basePrice=location.getPrice();\n  long transportationPrice=PricesService.getPriceForService(basePrice,player.getRace());\n  if (player.getController().isHiPassInEffect()) {\n    transportationPrice=1;\n  }\n  if (!inventory.tryDecreaseKinah(transportationPrice,ItemUpdateType.DEC_KINAH_FLY)) {\n    PacketSendUtility.sendPacket(player,SM_SYSTEM_MESSAGE.STR_MSG_NOT_ENOUGH_KINA(transportationPrice));\n    return false;\n  }\n  return true;\n}\n", "nl": "Check kinah in inventory for teleportation"}
{"code": "protected LuaObject(LuaObject parent,String name) throws LuaException {\nsynchronized (parent.getLuaState()) {\n    this.L=parent.getLuaState();\n    if (!parent.isTable() && !parent.isUserdata()) {\n      throw new LuaException(\"Object parent should be a table or userdata .\");\n    }\n    parent.push();\n    L.pushString(name);\n    L.getTable(-2);\n    L.remove(-2);\n    registerValue(-1);\n    L.pop(1);\n  }\n}\n", "nl": "Creates a reference to an object inside another object"}
{"code": "protected void initErrorReporter(){\n  if (fErrorReporter == null) {\n    fErrorReporter=new XMLErrorReporter();\n  }\n  if (fErrorHandler == null) {\n    fErrorHandler=new XPointerErrorHandler();\n  }\n  fErrorReporter.putMessageFormatter(XPointerMessageFormatter.XPOINTER_DOMAIN,new XPointerMessageFormatter());\n}\n", "nl": "Initializes error handling objects"}
{"code": "private static void init() throws Exception {\n  ve=new VelocityEngine();\n  ve.setProperty(RuntimeConstants.RESOURCE_LOADER,\"classpath\");\n  ve.setProperty(\"classpath.resource.loader.class\",ClasspathResourceLoader.class.getName());\n  ve.setProperty(Velocity.ENCODING_DEFAULT,\"UTF-8\");\n  ve.setProperty(Velocity.INPUT_ENCODING,\"UTF-8\");\n  ve.setProperty(Velocity.OUTPUT_ENCODING,\"UTF-8\");\n  ve.init();\n}\n", "nl": "init velocity"}
{"code": "public boolean isKeyguardLocked(){\n  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {\n    LogUtils.e(\"can not call isKeyguardLocked if SDK_INT < 16 \");\n    return false;\n  }\n else {\n    return keyguardManager.isKeyguardLocked();\n  }\n}\n", "nl": "Call requires API level 16"}
{"code": "public EmailService reconfig(ServerEmailConfig config){\n  this.authRequired=(null != config.getAuthEnabled() && config.getAuthEnabled());\n  Properties javaMailProperties=new Properties();\n  javaMailProperties.put(\"mail.smtp.connectiontimeout\",5000);\n  javaMailProperties.put(\"mail.smtp.auth\",this.authRequired);\n  javaMailProperties.put(\"mail.debug\",config.getDebug());\n  EmailService refreshed=new EmailService(javaMailProperties);\n  refreshed.setTemplateEngine(templateEngine);\n  this.setHost(config.getHost());\n  this.setPort(config.getPort());\n  this.setProtocol(config.getProtocol());\n  if (authRequired) {\n    this.setUsername(config.getUsername());\n    this.setPassword(config.getPassword());\n  }\n  return refreshed;\n}\n", "nl": "Reconfiguration possibility with database properties"}
{"code": "public static Value selectBase(Value val,boolean keepArrayRef){\n  if (val instanceof ArrayRef && !keepArrayRef) {\n    return selectBase(((ArrayRef)val).getBase(),keepArrayRef);\n  }\n  if (val instanceof CastExpr) {\n    return selectBase(((CastExpr)val).getOp(),keepArrayRef);\n  }\n  if (val instanceof UnopExpr)   return selectBase(((UnopExpr)val).getOp(),keepArrayRef);\n  return val;\n}\n", "nl": "the operations that are not relevant for analysis like \"not\" or casts are removed - array refs are only removed if explicitly stated"}
{"code": "public void printResults(){\n  for (  ResultSinkInfo sink : this.results.keySet()) {\n    logger.info(\"Found a flow to sink {}, from the following sources:\",sink);\n    for (    ResultSourceInfo source : this.results.get(sink)) {\n      logger.info(\"\\t- {}\",source.getSource());\n      if (source.getPath() != null && !source.getPath().isEmpty())       logger.info(\"\\t\\ton Path {}\",source.getPath());\n    }\n  }\n}\n", "nl": "Prints all results stored in this object to the standard output"}
{"code": "private <T,S extends ParseTree>T parseQueryFragment(Function<GraqlParser,S> parseRule,BiFunction<QueryVisitor,S,T> visit,GraqlErrorListener errorListener,TokenStream tokens){\n  GraqlParser parser=new GraqlParser(tokens);\n  parser.removeErrorListeners();\n  parser.addErrorListener(errorListener);\n  S tree=parseRule.apply(parser);\n  if (errorListener.hasErrors()) {\n    throw new IllegalArgumentException(errorListener.toString());\n  }\n  return visit.apply(getQueryVisitor(),tree);\n}\n", "nl": "Parse any part of a Graql query"}
{"code": "public final void testOpenInputStream(){\n  FallbackFileController fFileController=new FallbackFileController(PATH);\n  try {\n    fFileController.openFallbackInputStream();\n  }\n catch (  DataFallbackException e) {\n    fail(\"The InputStream could not be opened\");\n  }\n  assertNotNull(fFileController.getInput());\n}\n", "nl": "Tests the OpenInputStream method, the test is successful when the stream is correctly opened"}
{"code": "protected RequestHandle sendRequest(DefaultHttpClient client,HttpContext httpContext,HttpUriRequest uriRequest,String contentType,ResponseHandlerInterface responseHandler,Context context){\n  if (contentType != null) {\n    uriRequest.setHeader(\"Content-Type\",contentType);\n  }\n  responseHandler.setRequestHeaders(uriRequest.getAllHeaders());\n  responseHandler.setRequestURI(uriRequest.getURI());\n  Future<?> request=threadPool.submit(new AsyncHttpRequest(client,httpContext,uriRequest,responseHandler));\n  if (context != null) {\n    List<WeakReference<Future<?>>> requestList=requestMap.get(context);\n    if (requestList == null) {\n      requestList=new LinkedList<WeakReference<Future<?>>>();\n      requestMap.put(context,requestList);\n    }\n    requestList.add(new WeakReference<Future<?>>(request));\n  }\n  return new RequestHandle(request);\n}\n", "nl": "Puts a new request in queue as a new thread in pool to be executed"}
{"code": "private List<CarbonDictionaryColumnMetaChunk> readDictionaryMetadataFile() throws IOException {\n  CarbonDictionaryMetadataReader columnMetadataReaderImpl=getDictionaryMetadataReader();\n  List<CarbonDictionaryColumnMetaChunk> dictionaryMetaChunkList=null;\n  try {\n    dictionaryMetaChunkList=columnMetadataReaderImpl.read();\n  }\n  finally {\n    columnMetadataReaderImpl.close();\n  }\n  return dictionaryMetaChunkList;\n}\n", "nl": "This method will read dictionary metadata file and return the dictionary meta chunks"}
{"code": "private boolean checkNoAcquiredQuests(QuestStateList qsl){\n  if (noacquired != null && noacquired.size() > 0) {\n    for (    Integer questId : noacquired) {\n      QuestState qs=qsl.getQuestState(questId);\n      if (qs != null && (qs.getStatus() == QuestStatus.START || qs.getStatus() == QuestStatus.REWARD)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "nl": "Check, if the player has not acquired listed quests"}
{"code": "public void testUntypedListField() throws Exception {\n  AnObject empty=new AnObject();\n  AnObject full=helper.fill(new AnObject());\n  Object value=getPropertyValue(full,\"untypedListField\");\n  assertTrue(value instanceof List);\n  assertFalse(((List)value).isEmpty());\n  assertEquals(1L,((List)value).get(0));\n  assertTrue(helper.areEquals(full,full));\n  assertFalse(helper.areEquals(empty,full));\n}\n", "nl": "List field should always assigned new list with one elment 1L"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  ChartViewer chartViewer=(ChartViewer)getViewer();\n  LabelsJList list=chartViewer.getActiveLabelsJList();\n  StringBuilder buf=new StringBuilder();\n  int count=list.getSelectedLabels().size();\n  for (  String label : list.getSelectedLabels()) {\n    buf.append(label);\n    if (count > 1)     buf.append(\"\\n\");\n  }\n  if (buf.toString().length() > 0) {\n    StringSelection selection=new StringSelection(buf.toString());\n    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection,null);\n  }\n}\n", "nl": "action to be performed"}
{"code": "@ObjectiveCName(\"unlisten:\") public void unlisten(String pattern){\n  UtilListener listener=listeners.get(pattern);\n  if (listener != null) {\n    listener.destroy();\n    listeners.remove(pattern);\n  }\n else {\n    client.onError(Topic.RECORD,Event.NOT_LISTENING,pattern);\n  }\n}\n", "nl": "Removes a listener that was previously registered with listenForSubscriptions"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  String result=JOptionPane.showInputDialog((getViewer() != null ? getViewer().getFrame() : null),\"Paste MeganServer file URL:\");\n  if (result != null) {\n    if (!result.endsWith(\";\"))     result+=\";\";\n    String[] tokens=result.split(\";\");\n    final StringBuilder buf=new StringBuilder();\n    int count=0;\n    for (    String token : tokens) {\n      final String fileName=token.trim();\n      if (fileName.length() > 0)       buf.append(\"open file='\").append(fileName).append(\"';\");\n      count++;\n    }\n    if (count > 10) {\n      if (JOptionPane.showConfirmDialog(getViewer() != null ? getViewer().getFrame() : null,\"Do you really want to open \" + count + \" new files?\",\"Confirm\",JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION)       return;\n    }\n    execute(buf.toString());\n  }\n}\n", "nl": "action to be performed"}
{"code": "public void waitForConsistentState(){\n  if (isReplicated()) {\n    try {\n      if (shouldFlushPendingReplication())       getReplicationNode().getAdmin().flushPendingReplication(_clusterPolicy.getReplicationPolicy().getAsyncChannelShutdownTimeout(),TimeUnit.MILLISECONDS);\n    }\n catch (    RuntimeException e) {\n      if (_logger.isLoggable(Level.SEVERE))       _logger.log(Level.SEVERE,\"Flush pending replication raised an exception:\",e);\n      throw e;\n    }\n  }\n}\n", "nl": "Wait until the engine is a consistent state, which means it has no pending operations that will be lost when closing the engine"}
{"code": "public static void addElement(Document doc,Element rootElement,String elementName,String typeIn,String isArrayIn,String partitionerIn){\n  Element element=doc.createElement(\"element\");\n  rootElement.appendChild(element);\n  Element name=doc.createElement(\"name\");\n  name.appendChild(doc.createTextNode(elementName));\n  element.appendChild(name);\n  Element type=doc.createElement(\"type\");\n  type.appendChild(doc.createTextNode(typeIn));\n  element.appendChild(type);\n  if (isArrayIn.equals(\"true\")) {\n    element.appendChild(doc.createElement(\"isArray\"));\n  }\n  if (partitionerIn != null) {\n    Element partitioner=doc.createElement(\"partitioner\");\n    partitioner.appendChild(doc.createTextNode(partitionerIn));\n    element.appendChild(partitioner);\n  }\n}\n", "nl": "Helper method to add elements to the test data schema"}
{"code": "public Date calculateEasterForYear(int year){\n  int a=year % 4;\n  int b=year % 7;\n  int c=year % 19;\n  int d=(19 * c + 15) % 30;\n  int e=(2 * a + 4 * b - d + 34) % 7;\n  int month=(int)Math.floor((d + e + 114) / 31);\n  int day=((d + e + 144) % 31) + 1;\n  day++;\n  return Date.on(day,month,year).addDay(13);\n}\n", "nl": "Calculates the date of the easter Sunday for the given year"}
{"code": "public final void testCloseOutputStream(){\n  FallbackFileController fFileController=new FallbackFileController(PATH);\n  try {\n    fFileController.closeFallbackOutputStream();\n  }\n catch (  DataFallbackException e) {\n    fail(\"The OutputStream could not be closed\");\n  }\n  assertNull(fFileController.getOutput());\n}\n", "nl": "Tests the CloseOutputStream method, the test is successful when the stream is correctly closed"}
{"code": "public void useIncense(ItemId type) throws RemoteServerException, LoginFailedException {\n  UseIncenseMessage useIncenseMessage=UseIncenseMessage.newBuilder().setIncenseType(type).setIncenseTypeValue(type.getNumber()).build();\n  ServerRequest useIncenseRequest=new ServerRequest(RequestType.USE_INCENSE,useIncenseMessage);\n  api.getRequestHandler().sendServerRequests(useIncenseRequest);\n  try {\n    UseIncenseResponse response=UseIncenseResponse.parseFrom(useIncenseRequest.getData());\n    Log.i(\"Main\",\"Use incense result: \" + response.getResult());\n  }\n catch (  InvalidProtocolBufferException e) {\n    throw new RemoteServerException(e);\n  }\n}\n", "nl": "use an incense"}
{"code": "public static Location toLocation(ICompilationUnit unit,int offset,int length) throws JavaModelException {\n  Location result=new Location();\n  result.setUri(getFileURI(unit));\n  int[] loc=JsonRpcHelpers.toLine(unit.getBuffer(),offset);\n  int[] endLoc=JsonRpcHelpers.toLine(unit.getBuffer(),offset + length);\n  Range range=new Range();\n  if (loc != null) {\n    range.withStart(new Position().withLine(loc[0]).withCharacter(loc[1]));\n  }\n  if (endLoc != null) {\n    range.withEnd(new Position().withLine(endLoc[0]).withCharacter(endLoc[1]));\n  }\n  return result.withRange(range);\n}\n", "nl": "Creates location to the given offset and length for the compilation unit"}
{"code": "public void paintSelection(Graphics g0){\n  Graphics2D g=(Graphics2D)g0;\n  SelectedBlock selectedBlock=getSelectedBlock();\n  if (selectedBlock.isSelected()) {\n    Rectangle2D rect=new Rectangle2D.Double(Math.max(0,getX(selectedBlock.getFirstCol())),0,0,0);\n    rect.add(Math.min(getX(selectedBlock.getLastCol() + 1),getSize().getWidth()),getSize().height);\n    g.setColor(highlightColorSemiTransparent);\n    g.fill(rect);\n    g.setColor(highlightColor);\n    g.draw(rect);\n  }\n}\n", "nl": "paint the selection rectangle"}
{"code": "private void logIndexed(String repoName,List<String[]> reportList){\n  try {\n    CSVWriter writer=new CSVWriter(new FileWriter(Helpers.getLogPath() + repoName + \".csv.tmp\"));\n    writer.writeAll(reportList);\n    writer.flush();\n    writer.close();\n    Path source=Paths.get(Helpers.getLogPath() + repoName + \".csv.tmp\");\n    Files.move(source,source.resolveSibling(repoName + \".csv\"),StandardCopyOption.REPLACE_EXISTING);\n  }\n catch (  IOException ex) {\n    Singleton.getLogger().warning(\"ERROR - caught a \" + ex.getClass() + \" in \"+ this.getClass()+ \" logIndexed for \"+ repoName+ \"\\n with message: \"+ ex.getMessage());\n  }\n}\n", "nl": "Logs to the logs directory a formatted CSV of the supplied list strings"}
{"code": "public ChangeReport onEquipmentUnitRemove(final EquipmentUnitRemove equipmentUnitRemove){\n  log.debug(\"onEquipmentUnitRemove - entering onEquipmentUnitRemove()..\");\n  ChangeReport changeReport=new ChangeReport(equipmentUnitRemove);\n  changeReport.setState(CHANGE_STATE.SUCCESS);\n  ProcessConfiguration processConfiguration=configurationController.getProcessConfiguration();\n  if (processConfiguration.getEquipmentConfiguration(equipmentUnitRemove.getEquipmentId()) == null) {\n    changeReport.appendError(\"Equipment unit id: \" + equipmentUnitRemove.getEquipmentId() + \" is unknown\");\n    changeReport.setState(CHANGE_STATE.FAIL);\n    return changeReport;\n  }\n  if (!unregisterEquipmentUnit(equipmentUnitRemove.getEquipmentId())) {\n    changeReport.setState(CHANGE_STATE.REBOOT);\n    changeReport.appendWarn(\"problem detected while unregistering equipment id: \" + equipmentUnitRemove.getEquipmentId() + \". You need to restart the DAQ\");\n  }\n  return changeReport;\n}\n", "nl": "Updates the DAQ by removing a whole EquipmentUnit"}
{"code": "public int executeUpdate() throws GenericDataSourceException {\n  try {\n    return _ps.executeUpdate();\n  }\n catch (  SQLException sqle) {\n    this.checkLockWaitInfo(sqle);\n    throw new GenericDataSourceException(\"SQL Exception while executing the following:\" + _sql,sqle);\n  }\n}\n", "nl": "Execute updates"}
{"code": "private static boolean containsOnlyTransientAndStaticFields(List<Field> fields){\n  boolean containsNormalField=false;\n  for (  Field field : fields) {\n    if (!Modifier.isTransient(field.getModifiers()) && !Modifier.isStatic(field.getModifiers())) {\n      containsNormalField=true;\n    }\n  }\n  return !containsNormalField;\n}\n", "nl": "Only contains transient or static fields, which is the case for a model that is empty, but says it \"implements Parcelable\""}
{"code": "private void analyzeMethodForDynamicBroadcastReceiver(SootMethod method){\n  if (!method.isConcrete() || !method.hasActiveBody())   return;\n  for (  Unit u : method.getActiveBody().getUnits()) {\n    Stmt stmt=(Stmt)u;\n    if (stmt.containsInvokeExpr()) {\n      if (stmt.getInvokeExpr().getMethod().getName().equals(\"registerReceiver\") && stmt.getInvokeExpr().getArgCount() > 0 && isInheritedMethod(stmt,\"android.content.ContextWrapper\",\"android.content.Context\")) {\n        Value br=stmt.getInvokeExpr().getArg(0);\n        if (br.getType() instanceof RefType) {\n          RefType rt=(RefType)br.getType();\n          dynamicManifestComponents.add(rt.getClassName());\n        }\n      }\n    }\n  }\n}\n", "nl": "Checks whether the given method dynamically registers a new broadcast receiver"}
{"code": "static void verify(Principal[] principals) throws InvalidObjectException {\n  if (principals == null || principals.length == 0) {\n    throw new InvalidObjectException(\"cannot create constraint with no elements\");\n  }\n  for (int i=principals.length; --i >= 0; ) {\n    Principal p=principals[i];\n    if (p == null) {\n      throw new InvalidObjectException(\"elements cannot be null\");\n    }\n    if (contains(principals,i,p)) {\n      throw new InvalidObjectException(\"cannot create constraint with duplicate elements\");\n    }\n  }\n}\n", "nl": "Verifies that there is at least one element, and that there are no duplicates;"}
{"code": "private static boolean parse(){\n  URLClassLoader cLoader=(URLClassLoader)ManifestParser.class.getClassLoader();\n  try {\n    URL url=cLoader.findResource(\"META-INF/MANIFEST.MF\");\n    manifest=new Manifest(url.openStream());\n    return true;\n  }\n catch (  IOException ex) {\n    ex.printStackTrace();\n    return false;\n  }\n}\n", "nl": "Parses the Manifest File"}
{"code": "private void doScrollX(int delta){\n  if (delta != 0) {\n    if (mSmoothScrollingEnabled) {\n      smoothScrollBy(delta,0);\n    }\n else {\n      scrollBy(delta,0);\n    }\n  }\n}\n", "nl": "Smooth scroll by a X delta"}
{"code": "public static String byteToHexString(byte[] bytes,int start,int end){\n  if (bytes == null) {\n    throw new IllegalArgumentException(\"bytes == null\");\n  }\n  StringBuilder s=new StringBuilder();\n  for (int i=start; i < end; i++) {\n    s.append(String.format(\"%02x\",bytes[i]));\n  }\n  return s.toString();\n}\n", "nl": "Given an array of bytes it will convert the bytes to a hex string representation of the bytes"}
{"code": "public static double sumOfMeanDifferencesOnePoint(double[] vector){\n  double mean=sum(vector) / vector.length;\n  double ret=0;\n  for (int i=0; i < vector.length; i++) {\n    double vec1Diff=Math.pow(vector[i] - mean,2);\n    ret+=vec1Diff;\n  }\n  return ret;\n}\n", "nl": "Used for calculating top part of simple regression for beta 1"}
{"code": "private long parseLong(int start,int end,int radix){\n  long result=0;\n  long digit;\n  for (int i=start; i < end; i++) {\n    digit=Character.digit(yycharat(i),radix);\n    result*=radix;\n    result+=digit;\n  }\n  return result;\n}\n", "nl": "assumes correct representation of a long value for  specified radix in scanner buffer from <code>start</code>  to <code>end</code>"}
{"code": "private static void extractFile(ZipInputStream zipIn,String filePath) throws IOException {\n  BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(filePath));\n  byte[] bytesIn=new byte[BUFFER_SIZE];\n  int read=0;\n  while ((read=zipIn.read(bytesIn)) != -1) {\n    bos.write(bytesIn,0,read);\n  }\n  bos.close();\n}\n", "nl": "Extracts a zip entry (file entry)"}
{"code": "private static int convert(ConstraintWidget.DimensionBehaviour behaviour){\nswitch (behaviour) {\ncase FIXED:\n    return SingleWidgetView.FIXED;\ncase WRAP_CONTENT:\n  return SingleWidgetView.WRAP_CONTENT;\ncase ANY:\nreturn SingleWidgetView.ANY;\n}\nreturn SingleWidgetView.FIXED;\n}\n", "nl": "Convert Any to SingleWidgetView flags"}
{"code": "private InputSplit[] generateDebugSplits(Path input_path,JobConf job){\n  long block_size=localFs.getDefaultBlockSize();\n  System.out.println(\"default block size: \" + (block_size / 1024 / 1024) + \"MB\");\n  FileInputFormat.setInputPaths(job,input_path);\n  TextInputFormat format=new TextInputFormat();\n  format.configure(job);\n  int numSplits=1;\n  InputSplit[] splits=null;\n  try {\n    splits=format.getSplits(job,numSplits);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n  return splits;\n}\n", "nl": "generate splits for this run"}
{"code": "public static Sample loadBinary(ByteBuffer bb) throws IOException {\n  int frameDataSize=bb.getInt();\n  short[] frameData=new short[frameDataSize];\n  for (int i=0; i < frameData.length; i++) {\n    frameData[i]=bb.getShort();\n  }\n  int residualDataSize=bb.getInt();\n  byte[] residualData=new byte[residualDataSize];\n  for (int i=0; i < residualData.length; i++) {\n    residualData[i]=bb.get();\n  }\n  return new Sample(frameData,residualData,residualDataSize);\n}\n", "nl": "Loads the samples from the byte bufer"}
{"code": "private void updateTexts(DocumentEvent e){\n  Document doc=e.getDocument();\n  if (doc == projectNameTextField.getDocument() || doc == projectLocationTextField.getDocument()) {\n    String projectName=projectNameTextField.getText();\n    String projectFolder=projectLocationTextField.getText();\n    createdFolderTextField.setText(projectFolder + File.separatorChar + projectName);\n  }\n  panel.fireChangeEvent();\n}\n", "nl": "Handles changes in the Project name and project directory,"}
{"code": "public String toString(){\n  StringBuilder builder=new StringBuilder();\n  Set<Map.Entry<String,TableOption>> entries=mapOFOptions.entrySet();\n  Iterator<Map.Entry<String,TableOption>> iterator=entries.iterator();\n  while (iterator.hasNext()) {\n    Map.Entry<String,TableOption> entry=iterator.next();\n    builder.append(entry.getValue().toString());\n    builder.append(CarbonCommonConstants.HASH_SPC_CHARACTER);\n  }\n  return builder.toString();\n}\n", "nl": "return the string object"}
{"code": "private static int readCode(boolean[] rawbits,int startIndex,int length){\n  int res=0;\n  for (int i=startIndex; i < startIndex + length; i++) {\n    res<<=1;\n    if (rawbits[i]) {\n      res|=0x01;\n    }\n  }\n  return res;\n}\n", "nl": "Reads a code of given length and at given index in an array of bits"}
{"code": "public static List<String> splitPath(File file){\n  List<String> output=new ArrayList<>();\n  File current=file;\n  while (current != null) {\n    output.add(current.getName());\n    current=current.getParentFile();\n  }\n  Collections.reverse(output);\n  return output;\n}\n", "nl": "Split a file into a list of directories ending with the file name"}
{"code": "private static int snapHorizontal(Collection<ConstraintWidget> widgets,ConstraintWidget widget,ConstraintAnchor anchor,int position,ArrayList<SnapCandidate> snapCandidates){\n  SnapCandidate candidate=new SnapCandidate();\n  ConstraintHandle handle=WidgetInteractionTargets.constraintHandle(anchor);\n  handle.setDrawX(position);\n  SnapPlacement.snapAnchor(widgets,widget,anchor,candidate);\n  if (candidate.target != null) {\n    ConstraintHandle targetHandle=WidgetInteractionTargets.constraintHandle(candidate.target);\n    int tx=candidate.x;\n    if (targetHandle != null) {\n      tx=targetHandle.getDrawX();\n    }\n    position=tx + candidate.margin;\n    snapCandidates.add(candidate);\n  }\n  return position;\n}\n", "nl": "Utility function to gather snap candidates on the horizontal axis"}
{"code": "public static byte[] copyBytes(byte[] source,byte[] target,int position){\n  byte[] newBytes=new byte[target.length + source.length];\n  for (int i=0, n=0, x=0; i < newBytes.length; i++) {\n    if (i < position || i > (position + source.length - 2)) {\n      newBytes[i]=target[n];\n      n++;\n    }\n else {\n      for (; x < source.length; x++) {\n        newBytes[i]=source[x];\n        if (source.length - 1 > x) {\n          i++;\n        }\n      }\n    }\n  }\n  return newBytes;\n}\n", "nl": "Copies a byte[] into another byte[] starting at a specific position"}
{"code": "public void draw(Canvas c,Rect bounds){\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mPaint.setColor(mCurrentColor);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n  if (mAlpha < 255) {\n    mCirclePaint.setColor(mBackgroundColor);\n    mCirclePaint.setAlpha(255 - mAlpha);\n    c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  }\n}\n", "nl": "Draw the progress spinner"}
{"code": "private void loadTextData(DataInputStream dis) throws IOException {\n  for (int f=0; f < numFrames; f++) {\n    times[f]=Float.parseFloat(General.readWord(dis));\n    General.readWord(dis);\n    for (int c=0; c < numChannels; c++) {\n      frames[f][c]=Float.parseFloat(General.readWord(dis));\n    }\n  }\n}\n", "nl": "load the data section of the file as ascii text"}
{"code": "private void registerTaskInstances(){\n  for (  TaskFromDBTrigger trigger : tasksList) {\n    if (trigger.isValid()) {\n      trigger.initTrigger();\n    }\n else {\n      log.error(\"Cannot load task from db with ID: \" + trigger.getTaskId());\n    }\n  }\n}\n", "nl": "Launching & checking task process"}
{"code": "private void init() throws IOException {\n  initDictionaryChunkSize();\n  initPaths();\n  boolean dictFileExists=CarbonUtil.isFileExists(this.dictionaryFilePath);\n  if (dictFileExists && CarbonUtil.isFileExists(this.dictionaryMetaFilePath)) {\n    this.chunk_start_offset=CarbonUtil.getFileSize(this.dictionaryFilePath);\n    validateDictionaryFileOffsetWithLastSegmentEntryOffset();\n  }\n else   if (dictFileExists) {\n    FileFactory.getCarbonFile(dictionaryFilePath,FileFactory.getFileType(dictionaryFilePath)).delete();\n  }\n  openThriftWriter(this.dictionaryFilePath);\n  createChunkList();\n}\n", "nl": "This method will check and created the directory path where dictionary file has to be created"}
{"code": "public void testIsRJavaFileImportedNoManifest() throws Exception {\n  Module libModule=myAdditionalModules.get(0);\n  deleteManifest(libModule);\n  myFixture.copyFileToProject(\"util/lib/AndroidManifest.xml\",\"additionalModules/lib/AndroidManifest.xml\");\n  VirtualFile libRFile=myFixture.copyFileToProject(\"util/lib/R.java\",\"additionalModules/lib/gen/p1/p2/lib/R.java\");\n  myFixture.copyFileToProject(\"util/lib/strings.xml\",\"additionalModules/lib/res/values/strings.xml\");\n  deleteManifest(myModule);\n  PsiField[] mainFields=AndroidResourceUtil.findResourceFields(AndroidFacet.getInstance(myModule),\"string\",\"lib_hello\",false);\n  assertEmpty(mainFields);\n  PsiManager psiManager=PsiManager.getInstance(getProject());\n  PsiFile libRClassFile=psiManager.findFile(libRFile);\n  assertNotNull(libRClassFile);\n  assertTrue(AndroidResourceUtil.isRJavaFile(myFacet,libRClassFile));\n}\n", "nl": "Tests that a module without an Android Manifest can still import a lib's R class"}
{"code": "public void save(File file,boolean append) throws IOException {\n  try (DataOutputStream outs=new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file,append)))){\n    outs.writeInt(MAGIC_NUMBER);\n    outs.writeBoolean(m_hasFreeKey);\n    outs.writeInt(m_freeValue);\n    outs.writeFloat(m_fillFactor);\n    outs.writeInt(m_threshold);\n    outs.writeInt(m_size);\n    outs.writeInt(m_mask);\n    outs.writeInt(m_mask2);\n    outs.writeInt(m_data.length);\n    for (    int a : m_data)     outs.writeInt(a);\n  }\n }\n", "nl": "save to file"}
{"code": "public void dragComponent(@AndroidCoordinate int x,@AndroidCoordinate int y){\n  if (myDragDropWidget == null) {\n    return;\n  }\n  int ax=pxToDp(x);\n  int ay=pxToDp(y);\n  myDragDropWidget.setX(ax);\n  myDragDropWidget.setY(ay);\n  myDragDropWidget.forceUpdateDrawPosition();\n  for (  DrawConstraintModel drawConstraintModel : getDrawConstraintModels()) {\n    drawConstraintModel.getMouseInteraction().dragAndDrop(myDragDropWidget,ax,ay);\n  }\n}\n", "nl": "Drag the current drag'n drop widget"}
{"code": "public String parse(String str,Model m){\n  try {\n    str=VEngine.parse(str,m.context);\n  }\n catch (  Exception e) {\n    log.error(str,e);\n  }\n  return str;\n}\n", "nl": "Parses the string with the model using velocity engine"}
{"code": "public void performRankingUpdate(Map<Integer,Integer> legionRanking){\n  log.info(\"Legion ranking update task started\");\n  long startTime=System.currentTimeMillis();\n  Iterator<Legion> legionsIterator=allCachedLegions.iterator();\n  int legionsUpdated=0;\n  this.legionRanking=legionRanking;\n  while (legionsIterator.hasNext()) {\n    Legion legion=legionsIterator.next();\n    if (legionRanking.containsKey(legion.getLegionId())) {\n      legion.setLegionRank(legionRanking.get(legion.getLegionId()));\n      PacketSendUtility.broadcastPacketToLegion(legion,new SM_LEGION_EDIT(0x01,legion));\n    }\n    legionsUpdated++;\n  }\n  long workTime=System.currentTimeMillis() - startTime;\n  log.info(\"Legion ranking update: \" + workTime + \" ms, legions: \"+ legionsUpdated);\n}\n", "nl": "This method will set the legion ranking if needed"}
{"code": "@Deployment public void testEventBasedGateway(){\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"catchSignal\");\n  Execution waitingExecution=runtimeService.createExecutionQuery().signalEventSubscriptionName(\"alert\").singleResult();\n  assertNotNull(waitingExecution);\n  runtimeService.signalEventReceived(\"alert\",waitingExecution.getId());\n  assertEquals(0L,runtimeService.createProcessInstanceQuery().processInstanceId(processInstance.getId()).count());\n  HistoricActivityInstance historicActivityInstance=historyService.createHistoricActivityInstanceQuery().activityId(\"eventBasedgateway\").processInstanceId(processInstance.getId()).singleResult();\n  assertNotNull(historicActivityInstance);\n}\n", "nl": "Test to validate fix for ACT-1399: Boundary-event and event-based auditing"}
{"code": "public CartPaymentInfo makePaymentInfo(String id,String refNum,BigDecimal amount){\n  CartPaymentInfo inf=new CartPaymentInfo();\n  inf.refNum[0]=refNum;\n  inf.amount=amount;\n  inf.origAmount=amount;\n  if (!isPaymentMethodType(id)) {\n    inf.paymentMethodTypeId=this.getPaymentMethodTypeId(id);\n    inf.paymentMethodId=id;\n  }\n else {\n    inf.paymentMethodTypeId=id;\n  }\n  return inf;\n}\n", "nl": "Creates a CartPaymentInfo object"}
{"code": "@Deployment(resources={\"org/activiti/engine/test/history/oneTaskProcess.bpmn20.xml\"}) public void testQueryHistoricProcessInstanceIncludeBinaryVariable() throws Exception {\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"oneTaskProcess\",Collections.singletonMap(\"binaryVariable\",(Object)\"It is I, le binary\".getBytes()));\n  Task task=taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();\n  assertNotNull(task);\n  taskService.complete(task.getId());\n  HistoricProcessInstance historicProcess=historyService.createHistoricProcessInstanceQuery().processInstanceId(processInstance.getId()).includeProcessVariables().singleResult();\n  assertNotNull(historicProcess);\n  assertNotNull(historicProcess.getProcessVariables());\n  byte[] bytes=(byte[])historicProcess.getProcessVariables().get(\"binaryVariable\");\n  assertEquals(\"It is I, le binary\",new String(bytes));\n}\n", "nl": "Test confirming fix for ACT-1731"}
{"code": "public void afterLast() throws GenericEntityException {\n  try {\n    resultSet.afterLast();\n  }\n catch (  SQLException e) {\n    if (!closed) {\n      this.close();\n      Debug.logWarning(\"Warning: auto-closed EntityListIterator because of exception: \" + e.toString(),module);\n    }\n    throw new GenericEntityException(\"Error setting the cursor to afterLast\",e);\n  }\n}\n", "nl": "Sets the cursor position to just after the last result so that previous() will return the last result"}
{"code": "@Override public CompletableFuture<Void> doUnsubscribe(Consumer consumer){\n  CompletableFuture<Void> future=new CompletableFuture<>();\n  try {\n    if (dispatcher.canUnsubscribe(consumer)) {\n      consumer.close();\n      return delete();\n    }\n    future.completeExceptionally(new ServerMetadataException(\"Unconnected or shared consumer attempting to unsubscribe\"));\n  }\n catch (  BrokerServiceException e) {\n    log.warn(\"Error removing consumer {}\",consumer);\n    future.completeExceptionally(e);\n  }\n  return future;\n}\n", "nl": "Handle unsubscribe command from the client API Check with the dispatcher is this consumer can proceed with unsubscribe"}
{"code": "public static String[] toArray(String arg){\n  if (arg == null) {\n    return new String[0];\n  }\n  StringTokenizer tok=new StringTokenizer(arg,\" ,\");\n  String[] array=new String[tok.countTokens()];\n  int i=0;\n  while (tok.hasMoreTokens()) {\n    array[i]=tok.nextToken();\n    i++;\n  }\n  return (array);\n}\n", "nl": "Convert comma delimited and/or space String to array of Strings"}
{"code": "private void generateHelpText(){\n  String filename=\"resources/files/attributehelp.txt\";\n  helpText=new StringBuilder(3000);\n  try {\n    String line;\n    BufferedReader br=new BufferedReader(new FileReader(filename));\n    while (true) {\n      line=br.readLine();\n      if (line == null)       break;\n      helpText.append(line);\n    }\n  }\n catch (  IOException e1) {\n    System.out.println(\"Could not find/parse \" + filename);\n    e1.printStackTrace();\n  }\n}\n", "nl": "Reads in the html page with infos on the ncbi attributes"}
{"code": "public MonsterToArenaCursor queryMonsterToArenaMonster(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=true;\n  qh.Table=S.TABLE_MONSTER_TO_ARENA;\n  qh.Columns=null;\n  qh.Selection=\"mta.\" + S.COLUMN_MONSTER_TO_ARENA_MONSTER_ID + \" = ? \";\n  qh.SelectionArgs=new String[]{\"\" + id};\n  qh.GroupBy=\"a.\" + S.COLUMN_ARENA_QUESTS_NAME;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new MonsterToArenaCursor(wrapJoinHelper(builderMonsterToArena(qh.Distinct),qh));\n}\n", "nl": "****************************** MONSTER TO ARENA QUERIES"}
{"code": "public AdsGetDemographicsQuery(VkApiClient client,UserActor actor,int accountId,AdsGetDemographicsIdsType idsType,String ids,String period,String dateFrom,String dateTo){\n  super(client,\"ads.getDemographics\",Utils.buildParametrizedType(List.class,DemoStats.class));\n  accessToken(actor.getAccessToken());\n  accountId(accountId);\n  idsType(idsType);\n  ids(ids);\n  period(period);\n  dateFrom(dateFrom);\n  dateTo(dateTo);\n}\n", "nl": "Creates a AbstractQueryBuilder instance that can be used to build api request with various parameters"}
{"code": "public static void deleteESInput(){\n  String esPIRIndex=SystemConfiguration.getProperty(DistributedTestDriver.ES_INPUT_NODES_PROPERTY) + \":\" + SystemConfiguration.getProperty(DistributedTestDriver.ES_INPUT_PORT_PROPERTY)+ \"/\"+ SystemConfiguration.getProperty(DistributedTestDriver.ES_INPUT_INDEX_PROPERTY);\n  logger.info(\"ES input being deleted at \" + esPIRIndex);\n  ProcessBuilder pDeletePIR=new ProcessBuilder(\"curl\",\"-XDELETE\",esPIRIndex);\n  try {\n    TestUtils.executeCommand(pDeletePIR);\n    logger.info(\"ES input deleted!\");\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Delete the ElasticSearch indices that was used for functional testing"}
{"code": "@deprecated protected int writeDeltaTo(int jumpTarget){\n  int i=this.charsLength - jumpTarget;\n  assert (i >= 0);\n  if (i <= 64511)   return write(i);\n  int length;\n  int length;\n  if (i <= 67043327) {\n    this.intUnits[0]=((char)(64512 + (i >> 16)));\n    length=1;\n  }\n else {\n    this.intUnits[0]=65535;\n    this.intUnits[1]=((char)(i >> 16));\n    length=2;\n  }\n  this.intUnits[(length++)]=((char)i);\n  return write(this.intUnits,length);\n}\n", "nl": "/*    "}
{"code": "protected static void addSourceFileTag(SootClass sc,String fileName){\n  soot.tagkit.SourceFileTag tag=null;\n  if (sc.hasTag(\"SourceFileTag\")) {\n    return;\n  }\n else {\n    tag=new soot.tagkit.SourceFileTag();\n    sc.addTag(tag);\n  }\n  tag.setSourceFile(fileName);\n}\n", "nl": "adds source file tag to each sootclass"}
{"code": "private boolean checkCameraHardware(Context context){\n  if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)) {\n    return true;\n  }\n else   if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA_FRONT)) {\n    return true;\n  }\n else   if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Check if this device has a camera"}
{"code": "@EventHandler(priority=EventPriority.LOW,ignoreCancelled=true) public void onBlockExplode(BlockExplodeEvent event){\n  List<Block> blocks=event.blockList();\n  if (blocks.isEmpty())   return;\n  BlockPos pos=plugin.blockPos(blocks.get(0));\n  ClaimedChunk chunk=plugin.mineCity.provideChunk(pos.getChunk());\n  for (Iterator<Block> iter=blocks.iterator(); iter.hasNext(); ) {\n    Block block=iter.next();\n    BlockPos blockPos=plugin.blockPos(pos,block);\n    ClaimedChunk claim=plugin.mineCity.provideChunk(blockPos.getChunk(),chunk);\n    if (claim.reserve || claim.owner instanceof Nature) {\n      if (blockPos.y >= 40)       iter.remove();\n    }\n else {\n      iter.remove();\n    }\n  }\n}\n", "nl": "BlockExplodeEvent is fired when an explosion happens with an unknown case"}
{"code": "public static void mgc2mgc(double c1[],int m1,double a1,double g1,double c2[],int m2,double a2,double g2){\n  if (a1 == a2) {\n    gnorm(c1,c1,m1,g1);\n    gc2gc(c1,m1,g1,c2,m2,g2);\n    ignorm(c2,c2,m2,g2);\n  }\n else {\n    double a=(a2 - a1) / (1 - a1 * a2);\n    freqt(c1,m1,c2,m2,a);\n    gnorm(c2,c2,m2,g1);\n    gc2gc(c2,m2,g1,c2,m2,g2);\n    ignorm(c2,c2,m2,g2);\n  }\n}\n", "nl": "mgc2mgc: frequency and generalized cepstral transformation"}
{"code": "private void updateStatusBar(){\n  SampleAttributeTable sampleAttributeTable=doc.getSampleAttributeTable();\n  String message=\"Samples=\" + sampleAttributeTable.getNumberOfSamples();\n  message+=\" Attributes=\" + sampleAttributeTable.getNumberOfUnhiddenAttributes();\n  if (getSamplesTable().getNumberOfSelectedSamples() > 0 || getSamplesTable().getNumberOfSelectedCols() > 0) {\n    message+=\" (Selection: \" + getSamplesTable().getNumberOfSelectedSamples() + \" samples, \"+ getSamplesTable().getNumberOfSelectedCols()+ \" attributes)\";\n  }\n  statusbar.setText2(message);\n}\n", "nl": "rescan the status bar"}
{"code": "@Nullable private static Message findRootCause(@NotNull String text,@NotNull Collection<Message> messages){\n  for (  Message message : messages) {\n    if (message.getKind() != Message.Kind.INFO && message.getText().contains(text)) {\n      if (message.getSourceFilePositions().isEmpty()) {\n        return message;\n      }\n    }\n  }\n  int index=text.indexOf(':');\n  if (index != -1 && index < text.length() - 1) {\n    return findRootCause(text.substring(index + 1).trim(),messages);\n  }\n  return null;\n}\n", "nl": "Looks through the existing errors and attempts to find one that has the same root cause"}
{"code": "public SiteAdminPage movePage(String title,String destinationPath){\n  grid.selectPageByTitle(title);\n  grid.getActionBar().clickOnButton(SiteAdminButtons.MOVE,movePageWindow);\n  movePageWindow.typeDestinationPath(destinationPath);\n  movePageWindow.confirm();\n  clickYesOnConfirmationWindow();\n  grid.waitForLoaderNotPresent();\n  return this;\n}\n", "nl": "Moves the page with provided title to provided destination path by selecting it and pressing Move button on Action Bar"}
{"code": "public boolean filterOut(final SAMRecord record){\n  if (include) {\n    if (record.getReadFailsVendorQualityCheckFlag()) {\n      return false;\n    }\n  }\n else {\n    if (!record.getReadFailsVendorQualityCheckFlag()) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "private Date parseDate(String date){\n  try {\n    return DateFormat.getDateInstance(DateFormat.SHORT).parse(date);\n  }\n catch (  ParseException e) {\n    MessageDialog.openError(getShell(),Messages.FilterRevisionsDialog_dateParseErrorTitle,Messages.FilterRevisionsDialog_dateParseErrorMessage);\n    return null;\n  }\n}\n", "nl": "Parses a date in a string to a Date"}
{"code": "public static void f(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_FATAL) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.wtf(tag,msg);\n}\n", "nl": "Send a FATAL ERROR log message"}
{"code": "public static <T extends Bean>T load(Bson query,Class<T> t){\n  String collection=getCollection(t);\n  if (collection != null) {\n    try {\n      T obj=t.newInstance();\n      return load(query,null,obj);\n    }\n catch (    Exception e) {\n      if (log.isErrorEnabled())       log.error(e.getMessage(),e);\n    }\n  }\n  return null;\n}\n", "nl": "load the data by the query"}
{"code": "private void dismiss(){\n  preferencesManager.setDisplayed(usageId);\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n    if (isRevealAnimationEnabled)     exitRevealAnimation();\n else     startFadeout();\n  }\n else {\n    startFadeout();\n  }\n}\n", "nl": "Dissmiss view with reverse animation"}
{"code": "public static Result verify(String sid,String code){\n  String id=\"//captcha/\" + sid;\n  Code c=(Code)Cache.get(id);\n  if (c == null) {\n    log.warn(\"no code in cache, sid=\" + sid);\n    return Result.badcode;\n  }\n else   if (!X.isSame(code,c.code)) {\n    log.warn(\"is not same, code.server=\" + c.code + \", code.client=\"+ code);\n    return Result.badcode;\n  }\n else   if (c.expired < System.currentTimeMillis()) {\n    log.warn(\"expired, expired=\" + c.expired);\n    return Result.expired;\n  }\n  return Result.ok;\n}\n", "nl": "verify the code associated"}
{"code": "public void add(RemoteEventBusPacket packet){\n  OperationID id=packet.getStatus().getOperationId();\n  ConcurrentHashSet<RemoteEventBusPacket> outgoingEventsForOperation=_outgoingEvents.get(id);\n  if (outgoingEventsForOperation == null) {\n    outgoingEventsForOperation=new ConcurrentHashSet<RemoteEventBusPacket>();\n    ConcurrentHashSet<RemoteEventBusPacket> previous=_outgoingEvents.putIfAbsent(id,outgoingEventsForOperation);\n    if (previous != null)     outgoingEventsForOperation=previous;\n  }\n  outgoingEventsForOperation.add(packet);\n}\n", "nl": "Stored  notify events that were generated by replication only on backup"}
{"code": "public void requestRemoveNodesStart(){\n  if (exclusion == true || inclusion == true) {\n    logger.debug(\"ZWave exclusion already in progress - aborted\");\n    return;\n  }\n  enqueue(new RemoveNodeMessageClass().doRequestStart());\n  exclusion=true;\n  startInclusionTimer();\n  logger.debug(\"ZWave controller start exclusion\");\n}\n", "nl": "Puts the controller into exclusion mode to remove new nodes"}
{"code": "public int prepareAndCommit(TransactionManager mgr,ServerTransaction st,OperationID operationID) throws UnknownTransactionException, RemoteException {\n  if (_operationLogger.isLoggable(Level.FINEST))   _operationLogger.finest(\"preparing and committing transaction [\" + createTransactionDetailsString(st,operationID) + \"]\");\n  int result;\n  if (isExecutedAlready(operationID)) {\n    handleDuplicateCommitOperation(st,operationID);\n    result=TransactionConstants.COMMITTED;\n  }\n else {\n    result=prepare(mgr,st,true,false,operationID);\n    if (result == TransactionConstants.PREPARED) {\n      commitSA(mgr,st,false,null,true);\n      result=TransactionConstants.COMMITTED;\n    }\n  }\n  if (_operationLogger.isLoggable(Level.FINEST))   _operationLogger.finest(\"prepared and committed transaction [\" + createTransactionDetailsString(st,operationID) + \"] result=\"+ result);\n  return result;\n}\n", "nl": "Prepare and commit the transaction - called for single participant transaction or transaction without changes"}
{"code": "public void addToBreakList(String labelBroken,DavaFlowSet<T> set){\n  List<DavaFlowSet<T>> labelsBreakList=breakList.get(labelBroken);\n  if (labelsBreakList == null) {\n    labelsBreakList=new ArrayList<DavaFlowSet<T>>();\n    labelsBreakList.add(set);\n    breakList.put(labelBroken,labelsBreakList);\n  }\n else {\n    breakList.put(labelBroken,addIfNotDuplicate(labelsBreakList,set));\n  }\n}\n", "nl": "When an explicit break statement is encountered this method should be called to store the current davaflowset"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"select series=\");\n  List<String> list=np.getTokensRespectCase(null,\";\");\n  ChartViewer viewer=(ChartViewer)getViewer();\n  for (  String name : list) {\n    if (name.equalsIgnoreCase(\"all\"))     viewer.getChartSelection().setSelectedSeries(viewer.getChartData().getSeriesNames(),true);\n else     if (name.equalsIgnoreCase(\"none\"))     viewer.getChartSelection().setSelectedSeries(viewer.getChartData().getSeriesNames(),false);\n else     viewer.getChartSelection().setSelectedSeries(name,true);\n  }\n  viewer.repaint();\n}\n", "nl": "parses the given command and executes it"}
{"code": "public void activate(){\n  getViewer().getSearchManager().setSearcher(getSearcher());\n  getViewer().getSearchManager().getFindDialogAsToolBar().clearMessage();\n  if (!inSelection) {\n    inSelection=true;\n    try {\n      chartSelection.clearSelectionSeries();\n      chartSelection.setSelectedSeries(getSelectedLabels(),true);\n      this.repaint();\n    }\n  finally {\n      inSelection=false;\n    }\n  }\n}\n", "nl": "call this when tab containing list is activated"}
{"code": "public static void f(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_FATAL) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.wtf(tag,msg);\n}\n", "nl": "Send a FATAL ERROR log message"}
{"code": "@RequestMapping(value=\"/user/login\",method=RequestMethod.POST,headers={\"Accept=application/json; charset=UTF-8\",\"Content-Type=application/json\"}) public RespJson userLogin(@RequestBody LoginReqDto reqDto){\n  if (reqDto == null || StringUtils.isEmpty(reqDto.getUserId()) || StringUtils.isEmpty(reqDto.getPassword())) {\n    return RespJson.buildFailureResponse(ERR_ID_PASSWORD_EMPTY);\n  }\n  try {\n    LoginResDto resDto=userService.login(reqDto);\n    return RespJson.buildSuccessResponse(resDto);\n  }\n catch (  Exception e) {\n    logger.error(\"Login Failed: \" + StringUtils.getValidString(e.getMessage()));\n    return RespJson.buildFailureResponse(StringUtils.getValidString(e.getMessage()));\n  }\n}\n", "nl": "User login api"}
{"code": "public Matrix minusEquals(Matrix B){\n  checkMatrixDimensions(B);\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      A[i][j]=A[i][j] - B.A[i][j];\n    }\n  }\n  return this;\n}\n", "nl": "A = A - B"}
{"code": "@Override public void actionPerformed(ActionEvent event){\n  final ImportBlastDialog importBlastDialog=(ImportBlastDialog)getParent();\n  final File lastOpenFile=ProgramProperties.getFile(MeganProperties.BLASTFILE);\n  final DAAFileFilter fileFilter=new DAAFileFilter();\n  java.util.List<File> files=ChooseFileDialog.chooseFilesToOpen(importBlastDialog,lastOpenFile,fileFilter,fileFilter,event,\"Open Diamond DAA file(s)\");\n  if (files.size() > 0) {\n    importBlastDialog.setBlastFileName(Basic.toString(files,\"\\n\"));\n    importBlastDialog.getBlastFileNameField().setText(Basic.toString(files,\"\\n\"));\n    ProgramProperties.put(MeganProperties.BLASTFILE,files.get(0));\n  }\n}\n", "nl": "action to be performed"}
{"code": "private void calculateOptimalWidthAndHeight(){\n  if (state == State.DEFAULT || getWidth() == 0) {\n    return;\n  }\n  float maxWidth=getWidth(), maxHeight=getHeight();\n  float w=pageWidth, h=pageHeight;\n  float ratio=w / h;\n  w=maxWidth;\n  h=(float)Math.floor(maxWidth / ratio);\n  if (h > maxHeight) {\n    h=maxHeight;\n    w=(float)Math.floor(maxHeight * ratio);\n  }\n  optimalPageWidth=w;\n  optimalPageHeight=h;\n}\n", "nl": "Calculate the optimal width and height of a page considering the area width and height"}
{"code": "public List<ShoppingCartItem> findAllCartItems(String productId,String groupNumber){\n  if (productId == null)   return this.items();\n  List<ShoppingCartItem> itemsToReturn=FastList.newInstance();\n  for (  ShoppingCartItem cartItem : cartLines) {\n    if (UtilValidate.isNotEmpty(groupNumber) && !cartItem.isInItemGroup(groupNumber)) {\n      continue;\n    }\n    if (productId.equals(cartItem.getProductId())) {\n      itemsToReturn.add(cartItem);\n    }\n  }\n  return itemsToReturn;\n}\n", "nl": "Get all ShoppingCartItems from the cart object with the given productId and optional groupNumber to limit it to a specific item group"}
{"code": "public WishlistDataCursor queryWishlistsData(){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=false;\n  qh.Table=S.TABLE_WISHLIST_DATA;\n  qh.Columns=null;\n  qh.Selection=null;\n  qh.SelectionArgs=null;\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  SQLiteQueryBuilder qb=builderWishlistData();\n  Cursor cursor=qb.query(getWritableDatabase(),qh.Columns,qh.Selection,qh.SelectionArgs,qh.GroupBy,qh.Having,qh.OrderBy,qh.Limit);\n  return new WishlistDataCursor(cursor);\n}\n", "nl": "****************************** WISHLIST DATA QUERIES"}
{"code": "public static Bitmap toRoundCorner(Bitmap bitmap){\n  int height=bitmap.getHeight();\n  int width=bitmap.getHeight();\n  Bitmap output=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);\n  Canvas canvas=new Canvas(output);\n  final Paint paint=new Paint();\n  final Rect rect=new Rect(0,0,width,height);\n  paint.setAntiAlias(true);\n  canvas.drawARGB(0,0,0,0);\n  paint.setColor(0xff424242);\n  canvas.drawCircle(width / 2,height / 2,width / 2,paint);\n  paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n  canvas.drawBitmap(bitmap,rect,rect,paint);\n  return output;\n}\n", "nl": "convert Bitmap to round corner"}
{"code": "public static void drawRect(Graphics2D gc,double x,double y,double width,double height,double labelAngle){\n  Dimension theSize=new Dimension((int)Math.round(width),(int)Math.round(height));\n  Point2D apt=new Point2D.Float((float)x,(float)y);\n  AffineTransform saveTransform=gc.getTransform();\n  if (labelAngle >= 0.5 * Math.PI && labelAngle <= 1.5 * Math.PI) {\n    apt=Geometry.translateByAngle(apt,labelAngle,theSize.getWidth());\n    gc.rotate(Geometry.moduloTwoPI(labelAngle - Math.PI),apt.getX(),apt.getY());\n  }\n else {\n    gc.rotate(labelAngle,apt.getX(),apt.getY());\n  }\n  gc.drawRect((int)Math.round(apt.getX()),(int)Math.round(apt.getY()) - theSize.height,theSize.width,theSize.height);\n  gc.setTransform(saveTransform);\n}\n", "nl": "draw a rectangle at the given anchor point at the given angle (in radiant)"}
{"code": "public static ILogEntry[] createLogEntriesFrom(ISVNRemoteFile remoteFile,ISVNLogMessage[] logMessages,Tags[] tags,SVNUrl[] urls){\n  ILogEntry[] result=new ILogEntry[logMessages.length];\n  for (int i=0; i < logMessages.length; i++) {\n    ISVNLogMessage logMessage=logMessages[i];\n    ISVNRemoteResource correspondingResource;\n    correspondingResource=new RemoteFile(null,remoteFile.getRepository(),urls[i],logMessage.getRevision(),logMessage.getRevision(),logMessage.getDate(),logMessage.getAuthor());\n    result[i]=new LogEntry(logMessage,remoteFile,correspondingResource,(tags[i] != null) ? tags[i].getTags() : null);\n  }\n  return result;\n}\n", "nl": "create the LogEntry for the logMessages"}
{"code": "public static String decompressToStringForZlib(byte[] bytesToDecompress){\n  byte[] bytesDecompressed=decompressForZlib(bytesToDecompress);\n  String returnValue=null;\n  try {\n    returnValue=new String(bytesDecompressed,0,bytesDecompressed.length,\"UTF-8\");\n  }\n catch (  UnsupportedEncodingException uee) {\n    uee.printStackTrace();\n  }\n  return returnValue;\n}\n", "nl": "zlib decompress 2 String"}
{"code": "public void extractSamples(Collection<String> samples,Document srcDoc){\n  getDataTable().clear();\n  srcDoc.getDataTable().extractSamplesTo(samples,getDataTable());\n  getSampleAttributeTable().clear();\n  getSampleAttributeTable().addTable(srcDoc.getSampleAttributeTable().extractTable(samples),false,true);\n  getSampleAttributeTable().getAttributeOrder().clear();\n  getSampleAttributeTable().setAttributeOrder(srcDoc.getSampleAttributeTable().getAttributeOrder());\n  getSampleAttributeTable().getSampleOrder().clear();\n  getSampleAttributeTable().getSampleOrder().addAll(samples);\n}\n", "nl": "extract named samples from the given document"}
{"code": "public static ContextSet singleton(String key,String value){\n  if (key == null) {\n    throw new NullPointerException(\"key\");\n  }\n  if (value == null) {\n    throw new NullPointerException(\"value\");\n  }\n  MutableContextSet set=new MutableContextSet();\n  set.add(key,value);\n  return set.immutableCopy();\n}\n", "nl": "Make a singleton ContextSet from a context pair"}
{"code": "public boolean saveHtmlCache(String url,byte[] bytes){\n  if (TextUtils.isEmpty(url) || null == bytes || bytes.length == 0) {\n    return false;\n  }\n  if (!checkUrl(url)) {\n    return true;\n  }\n  return mInternalHtmlCache.saveCache(url,bytes);\n}\n", "nl": "Just save html file"}
{"code": "public void computeOverlapGraph(String label,int minOverlap,List<ReadData> readData,ProgressListener progress) throws IOException, CanceledException {\n  this.label=label;\n  final OverlapGraphBuilder overlapGraphBuilder=new OverlapGraphBuilder(minOverlap,verbose);\n  overlapGraphBuilder.apply(readData,progress);\n  overlapGraph=overlapGraphBuilder.getOverlapGraph();\n{\n    if (verbose)     System.err.print(\"Checking for cycles: \");\n    final int edgesRemoved=DirectedCycleBreaker.apply(overlapGraph);\n    if (verbose) {\n      System.err.println(edgesRemoved + (edgesRemoved > 0 ? \" removed\" : \"\"));\n    }\n  }\n  readId2ReadData=overlapGraphBuilder.getReadId2ReadData();\n  node2ReadNameMap=overlapGraphBuilder.getNode2ReadNameMap();\n  readId2ContainedReads=overlapGraphBuilder.getReadId2ContainedReads();\n  final PathExtractor pathExtractor=new PathExtractor(overlapGraph,readId2ContainedReads);\n  pathExtractor.apply(progress);\n}\n", "nl": "build the overlap graph"}
{"code": "public static boolean deleteDir(File dir){\n  if (dir == null) {\n    return false;\n  }\n  if (dir.isDirectory()) {\n    String[] children=dir.list();\n    for (    String child : children) {\n      boolean success=deleteDir(new File(dir,child));\n      if (!success) {\n        return false;\n      }\n    }\n  }\n  return dir.delete();\n}\n", "nl": "Delete a selected directory recursively"}
{"code": "public static String convertReaderToString(Reader reader,int readerLength) throws IOException {\n  StringWriter writer=new StringWriter();\n  int blockSize=DEFAULT_BUFFER_SIZE;\n  char[] buffer=new char[blockSize];\n  int left=readerLength;\n  while (left > 0) {\n    int read=reader.read(buffer,0,left > blockSize ? blockSize : left);\n    if (read == -1)     break;\n    writer.write(buffer,0,read);\n    left-=read;\n  }\n  writer.close();\n  return writer.toString();\n}\n", "nl": "Convert a reader to a string"}
{"code": "public static void main(String[] args){\n  try {\n    ProgramProperties.setProgramName(\"GCAssembler\");\n    ProgramProperties.setProgramVersion(megan.main.Version.SHORT_DESCRIPTION);\n    PeakMemoryUsageMonitor.start();\n    (new GCAssembler()).run(args);\n    System.err.println(\"Total time:  \" + PeakMemoryUsageMonitor.getSecondsSinceStartString());\n    System.err.println(\"Peak memory: \" + PeakMemoryUsageMonitor.getPeakUsageString());\n    System.exit(0);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n    System.exit(1);\n  }\n}\n", "nl": "performs gene-centric assemblies"}
{"code": "public static boolean isSystemApplication(Context context,String packageName){\n  PackageManager packageManager=context.getPackageManager();\n  if (packageManager == null || packageName == null || packageName.length() == 0) {\n    return false;\n  }\n  try {\n    ApplicationInfo app=packageManager.getApplicationInfo(packageName,0);\n    return (app != null && (app.flags & ApplicationInfo.FLAG_SYSTEM) > 0);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  return false;\n}\n", "nl": "whether packageName is system application"}
{"code": "public static double vectorLength(double[] vector){\n  double ret=0;\n  if (vector == null)   return ret;\n else {\n    for (    double aVector : vector) {\n      ret+=Math.pow(aVector,2);\n    }\n  }\n  return ret;\n}\n", "nl": "Returns the vector length (sqrt(sum(x_i))"}
{"code": "public boolean isIdentity(){\n  for (int i=0; i < v.length; i++) {\n    for (int j=0; j < v.length; j++) {\n      if (i == j) {\n        if (v[i].v[j] != 1)         return false;\n      }\n else       if (v[i].v[j] != 0)       return false;\n    }\n  }\n  return true;\n}\n", "nl": "determines whether this is the identity matrix"}
{"code": "private Class<?> defineClass(String className,byte[] definition) throws ClassFormatError {\n  if (_logger.isLoggable(Level.FINE))   _logger.fine(this.toString() + \" defining class: \" + className);\n  try {\n    Class<?> defineClass=defineClass(className,definition,0,definition.length);\n    LRMIClassLoader previousClassLoader=_serviceClassLoaderContext.putClassBytesAndLoader(className,this,definition);\n    if (previousClassLoader != null)     throw new IllegalStateException(\"Class: \" + className + \" is already loaded in this service by LRMIClassLoader \"+ previousClassLoader);\n    return defineClass;\n  }\n catch (  ClassFormatError e) {\n    if (_logger.isLoggable(Level.SEVERE))     _logger.log(Level.SEVERE,this.toString() + \" class format error caught while defining class: \" + className,e);\n    throw e;\n  }\n}\n", "nl": "Defines class from bytecode, in the current classloader"}
{"code": "public boolean isApplicable(){\n  try {\n    resamplingMethod.setOptionResamplingSize(Integer.parseInt(resamplingSizeTF.getText()));\n    resamplingMethod.setOptionRepeatitions(Integer.parseInt(repeatitionsTF.getText()));\n    resamplingMethod.setOptionLeftPercentile(Double.parseDouble(percentileLeftTF.getText()));\n    return resamplingMethod.isApplicable();\n  }\n catch (  NumberFormatException ex) {\n    System.err.println(\"Error: \" + ex);\n    return false;\n  }\n}\n", "nl": "check whether current entries are valid"}
{"code": "@Override public final void storeData(final IFallback object) throws IDBPersistenceException {\n  if (object instanceof FallbackImpl) {\n    if (!((FallbackImpl)object).toString().equals(FallbackImpl.ERROR)) {\n      storage.add(object);\n    }\n else {\n      throw new IDBPersistenceException(\"Connection to the DB has been lost\");\n    }\n  }\n}\n", "nl": "Stores an IFallback object into a DB table"}
{"code": "private void updateTexts(DocumentEvent e){\n  Document doc=e.getDocument();\n  if (doc == projectNameTextField.getDocument() || doc == projectLocationTextField.getDocument()) {\n    String projectName=projectNameTextField.getText();\n    String projectFolder=projectLocationTextField.getText();\n    createdFolderTextField.setText(projectFolder + File.separatorChar + projectName);\n  }\n  panel.fireChangeEvent();\n}\n", "nl": "Handles changes in the Project name and project directory,"}
{"code": "public SM_EMOTION(Creature creature,EmotionType emotionType,int emotion,int targetObjectId){\n  this.senderObjectId=creature.getObjectId();\n  this.emotionType=emotionType;\n  this.emotion=emotion;\n  this.targetObjectId=targetObjectId;\n  this.state=creature.getState();\n  Stat2 aSpeed=creature.getGameStats().getAttackSpeed();\n  this.baseAttackSpeed=aSpeed.getBase();\n  this.currentAttackSpeed=aSpeed.getCurrent();\n  this.speed=creature.getGameStats().getMovementSpeedFloat();\n}\n", "nl": "Constructs new server packet with specified opcode"}
{"code": "public QualityCheckStep(){\n  super();\n  try {\n    parentSession=new QualityCheckSession();\n    Field field=FieldUtils.getDeclaredField(this.getClass().getSuperclass(),\"session\",true);\n    field.set(this,parentSession);\n  }\n catch (  IllegalAccessException e) {\n    logger.error(\"Cannot replace the QualityCheckSession with Reflection\");\n  }\n}\n", "nl": "Initializes the QualityCheckSession defined in the parent step, using Reflection"}
{"code": "public static String clearAllEvent(HttpServletRequest request,HttpServletResponse response){\n  String errMsg=\"\";\n  Locale locale=UtilHttp.getLocale(request);\n  Security security=(Security)request.getAttribute(\"security\");\n  if (!security.hasPermission(\"UTIL_CACHE_EDIT\",request.getSession())) {\n    errMsg=UtilProperties.getMessage(UtilCacheEvents.err_resource,\"utilCacheEvents.permissionEdit\",locale) + \".\";\n    request.setAttribute(\"_ERROR_MESSAGE_\",errMsg);\n    return \"error\";\n  }\n  UtilCache.clearAllCaches();\n  errMsg=UtilProperties.getMessage(UtilCacheEvents.err_resource,\"utilCache.clearAllCaches\",locale);\n  request.setAttribute(\"_EVENT_MESSAGE_\",errMsg + \" (\" + UtilDateTime.nowDateString(\"yyyy-MM-dd HH:mm:ss\")+ \").\");\n  return \"success\";\n}\n", "nl": "An HTTP WebEvent handler that clears all caches"}
{"code": "public static <T>Set<T> toSet(T obj1,T obj2,T obj3,T obj4,T obj5,T obj6){\n  Set<T> theSet=new LinkedHashSet<T>();\n  theSet.add(obj1);\n  theSet.add(obj2);\n  theSet.add(obj3);\n  theSet.add(obj4);\n  theSet.add(obj5);\n  theSet.add(obj6);\n  return theSet;\n}\n", "nl": "Create a Set from passed objX parameters"}
{"code": "public String timerString(String message,String module){\n  long tsStart=System.currentTimeMillis();\n  StringBuilder retBuf=new StringBuilder();\n  retBuf.append(\"[[\").append(message).append(\"- total:\").append(secondsSinceStart());\n  if (lastMessage != null) {\n    retBuf.append(\",since last(\").append(((lastMessage.length() > 20) ? (lastMessage.substring(0,17) + \"...\") : lastMessage)).append(\"):\").append(secondsSinceLast());\n  }\n  retBuf.append(\"]]\");\n  if (UtilValidate.isNotEmpty(timerName)) {\n    retBuf.append(\" - '\").append(timerName).append(\"'\");\n  }\n  lastMessage=message;\n  String retString=retBuf.toString();\n  if (log)   Debug.log(Debug.TIMING,null,retString,module,\"org.ofbiz.base.util.UtilTimer\");\n  lastMessageTime=System.currentTimeMillis();\n  startTime+=(lastMessageTime - tsStart);\n  return retString;\n}\n", "nl": "Creates a string with information including the passed message, the last passed message and the time since the last call, and the time since the beginning"}
{"code": "public void collapsed(boolean collapsed){\n  this.collapsed=collapsed;\n  if (collapsed) {\n    Assert.IsNull(entryLookup);\n    entryLookup=new ConsoleEntryLookupTable();\n  }\n else {\n    entryLookup=null;\n  }\n  applyFilter();\n}\n", "nl": "Sets the boolean flag controlling similar entries collapse"}
{"code": "private URI parseUri(String url,String defaultPath) throws URISyntaxException {\n  if (url.matches(\"^http:|^https:\")) {\n    throw new URISyntaxException(url,\"HTTP/HTTPS is not supported, please use ws or wss instead\");\n  }\n  if (url.matches(\"^//\")) {\n    url=\"ws:\" + url;\n  }\n else   if (!url.matches(\"^ws:|^wss:\")) {\n    url=\"ws://\" + url;\n  }\n  URI uri=new URI(url);\n  if (uri.getPath().equals(\"\")) {\n    uri=uri.resolve(defaultPath);\n  }\n  return uri;\n}\n", "nl": "Take the url passed when creating the client and ensure the correct protocol is provided"}
{"code": "private int measureWidth(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=InfiniteViewPager.FakePositionHelper.getAdapterSize(mViewPager);\n    result=getPaddingLeft() + getPaddingRight() + (count * mLineWidth)+ ((count - 1) * mGapWidth);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)Math.ceil(result);\n}\n", "nl": "Determines the width of this view"}
{"code": "private boolean tryToNotifyReset(){\n  if ((mStatus == PTR_STATUS_COMPLETE || mStatus == PTR_STATUS_PREPARE) && mPtrIndicator.isInStartPosition()) {\n    if (mPtrUIHandlerHolder.hasHandler()) {\n      mPtrUIHandlerHolder.onUIReset(this);\n      if (DEBUG) {\n        PtrCLog.i(LOG_TAG,\"PtrUIHandler: onUIReset\");\n      }\n    }\n    mStatus=PTR_STATUS_INIT;\n    clearFlag();\n    return true;\n  }\n  return false;\n}\n", "nl": "If at the top and not in loading, reset"}
{"code": "public static String grabLastInLinePassedScore(String text,String key) throws IOException {\n  int scorePos=text.indexOf(\"Score\");\n  if (scorePos == -1)   throw new IOException(\"Token not found: 'Score'\");\n  int end=text.lastIndexOf(key);\n  if (end == -1)   throw new IOException(\"Token not found: '\" + key + \"'\");\n  if (end < scorePos)   throw new IOException(\"Token not found before 'Score': '\" + key + \"'\");\n  end=text.indexOf(\"\\n\",end);\n  if (end == -1)   end=text.length() - 1;\n  while (end > 0 && Character.isWhitespace(text.charAt(end)))   end--;\n  int start=end;\n  while (start > 0 && !Character.isWhitespace(text.charAt(start)))   start--;\n  start+=1;\n  return text.substring(start,end + 1);\n}\n", "nl": "grab the last token of the last line that contains the given key and is passed the first occurrence of \"Score\""}
{"code": "public boolean closeDatabase(String dbfile){\n  if (databases.get(dbfile) != null) {\n    SQLiteDatabase db=(SQLiteDatabase)databases.get(dbfile);\n    db.close();\n    databases.remove(dbfile);\n    return true;\n  }\n  return false;\n}\n", "nl": "Close assets database"}
{"code": "public int append_file(String group_name,String appender_filename,String local_filename) throws IOException, MyException {\n  File f=new File(local_filename);\n  FileInputStream fis=new FileInputStream(f);\n  try {\n    return this.do_append_file(group_name,appender_filename,f.length(),new UploadStream(fis,f.length()));\n  }\n  finally {\n    fis.close();\n  }\n}\n", "nl": "append file to storage server (by file name)"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set colorMatchesVsConsensus=\");\n  boolean value=np.getBoolean();\n  np.matchIgnoreCase(\";\");\n  AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  viewer.getAlignmentViewerPanel().getAlignmentPanel().setColorMatchesVsConsensus(value);\n  ProgramProperties.put(\"ColorMatchesVsConsensus\",value);\n  viewer.repaint();\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static void main(String[] args){\n  try {\n    ProgramProperties.setProgramName(\"DAA2RMA\");\n    ProgramProperties.setProgramVersion(megan.main.Version.SHORT_DESCRIPTION);\n    PeakMemoryUsageMonitor.start();\n    (new DAA2RMA6()).run(args);\n    System.err.println(\"Total time:  \" + PeakMemoryUsageMonitor.getSecondsSinceStartString());\n    System.err.println(\"Peak memory: \" + PeakMemoryUsageMonitor.getPeakUsageString());\n    System.exit(0);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n    System.exit(1);\n  }\n}\n", "nl": "merge RMA files"}
{"code": "public void copyRemoteResource(ISVNRemoteResource resource,ISVNRemoteFolder destinationFolder,String message,IProgressMonitor monitor) throws SVNException {\n  IProgressMonitor progress=Policy.monitorFor(monitor);\n  progress.beginTask(Policy.bind(\"RepositoryResourcesManager.copyRemoteResources\"),100);\n  ISVNClientAdapter svnClient=null;\n  try {\n    svnClient=resource.getRepository().getSVNClient();\n    svnClient.copy(resource.getUrl(),destinationFolder.getUrl(),message,SVNRevision.HEAD);\n    destinationFolder.refresh();\n    remoteResourceCopied(resource,destinationFolder);\n  }\n catch (  SVNClientException e) {\n    throw SVNException.wrapException(e);\n  }\n finally {\n    resource.getRepository().returnSVNClient(svnClient);\n    progress.done();\n  }\n}\n", "nl": "copy the remote resource to the given remote folder "}
{"code": "private Label createLabel(Composite parent,String text,int span,int horizontalIndent){\n  Label label=new Label(parent,SWT.LEFT);\n  label.setText(text);\n  GridData data=new GridData();\n  data.horizontalSpan=span;\n  data.horizontalAlignment=GridData.FILL;\n  data.horizontalIndent=horizontalIndent;\n  label.setLayoutData(data);\n  return label;\n}\n", "nl": "creates a label"}
{"code": "public void printSources(){\n  if (this.sourceSinkProvider == null) {\n    System.err.println(\"Sources not calculated yet\");\n    return;\n  }\n  System.out.println(\"Sources:\");\n  for (  SourceSinkDefinition am : getSources()) {\n    System.out.println(am.toString());\n  }\n  System.out.println(\"End of Sources\");\n}\n", "nl": "Prints the list of sources registered with FlowDroud to stdout"}
{"code": "protected Map<String,Object> filterItemValue(String entityName,Map<String,Object> itemValues){\n  ClassMetadata classMetadata=sessionFactory.getClassMetadata(entityName);\n  String[] propertyNames=classMetadata.getPropertyNames();\n  List<String> names=Arrays.asList(propertyNames);\n  Iterator<String> iterator=itemValues.keySet().iterator();\n  while (iterator.hasNext()) {\n    if (!names.contains(iterator.next()))     iterator.remove();\n  }\n  return itemValues;\n}\n", "nl": "Filter from the input map the unmapped field of this entity"}
{"code": "public static final void createSummon(Player master,int npcId,int skillId,int skillLevel,int time){\n  if (master.getSummon() != null) {\n    PacketSendUtility.sendPacket(master,new SM_SYSTEM_MESSAGE(1300072));\n    return;\n  }\n  Summon summon=VisibleObjectSpawner.spawnSummon(master,npcId,skillId,skillLevel,time);\n  if (summon.getAi2().getName().equals(\"siege_weapon\")) {\n    summon.getAi2().onGeneralEvent(AIEventType.SPAWNED);\n  }\n  master.setSummon(summon);\n  PacketSendUtility.sendPacket(master,new SM_SUMMON_PANEL(summon));\n  PacketSendUtility.broadcastPacket(summon,new SM_EMOTION(summon,EmotionType.START_EMOTE2));\n  PacketSendUtility.broadcastPacket(summon,new SM_SUMMON_UPDATE(summon));\n}\n", "nl": "create summon"}
{"code": "@RequestMapping(value=\"/order/info\",method=RequestMethod.GET) public RespJson selectOrderInfo(@RequestParam(value=\"id\",required=false) long id){\n  try {\n    Order order=orderDao.searchById(id);\n    order.setOrderTypeName(OrderType.getByCode(order.getOrderType()).getDesc());\n    order.setCustomerGenderName(Gender.getByCode(order.getCustomerGender()).getDesc());\n    return RespJson.buildSuccessResponse(order);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return RespJson.buildFailureResponse(StringUtils.getValidString(e.getMessage()));\n  }\n}\n", "nl": "Search order info by primary key"}
{"code": "public void remove(IObjectInfo<T> oi){\n  lock.lock();\n  try {\n    if (_objectsMap != null && oi.getSubject() != null) {\n      _objectsMap.remove(oi.getSubject());\n    }\n    remove_impl((ObjectInfo<T>)oi);\n    if (m_Size == 0 && _objectsMap != null)     _objectsMap=null;\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "remove an element described by ObjectInfo"}
{"code": "private void loadList(Collection<String> files){\n  int[] selectionIds=new int[files.size()];\n  int f=0;\n  for (  String file : files) {\n    selectionIds[f++]=listModel.size();\n    listModel.addElement(new MyListItem(file));\n  }\n  if (f > 0)   jList.setSelectedIndices(selectionIds);\n}\n", "nl": "setup the list"}
{"code": "public int readLocations(ClassificationsFooterRMA3 classificationsFooter,IInputReader reader,int classId,ListOfLongs list) throws IOException {\n  long start=classificationsFooter.getStart(classificationType);\n  if (start != 0) {\n    reader.seek(start);\n    final int numberOfClasses=reader.readInt();\n    for (int i=0; i < numberOfClasses; i++) {\n      int currentId=reader.readInt();\n      int sum=reader.readInt();\n      if (currentId == classId) {\n        for (int z=0; z < sum; z++) {\n          list.add(reader.readLong());\n        }\n      }\n else       reader.skipBytes(8 * sum);\n    }\n  }\n  return list.size();\n}\n", "nl": "read all locations for a given class and adds the to list"}
{"code": "public ThreadPool(String identifier,int min,int max){\n  setIdentifier(identifier);\n  setMin(min);\n  setMax(max);\n  group=new ThreadGroup(identifier);\n  group.setDaemon(true);\n  try {\n    createResources();\n  }\n catch (  ResourceUnavailableException e) {\n    logger.log(Level.SEVERE,\"Creating ThreadPool with min=\" + min + \", max=\"+ max,e);\n  }\n}\n", "nl": "Create new named ThreadPool with a specified amount of minimum and maximum elements in the pool"}
{"code": "public static int dip2px(float dpValue){\n  float scale=2;\n  try {\n    scale=WXEnvironment.getApplication().getResources().getDisplayMetrics().density;\n  }\n catch (  Exception e) {\n    WXLogUtils.e(\"[WXViewUtils] dip2px:\",e);\n  }\n  float finalPx=(dpValue * scale + 0.5f);\n  return finalPx > 0 && finalPx < 1 ? 1 : (int)finalPx;\n}\n", "nl": "Convert dp to px"}
{"code": "public TileLayerWMSOptions build(){\n  TileLayerWMSOptions options=new TileLayerWMSOptions();\n  options.layers=this.layers;\n  options.styles=this.styles;\n  options.format=this.format;\n  options.transparent=this.transparent;\n  options.version=this.version;\n  options.crs=this.crs;\n  return options;\n}\n", "nl": "Builds the TileLayerWMSOptions new instance"}
{"code": "private void updateFooterViewSize(int dy,XRecyclerView view){\n  if (dy > 0) {\n    if (view.mFooterView.getLayoutParams().height < view.mFooterViewHeight) {\n      view.mFooterView.getLayoutParams().height+=dy / 2;\n    }\n else {\n      view.mFooterView.getLayoutParams().height+=dy / 4;\n    }\n  }\n  view.mFooterView.setVisibility(VISIBLE);\n  view.mFooterView.requestLayout();\n}\n", "nl": "reset the footer view height"}
{"code": "public SearchResult search(String queryString,int page){\n  SearchResult searchResult=new SearchResult();\n  statsService.incrementSearchCount();\n  try {\n    IndexReader reader=DirectoryReader.open(FSDirectory.open(Paths.get(this.INDEXPATH)));\n    IndexSearcher searcher=new IndexSearcher(reader);\n    Analyzer analyzer=new CodeAnalyzer();\n    QueryParser parser=new QueryParser(CODEFIELD,analyzer);\n    Query query=parser.parse(queryString);\n    LOGGER.info(\"Searching for: \" + query.toString(CODEFIELD));\n    searchResult=this.doPagingSearch(reader,searcher,query,page);\n    reader.close();\n  }\n catch (  Exception ex) {\n    LOGGER.warning(\" caught a \" + ex.getClass() + \"\\n with message: \"+ ex.getMessage());\n  }\n  return searchResult;\n}\n", "nl": "Given a query and what page of results we are on return the matching results for that search"}
{"code": "public static void closeStreams(Closeable... streams){\n  if (null != streams) {\n    for (    Closeable stream : streams) {\n      if (null != stream) {\n        try {\n          stream.close();\n        }\n catch (        IOException e) {\n          LOGGER.error(\"Error while closing stream\" + stream);\n        }\n      }\n    }\n  }\n}\n", "nl": "This method closes the streams"}
{"code": "private String checkAndCreateCarbonStoreLocation(String factStoreLocation,String databaseName,String tableName,String partitionId,String segmentId){\n  String carbonStorePath=factStoreLocation;\n  CarbonTable carbonTable=CarbonMetadata.getInstance().getCarbonTable(databaseName + CarbonCommonConstants.UNDERSCORE + tableName);\n  CarbonTableIdentifier carbonTableIdentifier=carbonTable.getCarbonTableIdentifier();\n  CarbonTablePath carbonTablePath=CarbonStorePath.getCarbonTablePath(carbonStorePath,carbonTableIdentifier);\n  String carbonDataDirectoryPath=carbonTablePath.getCarbonDataDirectoryPath(partitionId,segmentId);\n  CarbonUtil.checkAndCreateFolder(carbonDataDirectoryPath);\n  return carbonDataDirectoryPath;\n}\n", "nl": "This method will get the store location for the given path, segment id and partition id"}
{"code": "public boolean ContainsFunction(PetFunctionType type){\n  if (type.getId() < 0) {\n    return false;\n  }\n  for (  PetFunction t : getPetFunctions()) {\n    if (t.getPetFunctionType() == type) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Used to write to SM_PET packet, so checks only needed ones"}
{"code": "private ResponsePacket executeDelete(QueryTemplatePacket template,ISpaceProxy space,Transaction txn) throws RemoteException, TransactionException, UnusableEntryException, InterruptedException {\n  ResponsePacket packet=new ResponsePacket();\n  template.setOperationID(getOperationID());\n  template.setExplainPlan(getExplainPlan());\n  if (isReturnResult()) {\n    int max=getRownumLimit();\n    ArrayList<IEntryPacket> entries=template.take(space,getRouting(),getProjectionTemplate(),txn,getTimeout(),getReadModifier(),getIfExists(),max,getMinEntriesToWaitFor(),getQueryResultType());\n    packet.setResultSet(entries);\n    packet.setIntResult(entries.size());\n  }\n else {\n    template.setRouting(getRouting());\n    int cleared=_executor.clear(template,space,txn,getReadModifier());\n    packet.setIntResult(cleared);\n  }\n  return packet;\n}\n", "nl": "Execute delete operation with given template"}
{"code": "public boolean copyReference(){\n  final SelectedBlock selectedBlock=getSelectedBlock();\n  if (selectedBlock.isSelected()) {\n    StringSelection ss=new StringSelection(getSelectedReference());\n    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss,null);\n    return true;\n  }\n  return false;\n}\n", "nl": "copy selected reference to clip-board"}
{"code": "@Override @Test public void testInsufficientData(){\n  double[] one=new double[]{1};\n  double[] two=new double[]{2};\n  try {\n    new SpearmansCorrelation().correlation(one,two);\n    Assert.fail(\"Expecting MathIllegalArgumentException\");\n  }\n catch (  MathIllegalArgumentException ex) {\n  }\n  RealMatrix matrix=new BlockRealMatrix(new double[][]{{0},{1}});\n  try {\n    new SpearmansCorrelation(matrix);\n    Assert.fail(\"Expecting MathIllegalArgumentException\");\n  }\n catch (  MathIllegalArgumentException ex) {\n  }\n}\n", "nl": "Insufficient data"}
{"code": "public void openAll(){\n  ArrayList<ItemIndex> lvl1Sections=getItemIndices(ItemType.LVL1_SECTION);\n  for (  ItemIndex itemIndex : lvl1Sections) {\n    openCloseLvl1Section(itemIndex,true);\n  }\n  ArrayList<ItemIndex> lvl2Sections=getItemIndices(ItemType.LVL2_SECTION);\n  for (  ItemIndex itemIndex : lvl2Sections) {\n    openCloseLvl2Section(itemIndex,true);\n  }\n  ArrayList<ItemIndex> lvl3Sections=getItemIndices(ItemType.LVL3_SECTION);\n  for (  ItemIndex itemIndex : lvl3Sections) {\n    openCloseLvl3Section(itemIndex,true);\n  }\n}\n", "nl": "custom function to open all REALLY FUCKING SLOW"}
{"code": "public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"expand attribute=\");\n  final String attribute=np.getWordRespectCase();\n  np.matchIgnoreCase(\";\");\n  final Director dir=(Director)getDir();\n  final Document doc=dir.getDocument();\n  final SamplesViewer samplesViewer=(SamplesViewer)getDir().getViewerByClass(SamplesViewer.class);\n  if (samplesViewer != null) {\n  }\n  final int count=doc.getSampleAttributeTable().expandAttribute(attribute,true);\n  if (count > 0 && samplesViewer != null)   samplesViewer.getSamplesTable().syncFromDocument();\n  if (count == 0)   NotificationsInSwing.showWarning(getViewer().getFrame(),\"Expand attribute failed\");\n else   NotificationsInSwing.showInformation(getViewer().getFrame(),\"Expand \" + attribute + \"' added \"+ count+ \" columns\");\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static void startMission(QuestEnv env,QuestStatus status){\n  Player player=env.getPlayer();\n  int questId=env.getQuestId();\n  if (player.getQuestStateList().getQuestState(questId) != null) {\n    return;\n  }\n else {\n    player.getQuestStateList().addQuest(questId,new QuestState(questId,status,0,0,null,0,null));\n  }\n  PacketSendUtility.sendPacket(player,new SM_QUEST_ACTION(questId,status.value(),0));\n}\n", "nl": "Starts or temporary locks the mission Used only from the QuestHandler class"}
{"code": "public static void openPlayStoreAppPage(Context context){\n  final String appPackageName=context.getPackageName();\n  try {\n    context.startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(\"market://details?id=\" + appPackageName)));\n  }\n catch (  android.content.ActivityNotFoundException anfe) {\n    context.startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(\"https://play.google.com/store/apps/details?id=\" + appPackageName)));\n  }\n}\n", "nl": "Open the playstore page for the current app"}
{"code": "private void listAssignedRec(ViewerBase viewer,Classification classification,NodeSet selectedNodes,Node v,int indent,Writer outs,final Single<Integer> countLines) throws IOException {\n  int id=(Integer)v.getInfo();\n  final String name=classification.getName2IdMap().get(id);\n  NodeData data=(viewer.getNodeData(v));\n  if ((selectedNodes == null || selectedNodes.contains(v))) {\n    if (data.getCountSummarized() > 0) {\n      for (int i=0; i < indent; i++)       outs.write(\" \");\n      outs.write(name + \": \" + Basic.toString(data.getSummarized(),\",\")+ \"\\n\");\n      countLines.set(countLines.get() + 1);\n    }\n  }\n  if (viewer.getCollapsedIds().contains(id)) {\n    return;\n  }\n  for (Edge f=v.getFirstOutEdge(); f != null; f=v.getNextOutEdge(f)) {\n    listAssignedRec(viewer,classification,selectedNodes,f.getOpposite(v),indent + 2,outs,countLines);\n  }\n}\n", "nl": "recursively print a summary"}
{"code": "public ClusterUnitVoice(String name,Gender gender,Age age,String description,Locale locale,String domain,String organization,Lexicon lexicon,URL database,ClusterUnitNamer unitNamer,URL phonesetURL,URL partOfSpeechURL){\n  super(name,gender,age,description,locale,domain,organization);\n  setRate(150f);\n  setPitch(100F);\n  setPitchRange(12F);\n  if (lexicon != null) {\n    setLexicon(lexicon);\n  }\n else {\n    setLexicon(new CMULexicon(\"cmutimelex\"));\n  }\n  this.database=database;\n  this.unitNamer=unitNamer;\n  this.phonesetURL=phonesetURL;\n  this.partOfSpeechURL=partOfSpeechURL;\n}\n", "nl": "Creates a ClusterUnitVoice"}
{"code": "@PostConstruct public void init(){\n  LOGGER.trace(\"Initialising AliveTimerChecker...\");\n  clusterCache.acquireWriteLockOnKey(LAST_ALIVE_TIMER_CHECK_INITIALISATION_KEY);\n  try {\n    if (!clusterCache.hasKey(LAST_ALIVE_TIMER_CHECK_INITIALISATION_KEY)) {\n      clusterCache.put(LAST_ALIVE_TIMER_CHECK_INITIALISATION_KEY,true);\n      clusterCache.put(LAST_ALIVE_TIMER_CHECK_LONG,Long.valueOf(0L));\n    }\n  }\n  finally {\n    clusterCache.releaseWriteLockOnKey(LAST_ALIVE_TIMER_CHECK_INITIALISATION_KEY);\n  }\n  LOGGER.trace(\"Initialisation complete.\");\n}\n", "nl": "Initialises the clustered values"}
{"code": "public void clearAllInsertions(){\n  List<MODEL> items=new ArrayList<>();\n  items.addAll(getOnlyItems());\n  mInserts.clear();\n  getItems().clear();\n  mOnlyInsertsCount=0;\n  mHeadersCount=0;\n  mFootersCount=0;\n  reAddAllItems(items);\n  notifyIfNeed();\n}\n", "nl": "Clear all insertions with headers and footers"}
{"code": "private int measureWidth(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=mViewPager.getAdapter().getCount();\n    result=getPaddingLeft() + getPaddingRight() + (count * mLineWidth)+ ((count - 1) * mGapWidth);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)Math.ceil(result);\n}\n", "nl": "Determines the width of this view"}
{"code": "public void loadFromFile(String sFileName) throws FileNotFoundException, IOException {\n  FileReader frFile=new FileReader(sFileName);\n  String sText=\"\";\n  int c=frFile.read();\n  while (c != -1) {\n    sText+=c;\n    c=frFile.read();\n  }\n  addText(sText);\n  frFile.close();\n}\n", "nl": "Loads a text file with filename sFilename and adds all its words to the definitions"}
{"code": "public static void updateGatherableStatus(Player player){\n  if (player.isNotGatherable()) {\n    long gatherableTimer=player.getGatherableTimer();\n    if (gatherableTimer > 0) {\n      scheduleGatherableTask(player,gatherableTimer);\n      player.setStopGatherable(System.currentTimeMillis());\n    }\n  }\n}\n", "nl": "This method will update the gathering status"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  AttributesWindow viewer=(AttributesWindow)getViewer();\n  if (viewer != null) {\n    DefaultMutableTreeNode root=(DefaultMutableTreeNode)viewer.getTree().getModel().getRoot();\n    TreeNode[] treePath=root.getPath();\n    if (treePath != null) {\n      viewer.getTree().setSelectionPath(new TreePath(treePath));\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public void checkExpectedGeneratedResources(){\n  try {\n    checkDirectoriesContainSameContent(getExpectedResourcesTestDir(),targetTestDir);\n  }\n catch (  DifferentDirectoryContentException e) {\n    String msg=\"Generated resources do not match the expected resources\";\n    logger.debug(msg,e);\n    Assert.fail(msg + \"\\n\" + e.getMessage());\n  }\n}\n", "nl": "Asserts that the resources generated by the test exactly match the resources located in the expected directory"}
{"code": "public void edit(final double[] key,final Editor<T> editor) throws KeySizeException, KeyDuplicateException {\n  if (key.length != m_K) {\n    throw new KeySizeException();\n  }\nsynchronized (this) {\n    if (null == m_root) {\n      m_root=KDNode.create(new HPoint(key),editor);\n      m_count=m_root.deleted ? 0 : 1;\n      return;\n    }\n  }\n  m_count+=KDNode.edit(new HPoint(key),editor,m_root,0,m_K);\n}\n", "nl": "Edit a node in a KD-tree"}
{"code": "public int previousIndex(){\n  try {\n    return currentIndex() - 1;\n  }\n catch (  GenericEntityException e) {\n    if (!closed) {\n      try {\n        this.close();\n      }\n catch (      GenericEntityException e1) {\n        Debug.logError(e1,\"Error auto-closing EntityListIterator on error, so info below for more info on original error; close error: \" + e1.toString(),module);\n      }\n      Debug.logWarning(\"Warning: auto-closed EntityListIterator because of exception: \" + e.toString(),module);\n    }\n    throw new GeneralRuntimeException(\"Error getting the current index\",e);\n  }\n}\n", "nl": "Returns the index of the previous result, but does not guarantee that there will be a previous result"}
{"code": "public boolean isApplicable(){\n  if (getViewer() instanceof ClusterViewer) {\n    final ClusterViewer clusterViewer=(ClusterViewer)getViewer();\n    return clusterViewer.isPCoATab() && clusterViewer.getGraphView().getSelectedNodes().size() >= 1;\n  }\n else   if (getViewer() instanceof SamplesViewer) {\n    final SamplesViewer samplesViewer=(SamplesViewer)getViewer();\n    return samplesViewer.getSamplesTable().getNumberOfSelectedSamples() > 0;\n  }\n else   return ((Director)getDir()).getDocument().getSampleSelection().size() >= 1;\n}\n", "nl": "is the command currently applicable? Used to set enable state of command"}
{"code": "private boolean isConfigurationPluginAvailable(){\n  if (configurationPluginAvailable == null) {\n    try {\n      String value=APILocator.getPluginAPI().loadProperty(pluginName,\"environment\");\n      configurationPluginAvailable=(value != null);\n    }\n catch (    Exception e) {\n      Logger.warn(this,\"Exception while trying to get property 'environment' \",e);\n      configurationPluginAvailable=false;\n    }\n    Logger.info(this,\"Configuration plugin available: \" + configurationPluginAvailable);\n  }\n  return configurationPluginAvailable;\n}\n", "nl": "Check for the \"environment\" key in the pluginAPI"}
{"code": "public void cancelTransference(OCFile file){\n  Account account=mFileActivity.getAccount();\n  if (file.isFolder()) {\n    OperationsService.OperationsServiceBinder opsBinder=mFileActivity.getOperationsServiceBinder();\n    if (opsBinder != null) {\n      opsBinder.cancel(account,file);\n    }\n  }\n  FileDownloaderBinder downloaderBinder=mFileActivity.getFileDownloaderBinder();\n  if (downloaderBinder != null && downloaderBinder.isDownloading(account,file)) {\n    downloaderBinder.cancel(account,file);\n  }\n  FileUploaderBinder uploaderBinder=mFileActivity.getFileUploaderBinder();\n  if (uploaderBinder != null && uploaderBinder.isUploading(account,file)) {\n    uploaderBinder.cancel(account,file);\n  }\n}\n", "nl": "Cancel the transference in downloads (files/folders) and file uploads"}
{"code": "public static BufferedImage toBufferedImage(Image img,int type){\n  if (img instanceof BufferedImage) {\n    return (BufferedImage)img;\n  }\n  BufferedImage bimage=new BufferedImage(img.getWidth(null),img.getHeight(null),type);\n  Graphics2D bGr=bimage.createGraphics();\n  bGr.drawImage(img,0,0,null);\n  bGr.dispose();\n  return bimage;\n}\n", "nl": "Converts a given Image into a BufferedImage"}
{"code": "public String toString(String hitDef,int hitLen){\n  StringBuilder buffer=new StringBuilder();\n  buffer.append(String.format(\">%s\\n\\tLength = %d\\n\",Basic.fold(hitDef,100),hitLen));\n  buffer.append(String.format(\" Score = %.1f bits (%.1f), Expect= %e\\n\",bitScore,score,eValue));\n  buffer.append(String.format(\" Identities = %d/%d (%d%%), Positives = %d/%d (%d%%), Gaps = %d/%d (%d%%)\\n\",identity,alignLength,Math.round(100 * identity / alignLength),positive,alignLength,100 * positive / alignLength,gaps,alignLength,100 * gaps / alignLength));\n  if (queryFrame != 0)   buffer.append(String.format(\" Frame = %+d\\n\",queryFrame));\n  if (qSeq != null && hSeq != null) {\n    long a=(queryFrame >= 0 ? queryFrom : queryTo);\n    long b=(queryFrame >= 0 ? queryTo : queryFrom);\n    buffer.append(String.format(\"\\nQuery:%9d  %s  %d\\n\",a,qSeq,b));\n    if (midLine != null)     buffer.append(String.format(\"                 %s\\n\",midLine));\n    buffer.append(String.format(\"Sbjct:%9d  %s  %d\\n\",hitFrom,hSeq,hitTo));\n  }\n else   buffer.append(\"[No alignment given]\\n\");\n  return buffer.toString();\n}\n", "nl": "return human readable string representation"}
{"code": "@Override public void stop(boolean force){\n  try {\n    if (force) {\n      getProcessAdmin().killVM();\n    }\n  }\n catch (  RemoteException ex) {\n    ProcessLogger.log(\"Exception caught while killing VM\",ex);\n  }\n  super.stop(force);\n}\n", "nl": "force killing forkable VM by direct remote call on remote JVM"}
{"code": "@Override public boolean continueExecuting(){\n  if (targetItem.isDead || targetItem.getEntityItem().stackSize < 1)   return false;\n  if (entity.getGrowingAge() < 1 && !entity.isInLove()) {\n    if (entity instanceof EntityWolf) {\n      if (((EntityWolf)entity).isSitting())       return false;\n    }\n    if (timeoutCounter > 1200)     return false;\n    if (!this.entity.getNavigator().noPath()) {\n      double sqDistToPos=this.entity.getDistanceSq(targetItem.posX,targetItem.posY,targetItem.posZ);\n      if (sqDistToPos > 2.0D)       return true;\n    }\n  }\n  return false;\n}\n", "nl": "Returns whether an in-progress EntityAIBase should continue executing"}
{"code": "private boolean isSourceSinkOrTaintWrapped(Stmt callSite){\n  if (!callSite.containsInvokeExpr())   return false;\n  SootMethod method=callSite.getInvokeExpr().getMethod();\n  if (sourceSinkManager != null && sourceSinkManager.getSourceInfo((Stmt)callSite,icfg) != null) {\n    methodFieldReads.put(method,true);\n    return true;\n  }\n  if (sourceSinkManager != null && sourceSinkManager.isSink((Stmt)callSite,icfg,null)) {\n    methodSinks.put(method,true);\n    return true;\n  }\n  if (taintWrapper != null && taintWrapper.supportsCallee(method)) {\n    methodSideEffects.put(method,true);\n    return true;\n  }\n  return false;\n}\n", "nl": "Checks whether the given method is a source, a sink or is accepted by the taint wrapper"}
{"code": "public Boolean deleteProductCategory(EntityManager em,String productCategory){\n  Boolean status=true;\n  ProductCategory prodcat=null;\n  try {\n    if (!em.getTransaction().isActive()) {\n      em.getTransaction().begin();\n    }\n    prodcat=em.find(ProductCategory.class,productCategory);\n    em.remove(prodcat);\n    em.getTransaction().commit();\n  }\n catch (  Exception e) {\n    status=false;\n    logger.error(\"Error occured during delete of Product category. Detailed info: \" + e);\n  }\n  return status;\n}\n", "nl": "Helper method to delete Product Category"}
{"code": "private List<SysMenu> buildSystemMenus(String userId){\n  List<SysMenu> menuList=new ArrayList<SysMenu>();\n  List<Module> modules=moduleDao.getModulesByUserId(userId);\n  if (modules != null && !modules.isEmpty()) {\n    for (    Module module : modules) {\n      if (module.getParent() == null)       menuList.add(buildMenuFromModule(module));\n    }\n    for (    SysMenu firstMenu : menuList) {\n      buildSubMenu(firstMenu,modules);\n      if (firstMenu.getSubMenus() != null) {\n        for (        SysMenu secondMenu : firstMenu.getSubMenus())         buildSubMenu(secondMenu,modules);\n      }\n    }\n  }\n  return menuList;\n}\n", "nl": "Build system menus"}
{"code": "static String toS(float[] a){\n  String s=\"[\";\n  if (a == null) {\n    return \"[null]\";\n  }\n  for (int i=0; i < a.length; i++) {\n    if (i != 0) {\n      s+=\" , \";\n    }\n    String t=df.format(a[i]) + \"       \";\n    s+=t.substring(0,7);\n  }\n  s+=\"]\";\n  return s;\n}\n", "nl": "convert an array of floats to fixed length strings"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  final InspectorWindow inspectorWindow=(InspectorWindow)getViewer();\n  final TreePath[] paths=inspectorWindow.getDataTree().getSelectionPaths();\n  if (paths != null) {\n    inspectorWindow.expand(paths);\n  }\n else {\n    for (    NodeBase root : inspectorWindow.getClassification2RootNode().values()) {\n      inspectorWindow.expand(root);\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static double min(final double a,final double b){\n  if (a > b) {\n    return b;\n  }\n  if (a < b) {\n    return a;\n  }\n  if (a != b) {\n    return Double.NaN;\n  }\n  long bits=Double.doubleToRawLongBits(a);\n  if (bits == 0x8000000000000000L) {\n    return a;\n  }\n  return b;\n}\n", "nl": "Compute the minimum of two values"}
{"code": "private boolean checkLastStamp(Timestamp lastStamp){\n  Timestamp now=new Timestamp(System.currentTimeMillis());\n  Calendar c=Calendar.getInstance();\n  c.setTimeInMillis(lastStamp.getTime());\n  c.add(Calendar.DATE,1);\n  c.set(Calendar.HOUR_OF_DAY,9);\n  c.set(Calendar.MINUTE,0);\n  Timestamp nextStamp=new Timestamp(c.getTime().getTime());\n  return now.after(nextStamp);\n}\n", "nl": "Checks if laststamp is on the previous day and only gives the stamp if it is after 9 AM"}
{"code": "private void drawBorder(Canvas canvas){\n  if (borderWidth > 0) {\n    Paint paint=new Paint();\n    paint.setStrokeWidth(borderWidth);\n    paint.setStyle(Paint.Style.STROKE);\n    paint.setColor(borderColor);\n    paint.setAntiAlias(true);\n    if (shapeType == 1) {\n      canvas.drawCircle(width / 2,height / 2,(width - borderWidth) / 2,paint);\n    }\n else     if (shapeType == 2) {\n      RectF rectf=new RectF(borderWidth / 2,borderWidth / 2,getWidth() - borderWidth / 2,getHeight() - borderWidth / 2);\n      canvas.drawRoundRect(rectf,radius,radius,paint);\n    }\n  }\n}\n", "nl": "draw customized border"}
{"code": "public Bitmap onTakePhotoResult(){\n  Uri takenPhotoUri=getPhotoFileUri(this.thePhotoName,this.anotherPhotoName,this.activity);\n  if (takenPhotoUri != null) {\n    Bitmap takenImage=BitmapFactory.decodeFile(takenPhotoUri.getPath());\n    takenImage=resizePhoto(takenImage,this.resizePhoto,true);\n    return takenImage;\n  }\n else {\n    return null;\n  }\n}\n", "nl": "Save the photo in memory bitmap, resize and return the photo"}
{"code": "public QuestRewardCursor queryQuestRewardItem(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Columns=null;\n  qh.Table=S.TABLE_QUEST_REWARDS;\n  qh.Selection=\"qr.\" + S.COLUMN_QUEST_REWARDS_ITEM_ID + \" = ? \";\n  qh.SelectionArgs=new String[]{\"\" + id};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=\"q.\" + S.COLUMN_QUESTS_HUB + \" ASC, \"+ \"q.\"+ S.COLUMN_QUESTS_STARS+ \" ASC\";\n  qh.Limit=null;\n  return new QuestRewardCursor(wrapJoinHelper(builderQuestReward(),qh));\n}\n", "nl": "****************************** QUEST REWARD QUERIES"}
{"code": "private void drawXAxis(Graphics2D gc){\n  int x0=leftMargin;\n  int x1=getWidth() - rightMargin;\n  int y0=getHeight() - bottomMargin;\n  int y1=topMargin;\n  gc.setColor(Color.BLACK);\n  gc.drawLine(x0,y0,x1 + 10,y0);\n  drawArrowHead(gc,new Point(x0,y0),new Point(x1 + 10,y0));\n  drawXAxisTicks(gc);\n  if (getChartData().getSeriesLabel() != null) {\n    gc.setFont(getFont(ChartViewer.FontKeys.XAxisFont.toString()));\n    gc.setColor(getFontColor(ChartViewer.FontKeys.XAxisFont.toString(),Color.BLACK));\n    int x=5;\n    int y=getHeight() - bottomMargin + 25;\n    if (isTranspose())     gc.drawString(getChartData().getClassesLabel(),x,y);\n else     gc.drawString(getChartData().getSeriesLabel(),x,y);\n  }\n}\n", "nl": "draw the x axis"}
{"code": "protected int findUTCSign(String buffer,int start,int end){\n  int c;\n  for (int i=start; i < end; i++) {\n    c=buffer.charAt(i);\n    if (c == 'Z' || c == '+' || c == '-') {\n      return i;\n    }\n  }\n  return -1;\n}\n", "nl": "Return index of UTC char: 'Z', '+', '-'"}
{"code": "public void printSinks(){\n  if (this.sourceSinkProvider == null) {\n    System.err.println(\"Sinks not calculated yet\");\n    return;\n  }\n  System.out.println(\"Sinks:\");\n  for (  SourceSinkDefinition am : getSinks()) {\n    System.out.println(am.toString());\n  }\n  System.out.println(\"End of Sinks\");\n}\n", "nl": "Prints the list of sinks registered with FlowDroud to stdout"}
{"code": "@Override public AbstractScannedResult scanBlocklet(BlocksChunkHolder blocksChunkHolder) throws QueryExecutionException {\n  try {\n    fillScannedResult(blocksChunkHolder);\n  }\n catch (  FilterUnsupportedException e) {\n    throw new QueryExecutionException(e.getMessage());\n  }\n  return scannedResult;\n}\n", "nl": "Below method will be used to process the block"}
{"code": "private void subCheckTheTicTacTocWin(int tag,int i,int j){\n  if (_isGameContinueCheck)   if (getTictactocBoardStatues()[j][i] == tag) {\n    _counter++;\n    if (_counter >= Settings.nWinTheTicTacTocCountNumber) {\n      setTheClientScoreAboutTicTacTok(tag);\n    }\n  }\n else {\n    _counter=0;\n  }\n}\n", "nl": "subCheck the TicTacToc game win using user define constant"}
{"code": "public static void e(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_ERROR) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.e(tag,msg);\n}\n", "nl": "Send an ERROR log message"}
{"code": "private int measureWidthSize(int measureSpec){\n  int defSize=dp2px(DEFAULT_WIDTH);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int result=0;\nswitch (specMode) {\ncase MeasureSpec.UNSPECIFIED:\ncase MeasureSpec.AT_MOST:\n    result=Math.min(defSize,specSize);\n  break;\ncase MeasureSpec.EXACTLY:\nresult=specSize;\nbreak;\n}\nreturn result;\n}\n", "nl": "measure width"}
{"code": "public void remove(String key){\n  if (key == null || key.isEmpty())   return;\n  if (super.containsKey(key))   super.remove(key);\n else   if (this.containsKey(\".\")) {\n    String[] keys=key.split(\"\\\\.\",2);\n    if (super.get(keys[0]) instanceof ConfigSection) {\n      ConfigSection section=(ConfigSection)super.get(keys[0]);\n      section.remove(keys[1]);\n    }\n  }\n}\n", "nl": "Remove config section element"}
{"code": "public int insertFromScan(Scan s){\n  if (!super.insertIntoNextEmptySlot()) {\n    return 0;\n  }\n  for (  String fldName : sch.fields()) {\n    Constant val=s.getVal(fldName);\n    this.setVal(fldName,val);\n  }\n  if (s.next())   return 1;\n else   return -1;\n}\n", "nl": "Insert records to TempRecordFile for sorting, at most one block long"}
{"code": "@NotNull public static String listToString(@NotNull JListFixture list,int startRow,int endRow,int cellWidth){\n  String[] contents=list.contents();\n  StringBuilder sb=new StringBuilder();\n  String formatString=\"%-\" + Integer.toString(cellWidth) + \"s\";\n  for (int row=Math.max(0,startRow); row < Math.min(endRow,contents.length); row++) {\n    String cell=contents[row];\n    if (cell.length() > cellWidth) {\n      cell=cell.substring(0,cellWidth - 3) + \"...\";\n    }\n    sb.append(String.format(formatString,cell));\n    sb.append('\\n');\n  }\n  return sb.toString();\n}\n", "nl": "Pretty-prints the given list fixture"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  final megan.remote.RemoteServiceBrowser remoteServiceBrowser=(megan.remote.RemoteServiceBrowser)getViewer();\n  if (remoteServiceBrowser != null) {\n    String url=remoteServiceBrowser.getURL();\n    if (url.length() > 0) {\n      execute(\"detach remoteServer=\" + url + \";\");\n    }\n  }\n}\n", "nl": "action to be performed"}
{"code": "public static String createStopList(FileSystem fs,boolean hdfs) throws IOException, PIRException {\n  logger.info(\"StopList file being created\");\n  List<String> elements=Arrays.asList(\"something.else.on.stoplist\",\"3.3.3.132\");\n  if (hdfs) {\n    String pirStopListFile=SystemConfiguration.getProperty(DistributedTestDriver.PIR_STOPLIST_FILE);\n    if (pirStopListFile == null) {\n      throw new PIRException(\"HDFS stop list file configuration name is required.\");\n    }\n    HDFS.writeFile(elements,fs,pirStopListFile,true);\n    logger.info(\"pirStopListFile file successfully created on hdfs!\");\n  }\n  String prefix=SystemConfiguration.getProperty(\"pir.stopListFile\");\n  if (prefix == null) {\n    throw new PIRException(\"Local stop list file configuration name is required.\");\n  }\n  return TestUtils.writeToTmpFile(elements,prefix,null);\n}\n", "nl": "Creates stoplist file"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set showBiPlot=\");\n  boolean show=np.getBoolean();\n  np.matchIgnoreCase(\";\");\n  ClusterViewer viewer=getViewer();\n  viewer.getPcoaTab().setShowBiPlot(show);\n  try {\n    viewer.updateView(IDirector.ENABLE_STATE);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public ResourcesPoet addTypedArray(String name,@NotNull List<String> values){\n  Element element=document.createElement(\"array\");\n  element.setAttribute(\"name\",name);\n  for (  String value : values) {\n    Element valueElement=document.createElement(\"item\");\n    valueElement.appendChild(document.createTextNode(value));\n    element.appendChild(valueElement);\n  }\n  resourceElement.appendChild(element);\n  return this;\n}\n", "nl": "Add a typed array to the config"}
{"code": "String brewJava(){\n  StringBuilder java=new StringBuilder();\n  java.append(\"package \").append(classPackage).append(\";\").append(\"\\n\");\n  java.append(\"\\n\");\n  java.append(\"import android.os.Bundle;\").append(\"\\n\");\n  java.append(\"import android.os.Parcelable;\").append(\"\\n\");\n  java.append(\"import java.io.Serializable;\").append(\"\\n\");\n  java.append(\"import java.util.ArrayList;\").append(\"\\n\");\n  java.append(\"\\n\");\n  java.append(\"import com.thirtydegreesray.dataautoaccess.DataAutoAccess;\").append(\"\\n\");\n  java.append(\"import com.thirtydegreesray.dataautoaccess.DataAutoAccess.DataAccessor;\").append(\"\\n\");\n  java.append(\"\\n\");\n  java.append(\"public class \").append(className).append(\"<T extends \").append(targetClass).append(\">\").append(\" implements\").append(\" DataAccessor<T>\").append(\"{\\n\");\n  generateGetDataCode(java);\n  generateSaveDataCode(java);\n  java.append(\"}\\n\");\n  return java.toString();\n}\n", "nl": "generate java code"}
{"code": "public VersionChecker(Context ctx,String versionUrl,int iconResId,int uniqueNotificationId,String notificationUrl){\n  handler=new LeakGuardHandlerWrapper<Context>(ctx);\n  this.userAgent=new OkHttpClient();\n  this.versionUrl=versionUrl;\n  this.iconResId=iconResId;\n  this.notificationUrl=notificationUrl;\n  this.uniqueNotificationId=uniqueNotificationId;\n  try {\n    this.currentVersion=ctx.getPackageManager().getPackageInfo(ctx.getPackageName(),0).versionCode;\n  }\n catch (  NameNotFoundException e) {\n  }\n}\n", "nl": "Creates a simple version checker"}
{"code": "public static String decompressToStringForZlib(byte[] bytesToDecompress){\n  byte[] bytesDecompressed=decompressForZlib(bytesToDecompress);\n  String returnValue=null;\n  try {\n    returnValue=new String(bytesDecompressed,0,bytesDecompressed.length,\"UTF-8\");\n  }\n catch (  UnsupportedEncodingException uee) {\n    uee.printStackTrace();\n  }\n  return returnValue;\n}\n", "nl": "zlib decompress 2 String"}
{"code": "private void computeOffsets(@Nullable ScreenView currentScreenView){\n  if (myDesignSurface != null && currentScreenView != null) {\n    myCurrentScreenViewSize=currentScreenView.getSize(myCurrentScreenViewSize);\n    if (myDesignSurface.getScreenMode() == BOTH) {\n      if (myDesignSurface.isStackVertically()) {\n        mySecondScreenOffset.setLocation(0,myDeviceSize.getHeight() * myDeviceScale + myScaledScreenSpace);\n      }\n else {\n        mySecondScreenOffset.setLocation(myDeviceSize.getWidth() * myDeviceScale + myScaledScreenSpace,0);\n      }\n    }\n  }\n  myCenterOffset=(int)Math.round((PREFERRED_SIZE.getWidth() - myXScreenNumber * myDeviceSize.getWidth() * myDeviceScale) / 2);\n}\n", "nl": "Set the Offsets of the Screens to draw and the offset to center all the content"}
{"code": "private static LeaseMap createBatchLeaseMap(List<Entry> bList,long now){\n  Iterator<Entry> iter=bList.iterator();\n  Entry e=iter.next();\n  LeaseMap batchLeaseMap=e.lease.createLeaseMap(e.getRenewDuration(now));\n  if (e.lease instanceof RemoteMethodControl && batchLeaseMap instanceof RemoteMethodControl) {\n    batchLeaseMap=(LeaseMap)((RemoteMethodControl)batchLeaseMap).setConstraints(ConstrainableProxyUtil.translateConstraints(((RemoteMethodControl)e.lease).getConstraints(),leaseToLeaseMapMethods));\n  }\n  while (iter.hasNext()) {\n    e=iter.next();\n    batchLeaseMap.put(e.lease,new Long(e.getRenewDuration(now)));\n  }\n  return batchLeaseMap;\n}\n", "nl": "Create a LeaseMap for batch renewal"}
{"code": "private void createRecursivly(String path) throws KeeperException, InterruptedException {\n  try {\n    if (zk.exists(path,true) == null && path.length() > 0) {\n      String temp=path.substring(0,path.lastIndexOf(File.separator));\n      createRecursivly(temp);\n      zk.create(path,null,Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);\n    }\n else {\n      return;\n    }\n  }\n catch (  KeeperException e) {\n    throw e;\n  }\ncatch (  InterruptedException e) {\n    throw e;\n  }\n}\n", "nl": "Create zookeepr node if not exist"}
{"code": "@Override public boolean canSetSpeed(){\n  Log.d(SBMP_TAG,\"canSetSpeed() 180\");\n  if (pmInterface == null) {\n    if (!ConnectPlayMediaService()) {\n      ServiceBackedMediaPlayer.this.error(MediaPlayer.MEDIA_ERROR_UNKNOWN,0);\n    }\n  }\n  if (pmInterface != null) {\n    try {\n      return pmInterface.canSetSpeed(ServiceBackedMediaPlayer.this.sessionId);\n    }\n catch (    RemoteException e) {\n      e.printStackTrace();\n      ServiceBackedMediaPlayer.this.error(MediaPlayer.MEDIA_ERROR_UNKNOWN,0);\n    }\n  }\n  return false;\n}\n", "nl": "Returns true if speed can be changed at this moment"}
{"code": "public void read(ByteInputBuffer buffer){\n  size=0;\n  for (PackedOperation op=new PackedOperation(buffer.read()); !op.equals(PackedOperation.terminator()); op=new PackedOperation(buffer.read())) {\n    if (size == transcript.length - 1) {\n      final PackedOperation[] tmp=new PackedOperation[2 * transcript.length];\n      System.arraycopy(transcript,0,tmp,0,size);\n      transcript=tmp;\n    }\n    transcript[size++]=op;\n  }\n}\n", "nl": "read a packed transcript from a buffer"}
{"code": "@Override protected void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  overridePendingTransition(0,0);\n  Scoop.getInstance().apply(this);\n  setContentView(R.layout.activity_main);\n  ButterKnife.bind(this);\n  Scoop.sugarCone().bind(this);\n  setSupportActionBar(mAppBar);\n}\n", "nl": "Lifecycle Methods"}
{"code": "public static Bitmap takeScreenShoteWithoutStatusBar(Activity activity){\n  View view=activity.getWindow().getDecorView();\n  view.setDrawingCacheEnabled(true);\n  view.buildDrawingCache();\n  Bitmap bmp=view.getDrawingCache();\n  int statusBarHeight=getStatusBarHeight(activity);\n  int width=getScreenWidthInPx(activity);\n  int height=getScreenHeightInPx(activity);\n  Bitmap bp=Bitmap.createBitmap(bmp,0,statusBarHeight,width,height - statusBarHeight);\n  view.destroyDrawingCache();\n  return bp;\n}\n", "nl": "Take a screenshot without the status bar"}
{"code": "static public Object deserialiseObject(String xml,String xsdFile,Class<?> objclass) throws JAXBException, SAXException, XMLStreamException {\n  Object obj=null;\n  JAXBContext jaxbContext=getJAXBContext(objclass);\n  SchemaFactory schemaFactory=SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n  final String schemaResourceFilename=new String(xsdFile);\n  URL schemaURL=MalmoMod.class.getClassLoader().getResource(schemaResourceFilename);\n  Schema schema=schemaFactory.newSchema(schemaURL);\n  Unmarshaller jaxbUnmarshaller=jaxbContext.createUnmarshaller();\n  jaxbUnmarshaller.setSchema(schema);\n  StringReader stringReader=new StringReader(xml);\n  XMLInputFactory xif=XMLInputFactory.newFactory();\n  xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES,false);\n  xif.setProperty(XMLInputFactory.SUPPORT_DTD,false);\n  XMLStreamReader XMLreader=xif.createXMLStreamReader(stringReader);\n  obj=jaxbUnmarshaller.unmarshal(XMLreader);\n  return obj;\n}\n", "nl": "Attempt to construct the specified object from this XML string"}
{"code": "public void updateEnableState(String commandName){\n  if (SwingUtilities.isEventDispatchThread())   super.updateEnableState(commandName);\n  for (  MenuItem menuItem : menuItem2CommandFX.keySet()) {\n    ICommand command=menuItem2CommandFX.get(menuItem);\n    if (command.getName().equals(commandName)) {\n      menuItem.setDisable(!command.isApplicable());\n      if (command instanceof ICheckBoxCommand) {\n        ((CheckMenuItem)menuItem).setSelected(((ICheckBoxCommand)command).isSelected());\n      }\n    }\n  }\n}\n", "nl": "update the enable state"}
{"code": "@Override protected Object onGetDefaultValue(TypedArray a,int index){\n  int colorInt;\n  String mHexDefaultValue=a.getString(index);\n  if (mHexDefaultValue != null && mHexDefaultValue.startsWith(\"#\")) {\n    colorInt=convertToColorInt(mHexDefaultValue);\n    return colorInt;\n  }\n else {\n    return a.getColor(index,Color.BLACK);\n  }\n}\n", "nl": "Method edited by"}
{"code": "@Override public int compareTo(IntArrayWrapper other){\n  for (int i=0; i < data.length; i++) {\n    if (data[i] > other.data[i]) {\n      return 1;\n    }\n else     if (data[i] < other.data[i]) {\n      return -1;\n    }\n  }\n  return 0;\n}\n", "nl": "Compare method for ArrayWrapper class this will used to compare Two ArrayWrapper data object, basically it will compare two surrogate keys array to check which one is greater"}
{"code": "private void initialize(){\n  if (_map == null) {\nsynchronized (lazyLock) {\n      if (_map == null) {\n        _map=new ConcurrentHashMap<Key,SoftReference<Value>>();\n      }\n    }\n  }\n}\n", "nl": "Lazy initialization of the map"}
{"code": "public static boolean isFullyEvolved(PokemonId pokemonId){\n  if (EEVEE_FINAL_EVOLUTIONS.contains(pokemonId)) {\n    return true;\n  }\n else {\n    PokemonId[] info=EVOLUTION_INFO.get(pokemonId);\n    return info[info.length - 1] == pokemonId;\n  }\n}\n", "nl": "Tell if a pokemon is fully evolved"}
{"code": "public boolean disableCharacteristicNotify(BluetoothGattCharacteristic characteristic){\n  if (characteristic != null && (characteristic.getProperties() | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {\n    BleLog.w(TAG,\"characteristic.getProperties():\" + characteristic.getProperties());\n    return setCharacteristicNotification(getBluetoothGatt(),characteristic,false);\n  }\n else {\n    return false;\n  }\n}\n", "nl": "stop notify"}
{"code": "@Override public void close(){\n  try {\n    raf.close();\n    System.err.println(\"Closing file: \" + file.getName() + \" (\"+ pages+ \"/\"+ data.length+ \" pages)\");\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n}\n", "nl": "close the array"}
{"code": "IdeFrameFixture create(){\n  WelcomeFrameFixture.find(guiTest.robot()).createNewProject();\n  NewProjectWizardFixture newProjectWizard=NewProjectWizardFixture.find(guiTest.robot());\n  ConfigureAndroidProjectStepFixture configureAndroidProjectStep=newProjectWizard.getConfigureAndroidProjectStep();\n  configureAndroidProjectStep.enterApplicationName(myName).enterCompanyDomain(myDomain).enterPackageName(myPkg);\n  guiTest.setProjectPath(configureAndroidProjectStep.getLocationInFileSystem());\n  newProjectWizard.clickNext();\n  newProjectWizard.getConfigureFormFactorStep().selectMinimumSdkApi(MOBILE,myMinSdk);\n  newProjectWizard.clickNext();\n  newProjectWizard.clickNext();\n  newProjectWizard.getChooseOptionsForNewFileStep().enterActivityName(myActivity);\n  newProjectWizard.clickFinish();\n  guiTest.ideFrame().requestFocusIfLost();\n  if (myWaitForSync) {\n    guiTest.ideFrame().waitForGradleProjectSyncToFinish();\n  }\n  return guiTest.ideFrame();\n}\n", "nl": "Creates a project fixture for this description"}
{"code": "private void initialize(){\n  location=null;\n  IAdaptable element=getElement();\n  if (element instanceof ISVNRepositoryLocation) {\n    location=(ISVNRepositoryLocation)element;\n  }\n else {\n    Object adapter=element.getAdapter(ISVNRepositoryLocation.class);\n    if (adapter instanceof ISVNRepositoryLocation) {\n      location=(ISVNRepositoryLocation)adapter;\n    }\n  }\n  showCredentials=SVNProviderPlugin.getPlugin().getSVNClientManager().getSvnClientInterface().equals(COMMANDLINE_CLIENT);\n  if (!showCredentials) {\n    if (location.getUsername() != null && !location.getUsername().trim().equals(\"\"))     showCredentials=true;\n  }\n}\n", "nl": "Initializes the page"}
{"code": "public void run() throws RepoException {\n  List<String> params=Lists.newArrayList(\"add\");\n  if (force) {\n    params.add(\"-f\");\n  }\n  if (all) {\n    params.add(\"--all\");\n  }\n  params.add(\"--\");\n  Iterables.addAll(params,files);\n  git(getCwd(),addGitDirAndWorkTreeParams(params));\n}\n", "nl": "Run the git command"}
{"code": "public static void abort(@Nullable AsyncAbortable abortable,boolean swallowIOException) throws IOException {\n  if (null == abortable) {\n    return;\n  }\n  try {\n    FutureUtils.result(abortable.asyncAbort());\n  }\n catch (  IOException ioe) {\n    if (swallowIOException) {\n      logger.warn(\"IOException thrown while aborting Abortable {} : \",abortable,ioe);\n    }\n else {\n      throw ioe;\n    }\n  }\n}\n", "nl": "Abort async <i>abortable</i>"}
{"code": "public static byte[] bigDecimalToByte(BigDecimal num){\n  BigInteger sig=new BigInteger(num.unscaledValue().toString());\n  int scale=num.scale();\n  byte[] bscale=new byte[]{(byte)(scale)};\n  byte[] buff=sig.toByteArray();\n  byte[] completeArr=new byte[buff.length + bscale.length];\n  System.arraycopy(bscale,0,completeArr,0,bscale.length);\n  System.arraycopy(buff,0,completeArr,bscale.length,buff.length);\n  return completeArr;\n}\n", "nl": "This method will convert a big decimal value to bytes"}
{"code": "private static String parsePiece(String whole,int[] idx) throws IllegalArgumentException {\n  int start=idx[0];\n  while (idx[0] < whole.length() && isDigitOrPeriod(whole.charAt(idx[0]))) {\n    idx[0]++;\n  }\n  if (idx[0] == whole.length()) {\n    throw new IllegalArgumentException(whole);\n  }\n  idx[0]++;\n  return whole.substring(start,idx[0]);\n}\n", "nl": "TODO: Javadoc"}
{"code": "private boolean doChangeState(State currentState,State acquireState) throws RemoteException, InterruptedException {\n  ServiceItem activeCandidate=findActive();\n  if (activeCandidate != null) {\n    if (_logger.isLoggable(Level.FINE)) {\n      _logger.fine(\"Advance from [\" + currentState + \"] to [\"+ acquireState+ \"] was rejected - found [\"+ activeCandidate.service+ \"] in [ACTIVE] state\");\n    }\n    return false;\n  }\n  if (_logger.isLoggable(Level.FINE)) {\n    _logger.fine(\"Advance from [\" + currentState + \"] to [\"+ acquireState+ \"] was accepted\");\n  }\n  return changeState(currentState,acquireState,false);\n}\n", "nl": "change current state to acquire state in lookup service"}
{"code": "@Nullable public static String createFilePositionUrl(@NotNull File file,int line,int column){\n  try {\n    String fileUrl=SdkUtils.fileToUrlString(file);\n    if (line != -1) {\n      if (column > 0) {\n        return fileUrl + ':' + line+ ':'+ column;\n      }\n else {\n        return fileUrl + ':' + line;\n      }\n    }\n    return fileUrl;\n  }\n catch (  MalformedURLException e) {\n    Logger.getInstance(HtmlLinkManager.class).error(e);\n    return null;\n  }\n}\n", "nl": "Creates a file url for the given file and line position"}
{"code": "private static Rectangle[] widgetsToRectangles(ScoutWidget[] list){\n  Rectangle[] ret=new Rectangle[list.length];\n  for (int i=0; i < ret.length; i++) {\n    int x=list[i].mConstraintWidget.getX();\n    int y=list[i].mConstraintWidget.getY();\n    int w=list[i].mConstraintWidget.getWidth();\n    int h=list[i].mConstraintWidget.getHeight();\n    ret[i]=new Rectangle(x,y,w,h);\n  }\n  return ret;\n}\n", "nl": "Take a list of InferWidgets and return a list of Rectangles"}
{"code": "public void put(E key,double count,boolean keepHigher){\n  if (keepHigher && entries.containsKey(key)) {\n    double oldCount=entries.get(key);\n    if (count > oldCount) {\n      entries.put(key,count);\n    }\n  }\n else {\n    entries.put(key,count);\n  }\n  dirty=true;\n}\n", "nl": "Set the count for the given key if it is larger than the previous one;"}
{"code": "@POST @Path(\"{experimentID}/pages\") @Consumes(APPLICATION_JSON) @ApiOperation(value=\"Post a list of pages to an experiment\",notes=\"Pages can only be added to an experiment with DRAFT, RUNNING, or PAUSED states\") @Timed public Response postPages(@PathParam(\"experimentID\") @ApiParam(value=\"Experiment ID\") final Experiment.ID experimentID,final ExperimentPageList experimentPageList,@HeaderParam(AUTHORIZATION) @ApiParam(value=EXAMPLE_AUTHORIZATION_HEADER,required=true) final String authorizationHeader){\n  Username userName=authorization.getUser(authorizationHeader);\n  Experiment experiment=experiments.getExperiment(experimentID);\n  if (experiment == null) {\n    throw new ExperimentNotFoundException(experimentID);\n  }\n  authorization.checkUserPermissions(userName,experiment.getApplicationName(),CREATE);\n  pages.postPages(experimentID,experimentPageList,authorization.getUserInfo(userName));\n  return httpHeader.headers(CREATED).build();\n}\n", "nl": "Add a list of pages to an experiment"}
{"code": "public BoxUser.Info createAppUser(String clientId,String clientSecret,String publicKeyId,String privateKey,String privateKeyPassword,String enterpriseId) throws BoxSDKServiceException {\n  logger.debug(\"Creating Box App User: {}\",MOJITO_APP_USER_NAME);\n  JWTEncryptionPreferences jwtEncryptionPreferences=boxSDKJWTProvider.getJWTEncryptionPreferences(publicKeyId,privateKey,privateKeyPassword);\n  BoxDeveloperEditionAPIConnection appEnterpriseConnection=BoxDeveloperEditionAPIConnection.getAppEnterpriseConnection(enterpriseId,clientId,clientSecret,jwtEncryptionPreferences,new InMemoryLRUAccessTokenCache(5));\n  CreateUserParams createUserParams=new CreateUserParams();\n  createUserParams.setSpaceAmount(UNLIMITED_SPACE);\n  try {\n    return BoxUser.createAppUser(appEnterpriseConnection,MOJITO_APP_USER_NAME,createUserParams);\n  }\n catch (  BoxAPIException e) {\n    throw new BoxSDKServiceException(\"Couldn't create App User\",e);\n  }\n}\n", "nl": "Create a Box App User"}
{"code": "public static byte[] compressForZlib(byte[] bytesToCompress){\n  Deflater deflater=new Deflater();\n  deflater.setInput(bytesToCompress);\n  deflater.finish();\n  byte[] bytesCompressed=new byte[Short.MAX_VALUE];\n  int numberOfBytesAfterCompression=deflater.deflate(bytesCompressed);\n  byte[] returnValues=new byte[numberOfBytesAfterCompression];\n  System.arraycopy(bytesCompressed,0,returnValues,0,numberOfBytesAfterCompression);\n  return returnValues;\n}\n", "nl": "zlib compress 2 byte"}
{"code": "public static FormatDefinition fromString(String string){\n  FormatDefinition formatDefinition=new FormatDefinition();\n  String[] tokens=string.split(\" \");\n  for (  String word : tokens) {\n    int pos=word.indexOf(\":\");\n    formatDefinition.addItem(word.substring(0,pos),Type.valueOf(word.substring(pos + 1)));\n  }\n  return formatDefinition;\n}\n", "nl": "create a format definition from a defining string"}
{"code": "private static double computeCorrelationDistanceBetweenSeries(String seriesA,String seriesB,Table<String,String,Double> seriesAndClass2Value){\n  final Set<String> classes=seriesAndClass2Value.columnKeySet();\n  final ArrayList<Double> xValues=new ArrayList<>(classes.size());\n  final ArrayList<Double> yValues=new ArrayList<>(classes.size());\n  for (  String className : classes) {\n    xValues.add(seriesAndClass2Value.get(seriesA,className));\n    yValues.add(seriesAndClass2Value.get(seriesB,className));\n  }\n  return 1 - Correlation.computePersonsCorrelationCoefficent(classes.size(),xValues,yValues);\n}\n", "nl": "compute correlation distance between two series"}
{"code": "public void mergeCluster(Cluster xCluster){\n  if (xCluster == null) {\n    throw new NullPointerException(\"Input cluster should not be null\");\n  }\n  ArrayList<String> xDataPoints=xCluster.getAllDataPoints();\n  Iterator<String> it=xDataPoints.iterator();\n  while (it.hasNext()) {\n    this.dataPoints.add(it.next());\n  }\n  this.clusterSize=this.dataPoints.size();\n}\n", "nl": "Given cluster will be merged into this cluster"}
{"code": "private void mapPortBindingProperties(ContainerState containerState,Map<String,Object> networkSettings){\n  if (networkSettings == null) {\n    return;\n  }\n  Map<String,List<Map<String,String>>> portMap=getMap(networkSettings,DOCKER_CONTAINER_NETWORK_SETTINGS_PORTS_PROP_NAME);\n  if (containerState.ports == null) {\n    containerState.ports=new ArrayList<PortBinding>();\n  }\n  if (portMap != null) {\n    List<DockerPortMapping> portMappings=DockerPortMapping.fromMap(portMap);\n    containerState.ports=portMappings.stream().map(null).collect(Collectors.toList());\n  }\n}\n", "nl": "Process port binding properties"}
{"code": "private void drawCenterRect(Canvas canvas){\n  int center=getHeight() / 2;\n  int offset=(int)(getItemHeight() / 2 * 1.2);\n  Paint paint=new Paint();\n  paint.setColor(getResources().getColor(R.color.province_line_border));\n  paint.setStrokeWidth((float)3);\n  canvas.drawLine(0,center - offset,getWidth(),center - offset,paint);\n  canvas.drawLine(0,center + offset,getWidth(),center + offset,paint);\n}\n", "nl": "Draws rect for current value"}
{"code": "public void removeFiles(Collection<OCFile> files,boolean onlyLocalCopy){\n  for (  OCFile file : files) {\n    Intent service=new Intent(mFileActivity,OperationsService.class);\n    service.setAction(OperationsService.ACTION_REMOVE);\n    service.putExtra(OperationsService.EXTRA_ACCOUNT,mFileActivity.getAccount());\n    service.putExtra(OperationsService.EXTRA_REMOTE_PATH,file.getRemotePath());\n    service.putExtra(OperationsService.EXTRA_REMOVE_ONLY_LOCAL,onlyLocalCopy);\n    mWaitingForOpId=mFileActivity.getOperationsServiceBinder().queueNewOperation(service);\n  }\n  mFileActivity.showLoadingDialog(mFileActivity.getString(R.string.wait_a_moment));\n}\n", "nl": "Start operations to delete one or several files"}
{"code": "public boolean isValid(long startTime,long dateTime){\n  long testTime=startTime;\n  if (testTime == dateTime)   return true;\n  while (testTime < dateTime) {\n    testTime=next(startTime,testTime,1);\n    if (testTime == dateTime)     return true;\n  }\n  return false;\n}\n", "nl": "Tests the date to see if it falls within the rules"}
{"code": "private void assertString(String expected) throws CharacterCodingException {\n  byte[] input=expected.getBytes(StandardCharsets.UTF_8);\n  int i=0;\n  int j=0;\n  while (i < input.length) {\n    while (!feeder.isFull() && i < input.length) {\n      feeder.feed(input[i]);\n      ++i;\n    }\n    while (feeder.hasInput()) {\n      assertEquals(expected.charAt(j),feeder.nextInput());\n      ++j;\n    }\n  }\n  assertEquals(expected.length(),j);\n  assertFalse(feeder.hasInput());\n  assertFalse(feeder.isFull());\n}\n", "nl": "Test if a given string can be decoded correctly"}
{"code": "public Long2IntegerBinMap(String fileName) throws IOException, CanceledException {\n  final File file=new File(fileName);\n  if (!file.exists())   throw new IOException(\"No such file: \" + file);\n  if (!file.canRead())   throw new IOException(\"Can't read file: \" + file);\n  if (!isBinFile(fileName))   throw new IOException(\"Wrong magic number: \" + file);\n  try {\n    reader=new IntFileGetterMappedMemory(file);\n  }\n catch (  IOException ex) {\n    System.err.println(\"Opening file: \" + file);\n    reader=new IntFileGetterRandomAccess(file);\n  }\n}\n", "nl": "open a bin  file"}
{"code": "public static void adoptPet(Player player,int eggObjId,int petId,String name,int decorationId){\n  int eggId=player.getInventory().getItemByObjId(eggObjId).getItemId();\n  ItemTemplate template=DataManager.ITEM_DATA.getItemTemplate(eggId);\n  if (!validateAdoption(player,template,petId)) {\n    return;\n  }\n  if (!player.getInventory().decreaseByObjectId(eggObjId,1)) {\n    return;\n  }\n  int expireTime=template.getActions().getAdoptPetAction().getExpireMinutes() != 0 ? (int)((System.currentTimeMillis() / 1000) + template.getActions().getAdoptPetAction().getExpireMinutes() * 60) : 0;\n  addPet(player,petId,name,decorationId,expireTime);\n}\n", "nl": "Create a pet for player (with validation)"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"chart wordCount kmer=\");\n  int kmer=np.getInt(1,Integer.MAX_VALUE);\n  np.matchIgnoreCase(\"step=\");\n  int step=np.getInt(1,Integer.MAX_VALUE);\n  np.matchIgnoreCase(\"mindepth=\");\n  int mindepth=np.getInt(1,Integer.MAX_VALUE);\n  np.matchIgnoreCase(\";\");\n  AlignmentViewer alignmentViewer=(AlignmentViewer)getViewer();\n  DiversityPlotViewer viewer=new DiversityPlotViewer((Director)getDir(),alignmentViewer,kmer,step,mindepth);\n  getDir().addViewer(viewer);\n  viewer.setVisible(true);\n}\n", "nl": "parses the given command and executes it"}
{"code": "public WishlistComponentCursor queryWishlistsComponent(){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=false;\n  qh.Table=S.TABLE_WISHLIST_COMPONENT;\n  qh.Columns=null;\n  qh.Selection=null;\n  qh.SelectionArgs=null;\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  SQLiteQueryBuilder qb=builderWishlistComponent();\n  Cursor cursor=qb.query(getWritableDatabase(),qh.Columns,qh.Selection,qh.SelectionArgs,qh.GroupBy,qh.Having,qh.OrderBy,qh.Limit);\n  return new WishlistComponentCursor(cursor);\n}\n", "nl": "****************************** WISHLIST COMPONENT QUERIES"}
{"code": "public Set<UserDefinedAction> areGesturesRegistered(Collection<MouseGesture> gesture){\n  Set<MouseGesture> collisions=new HashSet<>(actionMap.keySet());\n  collisions.retainAll(gesture);\n  Set<UserDefinedAction> output=new HashSet<>();\n  for (  MouseGesture collision : collisions) {\n    output.add(actionMap.get(collision));\n  }\n  return output;\n}\n", "nl": "Check if any collision between the gestures set and the set of currently registered gestures"}
{"code": "@Override public void put(long index,int value){\n  index<<=2;\n  if (index < fileLength) {\n    final ByteBuffer buf=buffers[getWhichBuffer(index)];\n    int indexBuffer=getIndexInBuffer(index);\n    buf.put(indexBuffer++,(byte)(value >> 24));\n    buf.put(indexBuffer++,(byte)(value >> 16));\n    buf.put(indexBuffer++,(byte)(value >> 8));\n    buf.put(indexBuffer,(byte)(value));\n  }\n else {\n    throw new ArrayIndexOutOfBoundsException(\"\" + index);\n  }\n}\n", "nl": "puts value for given index"}
{"code": "public void readMail(Player player,int letterId){\n  Letter letter=player.getMailbox().getLetterFromMailbox(letterId);\n  if (letter == null) {\n    log.warn(\"Cannot read mail \" + player.getObjectId() + \" \"+ letterId);\n    return;\n  }\n  PacketSendUtility.sendPacket(player,new SM_MAIL_SERVICE(player,letter,letter.getTimeStamp().getTime()));\n  letter.setReadLetter();\n}\n", "nl": "Read letter with specified letter id"}
{"code": "public static <T extends BaseFragment>T newInstance(Class<T> fragmentClazz,Bundle args){\n  T fragment=null;\n  try {\n    fragment=fragmentClazz.newInstance();\n    fragment.setArguments(args);\n  }\n catch (  java.lang.InstantiationException e) {\n    e.printStackTrace();\n  }\ncatch (  IllegalAccessException e) {\n    e.printStackTrace();\n  }\n  return fragment;\n}\n", "nl": "create fragment instance"}
{"code": "public void testSortByVirtualFieldStraight() throws Exception {\n  deleteAllDocs();\n  send(\"addDocument\",\"{fields: {id: 0, boost: 1.0}}\");\n  send(\"addDocument\",\"{fields: {id: 1, boost: 2.0}}\");\n  send(\"search\",\"{query: MatchAllDocsQuery, sort: {fields: [{field: logboost}]}, retrieveFields: [id]}\");\n  assertEquals(2,getInt(\"totalHits\"));\n  assertEquals(0,getInt(\"hits[0].fields.id\"));\n  assertEquals(1,getInt(\"hits[1].fields.id\"));\n  assertEquals(0.0f,getFloat(\"hits[0].fields.sortFields.logboost\"),.0001f);\n  assertEquals(.6931f,getFloat(\"hits[1].fields.sortFields.logboost\"),.0001f);\n}\n", "nl": "Non-reversed sort by virtual field"}
{"code": "public boolean similarTo(Object o){\n  if (o == null) {\n    return false;\n  }\n  if (!(o instanceof SemanticConcept)) {\n    return false;\n  }\n  SemanticConcept otherConcept=(SemanticConcept)o;\n  HashSet<Integer> synset_intersection=new HashSet<Integer>(this.synsets);\n  synset_intersection.retainAll(otherConcept.synsets);\n  if (!synset_intersection.isEmpty()) {\n    return true;\n  }\n  HashSet<String> concept_intersection=new HashSet<String>(this.concepts);\n  concept_intersection.retainAll(otherConcept.concepts);\n  return !concept_intersection.isEmpty();\n}\n", "nl": "SemanticConcepts are similar if they share a synset or a concept"}
{"code": "public IntArrayList top(int n){\n  IntArrayList top=new IntArrayList();\n  int[] values=data.toIntArray();\n  IntArrays.parallelQuickSort(values,ReverseIntComparator.instance());\n  for (int i=0; i < n && i < values.length; i++) {\n    top.add(values[i]);\n  }\n  return top;\n}\n", "nl": "Returns the largest (\"top\") n values in the column"}
{"code": "private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,ContrastMethod contrastMethod){\n  ContrastEnhancement contrastEnhancement=(ContrastEnhancement)styleFactory.contrastEnhancement(null,contrastMethod.name());\n  FilterFactory ff=CommonFactoryFinder.getFilterFactory();\n  Map<String,Expression> options=contrastEnhancement.getOptions();\n  options.put(\"algorithm\",ff.literal(\"TestStretchToMinimumMaximum\"));\n  options.put(\"minValue\",ff.literal(\"1.0\"));\n  options.put(\"maxValue\",ff.literal(\"5.0\"));\n  SelectedChannelType channelType=styleFactory.createSelectedChannelType(\"channel name\",contrastEnhancement);\n  SelectedChannelType[] channels=new SelectedChannelType[3];\n  channels[0]=channelType;\n  channels[1]=channelType;\n  channels[2]=channelType;\n  ChannelSelection channelSelection=styleFactory.createChannelSelection(channels);\n  return channelSelection;\n}\n", "nl": "Creates the channel selection error object"}
{"code": "public List<ModelEntity> induceModelFromDb(Collection<String> messages){\n  ExecutorService executor=Executors.newFixedThreadPool(datasourceInfo.getMaxWorkerPoolSize());\n  TreeSet<String> tableNames=this.getTableNames(messages);\n  Map<String,Map<String,ColumnCheckInfo>> colInfo=getColumnInfo(tableNames,true,messages,executor);\n  List<ModelEntity> newEntList=new LinkedList<ModelEntity>();\n  boolean isCaseSensitive=getIsCaseSensitive(messages);\n  for (  String tableName : new TreeSet<String>(colInfo.keySet())) {\n    Map<String,ColumnCheckInfo> colMap=colInfo.get(tableName);\n    ModelEntity newEntity=new ModelEntity(tableName,colMap,modelFieldTypeReader,isCaseSensitive);\n    newEntList.add(newEntity);\n  }\n  executor.shutdown();\n  return newEntList;\n}\n", "nl": "Creates a list of ModelEntity objects based on meta data from the database"}
{"code": "public static int findHighestMajorVersion(Collection<Throwable> list){\n  int result=0;\n  for (  Throwable t : list) {\n    if (t instanceof InconvertibleClassError) {\n      InconvertibleClassError error=(InconvertibleClassError)t;\n      result=Math.max(result,error.getMajor());\n    }\n  }\n  return result;\n}\n", "nl": "Given a set of exceptions, return the highest known classfile version format"}
{"code": "public static double stringSimilarity(String... strings){\n  if (strings == null)   return 0;\n  Counter<String> counter=new Counter<>();\n  Counter<String> counter2=new Counter<>();\n  for (int i=0; i < strings[0].length(); i++)   counter.incrementCount(String.valueOf(strings[0].charAt(i)),1.0);\n  for (int i=0; i < strings[1].length(); i++)   counter2.incrementCount(String.valueOf(strings[1].charAt(i)),1.0);\n  Set<String> v1=counter.keySet();\n  Set<String> v2=counter2.keySet();\n  Set<String> both=SetUtils.intersection(v1,v2);\n  double scalar=0, norm1=0, norm2=0;\n  for (  String k : both)   scalar+=counter.getCount(k) * counter2.getCount(k);\n  for (  String k : v1)   norm1+=counter.getCount(k) * counter.getCount(k);\n  for (  String k : v2)   norm2+=counter2.getCount(k) * counter2.getCount(k);\n  return scalar / Math.sqrt(norm1 * norm2);\n}\n", "nl": "Calculate string similarity with tfidf weights relative to each character frequency and how many times a character appears in a given string"}
{"code": "private int measureShort(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(2 * mRadius + getPaddingTop() + getPaddingBottom() + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the height of this view"}
{"code": "private void initRecyclerview(){\n  mRecyclerView.setLayoutManager(new GridLayoutManager(this,3));\n  mPicAdapter=new PicAdapter();\n  for (int i=0; i < names.length; i++) {\n    mPicAdapter.add(new Item(images[i],names[i],textDescription));\n  }\n  mRecyclerView.setAdapter(mPicAdapter);\n  ItemTouchHelper.Callback callback=new CustomItHelperCallback(this);\n  ItemTouchHelper touchHelper=new ItemTouchHelper(callback);\n  touchHelper.attachToRecyclerView(mRecyclerView);\n}\n", "nl": "Add data to the List"}
{"code": "@Override protected void entryRemoved(boolean evicted,String key,BitmapDrawable oldValue,BitmapDrawable newValue){\n  if (RecyclingBitmapDrawable.class.isInstance(oldValue)) {\n    ((RecyclingBitmapDrawable)oldValue).setIsCached(false);\n  }\n else {\n    if (Utils.hasHoneycomb()) {\n      mReusableBitmaps.add(new SoftReference<Bitmap>(oldValue.getBitmap()));\n    }\n  }\n}\n", "nl": "Notify the removed entry that is no longer being cached"}
{"code": "public void clearSticky(){\n  int size=headComponentStack.size();\n  while (size > 0 && headerViewStack.size() == size) {\n    WXCell headComponent=headComponentStack.pop();\n    View headerView=headerViewStack.pop();\n    ((ViewGroup)getParent()).removeView(headerView);\n    headComponent.recoverySticky();\n  }\n}\n", "nl": "Clear All Sticky of stack"}
{"code": "public void testImportSubProjectWithCustomLocation() throws IOException, ConfigurationException {\n  VirtualFile projectRoot=createProjectWithSubprojects(Collections.singletonMap(pathToGradleName(SAMPLE_PROJECT_NAME),SAMPLE_PROJECT_PATH));\n  Map<String,VirtualFile> subProjects=moduleListToMap(GradleModuleImporter.getRelatedProjects(projectRoot,getProject()));\n  assertEquals(1,subProjects.size());\n  VirtualFile moduleLocation=projectRoot.findFileByRelativePath(SAMPLE_PROJECT_PATH);\n  assert moduleLocation != null;\n  assertEquals(moduleLocation,subProjects.get(pathToGradleName(SAMPLE_PROJECT_NAME)));\n  GradleModuleImporter.importModules(this,subProjects,getProject(),null);\n  assertModuleImported(getProject(),SAMPLE_PROJECT_NAME,moduleLocation);\n}\n", "nl": "Verify discovery of projects with non-default locations"}
{"code": "public static String extractHostId(String hostId){\n  AssertUtil.assertNotNull(hostId,\"hostId\");\n  int idx=hostId.indexOf(HOST_ID_TENANT_SEPARATOR);\n  String id=hostId;\n  if (idx != -1) {\n    id=hostId.substring(idx + HOST_ID_TENANT_SEPARATOR.length());\n  }\n  return id;\n}\n", "nl": "Extracts the id from a host id"}
{"code": "public INDArray asMatrix(BufferedImage image){\n  if (channels == 3) {\n    return toBgr(image);\n  }\n else {\n    image=scalingIfNeed(image,true);\n    int w=image.getWidth();\n    int h=image.getHeight();\n    INDArray ret=Nd4j.create(h,w);\n    for (int i=0; i < h; i++) {\n      for (int j=0; j < w; j++) {\n        ret.putScalar(new int[]{i,j},image.getRGB(i,j));\n      }\n    }\n    return ret;\n  }\n}\n", "nl": "Convert an BufferedImage to a matrix"}
{"code": "public String writeDataFile() throws DataFileException {\n  ByteArrayOutputStream bos=new ByteArrayOutputStream();\n  writeDataFile(bos);\n  String outString=bos.toString();\n  try {\n    if (bos != null)     bos.close();\n  }\n catch (  IOException e) {\n    Debug.logWarning(e,module);\n  }\n  return outString;\n}\n", "nl": "Returns the records in this DataFile object as a plain text data file content"}
{"code": "public boolean removeByObject(T obj){\n  lock.lock();\n  try {\n    return removeByObject_impl(obj);\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "given an object scan the list, find it and remove it, returns true if found"}
{"code": "private void initialize(Builder builder){\n  if (builder.prefs != null && !builder.flavors.isEmpty()) {\n    mPreferences=builder.prefs;\n    mFlavors=new ArrayList<>(builder.flavors);\n    if (builder.defaultFlavor != null) {\n      mDefaultFlavorIndex=mFlavors.indexOf(builder.defaultFlavor);\n    }\n    mSugarCone=new SugarCone();\n    mInitialized=true;\n  }\n else {\n    throw new IllegalStateException(\"SharedPreferences and at least one flavor must be set\");\n  }\n}\n", "nl": "Initialize this helper class with the provided builder"}
{"code": "public CASCDistanceCalculator(String sPathToCasc) throws IOException {\n  PathToCasc=sPathToCasc;\n  Process p=Runtime.getRuntime().exec(PathToCasc);\n  try {\n    p.waitFor();\n  }\n catch (  InterruptedException iee) {\n    return;\n  }\n}\n", "nl": "Creates a new instance of CASCDistanceCalculator"}
{"code": "public static Map<String,IChartDrawer> createChartDrawers(){\nsynchronized (allSupportedChartDrawers) {\n    final boolean fillAllSupportedDrawers=(allSupportedChartDrawers.size() == 0);\n    final Map<String,IChartDrawer> name2DrawerInstance=new HashMap<>();\n    for (    Object object : PluginClassLoader.getInstances(paths,IChartDrawer.class)) {\n      if (object instanceof IChartDrawer) {\n        final IChartDrawer drawer=(IChartDrawer)object;\n        if (!(drawer instanceof MultiChartDrawer) && drawer.isEnabled()) {\n          name2DrawerInstance.put(drawer.getChartDrawerName(),drawer);\n          if (fillAllSupportedDrawers && !(object instanceof Plot2DDrawer))           allSupportedChartDrawers.add(drawer.getChartDrawerName());\n        }\n      }\n    }\n    return name2DrawerInstance;\n  }\n}\n", "nl": "creates a copy of all chart drawers"}
{"code": "@RequestMapping(value=ClientUris.CONFIG_PULLING,method=RequestMethod.POST) public void pulling(@RequestParam(\"configs\") String configs,HttpServletRequest req,HttpServletResponse resp){\n  ClientSession client=ClientContext.get();\n  assert client != null;\n  if (Strings.isNullOrEmpty(configs)) {\n    return;\n  }\n  Map<String,String> pullingConfigs=JsonUtil.INSTANCE.fromJson(configs,JsonUtil.MAP_STR_STR_TYPE);\n  pullingSupport.pulling(client,pullingConfigs,req,resp);\n}\n", "nl": "Long pulling config"}
{"code": "public static boolean wildcardSimilar(ItemStack template,ItemStack stranger){\n  if (template == null || stranger == null) {\n    return template == stranger;\n  }\n  if (template.getItemDamage() == WILDCARD_DAMAGE) {\n    return template.getItem() == stranger.getItem();\n  }\n  return similar(template,stranger);\n}\n", "nl": "Compare only itemIDs and damage value, taking into account that a damage value of -1 matches any"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"move attribute=\");\n  Set<String> attributes=new HashSet<>();\n  while (!np.peekMatchIgnoreCase(\"direction=\")) {\n    String attribute=np.getWordRespectCase();\n    attributes.add(attribute);\n  }\n  np.matchIgnoreCase(\"direction=\");\n  String direction=np.getWordMatchesIgnoringCase(\"left right\");\n  np.matchIgnoreCase(\";\");\n  if (attributes.size() > 0) {\n    final SamplesViewer viewer=((SamplesViewer)getViewer());\n    viewer.getSamplesTable().moveColumns(direction.equalsIgnoreCase(\"left\"),attributes.toArray(new String[attributes.size()]));\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private void notifyFailedSynchronization(){\n  NotificationCompat.Builder notificationBuilder=createNotificationBuilder();\n  boolean needsToUpdateCredentials=(mLastFailedResult != null && ResultCode.UNAUTHORIZED.equals(mLastFailedResult.getCode()));\n  if (needsToUpdateCredentials) {\n    Intent updateAccountCredentials=new Intent(getContext(),AuthenticatorActivity.class);\n    updateAccountCredentials.putExtra(AuthenticatorActivity.EXTRA_ACCOUNT,getAccount());\n    updateAccountCredentials.putExtra(AuthenticatorActivity.EXTRA_ACTION,AuthenticatorActivity.ACTION_UPDATE_EXPIRED_TOKEN);\n    updateAccountCredentials.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    updateAccountCredentials.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n    updateAccountCredentials.addFlags(Intent.FLAG_FROM_BACKGROUND);\n    notificationBuilder.setTicker(i18n(R.string.sync_fail_ticker_unauthorized)).setContentTitle(i18n(R.string.sync_fail_ticker_unauthorized)).setContentIntent(PendingIntent.getActivity(getContext(),(int)System.currentTimeMillis(),updateAccountCredentials,PendingIntent.FLAG_ONE_SHOT)).setContentText(i18n(R.string.sync_fail_content_unauthorized,getAccount().name));\n  }\n else {\n    notificationBuilder.setTicker(i18n(R.string.sync_fail_ticker)).setContentTitle(i18n(R.string.sync_fail_ticker)).setContentText(i18n(R.string.sync_fail_content,getAccount().name));\n  }\n  showNotification(R.string.sync_fail_ticker,notificationBuilder);\n}\n", "nl": "Notifies the user about a failed synchronization through the status notification bar"}
{"code": "private void openCounterDataOutputStream() throws DataFallbackException {\n  if (dOutput == null) {\n    if (LOG.isDebugEnabled())     LOG.debug(\"openDataOutputStream() ; Opening the writer for the \" + counterFile.getName() + \" file\");\n    try {\n      dOutput=new BufferedWriter(new FileWriter(counterFile));\n    }\n catch (    IOException e) {\n      throw new DataFallbackException(e.getMessage());\n    }\n  }\n}\n", "nl": "It opens the counter binary file for writing"}
{"code": "public void toString(StringBuffer sb){\n  sb.append(indent() + \"try (\");\n  for (  ResourceDeclaration resource : getResourceList()) {\n    sb.append(resource.toString());\n  }\n  sb.append(\") \");\n  getBlock().toString(sb);\n  for (  CatchClause cc : getCatchClauseList()) {\n    sb.append(\" \");\n    cc.toString(sb);\n  }\n  if (hasFinally()) {\n    sb.append(\" finally \");\n    getFinally().toString(sb);\n  }\n}\n", "nl": "Pretty printing of try-with-resources"}
{"code": "public static boolean isNetworkConnected(Context context){\n  if (null == context) {\n    return false;\n  }\n  ConnectivityManager connectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);\n  if (connectivityManager != null) {\n    NetworkInfo info=connectivityManager.getActiveNetworkInfo();\n    if (info != null && info.isConnected()) {\n      if (info.getState() == NetworkInfo.State.CONNECTED) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "whether the network is connected"}
{"code": "public static final Authentication create(String authPluginClassName,Map<String,String> authParams) throws UnsupportedAuthenticationException {\n  try {\n    if (isNotBlank(authPluginClassName)) {\n      Class<?> authClass=Class.forName(authPluginClassName);\n      Authentication auth=(Authentication)authClass.newInstance();\n      auth.configure(authParams);\n      return auth;\n    }\n else {\n      return new AuthenticationDisabled();\n    }\n  }\n catch (  Throwable t) {\n    throw new UnsupportedAuthenticationException(t);\n  }\n}\n", "nl": "Create an instance of the Authentication-Plugin"}
{"code": "private void initDefaultValues(){\n  myName.set(getUniqueId(null));\n  myDiagonalScreenSize.set(5.0);\n  myScreenResolutionWidth.set(1080);\n  myScreenResolutionHeight.set(1920);\n  myRamStorage.set(new Storage(2,Storage.Unit.GiB));\n  myHasHardwareButtons.set(false);\n  myHasHardwareKeyboard.set(false);\n  myNavigation.setValue(Navigation.NONAV);\n  mySupportsPortrait.set(true);\n  mySupportsLandscape.set(true);\n  myHasFrontCamera.set(true);\n  myHasBackCamera.set(true);\n  myHasAccelerometer.set(true);\n  myHasGyroscope.set(true);\n  myHasGps.set(true);\n  myHasProximitySensor.set(true);\n}\n", "nl": "Initialize a reasonable set of default values (based on the Nexus 5)"}
{"code": "public synchronized void removeAllFor(String nodeId){\n  RoutesMap rl=forwardTable.remove(nodeId);\n  if (rl == null) {\n    Set<String> targets=inverseTable.remove(nodeId);\n    if (targets != null) {\n      for (      String to : targets) {\n        RoutesMap trl=forwardTable.get(to);\n        if (trl != null) {\n          trl.remove(nodeId);\n          if (trl.size() == 0) {\n            forwardTable.remove(to);\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "Removes the information for this node from the table, either if it's a target node or a via node"}
{"code": "public void removeBites(){\n  setImageDrawable(drawableChomp);\n  bitesTakenMap=new HashMap<>();\n  for (  int direction : BITE_DIRECTIONS_LIST) {\n    bitesTakenMap.put(direction,0);\n  }\n  hasAllBitesTaken=false;\n  numBitesForOneDirection=(imageCircleRadius * 2) / biteRadius;\n}\n", "nl": "Public methods"}
{"code": "private int measureHeight(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=mPaintSelected.getStrokeWidth() + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)((float)Math.ceil(result));\n}\n", "nl": "Determines the height of this view"}
{"code": "private void addPortBindings(CommandInput input,PortBinding[] portBindings){\n  Map<String,Map<String,String>> exposedPortsMap=new HashMap<>();\n  input.withProperty(DOCKER_CONTAINER_EXPOSED_PORTS_PROP_NAME,exposedPortsMap);\n  Map<String,Object> hostConfig=getOrAddMap(input,DOCKER_CONTAINER_HOST_CONFIG_PROP_NAME);\n  Map<String,List<Map<String,String>>> portBindingsMap=new HashMap<>();\n  hostConfig.put(DOCKER_CONTAINER_PORT_BINDINGS_PROP_NAME,portBindingsMap);\n  for (  PortBinding portBinding : portBindings) {\n    exposedPortsMap.put(portBinding.containerPort,Collections.emptyMap());\n    DockerPortMapping mapping=DockerPortMapping.fromString(portBinding.toString());\n    Map<String,List<Map<String,String>>> portDetails=mapping.toMap();\n    portBindingsMap.putAll(portDetails);\n  }\n}\n", "nl": "Map port binding to ExposedPorts and PortBinding ExposedPorts are only used by the API adapter, as the docker CLI will add that itself"}
{"code": "public SourceContextAndPath extendPath(Abstraction abs,boolean trackPath){\n  if (abs == null)   return this;\n  if (abs.getCurrentStmt() == null && abs.getCorrespondingCallSite() == null)   return this;\n  if (abs.getCorrespondingCallSite() == null && !trackPath)   return this;\n  if (this.path != null)   for (  Abstraction a : this.path)   if (a == abs)   return null;\n  SourceContextAndPath scap=clone();\n  if (trackPath && abs.getCurrentStmt() != null) {\n    if (scap.path == null)     scap.path=new ArrayList<Abstraction>();\n    scap.path.add(0,abs);\n  }\n  if (abs.getCorrespondingCallSite() != null && abs.getCorrespondingCallSite() != abs.getCurrentStmt()) {\n    if (scap.callStack == null)     scap.callStack=new ArrayList<Stmt>();\n    scap.callStack.add(0,abs.getCorrespondingCallSite());\n  }\n  return scap;\n}\n", "nl": "Extends the taint propagation path with the given abstraction"}
{"code": "@Override public void bindDisappearEvent(WXComponent component){\n  ConcurrentHashMap<String,AppearData> appearMap=mAppearMap.get(getRef());\n  if (appearMap == null) {\n    appearMap=new ConcurrentHashMap<>();\n  }\n  AppearData appearData=appearMap.get(component.getRef());\n  if (appearData == null) {\n    appearData=new AppearData();\n  }\n  appearData.mAppearComponent=component;\n  appearData.hasDisappear=true;\n  appearMap.put(component.getRef(),appearData);\n  mAppearMap.put(getRef(),appearMap);\n}\n", "nl": "Bind disappear event"}
{"code": "public String groupName(){\n  int i=name.indexOf(\".\");\n  if (i > 0) {\n    int j=name.indexOf(\".\",i + 1);\n    if (j > 0) {\n      return name.substring(0,j);\n    }\n else {\n      return name.substring(0,i);\n    }\n  }\n  return \"access\";\n}\n", "nl": "get the group name of the access name"}
{"code": "private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints,float oldSide,float newSide){\n  float ratio=newSide / (2 * oldSide);\n  float dx=cornerPoints[0].getX() - cornerPoints[2].getX();\n  float dy=cornerPoints[0].getY() - cornerPoints[2].getY();\n  float centerx=(cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;\n  float centery=(cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;\n  ResultPoint result0=new ResultPoint(centerx + ratio * dx,centery + ratio * dy);\n  ResultPoint result2=new ResultPoint(centerx - ratio * dx,centery - ratio * dy);\n  dx=cornerPoints[1].getX() - cornerPoints[3].getX();\n  dy=cornerPoints[1].getY() - cornerPoints[3].getY();\n  centerx=(cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;\n  centery=(cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;\n  ResultPoint result1=new ResultPoint(centerx + ratio * dx,centery + ratio * dy);\n  ResultPoint result3=new ResultPoint(centerx - ratio * dx,centery - ratio * dy);\n  return new ResultPoint[]{result0,result1,result2,result3};\n}\n", "nl": "Expand the square represented by the corner points by pushing out equally in all directions"}
{"code": "protected soot.Value createLHS(polyglot.ast.Expr expr){\n  if (expr instanceof polyglot.ast.Local) {\n    return getLocal((polyglot.ast.Local)expr);\n  }\n else   if (expr instanceof polyglot.ast.ArrayAccess) {\n    return getArrayRefLocalLeft((polyglot.ast.ArrayAccess)expr);\n  }\n else   if (expr instanceof polyglot.ast.Field) {\n    return getFieldLocalLeft((polyglot.ast.Field)expr);\n  }\n else {\n    throw new RuntimeException(\"Unhandled LHS\");\n  }\n}\n", "nl": "create LHS expressions"}
{"code": "public static boolean stopRunningService(Context context,String className){\n  Intent intent_service=null;\n  boolean ret=false;\n  try {\n    intent_service=new Intent(context,Class.forName(className));\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  if (intent_service != null) {\n    ret=context.stopService(intent_service);\n  }\n  return ret;\n}\n", "nl": "Stop running service"}
{"code": "protected void drawBlurredBitmap(Canvas canvas,Bitmap blurredBitmap,int overlayColor){\n  if (blurredBitmap != null) {\n    mRectSrc.right=blurredBitmap.getWidth();\n    mRectSrc.bottom=blurredBitmap.getHeight();\n    mRectDst.right=getWidth();\n    mRectDst.bottom=getHeight();\n    canvas.drawBitmap(blurredBitmap,mRectSrc,mRectDst,null);\n  }\n  canvas.drawColor(overlayColor);\n}\n", "nl": "Custom draw the blurred bitmap and color to define your own shape"}
{"code": "@Override protected void entryRemoved(boolean evicted,String key,BitmapDrawable oldValue,BitmapDrawable newValue){\n  if (RecyclingBitmapDrawable.class.isInstance(oldValue)) {\n    ((RecyclingBitmapDrawable)oldValue).setIsCached(false);\n  }\n else {\n    if (Utils.hasHoneycomb()) {\n      mReusableBitmaps.add(new SoftReference<Bitmap>(oldValue.getBitmap()));\n    }\n  }\n}\n", "nl": "Notify the removed entry that is no longer being cached"}
{"code": "protected void checkIdentityFieldMatrix(FieldMatrix<Fraction> m){\n  for (int i=0; i < m.getRowDimension(); i++) {\n    for (int j=0; j < m.getColumnDimension(); j++) {\n      if (i == j) {\n        Assert.assertEquals(m.getEntry(i,j),Fraction.ONE);\n      }\n else {\n        Assert.assertEquals(m.getEntry(i,j),Fraction.ZERO);\n      }\n    }\n  }\n}\n", "nl": "Verifies that the matrix is an identity matrix"}
{"code": "private int measureWidth(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=mViewPager.getAdapter().getCount();\n    result=getPaddingLeft() + getPaddingRight() + (count * mLineWidth)+ ((count - 1) * mGapWidth);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)((float)Math.ceil(result));\n}\n", "nl": "Determines the width of this view"}
{"code": "public String upload_appender_file1(String group_name,String local_filename,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String parts[]=this.upload_appender_file(group_name,local_filename,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload appender file to storage server (by file name)"}
{"code": "public static <T extends Bean>T load(String collection,Bson query,Class<T> clazz){\n  try {\n    return load(collection,query,clazz.newInstance());\n  }\n catch (  Exception e) {\n    if (log.isErrorEnabled())     log.error(e.getMessage(),e);\n  }\n  return null;\n}\n", "nl": "Load the data by the query"}
{"code": "public static final void sendItemUpdatePacket(Player player,StorageType storageType,Item item,ItemUpdateType updateType){\nswitch (storageType) {\ncase CUBE:\n    PacketSendUtility.sendPacket(player,new SM_INVENTORY_UPDATE_ITEM(player,item,updateType));\n  break;\ncase LEGION_WAREHOUSE:\nif (item.getItemTemplate().isKinah()) {\n  PacketSendUtility.sendPacket(player,new SM_LEGION_EDIT(0x04,player.getLegion()));\n  break;\n}\ndefault :\nPacketSendUtility.sendPacket(player,new SM_WAREHOUSE_UPDATE_ITEM(player,item,storageType.getId(),updateType));\n}\n}\n", "nl": "Item will be updated in UI slot (stacked items)"}
{"code": "private synchronized void invokeReadAheadCallback(){\n  if (null != readAheadCallback) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Cache has space, schedule the read ahead\");\n    }\n    readAheadCallback.resumeReadAhead();\n    readAheadCallback=null;\n  }\n}\n", "nl": "Trigger read ahead callback"}
{"code": "public boolean takePhoto(){\n  this.thePhotoName=\"MagicalCamera\";\n  this.anotherPhotoName=\"MagicalCamera\";\n  Intent intent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE);\n  Uri FileUri=getPhotoFileUri(this.thePhotoName,this.anotherPhotoName,this.activity);\n  if (FileUri != null) {\n    intent.putExtra(MediaStore.EXTRA_OUTPUT,FileUri);\n    if (intent.resolveActivity(this.activity.getPackageManager()) != null) {\n      this.activity.startActivityForResult(intent,TAKE_PHOTO);\n    }\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "This method call the intent to take photo"}
{"code": "private void showLabel(boolean animate){\n  if (animate) {\n    mLabel.setVisibility(View.VISIBLE);\n    ViewCompat.setTranslationY(mLabel,mLabel.getHeight());\n    float scale=mEditText.getTextSize() / mLabel.getTextSize();\n    ViewCompat.setScaleX(mLabel,scale);\n    ViewCompat.setScaleY(mLabel,scale);\n    ViewCompat.animate(mLabel).translationY(0f).scaleY(1f).scaleX(1f).setDuration(ANIMATION_DURATION).setListener(null).setInterpolator(mInterpolator).start();\n  }\n else {\n    mLabel.setVisibility(VISIBLE);\n  }\n  mEditText.setHint(null);\n}\n", "nl": "Show the label"}
{"code": "public static List<BigInteger> embeddedSelectorToPartitions(String selector,String type,DataPartitioner partitioner) throws PIRException {\n  List<BigInteger> parts;\n  int partitionBits=partitioner.getBits(type);\n  if (partitionBits > 32) {\n    int hashedSelector=KeyedHash.hash(\"aux\",32,selector,\"MD5\");\n    parts=partitioner.toPartitions(hashedSelector,PrimitiveTypePartitioner.INT);\n  }\n else {\n    parts=partitioner.toPartitions(selector,type);\n  }\n  return parts;\n}\n", "nl": "Method to convert the given selector into the extracted BigInteger partitions"}
{"code": "public static void dump(String title,FloatList list){\n  System.out.println(title);\n  FloatList cur=list;\n  do {\n    System.out.println(\"Item: \" + cur.value);\n    cur=cur.next;\n  }\n while (cur != list);\n}\n", "nl": "prints out the contents of this list"}
{"code": "public static String[] split(byte[] text,int offset,int end,byte splitChar){\n  while (Character.isWhitespace((char)text[offset]) && offset < end)   offset++;\n  int count=0;\n  for (int i=offset; i < end; i++) {\n    if (text[i] == splitChar)     count++;\n  }\n  String[] result=new String[count];\n  count=0;\n  for (int i=offset; i < end; i++) {\n    if (text[i] == splitChar) {\n      result[count++]=new String(text,offset,i - offset);\n      offset=i + 1;\n    }\n  }\n  return result;\n}\n", "nl": "split a given text into strings"}
{"code": "@Override protected void addSubView(View child,int index){\n  if (child == null || getRealView() == null) {\n    return;\n  }\n  if (child instanceof WXBaseRefreshLayout) {\n    return;\n  }\n  int count=getRealView().getChildCount();\n  index=index >= count ? -1 : index;\n  if (index == -1) {\n    getRealView().addView(child);\n  }\n else {\n    getRealView().addView(child,index);\n  }\n}\n", "nl": "Intercept refresh view and loading view"}
{"code": "public IDataProcessStatus makeCopy(){\n  IDataProcessStatus copy=new DataProcessTaskStatus();\n  copy.setTableName(this.tableName);\n  copy.setDataloadstatusid(this.dataloadstatusid);\n  copy.setDesc(this.desc);\n  copy.setKey(this.key);\n  copy.setDatabaseName(databaseName);\n  copy.setStatus(status);\n  return copy;\n}\n", "nl": "to make a copy"}
{"code": "public static PageRespJson buildFailureResponse(String errorMsg,Integer reqId){\n  PageRespJson respJson=new PageRespJson();\n  respJson.setCode(ResponseCode.FAILURE.getCode());\n  respJson.setMsg(errorMsg);\n  respJson.setReqId(reqId);\n  respJson.setRecordsTotal(0L);\n  respJson.setRecordsFiltered(0L);\n  return respJson;\n}\n", "nl": "Construct Failure Response"}
{"code": "protected final void writeS(String text,int size){\n  if (text == null) {\n    buf.put(new byte[size]);\n  }\n else {\n    final int len=text.length();\n    for (int i=0; i < len; i++) {\n      buf.putChar(text.charAt(i));\n    }\n    buf.put(new byte[size - (len * 2)]);\n  }\n}\n", "nl": "Write String to buffer"}
{"code": "private void loadBinaryData(DataInputStream dis) throws IOException {\n  for (int f=0; f < numFrames; f++) {\n    times[f]=General.readFloat(dis,isBigEndian);\n    General.readFloat(dis,isBigEndian);\n    for (int c=0; c < numChannels; c++) {\n      frames[f][c]=General.readFloat(dis,isBigEndian);\n    }\n  }\n}\n", "nl": "load the data section of the file as ascii text"}
{"code": "protected boolean exists(final ISVNRemoteResource child,IProgressMonitor monitor) throws SVNException {\n  ISVNRemoteResource[] members;\n  try {\n    members=getMembers(monitor);\n  }\n catch (  SVNException e) {\n    if (e.getStatus().getCode() == SVNStatus.DOES_NOT_EXIST) {\n      return false;\n    }\n else {\n      throw e;\n    }\n  }\n  for (int i=0; i < members.length; i++) {\n    if (members[i].equals(child))     return true;\n  }\n  return false;\n}\n", "nl": "Check whether the given child exists"}
{"code": "private static float calculateScore(final int[] playCounts){\n  if (playCounts == null) {\n    return 0;\n  }\n  float score=0;\n  for (int i=0; i < Math.min(playCounts.length,NUM_WEEKS); i++) {\n    score+=playCounts[i] * getScoreMultiplierForWeek(i);\n  }\n  return score;\n}\n", "nl": "Calculates the score of the song given the play counts"}
{"code": "public static void i(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_INFO) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.i(tag,msg);\n}\n", "nl": "Send an INFO log message"}
{"code": "private static long dateStringToMSec(FieldDef fd,String s) throws ParseException {\n  assert fd.valueType == FieldDef.FieldValueType.DATE_TIME;\n  Calendar calendar=new GregorianCalendar(TimeZone.getTimeZone(\"UTC\"),Locale.ROOT);\n  calendar.setLenient(false);\n  SimpleDateFormat dateTimeFormat=new SimpleDateFormat(fd.dateTimeFormat,Locale.ROOT);\n  dateTimeFormat.setCalendar(calendar);\n  ParsePosition pos=new ParsePosition(0);\n  Date date=dateTimeFormat.parse(s,pos);\n  if (pos.getErrorIndex() != -1) {\n    throw new ParseException(\"could not parse field \\\"\" + fd.name + \"\\\", value \\\"\"+ s+ \"\\\" as date with format \\\"\"+ fd.dateTimeFormat+ \"\\\"\",pos.getErrorIndex());\n  }\n  if (pos.getIndex() != s.length()) {\n    throw new ParseException(\"could not parse field \\\"\" + fd.name + \"\\\", value \\\"\"+ s+ \"\\\" as date with format \\\"\"+ fd.dateTimeFormat+ \"\\\"\",pos.getIndex());\n  }\n  return date.getTime();\n}\n", "nl": "NOTE: this is a slow method, since it makes many objects just to parse one date/time value"}
{"code": "protected boolean remLink(String field,int len,int n,int e){\n  int[] array=(int[])m_links.get(n,field);\n  for (int i=0; i < len; ++i) {\n    if (array[i] == e) {\n      System.arraycopy(array,i + 1,array,i,len - i - 1);\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Internal method for removing a link from an adjacency list"}
{"code": "private static CopyState readCopyState(DataInput in) throws IOException {\n  byte[] infosBytes=new byte[in.readVInt()];\n  in.readBytes(infosBytes,0,infosBytes.length);\n  long gen=in.readVLong();\n  long version=in.readVLong();\n  Map<String,FileMetaData> files=CopyFilesHandler.readFilesMetaData(in);\n  int count=in.readVInt();\n  Set<String> completedMergeFiles=new HashSet<>();\n  for (int i=0; i < count; i++) {\n    completedMergeFiles.add(in.readString());\n  }\n  long primaryGen=in.readVLong();\n  return new CopyState(files,version,gen,infosBytes,completedMergeFiles,primaryGen,null);\n}\n", "nl": "Pulls CopyState off the wire"}
{"code": "public final void testCloseInputStream(){\n  FallbackFileController fFileController=new FallbackFileController(PATH);\n  try {\n    fFileController.closeFallbackInputStream();\n  }\n catch (  DataFallbackException e) {\n    fail(\"The InputStream could not be closed\");\n  }\n  assertNull(fFileController.getInput());\n}\n", "nl": "Tests the CloseInputStream method, the test is successful when the stream is correclty closed"}
{"code": "public static final void sendItemDeletePacket(Player player,StorageType storageType,Item item,ItemDeleteType deleteType){\nswitch (storageType) {\ncase CUBE:\n    PacketSendUtility.sendPacket(player,new SM_DELETE_ITEM(item.getObjectId(),deleteType));\n  break;\ndefault :\nPacketSendUtility.sendPacket(player,new SM_DELETE_WAREHOUSE_ITEM(storageType.getId(),item.getObjectId(),deleteType));\n}\nPacketSendUtility.sendPacket(player,SM_CUBE_UPDATE.cubeSize(storageType,player));\n}\n", "nl": "Item will be deleted from UI slot"}
{"code": "public void waitUntilClosed() throws InterruptedException {\n  mutex.lock();\n  try {\n    while (state != State.Closed) {\n      isClosedCondition.await();\n    }\n  }\n  finally {\n    mutex.unlock();\n  }\n}\n", "nl": "Block until the service is finally closed"}
{"code": "public static boolean isMatchPattern(final String string,final String patternString){\n  boolean result=false;\n  if (string != null && patternString != null) {\n    if (patternString.indexOf(METCH_PATTERN) >= 0) {\n      String matchPattern=Constant.Symbol.XOR + patternString.replaceAll(METCH_PATTERN_REGEX,METCH_PATTERN_REPLACEMENT) + Constant.Symbol.DOLLAR;\n      result=isMatchRegex(string,matchPattern);\n    }\n else {\n      if (string.equals(patternString)) {\n        result=true;\n      }\n    }\n  }\n  return result;\n}\n", "nl": "<p>Method:only for '*' match pattern,return true of false</p>"}
{"code": "private void showSticky(){\n  WXCell headComponent=headComponentStack.pop();\n  headComponentStack.push(headComponent);\n  View headerView=headComponent.getRealView();\n  if (headerView == null)   return;\n  headerViewStack.push(headerView);\n  headComponent.removeSticky();\n  ((ViewGroup)getParent()).addView(headerView);\n}\n", "nl": "Pop stickyView to stack"}
{"code": "void initOutputDirectory() throws CommandException {\n  if (outputDirectoryParam == null) {\n    outputDirectoryPath=Paths.get(nameParam);\n  }\n else {\n    outputDirectoryPath=Paths.get(outputDirectoryParam);\n  }\n  try {\n    java.nio.file.Files.createDirectories(outputDirectoryPath);\n  }\n catch (  IOException ioe) {\n    throw new CommandException(\"Error creating output directory\",ioe);\n  }\n}\n", "nl": "Create a directory that will contain the demo resource bundle"}
{"code": "public final boolean equals(Object obj){\n  if (toString() == null) {\n    return (obj != null) && (obj.toString() == null);\n  }\n  if (obj instanceof Type) {\n    return toString().equals(obj.toString());\n  }\n  return false;\n}\n", "nl": "Finalizes the equals method"}
{"code": "public int diff_commonPrefix(String text1,String text2){\n  int n=Math.min(text1.length(),text2.length());\n  for (int i=0; i < n; i++) {\n    if (text1.charAt(i) != text2.charAt(i)) {\n      return i;\n    }\n  }\n  return n;\n}\n", "nl": "Determine the common prefix of two strings"}
{"code": "public void showSvnProperties(ISVNRemoteResource resource) throws SVNException {\n  this.remoteResource=resource;\n  this.resource=null;\n  if (remoteResource != null) {\n    if (remoteResource.getRevision() != null) {\n      setContentDescription(Policy.bind(\"SvnRevPropertiesView.titleWithTwoArguments\",remoteResource.getRevision().toString(),remoteResource.getName()));\n    }\n  }\n else {\n    setContentDescription(\"\");\n  }\n  updateStatus();\n}\n", "nl": "Shows the properties for the given resource"}
{"code": "private boolean parseUnescapedField(int fieldUpto) throws ParseException {\n  int fieldStart=bufferUpto;\n  while (bufferUpto < bytes.length) {\n    byte b=bytes[bufferUpto++];\n    if (b == delimChar) {\n      addOneField(fieldUpto,fieldStart,bufferUpto - fieldStart - 1);\n      return true;\n    }\n else     if (b == NEWLINE) {\n      addOneField(fieldUpto,fieldStart,bufferUpto - fieldStart - 1);\n      bufferUpto--;\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Returns true if a field was parsed, else false if the end of the bytes was hit first"}
{"code": "public void useItem(ItemId type) throws RemoteServerException, LoginFailedException {\n  if (type == ItemId.UNRECOGNIZED) {\n    throw new IllegalArgumentException(\"You cannot use item for UNRECOGNIZED\");\n  }\nswitch (type) {\ncase ITEM_INCENSE_ORDINARY:\ncase ITEM_INCENSE_SPICY:\ncase ITEM_INCENSE_COOL:\ncase ITEM_INCENSE_FLORAL:\n    useIncense(type);\n  break;\ndefault :\nbreak;\n}\n}\n", "nl": "use an item with itemID"}
{"code": "public void changeItemTextAtPosition(int itemIndex,String newText){\n  if (itemIndex < 0 || itemIndex > spaceItems.size()) {\n    throwArrayIndexOutOfBoundsException(itemIndex);\n  }\n else {\n    SpaceItem spaceItem=spaceItems.get(itemIndex);\n    RelativeLayout textAndIconContainer=(RelativeLayout)spaceItemList.get(itemIndex);\n    TextView spaceItemIcon=(TextView)textAndIconContainer.findViewById(R.id.space_text);\n    spaceItemIcon.setText(newText);\n    spaceItem.setItemName(newText);\n    changedItemAndIconHashMap.put(itemIndex,spaceItem);\n  }\n}\n", "nl": "Change item text if space navigation already set up"}
{"code": "public void testRetrieveVirtualFieldWithSort() throws Exception {\n  deleteAllDocs();\n  send(\"addDocument\",\"{fields: {id: 0, boost: 1.0}}\");\n  send(\"addDocument\",\"{fields: {id: 1, boost: 2.0}}\");\n  send(\"search\",\"{query: MatchAllDocsQuery, sort: {fields: [{field: logboost}]}, retrieveFields: [id, logboost]}\");\n  assertEquals(2,getInt(\"totalHits\"));\n  assertEquals(0,getInt(\"hits[0].fields.id\"));\n  assertEquals(1,getInt(\"hits[1].fields.id\"));\n  assertEquals(0.0f,getFloat(\"hits[0].fields.logboost\"),.0001f);\n  assertEquals(.6931f,getFloat(\"hits[1].fields.logboost\"),.0001f);\n}\n", "nl": "Sort by virtual field, and ask for its value"}
{"code": "public static boolean isSuperInterface(Class child,String sup){\n  if (child == null)   return false;\n  if (child.getCanonicalName().equals(sup))   return true;\n  Class[] interfaces=child.getInterfaces();\n  for (  Class in : interfaces) {\n    if (in.getCanonicalName().equals(sup)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Check out if it is a super interface of child"}
{"code": "public static Method findMethodWith(Class<?> searchClass,Class<? extends Annotation> annotationClass){\n  Method foundMethod=null;\n  methodFinder:   while (searchClass != null && searchClass != Object.class) {\n    for (    Method method : searchClass.getDeclaredMethods()) {\n      if (method.isAnnotationPresent(annotationClass)) {\n        foundMethod=method;\n        break methodFinder;\n      }\n    }\n    searchClass=searchClass.getSuperclass();\n  }\n  return foundMethod;\n}\n", "nl": "Return a first occurrence of a method annotated with specified annotation"}
{"code": "private double[] calculateAbsoluteDifferences(final double[] z) throws MathIllegalArgumentException, NullArgumentException {\n  if (z == null) {\n    throw new NullArgumentException();\n  }\n  if (z.length == 0) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.NO_DATA);\n  }\n  final double[] zAbs=new double[z.length];\n  for (int i=0; i < z.length; ++i) {\n    zAbs[i]=FastMath.abs(z[i]);\n  }\n  return zAbs;\n}\n", "nl": "Calculates |z[i]| for all i"}
{"code": "public static Bitmap blurNatively(Bitmap original,int radius,boolean canReuseInBitmap){\n  if (radius < 1) {\n    return null;\n  }\n  Bitmap bitmap=buildBitmap(original,canReuseInBitmap);\n  if (radius == 1) {\n    return bitmap;\n  }\n  blurBitmap(bitmap,radius);\n  return (bitmap);\n}\n", "nl": "StackBlur By Jni Bitmap"}
{"code": "public static void kickAccount(int accountId){\nsynchronized (AccountController.class) {\n    for (    GameServerInfo gsi : GameServerTable.getGameServers()) {\n      if (gsi.isAccountOnGameServer(accountId)) {\n        gsi.getConnection().sendPacket(new SM_REQUEST_KICK_ACCOUNT(accountId));\n        break;\n      }\n    }\n    if (accountsOnLS.containsKey(accountId)) {\n      LoginConnection conn=accountsOnLS.remove(accountId);\n      conn.closeNow();\n    }\n  }\n}\n", "nl": "Kicks account from LoginServer and GameServers"}
{"code": "private Json convertFile(File file){\n  try {\n    return Json.read(file.toURI().toURL());\n  }\n catch (  MalformedURLException e) {\n    LOG.warn(\"Problem reading Json file \" + file.getPath());\n    return Json.object();\n  }\n}\n", "nl": "Convert a file into a Json object"}
{"code": "public static Ellipse computeEllipse(ArrayList<Point2D> points){\n  final double[][] array=new double[points.size()][2];\n  int i=0;\n  for (  Point2D aPoint : points) {\n    array[i][0]=aPoint.getX();\n    array[i++][1]=aPoint.getY();\n  }\n  final double[] dimensions=convertVariablesToDimension(apply(array));\n  return new Ellipse(dimensions[0],dimensions[1],dimensions[2],dimensions[3],dimensions[4]);\n}\n", "nl": "compute an ellipse"}
{"code": "private static void initialise(){\n  Hints hints=new Hints(Hints.CRS,DefaultGeographicCRS.WGS84);\n  PositionFactory positionFactory=GeometryFactoryFinder.getPositionFactory(hints);\n  GeometryFactory geometryFactory=GeometryFactoryFinder.getGeometryFactory(hints);\n  PrimitiveFactory primitiveFactory=GeometryFactoryFinder.getPrimitiveFactory(hints);\n  AggregateFactory aggregateFactory=GeometryFactoryFinder.getAggregateFactory(hints);\n  wktParser=new WKTParser(geometryFactory,primitiveFactory,positionFactory,aggregateFactory);\n  wktTypeList.add(new WKTType(WKT_POINT,false,1,\"Point\",false));\n  wktTypeList.add(new WKTType(WKT_MULTIPOINT,true,1,\"Point\",false));\n  wktTypeList.add(new WKTType(WKT_LINESTRING,false,2,\"Line\",false));\n  wktTypeList.add(new WKTType(\"LINEARRING\",false,2,\"Line\",false));\n  wktTypeList.add(new WKTType(WKT_MULTILINESTRING,true,2,\"Line\",false));\n  wktTypeList.add(new WKTType(WKT_POLYGON,false,-1,\"Polygon\",true));\n  wktTypeList.add(new WKTType(WKT_MULTIPOLYGON,true,-1,\"Polygon\",true,true));\n  for (  WKTType wkyType : wktTypeList) {\n    wktTypeMap.put(wkyType.getName(),wkyType);\n  }\n}\n", "nl": "Initialise the WKTParser object"}
{"code": "public static void launchComparison(Director dir0,Director dir1,Director dir2,String methodName,String options) throws IOException, CanceledException {\n  IMethodItem item=null;\n  if (methodName.equals(ResamplingMethodItem.NAME)) {\n    item=new ResamplingMethodItem();\n  }\n else   NotificationsInSwing.showError(\"Unknown statistical method: \" + methodName);\n  if (item != null) {\n    item.parseOptionString(options);\n    Map<Integer,Integer> input1=computeInputMapFromLeaves(dir1,item.getOptionUseInternal(),item.getOptionUseUnassigned());\n    System.err.println(\"Input map for \" + dir1.getTitle() + \": \"+ input1.keySet().size());\n    Map<Integer,Integer> input2=computeInputMapFromLeaves(dir2,item.getOptionUseInternal(),item.getOptionUseUnassigned());\n    System.err.println(\"Input map for \" + dir2.getTitle() + \": \"+ input2.keySet().size());\n    item.setInput(input1,input2);\n    item.apply(dir0.getDocument().getProgressListener());\n    Map<Integer,Double> result=item.getOutput();\n    ResamplingMethodItem.displayResult(result,dir1,dir2);\n  }\n}\n", "nl": "launch the computation of a comparison"}
{"code": "private void addImports(CompletionItem item){\n  if (this.importRewrite != null) {\n    try {\n      TextEdit edit=this.importRewrite.rewriteImports(new NullProgressMonitor());\n      TextEditConverter converter=new TextEditConverter(this.compilationUnit,edit);\n      item.setAdditionalTextEdits(converter.convert());\n    }\n catch (    CoreException e) {\n      JavaLanguageServerPlugin.logException(\"Error adding imports\",e);\n    }\n  }\n}\n", "nl": "Adds imports collected by importRewrite to item"}
{"code": "public ShortArrayList bottom(int n){\n  ShortArrayList bottom=new ShortArrayList();\n  short[] values=data.toShortArray();\n  ShortArrays.parallelQuickSort(values);\n  for (int i=0; i < n && i < values.length; i++) {\n    bottom.add(values[i]);\n  }\n  return bottom;\n}\n", "nl": "Returns the smallest (\"bottom\") n values in the column"}
{"code": "private void updateHeaderViewSize(int dy,XRecyclerView view){\n  if (dy < 0) {\n    if (view.mHeaderView.getLayoutParams().height > view.mHeaderViewHeight) {\n      view.mHeaderView.getLayoutParams().height+=-dy / 5;\n    }\n else {\n      view.mHeaderView.getLayoutParams().height+=-dy / 2;\n    }\n  }\n else {\n    view.isLoadingMoreData=true;\n    view.mHeaderView.getLayoutParams().height-=dy;\n  }\n  view.mHeaderView.requestLayout();\n}\n", "nl": "reset the header view height"}
{"code": "private static int readCode(boolean[] rawbits,int startIndex,int length){\n  int res=0;\n  for (int i=startIndex; i < startIndex + length; i++) {\n    res<<=1;\n    if (rawbits[i]) {\n      res|=0x01;\n    }\n  }\n  return res;\n}\n", "nl": "Reads a code of given length and at given index in an array of bits"}
{"code": "private AirMap(Context context,String auth,boolean pinCertificates){\n  this.context=context;\n  authToken=auth == null ? \"\" : auth;\n  certificatePinning=pinCertificates;\n  decodeToken(auth);\n  try {\n    InputStream inputStream=getContext().getResources().getAssets().open(\"airmap.config.json\");\n    String json=Utils.readInputStreamAsString(inputStream);\n    config=new JSONObject(json);\n    apiKey=getConfig().getJSONObject(\"airmap\").getString(\"api_key\");\n  }\n catch (  IOException|JSONException|NullPointerException e) {\n    e.printStackTrace();\n    throw new RuntimeException(\"Please ensure you have your airmap.config.json file in your /assets directory\");\n  }\n  client=new AirMapClient(apiKey,auth);\n}\n", "nl": "Constructs an AirMap instance"}
{"code": "@Path(path=\"verify\") public void verify(){\n  String code=this.getString(\"code\").toLowerCase();\n  Captcha.Result r=Captcha.verify(this.sid(),code);\n  JSON jo=new JSON();\n  if (Captcha.Result.badcode == r) {\n    jo.put(X.STATE,202);\n    jo.put(X.MESSAGE,\"bad code\");\n  }\n else   if (Captcha.Result.expired == r) {\n    jo.put(X.STATE,201);\n    jo.put(X.MESSAGE,\"expired\");\n  }\n else {\n    jo.put(X.STATE,200);\n    jo.put(X.MESSAGE,\"ok\");\n  }\n  this.response(jo);\n}\n", "nl": "verify the code"}
{"code": "private void collectAttributes(AttributeSet attributeSet){\n  TypedArray attributesArray=getContext().obtainStyledAttributes(attributeSet,R.styleable.PresenterLayout);\n  try {\n    mOverlappingBackgroundColor=attributesArray.getColor(R.styleable.PresenterLayout_background_color_overlapping,mDefaultOverlappingBackgroundColor);\n    mInflateDefaultViews=attributesArray.getBoolean(R.styleable.PresenterLayout_inflate_default_views,true);\n    mInitialViewId=attributesArray.getInt(R.styleable.PresenterLayout_show_initial_view,NONE_VIEW);\n  }\n  finally {\n    attributesArray.recycle();\n  }\n}\n", "nl": "Collect attributes provided in XML declaration"}
{"code": "public void testUntypedLinkedListField() throws Exception {\n  AnObject empty=new AnObject();\n  AnObject full=helper.fill(new AnObject());\n  Object value=getPropertyValue(full,\"untypedLinkedListField\");\n  assertTrue(value instanceof List);\n  assertFalse(((List)value).isEmpty());\n  assertEquals(1L,((List)value).get(0));\n  assertTrue(helper.areEquals(full,full));\n  assertFalse(helper.areEquals(empty,full));\n}\n", "nl": "List field should always assigned new list with one elment 1L"}
{"code": "private void addResizeHandles(){\n  mResizeHandles.add(mLeftTop);\n  mResizeHandles.add(mLeftBottom);\n  mResizeHandles.add(mRightTop);\n  mResizeHandles.add(mRightBottom);\n  if (mWidget instanceof Guideline) {\n    mResizeHandles.add(mLeftSide);\n    mResizeHandles.add(mTopSide);\n  }\n else {\n    if (USE_SIDE_RESIZE) {\n      mResizeHandles.add(mLeftSide);\n      mResizeHandles.add(mTopSide);\n      mResizeHandles.add(mRightSide);\n      mResizeHandles.add(mBottomSide);\n    }\n  }\n}\n", "nl": "Add all resize handles into a single array"}
{"code": "private void assignCoordinatesToNodes(boolean useWeights,PhyloTreeView view) throws NotOwnerException {\n  PhyloTree graph=(PhyloTree)view.getGraph();\n  if (graph.getNumberOfNodes() == 0)   return;\n  Node v=graph.getTaxon2Node(1);\n  view.setLocation(v,new Point2D.Float(0,0));\n  BitSet splitsInPath=new BitSet();\n  NodeSet nodesVisited=new NodeSet(graph);\n  assignCoordinatesToNodesRec(v,splitsInPath,nodesVisited,useWeights,view);\n}\n", "nl": "assigns coordinates to nodes"}
{"code": "private void createDo2(polyglot.ast.Do doStmt){\n  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();\n  body.getUnits().add(noop1);\n  endControlNoop.push(soot.jimple.Jimple.v().newNopStmt());\n  condControlNoop.push(soot.jimple.Jimple.v().newNopStmt());\n  createStmt(doStmt.body());\n  soot.jimple.Stmt continueStmt=condControlNoop.pop();\n  body.getUnits().add(continueStmt);\n  condControlNoop.push(continueStmt);\n  if (labelMap != null && labelMap.containsKey(doStmt)) {\n    body.getUnits().add(labelMap.get(doStmt));\n  }\n  polyglot.ast.Expr condition=doStmt.cond();\n  createBranchingExpr(condition,noop1,true);\n  body.getUnits().add((endControlNoop.pop()));\n  condControlNoop.pop();\n}\n", "nl": "DoWhile Stmts Creation"}
{"code": "public void moveFiles(Collection<OCFile> files,OCFile targetFolder){\n  for (  OCFile file : files) {\n    Intent service=new Intent(mFileActivity,OperationsService.class);\n    service.setAction(OperationsService.ACTION_MOVE_FILE);\n    service.putExtra(OperationsService.EXTRA_NEW_PARENT_PATH,targetFolder.getRemotePath());\n    service.putExtra(OperationsService.EXTRA_REMOTE_PATH,file.getRemotePath());\n    service.putExtra(OperationsService.EXTRA_ACCOUNT,mFileActivity.getAccount());\n    mWaitingForOpId=mFileActivity.getOperationsServiceBinder().queueNewOperation(service);\n  }\n  mFileActivity.showLoadingDialog(mFileActivity.getString(R.string.wait_a_moment));\n}\n", "nl": "Start operations to move one or several files"}
{"code": "private void buildViewForMeasuring(){\n  if (itemsLayout != null) {\n    recycle.recycleItems(itemsLayout,firstItem,new ItemsRange());\n  }\n else {\n    createItemsLayout();\n  }\n  int addItems=visibleItems / 2;\n  for (int i=currentItem + addItems; i >= currentItem - addItems; i--) {\n    if (addViewItem(i,true)) {\n      firstItem=i;\n    }\n  }\n}\n", "nl": "Builds view for measuring"}
{"code": "public static String keyForImage(String imagePath){\n  String key=null;\n  try {\n    MessageDigest messageDigest=MessageDigest.getInstance(\"md5\");\n    messageDigest.update(imagePath.getBytes());\n    key=byteToHex(messageDigest.digest());\n  }\n catch (  NoSuchAlgorithmException e) {\n    e.printStackTrace();\n  }\n  return key;\n}\n", "nl": "Generate md5 key for picture"}
{"code": "public void releaseId(int id){\n  try {\n    lock.lock();\n    boolean status=idList.get(id);\n    if (!status) {\n      throw new IDFactoryError(\"ID \" + id + \" is not taken, can't release it.\");\n    }\n    idList.clear(id);\n    if (id < nextMinId || nextMinId == Integer.MIN_VALUE) {\n      nextMinId=id;\n    }\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "Releases given id"}
{"code": "public static void backup(String filename){\n  File f=new File(filename);\n  f.getParentFile().mkdirs();\n  try {\n    ZipOutputStream zip=new ZipOutputStream(new FileOutputStream(f));\n    zip.putNextEntry(new ZipEntry(\"db\"));\n    PrintStream out=new PrintStream(zip);\n    Set<String> c1=getCollections();\n    log.debug(\"collections=\" + c1);\n    for (    String table : c1) {\n      _backup(out,table);\n    }\n    zip.closeEntry();\n    zip.close();\n  }\n catch (  Exception e) {\n  }\n}\n", "nl": "backup the whole data from file"}
{"code": "public CommandBuilder withLongSwitch(String switchName,Object value,UnaryOperator<String> switchNameMapper){\n  if (value != null) {\n    switches.add(String.format(\"--%s='%s'\",switchNameMapper.apply(switchName),escapeQuotedSwitch(String.valueOf(value))));\n  }\n else {\n    switches.add(\"--\" + switchNameMapper.apply(switchName));\n  }\n  return this;\n}\n", "nl": "add a long switch (--switch=value) with the given name and value applying the unary operator on the key"}
{"code": "@Deployment public void testProcessDefinitionListenerDefinitionEntities() throws Exception {\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"testEventListeners\");\n  assertNotNull(processInstance);\n  Task task=taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();\n  assertNotNull(task);\n  TestActivitiEventListener theListener=(TestActivitiEventListener)processEngineConfiguration.getBeans().get(\"testAttachmentEventListener\");\n  assertNotNull(theListener);\n  assertEquals(0,theListener.getEventsReceived().size());\n  taskService.createAttachment(\"test\",task.getId(),processInstance.getId(),\"test\",\"test\",\"url\");\n  assertEquals(2,theListener.getEventsReceived().size());\n  assertEquals(ActivitiEventType.ENTITY_CREATED,theListener.getEventsReceived().get(0).getType());\n  assertEquals(ActivitiEventType.ENTITY_INITIALIZED,theListener.getEventsReceived().get(1).getType());\n}\n", "nl": "Test to verify listeners defined in the BPMN xml are added to the process definition and are active, for all entity types"}
{"code": "public double distance(VectorN vector){\n  double d=0d;\n  for (int i=0; i < size(); i++) {\n    double x=vector.get(0) - get(0);\n    double y=vector.get(1) - get(1);\n    d+=x * x + y * y;\n  }\n  return Math.sqrt(d);\n}\n", "nl": "compute euclidean distance to given vector"}
{"code": "public boolean hasDualWeaponEquipped(ItemSlot slot){\n  ItemSlot[] slotValues=ItemSlot.getSlotsFor(slot.getSlotIdMask());\n  if (slotValues.length == 0) {\n    return false;\n  }\n  for (  ItemSlot s : slotValues) {\n    Item weapon=equipment.get(s.getSlotIdMask());\n    if (weapon == null || weapon.getItemTemplate().isTwoHandWeapon()) {\n      continue;\n    }\n    if (weapon.getItemTemplate().getWeaponType() != null) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks if dual one-handed weapon is equiped in any slot combination"}
{"code": "private boolean checkTombStones(int level){\nswitch (level) {\ncase 1:\n    if (getNpcs(702673).isEmpty() && getNpcs(702674).isEmpty() && getNpcs(702675).isEmpty()) {\n      return true;\n    }\n  break;\ncase 3:\nbreak;\n}\nreturn false;\n}\n", "nl": "When TombStones are Dead, first Door opens 457 = First Door in Tormet > 118 after second Boss 64 = Second Door in Terror"}
{"code": "public String parseTemplate(String templateString,Map<String,Object> data){\n  GraqlTemplateLexer lexer=getLexer(templateString);\n  CommonTokenStream tokens=new CommonTokenStream(lexer);\n  GraqlTemplateParser parser=getParser(tokens);\n  parser.setBuildParseTree(true);\n  ParseTree tree=parser.template();\n  TemplateVisitor visitor=new TemplateVisitor(tokens,data,macros);\n  return visitor.visit(tree).toString();\n}\n", "nl": "Parse and resolve a graql template"}
{"code": "@Override protected WXFrameLayout initComponentHostView(Context context){\n  if (isSticky()) {\n    WXFrameLayout view=new WXFrameLayout(context);\n    mRealView=new WXFrameLayout(context);\n    view.addView(mRealView);\n    return view;\n  }\n else {\n    WXFrameLayout view=new WXFrameLayout(context);\n    mRealView=view;\n    return view;\n  }\n}\n", "nl": "If Cell is Sticky, need wraped FrameLayout"}
{"code": "public void testWriteReadFull() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(full);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  ReplicationPolicy copy=(ReplicationPolicy)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(full,copy));\n}\n", "nl": "Test read and write full ClusterPolicy object"}
{"code": "public static void saveBitmapToFile(Bitmap bmp,String fullPathWithFileName) throws IOException {\n  FileOutputStream out=null;\n  try {\n    out=new FileOutputStream(createParentDirIfNotExists(fullPathWithFileName));\n    bmp.compress(Bitmap.CompressFormat.PNG,100,out);\n  }\n  finally {\n    try {\n      if (out != null) {\n        out.close();\n      }\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "nl": "Save a Bitmap to a local file"}
{"code": "public static String parse(CommandLineParser.Parameter[] params) throws IOException {\n  String path=null;\n  for (int i=0; i < params.length; i++) {\n    if (params[i].getName().equalsIgnoreCase(PATH_PARAMETER)) {\n      for (int j=0; j < params[i].getArguments().length; j++) {\n        path=params[i].getArguments()[j];\n        break;\n      }\n    }\n  }\n  return path;\n}\n", "nl": "Parses -path parameter"}
{"code": "@Override public boolean onCreateOptionsMenu(Menu menu){\n  if (menu.findItem(menuCameraId) == null) {\n    menuCamera=menu.add(Menu.NONE,menuCameraId,1,getString(R.string.camera));\n    menuCamera.setIcon(R.drawable.ic_camera_white);\n    menuCamera.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);\n    menuCamera.setVisible(showCamera);\n  }\n  if (menu.findItem(menuDoneId) == null) {\n    menuDone=menu.add(Menu.NONE,menuDoneId,2,getString(R.string.done));\n    menuDone.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);\n  }\n  updateTitle();\n  return true;\n}\n", "nl": "Create option menus and update title"}
{"code": "private boolean tryToNotifyReset(){\n  if ((mStatus == PTR_STATUS_COMPLETE || mStatus == PTR_STATUS_PREPARE) && mPtrIndicator.isInStartPosition()) {\n    if (mPtrUIHandlerHolder.hasHandler()) {\n      mPtrUIHandlerHolder.onUIReset(this);\n      if (DEBUG) {\n        PtrCLog.i(LOG_TAG,\"PtrUIHandler: onUIReset\");\n      }\n    }\n    mStatus=PTR_STATUS_INIT;\n    clearFlag();\n    return true;\n  }\n  return false;\n}\n", "nl": "If at the top and not in loading, reset"}
{"code": "public int rank(){\n  double eps=Math.pow(2.0,-52.0);\n  double tol=Math.max(m,n) * s[0] * eps;\n  int r=0;\n  for (int i=0; i < s.length; i++) {\n    if (s[i] > tol) {\n      r++;\n    }\n  }\n  return r;\n}\n", "nl": "Effective numerical matrix rank"}
{"code": "private static void allPositions(ScoutWidget[] list,int[] north,int[] south,int[] west,int[] east){\n  for (int i=1; i < list.length; i++) {\n    int k=i - 1;\n    north[k]=list[i].mConstraintWidget.getY();\n    west[k]=list[i].mConstraintWidget.getX();\n    south[k]=list[i].mConstraintWidget.getHeight() + north[k];\n    east[k]=list[i].mConstraintWidget.getWidth() + west[k];\n  }\n}\n", "nl": "Compute all possible positions for the north, south, east, and west borders of a group"}
{"code": "public static double[][] multiply(double[][] x,double[][] y){\n  final int rowsX=x.length;\n  final int colsX=x[0].length;\n  final int rowsY=y.length;\n  final int colsY=y[0].length;\n  if (colsX != rowsY)   throw new RuntimeException(\"multiply(x,y): incompatible dimensions\");\n  final double[][] z=new double[rowsX][colsY];\n  for (int a=0; a < rowsX; a++) {\n    for (int b=0; b < colsY; b++) {\n      double value=0;\n      for (int c=0; c < colsX; c++) {\n        value+=x[a][c] * y[c][b];\n      }\n      z[a][b]=value;\n    }\n  }\n  return z;\n}\n", "nl": "matrix multiplication"}
{"code": "@Override public Object validate(String content,ValidationContext context,ValidatedInfo validatedInfo) throws InvalidDatatypeValueException {\n  if (context == null)   context=fEmptyContext;\n  if (validatedInfo == null)   validatedInfo=new ValidatedInfo();\n else   validatedInfo.memberType=null;\n  boolean needNormalize=context == null || context.needToNormalize();\n  Object ob=getActualValue(content,context,validatedInfo,needNormalize);\n  validate(context,validatedInfo);\n  return ob;\n}\n", "nl": "validate a value, and return the compiled form"}
{"code": "public double EuclideanDistance(double[] x,double[] y){\n  double sum=0;\n  if (x.length != y.length) {\n    throw new RuntimeException(\"Given array lengths were not equal.\");\n  }\n  int d=x.length;\n  for (int i=0; i < d; i++) {\n    sum=sum + (x[i] - y[i]) * (x[i] - y[i]);\n  }\n  sum=Math.sqrt(sum);\n  return sum;\n}\n", "nl": "Euclidean distance"}
{"code": "public void updateView(){\n  Graphics2D graphics=(Graphics2D)getGraphics();\n  if (graphics != null) {\n    Dimension size=new Dimension();\n    draw(graphics,size);\n    setPreferredSize(size);\n    revalidate();\n  }\n}\n", "nl": "rescan the view"}
{"code": "public Map<String,Object> finalizeOrderEntryPayment(String checkOutPaymentId,BigDecimal amount,boolean singleUse,boolean append){\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  if (UtilValidate.isNotEmpty(checkOutPaymentId)) {\n    if (!append) {\n      cart.clearPayments();\n    }\n    cart.addPaymentAmount(checkOutPaymentId,amount,singleUse);\n  }\n  return result;\n}\n", "nl": "Sets the payment ID to use during the checkout process"}
{"code": "private boolean addViewItem(int index,boolean first){\n  View view=getItemView(index);\n  if (view != null) {\n    if (first) {\n      itemsLayout.addView(view,0);\n    }\n else {\n      itemsLayout.addView(view);\n    }\n    return true;\n  }\n  return false;\n}\n", "nl": "Adds view for item to items layout"}
{"code": "static int max(float[] array){\n  int max=0;\n  float val=array[0];\n  for (int i=1; i < array.length; i++) {\n    if (val < array[i]) {\n      max=i;\n      val=array[i];\n    }\n  }\n  return max;\n}\n", "nl": "Calculate the maximum of an array"}
{"code": "public static WritableArrayWritable jsonArrayStringToWritableArrayWritable(String jsonString){\n  String modString=jsonString.replaceFirst(\"\\\\[\",\"\");\n  modString=modString.replaceFirst(\"\\\\]\",\"\");\n  modString=modString.replaceAll(\"\\\"\",\"\");\n  String[] elements=modString.split(\"\\\\s*,\\\\s*\");\n  logger.debug(\"elements = \");\n  for (  String element : elements) {\n    logger.debug(\"element: \" + element);\n  }\n  return new WritableArrayWritable(elements);\n}\n", "nl": "Method to take an input json array format string and output a WritableArrayWritable"}
{"code": "@Deployment(resources={\"org/activiti/engine/test/history/HistoricProcessInstanceTest.testDeleteHistoricProcessInstanceWithCallActivity.bpmn20.xml\",\"org/activiti/engine/test/history/HistoricProcessInstanceTest.testDeleteHistoricProcessInstanceWithCallActivity-subprocess.bpmn20.xml\"}) public void testDeleteHistoricProcessInstanceWithCallActivity(){\n  if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.AUDIT)) {\n    ProcessInstance pi=runtimeService.startProcessInstanceByKey(\"callSimpleSubProcess\");\n    runtimeService.deleteProcessInstance(pi.getId(),\"testing\");\n    assertEquals(2L,historyService.createHistoricProcessInstanceQuery().count());\n    historyService.deleteHistoricProcessInstance(pi.getId());\n    assertEquals(0L,historyService.createHistoricProcessInstanceQuery().count());\n  }\n}\n", "nl": "Validation for ACT-821"}
{"code": "public static Date str2Date(String str,String format){\n  if (str == null || str.length() == 0) {\n    return null;\n  }\n  if (format == null || format.length() == 0) {\n    format=FORMAT;\n  }\n  Date date=null;\n  try {\n    SimpleDateFormat sdf=new SimpleDateFormat(format);\n    date=sdf.parse(str);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  return date;\n}\n", "nl": "string -> date"}
{"code": "private SocketChannel createChannel(String host,int port) throws IOException {\n  if (_logger.isLoggable(Level.FINE))   _logger.fine(\"connecting new socket channel to \" + host + \":\"+ port+ \", connect timeout=\"+ _config.getSocketConnectTimeout()+ \" keepalive=\"+ LRMIUtilities.KEEP_ALIVE_MODE);\n  SocketChannel sockChannel;\n  for (int i=0; ; ++i) {\n    sockChannel=createSocket(host,port);\n    try {\n      sockChannel.socket().connect(m_Address,(int)_config.getSocketConnectTimeout());\n      break;\n    }\n catch (    ClosedSelectorException e) {\n      handleConnectError(i,host,port,sockChannel,e);\n    }\n  }\n  sockChannel.configureBlocking(_blocking);\n  sockChannel.read(ByteBuffer.allocate(0));\n  return sockChannel;\n}\n", "nl": "Create a new socket channel and set its parameters"}
{"code": "public static String toString(Serializable serializable){\n  if (null == serializable) {\n    return null;\n  }\n  try {\n    return (String)serializable;\n  }\n catch (  Exception e) {\n    return serializable.toString();\n  }\n}\n", "nl": "serializable toString"}
{"code": "public int rank(){\n  double eps=Math.pow(2.0,-52.0);\n  double tol=Math.max(m,n) * s[0] * eps;\n  int r=0;\n  for (int i=0; i < s.length; i++) {\n    if (s[i] > tol) {\n      r++;\n    }\n  }\n  return r;\n}\n", "nl": "Effective numerical matrix rank"}
{"code": "@Override public void bindAppearEvent(WXComponent component){\n  ConcurrentHashMap<String,AppearData> appearMap=mAppearMap.get(getRef());\n  if (appearMap == null) {\n    appearMap=new ConcurrentHashMap<>();\n  }\n  AppearData appearData=appearMap.get(component.getRef());\n  if (appearData == null) {\n    appearData=new AppearData();\n  }\n  appearData.mAppearComponent=component;\n  appearData.hasAppear=true;\n  appearMap.put(component.getRef(),appearData);\n  mAppearMap.put(getRef(),appearMap);\n}\n", "nl": "Bind appear event"}
{"code": "protected IObjectInfo<T> store_impl(Segment<T> segment,ObjectInfo<T> oi){\n  if (_invalid)   return null;\n  _size.incrementAndGet();\n  segment.incrementSize();\n  ObjectInfo<T> tail=segment.getTail();\n  tail.setForwardRef(oi);\n  oi.setBackwardRef(tail);\n  segment.setTail(oi);\n  return oi;\n}\n", "nl": "store an element in segment"}
{"code": "public void processUtterance(Utterance utterance) throws ProcessException {\n  Relation tokenRelation;\n  if ((tokenRelation=utterance.getRelation(Relation.TOKEN)) == null) {\n    throw new IllegalStateException(\"TokenToWords: Token relation does not exist\");\n  }\n  Item wordItem;\n  wordRelation=WordRelation.createWordRelation(utterance,this);\n  for (tokenItem=tokenRelation.getHead(); tokenItem != null; tokenItem=tokenItem.getNext()) {\n    FeatureSet featureSet=tokenItem.getFeatures();\n    String tokenVal=featureSet.getString(\"name\");\n    tokenToWords(tokenVal);\n  }\n}\n", "nl": "process the utterance"}
{"code": "private void traverseView(View view,Typeface typeface){\n  if (view instanceof ViewGroup) {\n    ViewGroup viewGroup=(ViewGroup)view;\n    for (int i=0; i < viewGroup.getChildCount(); i++) {\n      View v=viewGroup.getChildAt(i);\n      if (v instanceof TextView) {\n        ((TextView)v).setTypeface(typeface);\n      }\n      if (v instanceof ViewGroup) {\n        traverseView(v,typeface);\n      }\n    }\n  }\n}\n", "nl": "Traverse view recursively from the given target view"}
{"code": "private static void addSkills(Player player,int level,PlayerClass playerClass,Race playerRace){\n  SkillLearnTemplate[] skillTemplates=DataManager.SKILL_TREE_DATA.getTemplatesFor(playerClass,level,playerRace);\n  PlayerSkillList playerSkillList=player.getSkillList();\n  for (  SkillLearnTemplate template : skillTemplates) {\n    if (checkLearnIsPossible(player,playerSkillList,template)) {\n      if (template.isStigma())       playerSkillList.addStigmaSkill(player,template.getSkillId(),template.getSkillLevel());\n else       playerSkillList.addSkill(player,template.getSkillId(),template.getSkillLevel());\n    }\n  }\n}\n", "nl": "Adds skill to player according to the specified level, class and race"}
{"code": "@Deployment public void testDeleteTaskWithChildren() throws Exception {\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"testBatchDeleteOfTask\");\n  assertNotNull(processInstance);\n  assertFalse(processInstance.isEnded());\n  Task firstTask=taskService.createTaskQuery().processInstanceId(processInstance.getId()).taskDefinitionKey(\"taskOne\").singleResult();\n  assertNotNull(firstTask);\n  taskService.complete(firstTask.getId());\n  processInstance=runtimeService.createProcessInstanceQuery().processInstanceId(processInstance.getId()).singleResult();\n  assertNull(processInstance);\n}\n", "nl": "Validating fix for ACT-2070"}
{"code": "@Override public int compareTo(ScoutWidget scoutWidget){\n  if (mParent == null) {\n    return -1;\n  }\n  if (mRootDistance != scoutWidget.mRootDistance) {\n    return Float.compare(mRootDistance,scoutWidget.mRootDistance);\n  }\n  if (mY != scoutWidget.mY) {\n    return Float.compare(mY,scoutWidget.mY);\n  }\n  if (mX != scoutWidget.mX) {\n    return Float.compare(mX,scoutWidget.mX);\n  }\n  return 0;\n}\n", "nl": "Sets the order root first followed by outside to inside, top to bottom, left to right"}
{"code": "public Matrix minusEquals(Matrix B){\n  checkMatrixDimensions(B);\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      A[i][j]=A[i][j] - B.A[i][j];\n    }\n  }\n  return this;\n}\n", "nl": "A = A - B"}
{"code": "@ObjectiveCName(\"subscribe:triggerNow:\") public List subscribe(ListChangedListener listChangedListener,boolean triggerNow){\n  this.listChangedListeners.add(listChangedListener);\n  if (this.listChangedListeners.size() == 1) {\n    this.record.subscribe(this.recordListeners);\n  }\n  if (triggerNow) {\n    for (    ListChangedListener listChangeListener : this.listChangedListeners) {\n      listChangeListener.onListChanged(this.name(),this.getEntries());\n    }\n  }\n  return this;\n}\n", "nl": "Notifies the user whenever the list has changed, and notifies immediately if triggerNow is true"}
{"code": "@Override public void xml(String xml){\n  if (TextUtils.isEmpty(xml)) {\n    d(\"Empty/Null xml content\");\n    return;\n  }\n  try {\n    Source xmlInput=new StreamSource(new StringReader(xml));\n    StreamResult xmlOutput=new StreamResult(new StringWriter());\n    Transformer transformer=TransformerFactory.newInstance().newTransformer();\n    transformer.setOutputProperty(OutputKeys.INDENT,\"yes\");\n    transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\",\"2\");\n    transformer.transform(xmlInput,xmlOutput);\n    d(xmlOutput.getWriter().toString().replaceFirst(\">\",\">\\n\"));\n  }\n catch (  TransformerException e) {\n    e(e.getCause().getMessage() + \"\\n\" + xml);\n  }\n}\n", "nl": "Formats the json content and print it"}
{"code": "public static javafx.scene.shape.Ellipse computeEllipseFX(ArrayList<Point2D> points){\n  final double[][] array=new double[points.size()][2];\n  int i=0;\n  for (  Point2D aPoint : points) {\n    array[i][0]=aPoint.getX();\n    array[i++][1]=aPoint.getY();\n  }\n  final double[] dimensions=convertVariablesToDimension(apply(array));\n  javafx.scene.shape.Ellipse ellipse=new javafx.scene.shape.Ellipse(dimensions[0],dimensions[1],dimensions[2],dimensions[3]);\n  ellipse.setRotate(Geometry.rad2deg(dimensions[4]));\n  return ellipse;\n}\n", "nl": "compute an ellipse"}
{"code": "public String upload_appender_file1(byte[] file_buff,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String parts[]=this.upload_appender_file(file_buff,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload appender file to storage server (by file buff)"}
{"code": "public IntIntMap(InputStream inputStream) throws IOException {\n  try (DataInputStream ins=new DataInputStream(inputStream)){\n    int magicNumber=ins.readInt();\n    if (magicNumber != MAGIC_NUMBER)     throw new IOException(\"Wrong file type\");\n    m_hasFreeKey=ins.readBoolean();\n    m_freeValue=ins.readInt();\n    m_fillFactor=ins.readFloat();\n    m_threshold=ins.readInt();\n    m_size=ins.readInt();\n    m_mask=ins.readInt();\n    m_mask2=ins.readInt();\n    final int m_data_length=ins.readInt();\n    m_data=new int[m_data_length];\n    for (int i=0; i < m_data_length; i++)     m_data[i]=ins.readInt();\n  }\n }\n", "nl": "construct from input stream"}
{"code": "public boolean isRowHeaderSelected(){\n  final ObservableList selectedCells=spreadsheetView.getSelectionModel().getSelectedCells();\n  try {\n    for (    Object obj : selectedCells) {\n      final int col=((TablePosition)obj).getColumn();\n      if (col == 0)       return true;\n    }\n  }\n catch (  Exception ex) {\n    if (Platform.isFxApplicationThread())     Basic.caught(ex);\n  }\n  return false;\n}\n", "nl": "is the row header column selected?"}
{"code": "public Object readResolve() throws ObjectStreamException {\n  ClassLoader cl=ReflectionUtil.getClassTargetLoader(_interfaces[0]);\n  Object proxyInstance=createInstance(cl);\n  if (_cacheProxy && _handler instanceof ILRMIProxy) {\n    StubId stubId=((ILRMIProxy)_handler).getStubId();\n    if (_stubCacheLogger.isLoggable(Level.FINE))     _stubCacheLogger.fine(\"adding stub to cache, id = \" + stubId + \", stub toString() = \"+ proxyInstance);\n    LRMIRuntime.getRuntime().getStubCache().addStub(stubId,proxyInstance);\n  }\n else {\n    if (_stubCacheLogger.isLoggable(Level.FINER))     _stubCacheLogger.finer(\"stub state is uncached, skipping cache insertion. toString() = \" + proxyInstance);\n  }\n  return proxyInstance;\n}\n", "nl": "DONT REMOVE!!!! Called by the ObjectInputStream on deserialization"}
{"code": "public static void main(String[] args) throws Exception {\n  ByteFileGetterInMemory byteFileGetterInMemory=new ByteFileGetterInMemory(new File(\"/dev/null\"));\n  int length0=(1 << byteFileGetterInMemory.BITS);\n  for (long i=0; i < 10L * Integer.MAX_VALUE; i++) {\n    int index=byteFileGetterInMemory.dataIndex(i);\n    int pos=byteFileGetterInMemory.dataPos(i);\n    long result=(long)index * (long)length0 + (long)pos;\n    if (result != i)     throw new Exception(\"i=\" + i + \" != result=\"+ result);\n  }\n}\n", "nl": "test indexing"}
{"code": "public static Bitmap blurNativelyPixels(Bitmap original,int radius,boolean canReuseInBitmap){\n  if (radius < 1) {\n    return null;\n  }\n  Bitmap bitmap=buildBitmap(original,canReuseInBitmap);\n  if (radius == 1) {\n    return bitmap;\n  }\n  int w=bitmap.getWidth();\n  int h=bitmap.getHeight();\n  int[] pix=new int[w * h];\n  bitmap.getPixels(pix,0,w,0,0,w,h);\n  blurPixels(pix,w,h,radius);\n  bitmap.setPixels(pix,0,w,0,0,w,h);\n  return (bitmap);\n}\n", "nl": "StackBlur By Jni Pixels"}
{"code": "public static void w(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_WARNING) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.w(tag,msg);\n}\n", "nl": "Send a WARNING log message"}
{"code": "public final void fallback(final IFallback fallbackObj) throws DataFallbackException {\n  try {\n    if (isFallbackFileEmpty())     fFileController.closeFallbackInputStream();\n    fFileController.openFallbackOutputStream();\n    fFileController.writeLine(fallbackObj);\n    fFileController.setNumberOfLines(fFileController.getNumberOfLines() + 1);\n  }\n catch (  DataFallbackException e) {\n    throw new DataFallbackException(e.getMessage());\n  }\n}\n", "nl": "Stores a IFallback object in the fallback file"}
{"code": "public static GenericValue findWebSite(Delegator delegator,String webSiteId,boolean useCache){\n  GenericValue result=null;\n  try {\n    result=EntityQuery.use(delegator).from(\"WebSite\").where(\"webSiteId\",webSiteId).cache(useCache).queryOne();\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(\"Error looking up website with id \" + webSiteId,module);\n  }\n  return result;\n}\n", "nl": "returns a WebSite-GenericValue"}
{"code": "protected boolean inExtensionNamespace(){\n  boolean inExtension=false;\n  Enumeration elements=namespaceStack.elements();\n  while (!inExtension && elements.hasMoreElements()) {\n    String ns=(String)elements.nextElement();\n    if (ns == null) {\n      inExtension=true;\n    }\n else {\n      inExtension=(!ns.equals(tr9401NamespaceName) && !ns.equals(namespaceName));\n    }\n  }\n  return inExtension;\n}\n", "nl": "Are we in an extension namespace?"}
{"code": "private int distBetweenPoints(int x1,int z1,int x2,int z2,boolean bAllowDiags){\n  int w=Math.abs(x2 - x1);\n  int h=Math.abs(z2 - z1);\n  if (bAllowDiags) {\n    if (w < h)     w=0;\n else     h=0;\n  }\n  return w + h + 1;\n}\n", "nl": "Calculate the number of cells on the shortest path between (x1,z1) and (x2,z2)"}
{"code": "public void readDataFile(InputStream dataFileStream,String locationInfo) throws DataFileException {\n  if (modelDataFile == null) {\n    throw new IllegalStateException(\"DataFile model is null, cannot load file\");\n  }\n  if (locationInfo == null) {\n    locationInfo=\"unknown\";\n  }\n  RecordIterator recordIterator=this.makeRecordIterator(dataFileStream,locationInfo);\n  while (recordIterator.hasNext()) {\n    this.records.add(recordIterator.next());\n  }\n}\n", "nl": "Loads (or reloads) the data file from the given stream"}
{"code": "public static void w(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_WARNING) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.w(tag,msg);\n}\n", "nl": "Send a WARNING log message"}
{"code": "@Override protected void initData(){\n  videoFilePresenter=new VideoFilePresenter();\n  videoFilePresenter.attachView(this);\n  if (path != null && !TextUtils.isEmpty(path)) {\n    tvFilePath.setText(path);\n    rootFile=new File(path);\n    videoFilePresenter.getVideoData(rootFile);\n  }\n}\n", "nl": "Initialize the Activity data"}
{"code": "public static void deleteSortLocationIfExists(String tempFileLocation) throws CarbonSortKeyAndGroupByException {\n  File file=new File(tempFileLocation);\n  if (file.exists()) {\n    try {\n      CarbonUtil.deleteFoldersAndFiles(file);\n    }\n catch (    CarbonUtilException e) {\n      LOGGER.error(e);\n    }\n  }\n}\n", "nl": "This method will be used to delete sort temp location is it is exites"}
{"code": "public static void addPet(Player player,int petId,String name,int decorationId,int expireTime){\n  PetCommonData petCommonData=player.getPetList().addPet(player,petId,decorationId,name,expireTime);\n  if (petCommonData != null) {\n    PacketSendUtility.sendPacket(player,new SM_PET(1,petCommonData));\n    if (expireTime > 0) {\n      ExpireTimerTask.getInstance().addTask(petCommonData,player);\n    }\n  }\n}\n", "nl": "Add pet to player"}
{"code": "private void listSummaryRec(ViewerBase viewer,Classification classification,NodeSet selectedNodes,Node v,int indent,Writer outs,final Single<Integer> countLines) throws IOException {\n  int id=(Integer)v.getInfo();\n  final String name=classification.getName2IdMap().get(id);\n  NodeData data=(viewer.getNodeData(v));\n  if ((selectedNodes == null || selectedNodes.contains(v))) {\n    if (data.getCountSummarized() > 0) {\n      for (int i=0; i < indent; i++)       outs.write(\" \");\n      outs.write(name + \": \" + Basic.toString(data.getSummarized(),\",\")+ \"\\n\");\n      countLines.set(countLines.get() + 1);\n    }\n  }\n  if (viewer.getCollapsedIds().contains(id)) {\n    return;\n  }\n  for (Edge f=v.getFirstOutEdge(); f != null; f=v.getNextOutEdge(f)) {\n    listSummaryRec(viewer,classification,selectedNodes,f.getOpposite(v),indent + 2,outs,countLines);\n  }\n}\n", "nl": "recursively print a summary"}
{"code": "public void updateAnchor(){\n  if (mOwner != null) {\n    ConstraintWidget widget=mOwner.getConstraintWidget();\n    if (widget instanceof Guideline) {\n      mAnchor=((Guideline)widget).getAnchor();\n    }\n else {\n      mAnchor=widget.getAnchor(mType);\n    }\n  }\n else {\n    mAnchor=null;\n  }\n}\n", "nl": "Retrieve the anchor from the owner's constraint widget"}
{"code": "public String createGroupWithPeople(@NotNull String personGroupId,@NotNull People people){\n  Validation.validateArray(people.simplePersons(),1,1000,new ParameterValidationException(\"people\",\"People list is invalid. min 1, max 1000\"));\n  boolean exists=!Utils.throwsException(null,PersonGroupNotFoundException.class);\n  if (!exists) {\n    personGroupBuilder.createGroup(personGroupId,personGroupId,\"\").withNoResult();\n  }\n  people.simplePersons().stream().forEach(null);\n  personGroupBuilder.trainGroup(personGroupId).withNoResult();\n  return personGroupId;\n}\n", "nl": "Create a new group from a set of people"}
{"code": "public String upload_appender_file1(String group_name,byte[] file_buff,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String parts[]=this.upload_appender_file(group_name,file_buff,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload appender file to storage server (by file buff)"}
{"code": "public Map<Integer,Integer> apply() throws CanceledException {\n  final Map<Integer,Integer> orphan2AncestorMapping=new HashMap<>();\n  if (progress != null) {\n    progress.setMaximum(tree.getNumberOfNodes());\n    progress.setProgress(0);\n  }\n  final Set<Integer> orphans=new HashSet<>();\n  if (tree.getRoot() != null)   computeOrphan2AncestorMappingRec(tree.getRoot(),orphan2AncestorMapping,orphans);\n  for (  Integer id : orphans) {\n    orphan2AncestorMapping.put(id,IdMapper.UNASSIGNED_ID);\n  }\n  orphans.clear();\n  if (progress instanceof ProgressPercentage)   ((ProgressPercentage)progress).reportTaskCompleted();\n  return orphan2AncestorMapping;\n}\n", "nl": "applies the min support filter to taxon classification"}
{"code": "public boolean removeAllEdgesOutOf(Unit u){\n  boolean hasRemoved=false;\n  for (QueueReader<Edge> edgeRdr=listener(); edgeRdr.hasNext(); ) {\n    Edge e=edgeRdr.next();\n    if (e.srcUnit() == u) {\n      removeEdge(e);\n      hasRemoved=true;\n    }\n  }\n  return hasRemoved;\n}\n", "nl": "Removes all outgoing edges that start at the given unit"}
{"code": "public static <V>List<V> invertList(List<V> sourceList){\n  if (isEmpty(sourceList)) {\n    return sourceList;\n  }\n  List<V> invertList=new ArrayList<V>(sourceList.size());\n  for (int i=sourceList.size() - 1; i >= 0; i--) {\n    invertList.add(sourceList.get(i));\n  }\n  return invertList;\n}\n", "nl": "invert list"}
{"code": "public static String id(){\n  String id=UID.id(System.currentTimeMillis(),UID.random());\n  try {\n    while (Helper.exists(id,Repo.class)) {\n      id=UID.id(System.currentTimeMillis(),UID.random());\n    }\n  }\n catch (  Exception e) {\n    log.error(e.getMessage(),e);\n  }\n  return id;\n}\n", "nl": "get the unique id of repo"}
{"code": "private double computeLoadingsScaleFactor(double[] vector){\n  if (vector.length >= 2) {\n    final double length=Math.sqrt(Geometry.squaredDistance(0,0,vector[0],vector[1]));\n    if (length > 0) {\n      final Rectangle2D bbox=graphView.getBBox();\n      return 0.2 * Math.min(bbox.getWidth(),bbox.getHeight()) / (length);\n    }\n  }\n  return 1;\n}\n", "nl": "compute the scale factor to be used when drawing loadings"}
{"code": "public synchronized boolean shouldWait(List<String> targetNames) throws InterruptedException {\n  if (_currentSpaceState == StartupState.LAST) {\n    return false;\n  }\n  if (!_activeSpaces.isEmpty())   return false;\n  if (_currentSpaceState == StartupState.UNINITIALIZED) {\n    if (_spaceName.equals(targetNames.get(0)))     return false;\n  }\n  return true;\n}\n", "nl": "Check if this space should wait for other space in cluster to start"}
{"code": "private double correlationOfNewFeature(String dataFile,String[] features,int indVarColNumber,int[] X,int y,int rowIni,int rowEnd){\n  double corXplusy;\n  Regression reg=new Regression();\n  int j=0;\n  int[] Xplusf=new int[X.length + 1];\n  for (int i=0; i < X.length; i++)   Xplusf[i]=X[i];\n  Xplusf[X.length]=y;\n  reg.multipleLinearRegression(dataFile,indVarColNumber,Xplusf,features,interceptTerm,rowIni,rowEnd);\n  corXplusy=reg.getCorrelation();\n  return corXplusy;\n}\n", "nl": "Correlation of X plus the new feature y (y is not included in X): J(X_k + y_j)"}
{"code": "private String constantToObjectName(String string){\n  if (!Character.isUpperCase(string.charAt(0))) {\n    string=StringUtils.capitalize(string);\n    int length=string.length();\n    for (int i=0; i < length; i++) {\n      char character=string.charAt(i);\n      if (character == \"_\".charAt(0)) {\n        String firstPart=string.substring(0,i);\n        String secondPart=string.substring(i + 1,length);\n        String newSecondPart=StringUtils.capitalize(secondPart);\n        string=firstPart + newSecondPart;\n        i=firstPart.length();\n        length--;\n      }\n    }\n  }\n  return string;\n}\n", "nl": "convert a constant to a object name schema"}
{"code": "private void locationPlacesIntent(){\n  try {\n    PlacePicker.IntentBuilder builder=new PlacePicker.IntentBuilder();\n    startActivityForResult(builder.build(this),PLACE_PICKER_REQUEST);\n  }\n catch (  GooglePlayServicesRepairableException|GooglePlayServicesNotAvailableException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Obter local do usuario"}
{"code": "public static String formatDate(String before){\n  String after;\n  try {\n    Date date=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\",Locale.getDefault()).parse(before);\n    after=new SimpleDateFormat(\"MM-dd HH:mm\",Locale.getDefault()).format(date);\n  }\n catch (  ParseException e) {\n    return before;\n  }\n  return after;\n}\n", "nl": "from yyyy-MM-dd HH:mm:ss to MM-dd HH:mm"}
{"code": "private int measureHeight(){\n  int dayOfWeek=calendar.get(Calendar.DAY_OF_WEEK);\n  int daysOfMonth=daysOfCurrentMonth();\n  int n=-1;\n  if (dayOfWeek >= 2 && dayOfWeek <= 7) {\n    n=daysOfMonth - (8 - dayOfWeek + 1);\n  }\n else   if (dayOfWeek == 1) {\n    n=daysOfMonth - 1;\n  }\n  int lines=2 + n / 7 + (n % 7 == 0 ? 0 : 1);\n  return (int)(cellHeight * lines);\n}\n", "nl": "calculate the total height of the widget"}
{"code": "public void rotateX(double theta){\n  Matrix3D tmp=new Matrix3D();\n  double c=Math.cos(theta);\n  double s=Math.sin(theta);\n  tmp.set(1,1,c);\n  tmp.set(1,2,-s);\n  tmp.set(2,1,s);\n  tmp.set(2,2,c);\n  preMultiply(tmp);\n}\n", "nl": "rotate transformation about the X axis"}
{"code": "public void paintSelection(Graphics g0){\n  if (selectedBlock.isSelected()) {\n    Graphics2D g=(Graphics2D)g0;\n    double xMin=Math.min(getX(selectedBlock.getFirstCol()),getSize().width);\n    double xMax=Math.min((getX(selectedBlock.getLastCol() + 1)),getSize().width - 2);\n    double yMin=Math.min(getY(selectedBlock.getFirstRow() - 1),getSize().height - 3);\n    double yMax=Math.min(getY(selectedBlock.getLastRow()),getSize().height - 3);\n    Rectangle2D rect=new Rectangle2D.Double(xMin,yMin,0,0);\n    rect.add(xMax,yMax);\n    g.setColor(highlightColor);\n    g.draw(rect);\n    g.setColor(highlightColorSemiTransparent);\n    g.fill(rect);\n    selectionRectangle.setRectangle(this,rect);\n  }\n  selectionRectangle.setAnimate(selectedBlock.isSelected());\n}\n", "nl": "paint the selection rectangle"}
{"code": "String parseCharsetFromHeader(String contentType){\n  String result=\"ISO-8859-1\";\n  if (contentType != null) {\n    String[] paramList=contentType.split(\";\");\n    for (    String param : paramList) {\n      if (param.toLowerCase().trim().startsWith(\"charset\") && param.indexOf(\"=\") != -1) {\n        result=param.substring(param.indexOf(\"=\") + 1).trim();\n      }\n    }\n  }\n  return result;\n}\n", "nl": "Response Content-Type could be something like this: application/x-ns-proxy-autoconfig; charset=UTF-8"}
{"code": "private void createWhile2(polyglot.ast.While whileStmt){\n  soot.jimple.Stmt brchTgt=soot.jimple.Jimple.v().newNopStmt();\n  soot.jimple.Stmt beginTgt=soot.jimple.Jimple.v().newNopStmt();\n  body.getUnits().add(beginTgt);\n  endControlNoop.push(soot.jimple.Jimple.v().newNopStmt());\n  condControlNoop.push(soot.jimple.Jimple.v().newNopStmt());\n  soot.jimple.Stmt continueStmt=condControlNoop.pop();\n  body.getUnits().add(continueStmt);\n  condControlNoop.push(continueStmt);\n  polyglot.ast.Expr condition=whileStmt.cond();\n  createBranchingExpr(condition,brchTgt,false);\n  createStmt(whileStmt.body());\n  soot.jimple.GotoStmt gotoLoop=soot.jimple.Jimple.v().newGotoStmt(beginTgt);\n  body.getUnits().add(gotoLoop);\n  body.getUnits().add((endControlNoop.pop()));\n  body.getUnits().add(brchTgt);\n  condControlNoop.pop();\n}\n", "nl": "While Stmts Creation"}
{"code": "private static int mapToRank(String rank,int taxonId){\n  int targetLevel=TaxonomicLevels.getId(rank);\n  Node v=TaxonomyData.getTree().getANode(taxonId);\n  while (v != null) {\n    int level=TaxonomyData.getTaxonomicRank(taxonId);\n    if (level != 0 && level == targetLevel)     return taxonId;\n    if (v.getInDegree() == 0)     v=null;\n else {\n      v=v.getFirstInEdge().getSource();\n      taxonId=(Integer)v.getInfo();\n    }\n  }\n  return 0;\n}\n", "nl": "makes the given taxon to the ancestor taxon of the given rank"}
{"code": "public static boolean identical(ItemStack a,ItemStack b){\n  if (a == null && b == null) {\n    return true;\n  }\n else   if (a == null || b == null) {\n    return false;\n  }\n  return couldMerge(a,b);\n}\n", "nl": "return if the two itemstacks are identical, excepting stacksize"}
{"code": "public Type<?> findAncestor(final Class<?> ancestor){\n  if (ancestor.isInterface()) {\n    return findInterface(ancestor);\n  }\n else {\n    if (this.getRawType().equals(ancestor)) {\n      return this;\n    }\n else     if (!TypeFactory.TYPE_OF_OBJECT.equals(this)) {\n      return getSuperType().findAncestor(ancestor);\n    }\n else {\n      return null;\n    }\n  }\n}\n", "nl": "Finds a class or interface which is an ancestor of this type"}
{"code": "private DomainSuffixes(){\n  String file=\"domain-suffixes.xml\";\n  InputStream input=this.getClass().getClassLoader().getResourceAsStream(file);\n  assert input != null;\n  try {\n    new DomainSuffixesReader().read(this,input);\n  }\n catch (  Exception ex) {\n    LOG.warn(StringUtils.stringifyException(ex));\n  }\n}\n", "nl": "private ctor"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set layout=\");\n  String layout=np.getWordMatchesIgnoringCase(Basic.toString(AlignmentViewer.AlignmentLayout.values(),\" \"));\n  np.matchIgnoreCase(\";\");\n  AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  viewer.getSelectedBlock().clear();\n  viewer.setAlignmentLayout(AlignmentViewer.AlignmentLayout.valueOfIgnoreCase(layout),((Director)getDir()).getDocument().getProgressListener());\n  viewer.getAlignmentViewerPanel().zoom(\"both\",\"fit\",null);\n}\n", "nl": "parses the given command and executes it"}
{"code": "public String encodeSLD(StyledLayerDescriptor sld){\n  String xml=\"\";\n  if (sld != null) {\n    SLDTransformer transformer=new SLDTransformer();\n    transformer.setIndentation(2);\n    try {\n      xml=transformer.transform(sld);\n    }\n catch (    TransformerException e) {\n      ConsoleManager.getInstance().exception(this,e);\n    }\n  }\n  return xml;\n}\n", "nl": "Encode sld to a string"}
{"code": "@Override public int countMissing(){\n  int count=0;\n  for (int i=0; i < size(); i++) {\n    if (getByte(i) == MISSING_VALUE) {\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Returns the count of missing values in this column"}
{"code": "public void testAddAfterStop() throws Exception {\n  deleteAllDocs();\n  send(\"stopIndex\");\n  try {\n    send(\"addDocument\",\"{fields: {}}\");\n    fail();\n  }\n catch (  IOException ioe) {\n  }\n  send(\"startIndex\");\n}\n", "nl": "Make sure you get an error if you try to addDocument after index is stopped"}
{"code": "private boolean isConfigurationPluginAvailable(){\n  if (configurationPluginAvailable == null) {\n    try {\n      String value=APILocator.getPluginAPI().loadProperty(pluginName,\"environment\");\n      configurationPluginAvailable=(value != null);\n    }\n catch (    Exception e) {\n      Logger.warn(this,\"Exception while trying to get property 'environment' \",e);\n      configurationPluginAvailable=false;\n    }\n    Logger.info(this,\"Configuration plugin available: \" + configurationPluginAvailable);\n  }\n  return configurationPluginAvailable;\n}\n", "nl": "Check for the \"environment\" key in the pluginAPI"}
{"code": "public static SequenceSchema inferSequence(List<List<Writable>> record){\n  SequenceSchema.Builder builder=new SequenceSchema.Builder();\n  for (int i=0; i < record.size(); i++) {\n    if (record.get(i) instanceof DoubleWritable)     builder.addColumnDouble(String.valueOf(i));\n else     if (record.get(i) instanceof IntWritable)     builder.addColumnInteger(String.valueOf(i));\n else     if (record.get(i) instanceof LongWritable)     builder.addColumnLong(String.valueOf(i));\n else     if (record.get(i) instanceof FloatWritable)     builder.addColumnFloat(String.valueOf(i));\n else     throw new IllegalStateException(\"Illegal writable for infering schema of type \" + record.get(i).getClass().toString());\n  }\n  builder.minSequenceLength(record.size());\n  builder.maxSequenceLength(record.size());\n  return builder.build();\n}\n", "nl": "Infers a sequence schema based on the record"}
{"code": "public static <T>Type<T> valueOf(final TypeVariable<?> var){\n  if (var.getBounds().length > 0) {\n    Set<Type<?>> bounds=new HashSet<Type<?>>(var.getBounds().length);\n    for (int i=0, len=var.getBounds().length; i < len; ++i) {\n      bounds.add(valueOf(var.getBounds()[i]));\n    }\n    return (Type<T>)refineBounds(bounds);\n  }\n else {\n    return (Type<T>)TYPE_OF_OBJECT;\n  }\n}\n", "nl": "Finds the Type value of the given TypeVariable"}
{"code": "@NotNull private List<Pair<StyleResourceValue,Module>> resolveLocallyDefinedModuleThemes(){\n  final Module module=myConfiguration.getModule();\n  final List<Pair<StyleResourceValue,Module>> result=Lists.newArrayList();\n  fillModuleResources(module,ModuleResourceRepository.getModuleResources(module,true),result);\n  final List<AndroidFacet> allAndroidDependencies=AndroidUtils.getAllAndroidDependencies(module,false);\n  for (  AndroidFacet facet : allAndroidDependencies) {\n    fillModuleResources(facet.getModule(),facet.getModuleResources(true),result);\n  }\n  return result;\n}\n", "nl": "Resolve all themes available from passed Configuration's source module and its dependencies which are defined in the current project (doesn't include themes available from libraries)"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"show findToolbar=\");\n  boolean show=np.getBoolean();\n  np.matchIgnoreCase(\";\");\n  if (getViewer() instanceof IViewerWithFindToolBar) {\n    IViewerWithFindToolBar viewer=(IViewerWithFindToolBar)getViewer();\n    if (show) {\n      if (!viewer.getSearchManager().getFindDialogAsToolBar().isEnabled())       viewer.setShowFindToolBar(true);\n else       viewer.getSearchManager().getFindDialogAsToolBar().setEnabled(true);\n    }\n else     viewer.setShowFindToolBar(false);\n  }\n else {\n    NotificationsInSwing.showWarning(getViewer().getFrame(),\"Find not implemented for this type of window\");\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static StateModelDefinition build(){\n  StateModelDefinition.Builder builder=new StateModelDefinition.Builder(name);\n  builder.initialState(States.OFFLINE.name());\n  builder.addState(States.ONLINE.name(),20);\n  builder.addState(States.OFFLINE.name(),-1);\n  for (  HelixDefinedState state : HelixDefinedState.values()) {\n    builder.addState(state.name(),-1);\n  }\n  builder.addTransition(States.ONLINE.name(),States.OFFLINE.name(),25);\n  builder.addTransition(States.OFFLINE.name(),States.ONLINE.name(),5);\n  builder.addTransition(States.OFFLINE.name(),HelixDefinedState.DROPPED.name(),0);\n  builder.dynamicUpperBound(States.ONLINE.name(),\"R\");\n  return builder.build();\n}\n", "nl": "Build OnlineOffline state model definition"}
{"code": "@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) @Override public void onBaseContextAttached(Context base){\n  super.onBaseContextAttached(base);\n  MultiDex.install(base);\n  SampleApplicationContext.application=getApplication();\n  SampleApplicationContext.context=getApplication();\n  TinkerManager.setTinkerApplicationLike(this);\n  TinkerManager.initFastCrashProtect();\n  TinkerManager.setUpgradeRetryEnable(true);\n  TinkerInstaller.setLogIml(new MyLogImp());\n  TinkerManager.installTinker(this);\n}\n", "nl": "install multiDex before install tinker so we don't need to put the tinker lib classes in the main dex"}
{"code": "protected void importTypes(Types types){\n  SchemaCompiler compiler=XJC.createSchemaCompiler();\n  ErrorListener elForRun=new ConsoleErrorReporter();\n  compiler.setErrorListener(elForRun);\n  Element rootTypes=this.getRootTypes();\n  this.createDefaultStructures(rootTypes);\n  S2JJAXBModel intermediateModel=this.compileModel(types,compiler,rootTypes);\n  Collection<? extends Mapping> mappings=intermediateModel.getMappings();\n  for (  Mapping mapping : mappings) {\n    this.importStructure(mapping);\n  }\n}\n", "nl": "Import the Types from the WSDL definition using the same strategy that Cxf uses taking advantage of JAXB"}
{"code": "private int measureLong(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=mViewPager.getAdapter().getCount();\n    result=(int)(getPaddingLeft() + getPaddingRight() + (count * 2 * mRadius)+ (count - 1) * mRadius + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the width of this view"}
{"code": "private void addShadowView(){\n  if (mShadowView == null) {\n    mShadowView=new ShadowView(getContext());\n    mShadowView.setX(-SHADOW_WIDTH);\n  }\n  final FrameLayout.LayoutParams layoutParams=new FrameLayout.LayoutParams(SHADOW_WIDTH,FrameLayout.LayoutParams.MATCH_PARENT);\n  final FrameLayout contentView=mCurrentContentView;\n  contentView.addView(mShadowView,1,layoutParams);\n}\n", "nl": "add shadow view on the left of content view"}
{"code": "public double computeMaxClassValueUsingPercentFactorPerSeries(DefaultChartData chartData,String[] series,double[] percentFactorPerSeries){\n  double maxValue=0;\n  for (  String className : chartData.getClassNamesIncludingDisabled()) {\n    double total=0;\n    for (int i=0; i < series.length; i++) {\n      String seriesName=series[i];\n      if (transposedHeightsAdditive)       total+=percentFactorPerSeries[i] * chartData.getValueAsDouble(seriesName,className);\n else       total=Math.max(total,percentFactorPerSeries[i] * chartData.getValueAsDouble(seriesName,className));\n    }\n    if (total > maxValue) {\n      maxValue=total;\n    }\n  }\n  return 1.1 * maxValue;\n}\n", "nl": "gets the max value for a given class in a transposed chart when using percentages"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  String choice=ProgramProperties.get(\"NucleotideColorScheme\",ColorSchemeNucleotides.NAMES.Default.toString());\n  String result=(String)JOptionPane.showInputDialog(getViewer().getFrame(),\"Choose nucleotide color scheme\",\"Choose colors\",JOptionPane.QUESTION_MESSAGE,ProgramProperties.getProgramIcon(),ColorSchemeNucleotides.getNames(),choice);\n  if (result != null) {\n    result=result.trim();\n    if (result.length() > 0) {\n      ProgramProperties.put(\"NucleotideColorScheme\",result);\n      execute(\"set nucleotideColors='\" + result + \"';\");\n    }\n  }\n}\n", "nl": "action to be performed"}
{"code": "@Override public void onSuccess(AirMapFlight response){\n  if (response != null) {\n    flightId=response.getFlightId();\n    options.setUserName(flightId);\n    AirMapLog.v(\"TrafficService\",options.toString());\n    AirMapLog.i(\"TrafficService\",\"Got flight with id: \" + flightId);\n    AirMapLog.i(\"TrafficService\",\"Connecting to MQTT server\");\n    try {\n      client.connect(options,ConnectionState.Connecting,actionListener);\n    }\n catch (    MqttException e) {\n      onDisconnect(false);\n    }\n  }\n}\n", "nl": "Called when the current flight was successfully received"}
{"code": "private int measureWidth(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=mViewPager.getAdapter().getCount();\n    result=getPaddingLeft() + getPaddingRight() + (count * mLineWidth)+ ((count - 1) * mGapWidth);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)FloatMath.ceil(result);\n}\n", "nl": "Determines the width of this view"}
{"code": "private static void paintShadow(Graphics2D g,ColorSet colorSet,ConnectionDrawing drawing){\n  Color pre=g.getColor();\n  Stroke s=g.getStroke();\n  if (colorSet.getStyle() == WidgetDecorator.BLUEPRINT_STYLE) {\n    g.setPaint(colorSet.getBackgroundPaint());\n    g.setStroke(sLineShadowStroke);\n  }\n else {\n    g.setColor(colorSet.getShadow());\n    g.setStroke(colorSet.getShadowStroke());\n  }\n  drawing.draw(g);\n  g.setColor(pre);\n  g.setStroke(s);\n}\n", "nl": "Utility to draw the given drawing as a shadow"}
{"code": "private LRMIMethod(IMethod realMethod,boolean isOneWay,boolean isCallBack,boolean isAsync,boolean useStubCache,boolean livenessPriority,boolean monitoringPriority,boolean isCustomTracking,int orderId,boolean supported){\n  this.realMethod=realMethod;\n  this.isOneWay=isOneWay;\n  this.isCallBack=isCallBack;\n  this.useStubCache=useStubCache;\n  this.isCustomTracking=isCustomTracking;\n  this.orderId=orderId;\n  this.isAsync=isAsync;\n  this.supported=supported;\n  this.isLivenessPriority=livenessPriority;\n  this.isMonitoringPriority=monitoringPriority;\n  this.methodTypes=this.realMethod == null ? null : this.realMethod.getParameterTypes();\n  this.realMethodString=LRMIUtilities.getMethodDisplayString(this.realMethod);\n}\n", "nl": "Private lrmi method that constructs an unsupported method representation"}
{"code": "public boolean filterOut(final SAMRecord record){\n  if (include) {\n    if (record.getSupplementaryAlignmentFlag()) {\n      return false;\n    }\n  }\n else {\n    if (!record.getSupplementaryAlignmentFlag()) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "static public void closeAllDatabase(){\n  Log.i(tag,\"closeAllDatabase\");\n  if (mInstance != null) {\n    for (int i=0; i < mInstance.databases.size(); ++i) {\n      if (mInstance.databases.get(i) != null) {\n        mInstance.databases.get(i).close();\n      }\n    }\n    mInstance.databases.clear();\n  }\n}\n", "nl": "Close all assets database"}
{"code": "private void cleanup(){\n  Iterator<Entry<Byte,Nonce>> iter=table.entrySet().iterator();\n  while (iter.hasNext()) {\n    Nonce nonce=iter.next().getValue();\n    if (nonce.getTimer() != null && nonce.getTimer().isExpired()) {\n      logger.warn(\"NODE {}: Expiring nonce with id={}\",node.getNodeId(),nonce.getNonceId());\n      iter.remove();\n      byte nonceId=nonce.getNonceId();\n      Iterator<Map.Entry<Long,Nonce>> iter2=timeToNonceMap.entrySet().iterator();\n      while (iter2.hasNext()) {\n        Map.Entry<Long,Nonce> entry=iter2.next();\n        if (nonceId == entry.getValue().getNonceId()) {\n          iter2.remove();\n        }\n      }\n    }\n  }\n}\n", "nl": "Remove any expired nonces from our table"}
{"code": "public static boolean calculateFallDamage(Player player,float distance,boolean stoped){\n  if (player.isInvul()) {\n    return false;\n  }\n  if (distance >= FallDamageConfig.MAXIMUM_DISTANCE_DAMAGE || !stoped) {\n    player.getController().onStopMove();\n    player.getFlyController().onStopGliding(false);\n    player.getLifeStats().reduceHp(player.getLifeStats().getMaxHp() + 1,player);\n    return true;\n  }\n else   if (distance >= FallDamageConfig.MINIMUM_DISTANCE_DAMAGE) {\n    float dmgPerMeter=player.getLifeStats().getMaxHp() * FallDamageConfig.FALL_DAMAGE_PERCENTAGE / 100f;\n    int damage=(int)(distance * dmgPerMeter);\n    player.getLifeStats().reduceHp(damage,player);\n    PacketSendUtility.sendPacket(player,new SM_ATTACK_STATUS(player,SM_ATTACK_STATUS.TYPE.FALL_DAMAGE,0,-damage));\n  }\n  return false;\n}\n", "nl": "Calculates the fall damage"}
{"code": "private AudioInputStream synthesizeVariant(AudioFileFormat aft,Element domElement) throws SynthesisException {\n  int numberOfBackChannels=unitFileReader.getNumberOfUnits();\n  int backchannelNumber=0;\n  if (domElement.hasAttribute(\"variant\")) {\n    backchannelNumber=Integer.parseInt(domElement.getAttribute(\"variant\"));\n  }\n  if (backchannelNumber >= numberOfBackChannels) {\n    throw new IllegalArgumentException(\"This voice has \" + numberOfBackChannels + \" backchannels only. so it doesn't support unit number \"+ backchannelNumber);\n  }\n  return synthesizeSelectedVocalization(backchannelNumber,aft,domElement);\n}\n", "nl": "Synthesize a \"variant\" vocalization"}
{"code": "Node(Node<K,V> parent,K key,int hash,Node<K,V> next,Node<K,V> prev){\n  this.parent=parent;\n  this.key=key;\n  this.hash=hash;\n  this.height=1;\n  this.next=next;\n  this.prev=prev;\n  prev.next=this;\n  next.prev=this;\n}\n", "nl": "Create a regular entry"}
{"code": "@Override public Settings init(String tag){\n  if (tag == null) {\n    throw new NullPointerException(\"tag may not be null\");\n  }\n  if (tag.trim().length() == 0) {\n    throw new IllegalStateException(\"tag may not be empty\");\n  }\n  this.tag=tag;\n  this.settings=new Settings();\n  return settings;\n}\n", "nl": "It is used to change the tag"}
{"code": "public String upload_file1(String master_file_id,String prefix_name,byte[] file_buff,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String[] parts=new String[2];\n  this.errno=this.split_file_id(master_file_id,parts);\n  if (this.errno != 0) {\n    return null;\n  }\n  parts=this.upload_file(parts[0],parts[1],prefix_name,file_buff,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload file to storage server (by file buff, slave file mode)"}
{"code": "public MonsterDamageCursor queryMonsterDamage(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=false;\n  qh.Table=S.TABLE_MONSTER_DAMAGE;\n  qh.Columns=null;\n  qh.Selection=S.COLUMN_MONSTER_DAMAGE_MONSTER_ID + \" = ?\";\n  qh.SelectionArgs=new String[]{String.valueOf(id)};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new MonsterDamageCursor(wrapHelper(qh));\n}\n", "nl": "****************************** MONSTER DAMAGE QUERIES"}
{"code": "public Matrix times(double s){\n  Matrix X=new Matrix(m,n);\n  double[][] C=X.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      C[i][j]=s * A[i][j];\n    }\n  }\n  return X;\n}\n", "nl": "Multiply a matrix by a scalar, C = s*A"}
{"code": "public void stopDragDropInteraction(){\n  for (  Layer layer : myLayers) {\n    if (layer instanceof ConstraintsLayer) {\n      ConstraintsLayer constraintsLayer=(ConstraintsLayer)layer;\n      if (constraintsLayer.isShowOnHover()) {\n        constraintsLayer.setShowOnHover(false);\n        repaint();\n      }\n    }\n  }\n}\n", "nl": "Gives us a chance to change layers behaviour upon drag and drop interaction ending"}
{"code": "public boolean isSideHandle(){\nswitch (mType) {\ncase LEFT_SIDE:\ncase RIGHT_SIDE:\ncase TOP_SIDE:\ncase BOTTOM_SIDE:\n    return true;\n}\nreturn false;\n}\n", "nl": "Return true if the ResizeHandle is a side handle (left/right/top/bottom)"}
{"code": "private void drawWind(Canvas canvas,float y,float xOffset){\n  float cof=(mScreenWidth + xOffset) / (LOADING_ANIMATION_COEFFICIENT / SLOW_DOWN_ANIMATION_COEFFICIENT);\n  float time=mLoadingAnimationTime;\n  if (mLastAnimationTime - mLoadingAnimationTime > 0) {\n    mInverseDirection=true;\n    time=(LOADING_ANIMATION_COEFFICIENT / SLOW_DOWN_ANIMATION_COEFFICIENT) - mLoadingAnimationTime;\n  }\n else {\n    mNewWindSet=true;\n    mInverseDirection=false;\n  }\n  float x=(mScreenWidth - (time * cof)) + xOffset - mWindLineWidth;\n  float xEnd=x + mWindLineWidth;\n  canvas.drawLine(x,y,xEnd,y,mWindPaint);\n}\n", "nl": "Draw wind on loading animation"}
{"code": "public static SequenceSchema inferSequenceMulti(List<List<List<Writable>>> record){\n  SequenceSchema.Builder builder=new SequenceSchema.Builder();\n  int minSequenceLength=record.get(0).size();\n  int maxSequenceLength=record.get(0).size();\n  for (int i=0; i < record.size(); i++) {\n    if (record.get(i) instanceof DoubleWritable)     builder.addColumnDouble(String.valueOf(i));\n else     if (record.get(i) instanceof IntWritable)     builder.addColumnInteger(String.valueOf(i));\n else     if (record.get(i) instanceof LongWritable)     builder.addColumnLong(String.valueOf(i));\n else     if (record.get(i) instanceof FloatWritable)     builder.addColumnFloat(String.valueOf(i));\n else     throw new IllegalStateException(\"Illegal writable for infering schema of type \" + record.get(i).getClass().toString() + \" with record \"+ record.get(0));\n    builder.minSequenceLength(Math.min(record.get(i).size(),minSequenceLength));\n    builder.maxSequenceLength(Math.max(record.get(i).size(),maxSequenceLength));\n  }\n  return builder.build();\n}\n", "nl": "Infers a sequence schema based on the record"}
{"code": "@deprecated public StringCharacterIterator(String text,int begin,int end,int pos){\n  if (text == null) {\n    throw new NullPointerException();\n  }\n  this.text=text;\n  if ((begin < 0) || (begin > end) || (end > text.length())) {\n    throw new IllegalArgumentException(\"Invalid substring range\");\n  }\n  if ((pos < begin) || (pos > end)) {\n    throw new IllegalArgumentException(\"Invalid position\");\n  }\n  this.begin=begin;\n  this.end=end;\n  this.pos=pos;\n}\n", "nl": "/*    "}
{"code": "public static int[] shuffle(int[] intArray,int shuffleCount){\n  int length;\n  if (intArray == null || shuffleCount < 0 || (length=intArray.length) < shuffleCount) {\n    return null;\n  }\n  int[] out=new int[shuffleCount];\n  for (int i=1; i <= shuffleCount; i++) {\n    int random=getRandom(length - i);\n    out[i - 1]=intArray[random];\n    int temp=intArray[length - i];\n    intArray[length - i]=intArray[random];\n    intArray[random]=temp;\n  }\n  return out;\n}\n", "nl": "Shuffling algorithm, Randomly permutes the specified int array"}
{"code": "public static void main(String[] args){\n  try {\n    ProgramProperties.setProgramName(\"ReferencesAnnotator\");\n    ProgramProperties.setProgramVersion(megan.main.Version.SHORT_DESCRIPTION);\n    PeakMemoryUsageMonitor.start();\n    (new ReferencesAnnotator()).run(args);\n    System.err.println(\"Total time:  \" + PeakMemoryUsageMonitor.getSecondsSinceStartString());\n    System.err.println(\"Peak memory: \" + PeakMemoryUsageMonitor.getPeakUsageString());\n    System.exit(0);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n    System.exit(1);\n  }\n}\n", "nl": "merge RMA files"}
{"code": "public static ArrayWritable jsonArrayStringtoArrayWritable(String jsonString){\n  String modString=jsonString.replaceFirst(\"\\\\[\",\"\");\n  modString=modString.replaceFirst(\"\\\\]\",\"\");\n  modString=modString.replaceAll(\"\\\"\",\"\");\n  String[] elements=modString.split(\"\\\\s*,\\\\s*\");\n  logger.debug(\"elements = \");\n  for (  String element : elements) {\n    logger.debug(\"element: \" + element);\n  }\n  return new ArrayWritable(elements);\n}\n", "nl": "Method to take an input json array format string and output an ArrayWritable"}
{"code": "public static byte[] encryptMD5(byte[] bytes){\n  try {\n    MessageDigest md=MessageDigest.getInstance(\"MD5\");\n    md.update(bytes);\n    return md.digest();\n  }\n catch (  NoSuchAlgorithmException e) {\n    e.printStackTrace();\n  }\n  return new byte[0];\n}\n", "nl": "Encrypt byte array"}
{"code": "public WishlistCursor queryWishlists(){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=false;\n  qh.Table=S.TABLE_WISHLIST;\n  qh.Columns=null;\n  qh.Selection=null;\n  qh.SelectionArgs=null;\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new WishlistCursor(wrapHelper(qh));\n}\n", "nl": "****************************** WISHLIST QUERIES"}
{"code": "public static int resumeChecksum(int previousChecksum,ByteBuf payload){\n  if (payload.hasMemoryAddress() && (CRC32C_HASH instanceof Sse42Crc32C)) {\n    return CRC32C_HASH.resume(previousChecksum,payload.memoryAddress() + payload.readerIndex(),payload.readableBytes());\n  }\n else   if (payload.hasArray()) {\n    return CRC32C_HASH.resume(previousChecksum,payload.array(),payload.arrayOffset() + payload.readerIndex(),payload.readableBytes());\n  }\n else {\n    return CRC32C_HASH.resume(previousChecksum,payload.nioBuffer());\n  }\n}\n", "nl": "Computes incremental checksum with input previousChecksum and input payload"}
{"code": "public static boolean isGiftCard(String stPassed){\n  if (isOFBGiftCard(stPassed)) {\n    return true;\n  }\n else   if (isValueLinkCard(stPassed)) {\n    return true;\n  }\n  return false;\n}\n", "nl": "Check to see if a card number is a supported Gift Card"}
{"code": "public static <E>RingBuffer<E> create(ProducerType producerType,EventFactory<E> factory,int bufferSize,WaitStrategy waitStrategy){\nswitch (producerType) {\ncase SINGLE:\n    return createSingleProducer(factory,bufferSize,waitStrategy);\ncase MULTI:\n  return createMultiProducer(factory,bufferSize,waitStrategy);\ndefault :\nthrow new IllegalStateException(producerType.toString());\n}\n}\n", "nl": "Create a new Ring Buffer with the specified producer type (SINGLE or MULTI)"}
{"code": "public static void openPermissionsSettings(Context context){\n  if (context == null) {\n    return;\n  }\n  final Intent i=new Intent();\n  i.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n  i.addCategory(Intent.CATEGORY_DEFAULT);\n  i.setData(Uri.parse(\"package:\" + context.getPackageName()));\n  i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n  i.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);\n  i.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n  context.startActivity(i);\n}\n", "nl": "Open the app settings to enable permissions"}
{"code": "public void destroyView() throws CanceledException {\n  ProgramProperties.put(MeganProperties.CHART_WINDOW_GEOMETRY,new int[]{getLocation().x,getLocation().y,getSize().width,getSize().height});\n  MeganProperties.removePropertiesListListener(getJMenuBar().getRecentFilesListener());\n  executorService.shutdownNow();\n  boolean ok=false;\n  try {\n    ok=executorService.awaitTermination(2,TimeUnit.SECONDS);\n  }\n catch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  if (!ok)   NotificationsInSwing.showInternalError(getFrame(),\"Failed to terminate runaway threads... (consider restarting MEGAN)\");\n  getChartDrawer().close();\n  if (searchManager != null && searchManager.getFindDialogAsToolBar() != null)   searchManager.getFindDialogAsToolBar().close();\n  dir.removeViewer(this);\n  dispose();\n}\n", "nl": "ask view to destroy itself"}
{"code": "public String upload_file1(String master_file_id,String prefix_name,String local_filename,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String[] parts=new String[2];\n  this.errno=this.split_file_id(master_file_id,parts);\n  if (this.errno != 0) {\n    return null;\n  }\n  parts=this.upload_file(parts[0],parts[1],prefix_name,local_filename,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload file to storage server (by file name, slave file mode)"}
{"code": "public static String bytesToHex(byte[] src){\n  char[] res=new char[src.length * 2];\n  final char hexDigits[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n  for (int i=0, j=0; i < src.length; i++) {\n    res[j++]=hexDigits[src[i] >>> 4 & 0x0f];\n    res[j++]=hexDigits[src[i] & 0x0f];\n  }\n  return new String(res);\n}\n", "nl": "Convert bytes to Hex"}
{"code": "public void print(){\n  System.out.println(\"<INDEX>\");\n  int numIdx=getNumIdx();\n  System.out.println(\"interval = \" + idxInterval);\n  System.out.println(\"numIdx = \" + numIdx);\n  for (int i=0; i < numIdx; i++) {\n    System.out.println(\"( \" + bytePtrs[i] + \" , \"+ timePtrs[i]+ \" )\");\n  }\n  System.out.println(\"</INDEX>\");\n}\n", "nl": "Method which writes an index to stdout"}
{"code": "@Override public int fillConvertedChunkData(int rowId,int columnIndex,int[] row,KeyStructureInfo restructuringInfo){\n  if (chunkAttributes.getInvertedIndexes() != null) {\n    rowId=chunkAttributes.getInvertedIndexesReverse()[rowId];\n  }\n  int start=rowId * chunkAttributes.getColumnValueSize();\n  int dict=0;\n  for (int i=start; i < start + chunkAttributes.getColumnValueSize(); i++) {\n    dict<<=8;\n    dict^=dataChunk[i] & 0xFF;\n  }\n  row[columnIndex]=dict;\n  return columnIndex + 1;\n}\n", "nl": "Converts to column dictionary integer value"}
{"code": "private void createNewPlayedEntry(final SQLiteDatabase database,final long songId){\n  float newScore=getScoreMultiplierForWeek(0);\n  int newPlayCount=1;\n  final ContentValues values=new ContentValues(3);\n  values.put(SongPlayCountColumns.ID,songId);\n  values.put(SongPlayCountColumns.PLAYCOUNTSCORE,newScore);\n  values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX,mNumberOfWeeksSinceEpoch);\n  values.put(getColumnNameForWeek(0),newPlayCount);\n  database.insert(SongPlayCountColumns.NAME,null,values);\n}\n", "nl": "This creates a new entry that indicates a song has been played once as well as its score"}
{"code": "public int computeId(BitSet activeMatches,IReadBlock readBlock){\n  if (name2id != null) {\n    final String name=readBlock.getReadName();\n    final Integer id=name2id.get(name);\n    if (id != null && id > 0)     return id;\n  }\n  if (activeMatches.cardinality() == 0)   return IdMapper.NOHITS_ID;\n  for (int i=activeMatches.nextSetBit(0); i != -1; i=activeMatches.nextSetBit(i + 1)) {\n    IMatchBlock match=readBlock.getMatchBlock(i);\n    int id=match.getId(cName);\n    if (id > 0)     return id;\n  }\n  return IdMapper.UNASSIGNED_ID;\n}\n", "nl": "computes the id for a read from its matches matches"}
{"code": "public void toTextOut(CART cart,PrintWriter pw) throws IOException {\n  try {\n    toWagonFormat(cart.getRootNode(),null,\"\",pw);\n    pw.flush();\n    pw.close();\n  }\n catch (  IOException ioe) {\n    IOException newIOE=new IOException(\"Error dumping CART to standard output\");\n    newIOE.initCause(ioe);\n    throw newIOE;\n  }\n}\n", "nl": "Debug output to a text file"}
{"code": "public void testThemeOverride(){\n  VirtualFile virtualFile=myFixture.copyFileToProject(\"themeEditor/themeEditorStyle/styles.xml\",\"res/values/styles.xml\");\n  myFixture.copyFileToProject(\"themeEditor/themeEditorStyle/styles_1.xml\",\"additionalModules/moduleA/res/values/styles.xml\");\n  ConfigurationManager configurationManager=myFacet.getConfigurationManager();\n  Configuration configuration=configurationManager.getConfiguration(virtualFile);\n  ThemeResolver resolver=new ThemeResolver(configuration);\n  ConfiguredThemeEditorStyle theme=resolver.getTheme(\"AppTheme\");\n  assertNotNull(theme);\n  assertEquals(1,theme.getParentNames().size());\n  assertEquals(\"ATheme\",theme.getParentNames().iterator().next().getElement());\n}\n", "nl": "Test that the main theme will override the one from the library"}
{"code": "public CASCDistanceCalculator() throws IOException {\n  Process p=Runtime.getRuntime().exec(PathToCasc);\n  try {\n    p.waitFor();\n  }\n catch (  InterruptedException iee) {\n    return;\n  }\n}\n", "nl": "Creates a new instance of CASCDistanceCalculator"}
{"code": "public static TransferTagValueImpl createTagForValue(final Object tagValue){\n  TransferTagValueImpl result;\n  DataTagQualityImpl tagQuality=new DataTagQualityImpl(TagQualityStatus.PROCESS_DOWN,\"Process Down\");\n  Timestamp sourceTimestamp=new Timestamp(System.currentTimeMillis());\n  Timestamp daqTimestamp=new Timestamp(System.currentTimeMillis());\n  Timestamp serverTimestamp=new Timestamp(System.currentTimeMillis());\n  String descr=\"Test transfer tag\";\n  String valDesc=\"Test val desc {{ \\\"aaa:\\\" \\\"342343\\\" } \\n , ] }\";\n  result=new TransferTagValueImpl(1234L,tagValue,valDesc,tagQuality,TagMode.TEST,sourceTimestamp,daqTimestamp,serverTimestamp,descr);\n  result.setValueClassName(tagValue.getClass().getName());\n  return result;\n}\n", "nl": "Helper method to create a <code>TransferTagValueImpl</code> test object"}
{"code": "private void validateNumCores(){\n  String numCoresStr=carbonProperties.getProperty(CarbonCommonConstants.NUM_CORES,CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);\n  try {\n    int numCores=Integer.parseInt(numCoresStr);\n    if (numCores < CarbonCommonConstants.NUM_CORES_MIN_VAL || numCores > CarbonCommonConstants.NUM_CORES_MAX_VAL) {\n      LOGGER.info(\"The num Cores  value \\\"\" + numCoresStr + \"\\\" is invalid. Using the default value \\\"\"+ CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);\n      carbonProperties.setProperty(CarbonCommonConstants.NUM_CORES,CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);\n    }\n  }\n catch (  NumberFormatException e) {\n    LOGGER.info(\"The num Cores  value \\\"\" + numCoresStr + \"\\\" is invalid. Using the default value \\\"\"+ CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);\n    carbonProperties.setProperty(CarbonCommonConstants.NUM_CORES,CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);\n  }\n}\n", "nl": "This method validates the number cores specified"}
{"code": "private void saveWidgetValues(){\n  IDialogSettings settings=getDialogSettings();\n  if (settings != null) {\n    if (showCredentials) {\n      String[] userNames=settings.getArray(STORE_USERNAME_ID);\n      if (userNames == null)       userNames=new String[0];\n      userNames=addToHistory(userNames,userCombo.getText());\n      settings.put(STORE_USERNAME_ID,userNames);\n    }\n    String[] hostNames=settings.getArray(STORE_URL_ID);\n    if (hostNames == null)     hostNames=new String[0];\n    hostNames=addToHistory(hostNames,urlCombo.getText());\n    settings.put(STORE_URL_ID,hostNames);\n  }\n}\n", "nl": "Saves the widget values for the next time"}
{"code": "public void storeFenceId(@NonNull String fenceId){\n  Set<String> setTmp=mPrefs.getStringSet(mPrefix + FENCE_ID_SET_KEY,null);\n  HashSet<String> fenceIdSet;\n  if (setTmp == null) {\n    fenceIdSet=new HashSet<>();\n  }\n else {\n    fenceIdSet=new HashSet<>(setTmp);\n  }\n  SharedPreferences.Editor editor=mPrefs.edit();\n  fenceIdSet.add(fenceId);\n  editor.putStringSet(mPrefix + FENCE_ID_SET_KEY,fenceIdSet);\n  editor.apply();\n}\n", "nl": "Stores immediately the given fence id to the store"}
{"code": "public void parseLabelMapFromLine(String labelMapAsLine){\n  NexusStreamParser np=new NexusStreamParser(new StringReader(labelMapAsLine));\n  try {\n    while (!np.peekMatchIgnoreCase(\";\")) {\n      String sample=np.getWordRespectCase();\n      np.matchIgnoreCase(\":\");\n      String label=np.getWordRespectCase();\n      sample2label.put(sample,label);\n    }\n  }\n catch (  IOException e) {\n  }\n}\n", "nl": "parse label map from line"}
{"code": "public static boolean isHasSdcard(){\n  String status=Environment.getExternalStorageState();\n  if (status.equals(Environment.MEDIA_MOUNTED)) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "sdcard check"}
{"code": "public Set<Speaker> find(final Speaker speaker){\n  final ArrayList<Speaker> speakers=new ArrayList<>();\n  speakers.addAll(this.speakers.values());\n  CollectionUtils.filter(speakers,null);\n  if (!speakers.isEmpty()) {\n    return new HashSet<>(speakers);\n  }\n  return Collections.emptySet();\n}\n", "nl": "Try and fuzzy find the specified Speaker"}
{"code": "private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints,float oldSide,float newSide){\n  float ratio=newSide / (2 * oldSide);\n  float dx=cornerPoints[0].getX() - cornerPoints[2].getX();\n  float dy=cornerPoints[0].getY() - cornerPoints[2].getY();\n  float centerx=(cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;\n  float centery=(cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;\n  ResultPoint result0=new ResultPoint(centerx + ratio * dx,centery + ratio * dy);\n  ResultPoint result2=new ResultPoint(centerx - ratio * dx,centery - ratio * dy);\n  dx=cornerPoints[1].getX() - cornerPoints[3].getX();\n  dy=cornerPoints[1].getY() - cornerPoints[3].getY();\n  centerx=(cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;\n  centery=(cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;\n  ResultPoint result1=new ResultPoint(centerx + ratio * dx,centery + ratio * dy);\n  ResultPoint result3=new ResultPoint(centerx - ratio * dx,centery - ratio * dy);\n  return new ResultPoint[]{result0,result1,result2,result3};\n}\n", "nl": "Expand the square represented by the corner points by pushing out equally in all directions"}
{"code": "public void cleanPatch(){\n  if (patchDirectory == null) {\n    return;\n  }\n  if (isTinkerLoaded()) {\n    TinkerLog.e(TAG,\"it is not safety to clean patch when tinker is loaded, you should kill all your process after clean!\");\n  }\n  SharePatchFileUtil.deleteDir(patchDirectory);\n}\n", "nl": "clean all patch files"}
{"code": "private int measureWidthSize(int measureSpec){\n  int defSize=dp2px(DEFAULT_WIDTH);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int result=0;\nswitch (specMode) {\ncase MeasureSpec.UNSPECIFIED:\ncase MeasureSpec.AT_MOST:\n    result=Math.min(defSize,specSize);\n  break;\ncase MeasureSpec.EXACTLY:\nresult=specSize;\nbreak;\n}\nreturn result;\n}\n", "nl": "measure width"}
{"code": "private void createInitializer(polyglot.ast.Initializer initializer){\n  if (initializer.flags().isStatic()) {\n    if (staticInitializerBlocks == null) {\n      staticInitializerBlocks=new ArrayList<Block>();\n    }\n    staticInitializerBlocks.add(initializer.body());\n  }\n else {\n    if (initializerBlocks == null) {\n      initializerBlocks=new ArrayList<Block>();\n    }\n    initializerBlocks.add(initializer.body());\n  }\n}\n", "nl": "Initializer Creation"}
{"code": "public static java.sql.Timestamp toTimestamp(String dateTime){\n  java.util.Date newDate=toDate(dateTime);\n  if (newDate != null) {\n    return new java.sql.Timestamp(newDate.getTime());\n  }\n else {\n    return null;\n  }\n}\n", "nl": "Converts a date and time String into a Timestamp"}
{"code": "@Override protected String dateToString(DateTimeData date){\n  StringBuffer message=new StringBuffer(16);\n  append(message,date.hour,2);\n  message.append(':');\n  append(message,date.minute,2);\n  message.append(':');\n  append(message,date.second);\n  append(message,(char)date.utc,0);\n  return message.toString();\n}\n", "nl": "Converts time object representation to String"}
{"code": "@deprecated protected void zeroPaddingNumber(NumberFormat nf,StringBuffer buf,int value,int minDigits,int maxDigits){\n  if ((this.useLocalZeroPaddingNumberFormat) && (value >= 0)) {\n    fastZeroPaddingNumber(buf,value,minDigits,maxDigits);\n  }\n else {\n    nf.setMinimumIntegerDigits(minDigits);\n    nf.setMaximumIntegerDigits(maxDigits);\n    nf.format(value,buf,new FieldPosition(-1));\n  }\n}\n", "nl": "/*     "}
{"code": "private float computeCorrelationCoefficent(String classNameX,String classNameY){\n  final ArrayList<Double> xValues=new ArrayList<>(getChartData().getSeriesNames().size());\n  final ArrayList<Double> yValues=new ArrayList<>(getChartData().getSeriesNames().size());\n  for (  String sample : getChartData().getSeriesNames()) {\n    xValues.add(getChartData().getValueAsDouble(sample,classNameX));\n    yValues.add(getChartData().getValueAsDouble(sample,classNameY));\n  }\n  return (float)Correlation.computePersonsCorrelationCoefficent(xValues.size(),xValues,yValues);\n}\n", "nl": "return Pearson's correlation coefficient"}
{"code": "public void testConfigurationUpdate(){\n  myFixture.copyFileToProject(\"themeEditor/attributeResolution/styles-v17.xml\",\"res/values-v17/styles.xml\");\n  myFixture.copyFileToProject(\"themeEditor/attributeResolution/styles-v19.xml\",\"res/values-v19/styles.xml\");\n  VirtualFile file=myFixture.copyFileToProject(\"themeEditor/attributeResolution/styles-v20.xml\",\"res/values-v20/styles.xml\");\n  ConfigurationManager configurationManager=myFacet.getConfigurationManager();\n  Configuration configuration=configurationManager.getConfiguration(file);\n  ThemeEditorContext context=new ThemeEditorContext(configuration);\n  ThemeResolver resolver=context.getThemeResolver();\n  assertNotNull(resolver.getTheme(\"V20OnlyTheme\"));\n  assertNotNull(resolver.getTheme(\"V19OnlyTheme\"));\n  assertNotNull(resolver.getTheme(\"V17OnlyTheme\"));\n  configuration.setTarget(new CompatibilityRenderTarget(configurationManager.getHighestApiTarget(),17,configurationManager.getHighestApiTarget()));\n  resolver=context.getThemeResolver();\n  assertNull(resolver.getTheme(\"V20OnlyTheme\"));\n  assertNull(resolver.getTheme(\"V19OnlyTheme\"));\n  assertNotNull(resolver.getTheme(\"V17OnlyTheme\"));\n}\n", "nl": "Check that, after a configuration update, the resolver updates the list of themes"}
{"code": "public static void configurePeriodicSync(Context context,Account account){\n  final String authority=context.getString(R.string.data_provider_authority);\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n    SyncRequest request=new SyncRequest.Builder().setExtras(Bundle.EMPTY).syncPeriodic(SYNC_INTERVAL,SYNC_FLEXTIME).setSyncAdapter(account,authority).build();\n    ContentResolver.requestSync(request);\n  }\n else {\n    ContentResolver.addPeriodicSync(account,authority,Bundle.EMPTY,SYNC_INTERVAL);\n  }\n  Log.v(LOG_TAG,\"Periodic sync configured with \" + SYNC_INTERVAL + \" interval and \"+ SYNC_FLEXTIME+ \" flextime\");\n}\n", "nl": "Helper method to schedule the sync adapter periodic execution"}
{"code": "public void flattenHierarchy(ConstraintWidgetContainer root){\n  ArrayList<ConstraintWidgetContainer> containers=gatherContainers(root);\n  while (containers.size() > 0) {\n    for (    ConstraintWidgetContainer container : containers) {\n      removeContainer(container);\n    }\n    containers=gatherContainers(root);\n  }\n}\n", "nl": "Flatten the hierachy -- remove all existing containers children of the given container"}
{"code": "public void writeString(String str) throws IOException {\n  if (str == null)   writeInt(0);\n else {\n    if (useCompression && str.length() >= Compressor.MIN_SIZE_FOR_DEFLATION) {\n      byte[] bytes=compressor.deflateString2ByteArray(str);\n      writeInt(-bytes.length);\n      io.write(bytes,0,bytes.length);\n    }\n else {\n      byte[] bytes=str.getBytes(\"UTF-8\");\n      writeInt(bytes.length);\n      io.write(bytes,0,bytes.length);\n    }\n  }\n}\n", "nl": "write a string"}
{"code": "protected void addRow(Object[] carbonTuple) throws SliceMergerException {\n  Object[] rowInWritableFormat;\n  rowInWritableFormat=tupleConvertor.getObjectArray(carbonTuple);\n  try {\n    this.dataHandler.addDataToStore(rowInWritableFormat);\n  }\n catch (  CarbonDataWriterException e) {\n    throw new SliceMergerException(\"Problem in merging the slice\",e);\n  }\n}\n", "nl": "Below method will be used to add sorted row"}
{"code": "public void addFiles(String fileUris,String group,Host host){\n  ParamValidationUtil.validateParamNotNull(fileUris,\"fileUris\");\n  ParamValidationUtil.validateParamNotNull(group,\"group\");\n  Host cleanHost=UtilMethods.isSet(host) ? host : HostTools.getCurrentHost(request);\n  for (  String fileUri : StringListUtil.getCleanStringList(fileUris)) {\n    FileAsset fileAsset=FileTools.getFileAssetByURI(fileUri,cleanHost,isLiveMode);\n    if (fileAsset != null) {\n      if (!fileMap.containsKey(group)) {\n        fileMap.put(group,new LinkedHashSet<FileAsset>());\n      }\n      fileMap.get(group).add(fileAsset);\n    }\n  }\n}\n", "nl": "Adds the given uris to the given group using the given dotCMS host as the host the uris should be looked up"}
{"code": "public void addFooter(@LayoutRes int layoutId,Object data){\n  int absoluteFootersCount=getAbsoluteFootersCount();\n  if (absoluteFootersCount > 0) {\n    int position=getItemCount() <= absoluteFootersCount ? 0 : getItemCount() - absoluteFootersCount;\n    mInserts.add(position,new Insertion(layoutId,data,Insertion.TYPE_FOOTER));\n    getItems().add(position,null);\n    mFootersCount+=1;\n  }\n else {\n    mInserts.add(new Insertion(layoutId,data,Insertion.TYPE_FOOTER));\n    getItems().add(null);\n    mFootersCount+=1;\n  }\n  notifyIfNeed();\n}\n", "nl": "Add footer after all items and before TYPE_ABSOLUTE_FOOTER"}
{"code": "public MonsterToQuestCursor queryMonsterToQuestMonster(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=true;\n  qh.Table=S.TABLE_MONSTER_TO_QUEST;\n  qh.Columns=null;\n  qh.Selection=\"mtq.\" + S.COLUMN_MONSTER_TO_QUEST_MONSTER_ID + \" = ? \";\n  qh.SelectionArgs=new String[]{\"\" + id};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=\"CASE q.\" + S.COLUMN_QUESTS_HUB + \" WHEN 'Village' THEN 0 WHEN 'Guild' THEN 1 WHEN 'Permit' THEN 2 ELSE (3||q.\"+ S.COLUMN_QUESTS_HUB+ \") END, \"+ \"q.\"+ S.COLUMN_QUESTS_STARS+ \" ASC\";\n  qh.Limit=null;\n  return new MonsterToQuestCursor(wrapJoinHelper(builderMonsterToQuest(qh.Distinct),qh));\n}\n", "nl": "****************************** MONSTER TO QUEST QUERIES"}
{"code": "public void deactivate(){\n  if (!inSelection) {\n    inSelection=true;\n    try {\n      chartSelection.clearSelectionAttributes();\n      this.repaint();\n    }\n  finally {\n      inSelection=false;\n    }\n  }\n}\n", "nl": "call this when tab containing list is deactivated"}
{"code": "public void writeLong(long a) throws IOException {\n  outs.write((byte)(a >> 56));\n  outs.write((byte)(a >> 48));\n  outs.write((byte)(a >> 40));\n  outs.write((byte)(a >> 32));\n  outs.write((byte)(a >> 24));\n  outs.write((byte)(a >> 16));\n  outs.write((byte)(a >> 8));\n  outs.write((byte)(a));\n  position+=8;\n}\n", "nl": "write a long"}
{"code": "@deprecated public final void reset(){\n  while (stackIsNotEmpty()) {\n    pop();\n  }\n  this.scriptStart=this.textStart;\n  this.scriptLimit=this.textStart;\n  this.scriptCode=-1;\n  this.parenSP=-1;\n  this.pushCount=0;\n  this.fixupCount=0;\n  this.textIndex=this.textStart;\n}\n", "nl": "/*    "}
{"code": "public Matrix times(double s){\n  Matrix X=new Matrix(m,n);\n  double[][] C=X.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      C[i][j]=s * A[i][j];\n    }\n  }\n  return X;\n}\n", "nl": "Multiply a matrix by a scalar, C = s*A"}
{"code": "private Throwable extractThrowable(Runnable runnable){\n  if ((runnable instanceof Future<?>) && ((Future<?>)runnable).isDone()) {\n    try {\n      ((Future<?>)runnable).get();\n    }\n catch (    CancellationException e) {\n      LOG.info(\"Task {} cancelled\",runnable,e.getCause());\n    }\ncatch (    InterruptedException e) {\n      LOG.info(\"Task {} was interrupted\",runnable,e);\n    }\ncatch (    ExecutionException e) {\n      return e.getCause();\n    }\n  }\n  return null;\n}\n", "nl": "Extract the exception (throwable) inside the ScheduledFutureTask"}
{"code": "public static <T>Set<T> toSet(T obj1,T obj2,T obj3,T obj4,T obj5){\n  Set<T> theSet=new LinkedHashSet<T>();\n  theSet.add(obj1);\n  theSet.add(obj2);\n  theSet.add(obj3);\n  theSet.add(obj4);\n  theSet.add(obj5);\n  return theSet;\n}\n", "nl": "Create a Set from passed objX parameters"}
{"code": "public static String rawHexDump(byte[] b){\n  if (b == null)   return \"\";\n  int size=b.length;\n  if (size == 0)   return \"\";\n  StringBuffer buf=new StringBuffer();\n  for (  byte aB : b) {\n    buf.append(zeropad(Integer.toHexString(byteToUInt(aB)).toUpperCase(),2));\n    buf.append(\" \");\n  }\n  buf.delete(buf.length() - 1,buf.length());\n  return buf.toString();\n}\n", "nl": "Returns the hex dump of the given byte array"}
{"code": "public SerialMessage startLevelChangeMessage(boolean increase,int duration){\n  logger.debug(\"NODE {}: Creating new message for command SWITCH_MULTILEVEL_START_LEVEL_CHANGE\",getNode().getNodeId());\n  SerialMessage result=new SerialMessage(getNode().getNodeId(),SerialMessageClass.SendData,SerialMessageType.Request,SerialMessageClass.SendData,SerialMessagePriority.Set);\n  byte[] newPayload={(byte)getNode().getNodeId(),5,(byte)getCommandClass().getKey(),(byte)SWITCH_MULTILEVEL_START_LEVEL_CHANGE,0,0,0};\n  if (increase) {\n    newPayload[4]=32;\n  }\n else {\n    newPayload[4]=96;\n  }\n  newPayload[5]=0;\n  newPayload[6]=(byte)duration;\n  result.setMessagePayload(newPayload);\n  return result;\n}\n", "nl": "Gets a SerialMessage with the SWITCH_MULTILEVEL_START_LEVEL_CHANGE command"}
{"code": "public String readString() throws IOException {\n  int size=readInt();\n  if (Math.abs(size) > 100000000)   throw new IOException(\"Unreasonable string length: \" + Math.abs(size));\n  byte[] bytes=new byte[Math.abs(size)];\n  int got=io.read(bytes,0,Math.abs(size));\n  if (got != Math.abs(size))   throw new IOException(\"Bytes read: \" + got + \", expected: \"+ Math.abs(size));\n  if (size < 0) {\n    try {\n      return compressor.inflateByteArray2String(-size,bytes);\n    }\n catch (    DataFormatException e) {\n      throw new IOException(e.getMessage());\n    }\n  }\n else {\n    return Compressor.convertUncompressedByteArray2String(size,bytes);\n  }\n}\n", "nl": "reads an archived string"}
{"code": "private void processFormFieldBegin(){\n  currentFieldPosition++;\n  FormField field=formFields.get(currentFieldPosition);\n  slickFormSubmitButton.setText(field.getStepLabel());\n  slickFieldContainer.setVisibility(View.VISIBLE);\n  slickFieldContainer.setAlpha(0.0f);\n  slickFieldContainer.animate().translationY(slickFormSubmitButton.getY()).alpha(1.0f);\n  applySlideDownAnimationTo(slickFormSubmitButton);\n  slickFieldContainer.addView(field);\n}\n", "nl": "Initialize the form submition progress by enabling the input field"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"deselect series=\");\n  List<String> list=np.getTokensRespectCase(null,\";\");\n  ChartViewer viewer=(ChartViewer)getViewer();\n  for (  String name : list) {\n    if (name.equalsIgnoreCase(\"all\"))     viewer.getChartSelection().setSelectedSeries(viewer.getChartData().getSeriesNames(),false);\n else     viewer.getChartSelection().setSelectedSeries(name,false);\n  }\n  viewer.repaint();\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static IQueryProcessor newInstance(IJSpace proxy,IRemoteSpace remoteSpace,Properties config) throws Exception {\n  if (isRemoteQueryProcessor(config))   return remoteSpace.getQueryProcessor();\n  ISpaceProxy clusteredProxy=(ISpaceProxy)proxy;\n  ISpaceProxy singleProxy=clusteredProxy;\n  if (clusteredProxy.isClustered()) {\n    singleProxy=(ISpaceProxy)clusteredProxy.getDirectProxy().getNonClusteredProxy();\n    CredentialsProvider credentialsProvider=clusteredProxy.getDirectProxy().getSecurityManager().getCredentialsProvider();\n    if (credentialsProvider != null)     singleProxy.getDirectProxy().getSecurityManager().login(credentialsProvider);\n  }\n  return newLocalInstance(clusteredProxy,singleProxy,config,null);\n}\n", "nl": "Creates local or remote QP according to configuration"}
{"code": "private int replicateAndfreeCache(Context context){\n  if (context != null) {\n    try {\n      return performReplication(context);\n    }\n  finally {\n      _cacheManager.freeCacheContext(context);\n    }\n  }\n  return 0;\n}\n", "nl": "Replicate and free the cache context"}
{"code": "public static boolean isCraftingSkill(int skillId){\n  Iterator<Integer> it=craftingSkillIds.iterator();\n  while (it.hasNext()) {\n    if (it.next() == skillId) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "check if skillId is crafting skill or not"}
{"code": "public static String clockFormat(long duration){\n  long value=duration;\n  value=value / 1000;\n  long seconds=value % 60;\n  value=value / 60;\n  long minutes=value % 60;\n  value=value / 60;\n  long hours=value % 24;\n  return ((hours < 10 ? \"0\" + hours : \"\" + hours) + \":\" + (minutes < 10 ? \"0\" + minutes : \"\" + minutes)+ \":\"+ (seconds < 10 ? \"0\" + seconds : \"\" + seconds));\n}\n", "nl": "Formats the duration as hh:mm:ss"}
{"code": "public static String parseCharset(Map<String,String> headers,String defaultCharset){\n  String contentType=headers.get(HTTP.CONTENT_TYPE);\n  if (contentType != null) {\n    String[] params=contentType.split(\";\");\n    for (int i=1; i < params.length; i++) {\n      String[] pair=params[i].trim().split(\"=\");\n      if (pair.length == 2) {\n        if (pair[0].equals(\"charset\")) {\n          return pair[1];\n        }\n      }\n    }\n  }\n  return defaultCharset;\n}\n", "nl": "Retrieve a charset from headers"}
{"code": "public void parseLines(String queryLine,String midLine,String subjectLine) throws IOException {\n  if (!queryLine.startsWith(Query))   throw new IOException(\"Token '\" + Query + \"' not found in line: \"+ queryLine);\n  String[] queryTokens=queryLine.split(\"\\\\s+\");\n  if (queryTokens.length != 4)   throw new IOException(\"Wrong number of tokens: \" + queryTokens.length + \" in query line: \"+ queryLine);\n  queryStart=Basic.parseInt(queryTokens[1]);\n  querySequence=queryTokens[2];\n  queryEnd=Basic.parseInt(queryTokens[3]);\n  if (!subjectLine.startsWith(Subject))   throw new IOException(\"Token '\" + Subject + \"' not found in line: \"+ midLine);\n  String[] subjTokens=subjectLine.split(\"\\\\s+\");\n  if (subjTokens.length != 4)   throw new IOException(\"Wrong number of tokens: \" + subjTokens.length + \" in subject line: \"+ subjectLine);\n  refStart=Basic.parseInt(subjTokens[1]);\n  refSequence=subjTokens[2];\n  refEnd=Basic.parseInt(subjTokens[3]);\n}\n", "nl": "parse the lines containing the match"}
{"code": "private static String generateAutoSubmitForm(String actionUrl,Map<String,String> paramMap){\n  StringBuilder html=new StringBuilder();\n  html.append(\"<script language=\\\"javascript\\\">window.onload=function(){document.pay_form.submit();}</script>\\n\");\n  html.append(\"<form id=\\\"pay_form\\\" name=\\\"pay_form\\\" action=\\\"\").append(actionUrl).append(\"\\\" method=\\\"post\\\">\\n\");\n  for (  String key : paramMap.keySet()) {\n    html.append(\"<input type=\\\"hidden\\\" name=\\\"\" + key + \"\\\" id=\\\"\"+ key+ \"\\\" value=\\\"\"+ paramMap.get(key)+ \"\\\">\\n\");\n  }\n  html.append(\"</form>\\n\");\n  return html.toString();\n}\n", "nl": "Generate an form, auto submit data to the given <code>actionUrl</code>"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set nodeRadius=\");\n  int radius=np.getInt(0,100);\n  np.matchIgnoreCase(\";\");\n  ClusterViewer viewer=getViewer();\n  for (Node v=viewer.getGraphView().getGraph().getFirstNode(); v != null; v=v.getNext()) {\n    viewer.getGraphView().getNV(v).setHeight(radius);\n    viewer.getGraphView().getNV(v).setWidth(radius);\n  }\n  viewer.setNodeRadius(radius);\n}\n", "nl": "parses the given command and executes it"}
{"code": "public CustomConfigurationBuilder(ClassLoader cl,String resource) throws ConfigurationException {\n  this();\n  InputStream is=cl.getResourceAsStream(resource);\n  if (is == null)   throw new ConfigurationException(\"Unable to locate resource '\" + resource + \"'\");\n  try {\n    try {\n      load(is);\n      loadedOnInstantiation=true;\n    }\n  finally {\n      is.close();\n    }\n  }\n catch (  IOException e) {\n    throw new ConfigurationException(e);\n  }\n}\n", "nl": "Load's the configuration from the specified resource"}
{"code": "public void haltAllTasks(){\n  LinkedList<Thread> endingThreads=new LinkedList<>();\n  endingThreads.addAll(executions.values());\n  for (  Thread thread : endingThreads) {\n    while (thread.isAlive() && thread != Thread.currentThread()) {\n      LOGGER.info(\"Interrupting execution thread \" + thread);\n      thread.interrupt();\n    }\n  }\n  executions.clear();\n}\n", "nl": "Interrupt all currently executing tasks, and clear the record of all executing tasks"}
{"code": "private int measureHeight(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=mPaintSelected.getStrokeWidth() + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)Math.ceil(result);\n}\n", "nl": "Determines the height of this view"}
{"code": "public static final Authentication create(String authPluginClassName,String authParamsString) throws UnsupportedAuthenticationException {\n  Map<String,String> authParams=new HashMap<String,String>();\n  if (isNotBlank(authParamsString)) {\n    String[] params=authParamsString.split(\",\");\n    for (    String p : params) {\n      String[] kv=p.split(\":\");\n      if (kv.length == 2) {\n        authParams.put(kv[0],kv[1]);\n      }\n    }\n  }\n  return AuthenticationFactory.create(authPluginClassName,authParams);\n}\n", "nl": "Create an instance of the Authentication-Plugin"}
{"code": "public static <V>int addDistinctList(List<V> sourceList,List<V> entryList){\n  if (sourceList == null || isEmpty(entryList)) {\n    return 0;\n  }\n  int sourceCount=sourceList.size();\n  for (  V entry : entryList) {\n    if (!sourceList.contains(entry)) {\n      sourceList.add(entry);\n    }\n  }\n  return sourceList.size() - sourceCount;\n}\n", "nl": "add all distinct entry to list1 from list2"}
{"code": "public int length(){\n  if (root.child == null) {\n    return 0;\n  }\n  if (length > -1) {\n    return length;\n  }\n  length=root.getChildCount();\n  return length;\n}\n", "nl": "Returns the number of fields on this object"}
{"code": "public static JsonNode addChild(JsonNode original,String key,JsonNode value){\n  Map<JsonStringNode,JsonNode> existingFields=original.getFields();\n  Map<JsonStringNode,JsonNode> newMap=new HashMap<>();\n  for (  Entry<JsonStringNode,JsonNode> entry : existingFields.entrySet()) {\n    newMap.put(entry.getKey(),entry.getValue());\n  }\n  newMap.put(JsonNodeFactories.string(key),value);\n  return JsonNodeFactories.object(newMap);\n}\n", "nl": "Add a child to the current json node"}
{"code": "final public void print(Object o){\n  try {\n    BufferedWriter writer=new BufferedWriter(resp.getWriter());\n    writer.write(o.toString());\n    writer.flush();\n  }\n catch (  Exception e) {\n    if (log.isErrorEnabled())     log.error(o,e);\n  }\n}\n", "nl": "Print the object to end-user"}
{"code": "private void onWaitingRoom(final int resultCode){\n  if (resultCode != Activity.RESULT_OK) {\n    Logger.log(\"waiting room result != ok, leaving room\");\n    leaveRoomIfExists(null,Option.<Throwable>none());\n  }\n else {\n    setSession(controller.session);\n  }\n  if (future != null && !future.isHappened()) {\n    Gdx.app.postRunnable(future);\n  }\n  future=null;\n}\n", "nl": "on main thread"}
{"code": "protected void animateToState(boolean checked){\n  if (mProcessAnimator == null) {\n    return;\n  }\n  if (mProcessAnimator.isRunning()) {\n    mProcessAnimator.cancel();\n  }\n  mProcessAnimator.setDuration(mAnimationDuration);\n  if (checked) {\n    mProcessAnimator.setFloatValues(mProcess,1f);\n  }\n else {\n    mProcessAnimator.setFloatValues(mProcess,0);\n  }\n  mProcessAnimator.start();\n}\n", "nl": "processing animation"}
{"code": "public static Properties loadConfigFile(String path){\n  Properties property=null;\n  File file=new File(path);\n  if (file.exists() && file.canRead()) {\n    try {\n      property=new Properties();\n      property.load(new FileReader(file.getAbsolutePath()));\n    }\n catch (    FileNotFoundException e) {\n      e.printStackTrace();\n    }\ncatch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n  return property;\n}\n", "nl": "searching the specified configuration file and return a Properties"}
{"code": "public static boolean isToday(Calendar _calendar){\n  Calendar now=Calendar.getInstance();\n  if (now.get(Calendar.DAY_OF_MONTH) == _calendar.get(Calendar.DAY_OF_MONTH)) {\n    if (now.get(Calendar.MONTH) == _calendar.get(Calendar.MONTH)) {\n      if (now.get(Calendar.YEAR) == _calendar.get(Calendar.YEAR)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Allows to know if a given calendar instance is set today"}
{"code": "public static boolean isMatchRegex(final String string,final String regex){\n  boolean result=false;\n  if (string != null && regex != null) {\n    Pattern pattern=Pattern.compile(regex);\n    Matcher matcher=pattern.matcher(string);\n    result=matcher.find();\n  }\n  return result;\n}\n", "nl": "<p>Method:only for regex</p>"}
{"code": "private static boolean isVmArt(String versionString){\n  boolean isArt=false;\n  if (versionString != null) {\n    Matcher matcher=Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)(\\\\.\\\\d+)?\").matcher(versionString);\n    if (matcher.matches()) {\n      try {\n        int major=Integer.parseInt(matcher.group(1));\n        int minor=Integer.parseInt(matcher.group(2));\n        isArt=(major > 2) || ((major == 2) && (minor >= 1));\n      }\n catch (      NumberFormatException e) {\n      }\n    }\n  }\n  return isArt;\n}\n", "nl": "vm whether it is art"}
{"code": "public static void f(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_FATAL) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.wtf(tag,msg);\n}\n", "nl": "Send a FATAL ERROR log message"}
{"code": "public static File unzipToTempFolder(File zipFile){\n  String zipFilename=zipFile.getName();\n  String tempFolderPrefix=zipFilename.substring(0,zipFilename.lastIndexOf('.'));\n  File tempFolder=createTempFolder(tempFolderPrefix);\n  try {\n    PUZipUtils.unzip(zipFile,tempFolder);\n    return tempFolder;\n  }\n catch (  Exception e) {\n    try {\n      FileUtils.deleteFileOrDirectory(tempFolder);\n    }\n catch (    RuntimeException ex) {\n      logger.debug(\"Failed to delete folder \" + tempFolder,ex);\n    }\n    throw new RuntimeException(\"Failed to unzip file \" + zipFile + \" to \"+ tempFolder,e);\n  }\n}\n", "nl": "unzips the specified zip file to a temp folder"}
{"code": "public CacheHeader(String key,Entry entry){\n  this.key=key;\n  this.size=entry.data.length;\n  this.etag=entry.etag;\n  this.serverDate=entry.serverDate;\n  this.ttl=entry.ttl;\n  this.softTtl=entry.softTtl;\n  this.responseHeaders=entry.responseHeaders;\n}\n", "nl": "Instantiates a new CacheHeader object"}
{"code": "private boolean isDefaultPackedEncoding(Field field){\n  if (field.getSyntax() == Syntax.SYNTAX_PROTO3 && field.isRepeated()) {\n    FieldDescriptorProto.Type fieldType=field.getProto().getType();\n    if (fieldType != FieldDescriptorProto.Type.TYPE_GROUP && fieldType != FieldDescriptorProto.Type.TYPE_BYTES && fieldType != FieldDescriptorProto.Type.TYPE_STRING && fieldType != FieldDescriptorProto.Type.TYPE_MESSAGE) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "In proto3, repeated fields of scalar numeric types use packed encoding by default"}
{"code": "public static String[] appendOverrides(String configFile){\n  if (configFile == null)   throw new NullPointerException(\"configFie is null\");\n  String[] confArgs;\n  if (overrideArgs != null)   confArgs=new String[overrideArgs.length + 1];\n else   confArgs=new String[]{\"\"};\n  confArgs[0]=configFile;\n  if (overrideArgs != null && overrideArgs.length > 0) {\n    for (int i=1; i < confArgs.length; i++)     confArgs[i]=overrideArgs[i - 1];\n  }\n  return (confArgs);\n}\n", "nl": "If this utility has been started with override arguments, append the override arguments to the configuration file"}
{"code": "public INDArray toRaveledTensor(File file){\n  try {\n    BufferedInputStream bis=new BufferedInputStream(new FileInputStream(file));\n    INDArray ret=toRaveledTensor(bis);\n    bis.close();\n    return ret.ravel();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Changes the input stream in to an bgr based raveled(flattened) vector"}
{"code": "private LocalResourceStatus basicGetStatus(IResource resource,StatusUpdateStrategy strategy) throws SVNException {\n  if (!resource.exists())   return LocalResourceStatus.NONE;\n  LocalResourceStatus status=null;\n  strategy.setStatusCache(statusCache);\n  setStatuses(resource,strategy.statusesToUpdate(resource));\n  status=statusCache.getStatus(resource);\n  if (status == null && resource != null && resource.getLocation() != null) {\n    status=new LocalResourceStatus(new SVNStatusUnversioned(resource.getLocation().toFile(),false),null,checkForReadOnly);\n  }\n  return status;\n}\n", "nl": "Get the statuse(s) from the svn meta files"}
{"code": "private int measureShort(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(3 * mRadius + getPaddingTop() + getPaddingBottom());\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the height of this view"}
{"code": "public static double euclideanDistance(float[] p,float[] q){\n  double ret=0;\n  for (int i=0; i < p.length; i++) {\n    double diff=(q[i] - p[i]);\n    double sq=Math.pow(diff,2);\n    ret+=sq;\n  }\n  return ret;\n}\n", "nl": "This returns the euclidean distance of two vectors sum(i=1,n)   (q_i - p_i)^2"}
{"code": "@Override public boolean equals(Object obj){\n  if (obj == null)   return false;\n  if (this == obj)   return true;\n  DynamicSmartStub eqSt=extractDynamicSmartStubFrom(obj);\n  if (eqSt == null)   return false;\n  if (eqSt == this)   return true;\n  if (_localObj != null && eqSt.getLocalObjImpl() != null)   return _localObj == eqSt.getLocalObjImpl();\n  return _remoteObjectId == eqSt._remoteObjectId;\n}\n", "nl": "Equals the DynamicSmartStub instances by direct obj reference if the stubs in local VM, otherwise equals by remoteObjId"}
{"code": "private String asReference(IProject project){\n  StringBuffer buffer=new StringBuffer();\n  buffer.append(\"0.9.3,\");\n  SVNTeamProvider provider=(SVNTeamProvider)RepositoryProvider.getProvider(project);\n  SVNWorkspaceRoot root=provider.getSVNWorkspaceRoot();\n  buffer.append(root.getLocalRoot().getUrl().toString());\n  buffer.append(\",\");\n  buffer.append(project.getName());\n  return buffer.toString();\n}\n", "nl": "Answer a string representing the specified project"}
{"code": "@Override public int[] colWidths(){\n  int cols=columnCount();\n  int[] widths=new int[cols];\n  List<String> columnNames=columnNames();\n  for (int i=0; i < columnCount(); i++) {\n    widths[i]=columnNames.get(i).length();\n  }\n  for (int rowNum=0; rowNum < rowCount(); rowNum++) {\n    for (int colNum=0; colNum < cols; colNum++) {\n      String value=get(colNum,rowNum);\n      widths[colNum]=Math.max(widths[colNum],StringUtils.length(value));\n    }\n  }\n  return widths;\n}\n", "nl": "Returns an array of column widths for printing tables"}
{"code": "@Override public boolean continueExecuting(){\n  if (!this.theEntityCreature.getNavigator().noPath() && this.theEntityCreature.getAITarget() != null) {\n    EntityLivingBase target=this.theEntityCreature.getAITarget();\n    if (target == null) {\n      return true;\n    }\n    double sqDistToPos=this.theEntityCreature.getDistanceSq(this.randPosX,this.randPosY,this.randPosZ);\n    if (sqDistToPos > 2.0D) {\n      double sqDistToTarget=this.theEntityCreature.getDistanceSqToEntity(target);\n      double sqDistOfTargetToPos=target.getDistanceSq(this.randPosX,this.randPosY,this.randPosZ);\n      if (sqDistToTarget < sqDistOfTargetToPos) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Returns whether an in-progress EntityAIBase should continue executing"}
{"code": "private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,ContrastMethod contrastMethod){\n  ContrastEnhancement contrastEnhancement=(ContrastEnhancement)styleFactory.contrastEnhancement(null,contrastMethod.name());\n  FilterFactory ff=CommonFactoryFinder.getFilterFactory();\n  Map<String,Expression> options=contrastEnhancement.getOptions();\n  options.put(\"algorithm\",ff.literal(\"TestStretchToMinimumMaximum\"));\n  options.put(\"minValue\",ff.literal(\"1.0\"));\n  options.put(\"maxValue\",ff.literal(\"5.0\"));\n  SelectedChannelType channelType=styleFactory.createSelectedChannelType(\"channel name\",contrastEnhancement);\n  SelectedChannelType[] channels=new SelectedChannelType[3];\n  channels[0]=channelType;\n  channels[1]=channelType;\n  channels[2]=channelType;\n  ChannelSelection channelSelection=styleFactory.createChannelSelection(channels);\n  return channelSelection;\n}\n", "nl": "Creates the channel selection error object"}
{"code": "public static void main(String[] args){\n  try {\n    ProgramProperties.setProgramName(\"Blast2LCA\");\n    ProgramProperties.setProgramVersion(megan.main.Version.SHORT_DESCRIPTION);\n    long start=System.currentTimeMillis();\n    (new Blast2LCA()).run(args);\n    System.err.println(\"Time: \" + ((System.currentTimeMillis() - start) / 1000) + \"s\");\n    System.exit(0);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n    System.exit(1);\n  }\n}\n", "nl": "prepare DNA protein for pDNA"}
{"code": "private void drawPress(Canvas canvas){\n  if (shapeType == 1) {\n    canvas.drawCircle(width / 2,height / 2,width / 2 - 1,pressPaint);\n  }\n else   if (shapeType == 2) {\n    RectF rectF=new RectF(1,1,width - 1,height - 1);\n    canvas.drawRoundRect(rectF,radius + 1,radius + 1,pressPaint);\n  }\n}\n", "nl": "draw the effect when pressed"}
{"code": "private String crawlCode(String content){\n  String result=\"\";\n  String resultSpan=\"\";\n  String resultParagraph=\"\";\n  String resultDiv=\"\";\n  resultSpan=getTagContent(\"span\",content);\n  resultParagraph=getTagContent(\"p\",content);\n  resultDiv=getTagContent(\"div\",content);\n  result=resultSpan;\n  if (resultParagraph.length() > resultSpan.length() && resultParagraph.length() >= resultDiv.length())   result=resultParagraph;\n else   if (resultParagraph.length() > resultSpan.length() && resultParagraph.length() < resultDiv.length())   result=resultDiv;\n else   result=resultParagraph;\n  return htmlDecode(result);\n}\n", "nl": "Crawls the code looking for relevant information"}
{"code": "private void updateTexts(DocumentEvent e){\n  Document doc=e.getDocument();\n  if (doc == projectNameTextField.getDocument() || doc == projectLocationTextField.getDocument()) {\n    String projectName=projectNameTextField.getText();\n    String projectFolder=projectLocationTextField.getText();\n    createdFolderTextField.setText(projectFolder + File.separatorChar + projectName);\n  }\n  panel.fireChangeEvent();\n}\n", "nl": "Handles changes in the Project name and project directory,"}
{"code": "private boolean addViewItem(int index,boolean first){\n  View view=getItemView(index);\n  if (view != null) {\n    if (first) {\n      itemsLayout.addView(view,0);\n    }\n else {\n      itemsLayout.addView(view);\n    }\n    return true;\n  }\n  return false;\n}\n", "nl": "Adds view for item to items layout"}
{"code": "private void updatePrimaryKeyMaxSurrogateMap(){\n  Map<String,Boolean> primaryKeyMap=columnsInfo.getPrimaryKeyMap();\n  for (  Entry<String,Boolean> entry : primaryKeyMap.entrySet()) {\n    if (!primaryKeyMap.get(entry.getKey())) {\n      int repeatedPrimaryFromLevels=getRepeatedPrimaryFromLevels(dimInsertFileNames,entry.getKey());\n      if (null == primaryKeysMaxSurroagetMap) {\n        primaryKeysMaxSurroagetMap=new HashMap<String,Integer>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n      }\n      primaryKeysMaxSurroagetMap.put(entry.getKey(),max[repeatedPrimaryFromLevels]);\n    }\n  }\n}\n", "nl": "update the"}
{"code": "private void handleFinalLocalParams(ArrayList sootParams,ArrayList sootParamTypes,polyglot.types.ClassType keyType){\n  HashMap<IdentityKey,AnonLocalClassInfo> finalLocalInfo=soot.javaToJimple.InitialResolver.v().finalLocalInfo();\n  if (finalLocalInfo != null) {\n    if (finalLocalInfo.containsKey(new polyglot.util.IdentityKey(keyType))) {\n      AnonLocalClassInfo alci=finalLocalInfo.get(new polyglot.util.IdentityKey(keyType));\n      ArrayList<IdentityKey> finalLocals=alci.finalLocalsUsed();\n      if (finalLocals != null) {\n        Iterator<IdentityKey> it=finalLocals.iterator();\n        while (it.hasNext()) {\n          Object next=it.next();\n          polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)next).object();\n          sootParamTypes.add(Util.getSootType(li.type()));\n          sootParams.add(getLocal(li));\n        }\n      }\n    }\n  }\n}\n", "nl": "Adds extra params"}
{"code": "public static void fillAndDrawRect(Graphics2D gc,double x,double y,double width,double height,double labelAngle,Color fillColor,Color drawColor){\n  Dimension theSize=new Dimension((int)Math.round(width),(int)Math.round(height));\n  Point2D apt=new Point2D.Float((float)x,(float)y);\n  AffineTransform saveTransform=gc.getTransform();\n  if (labelAngle >= 0.5 * Math.PI && labelAngle <= 1.5 * Math.PI) {\n    apt=Geometry.translateByAngle(apt,labelAngle,theSize.getWidth());\n    gc.rotate(Geometry.moduloTwoPI(labelAngle - Math.PI),apt.getX(),apt.getY());\n  }\n else {\n    gc.rotate(labelAngle,apt.getX(),apt.getY());\n  }\n  gc.setColor(fillColor);\n  gc.fillRect((int)Math.round(apt.getX()),(int)Math.round(apt.getY()) - theSize.height,theSize.width,theSize.height);\n  gc.setColor(drawColor);\n  gc.drawRect((int)Math.round(apt.getX()),(int)Math.round(apt.getY()) - theSize.height,theSize.width,theSize.height);\n  gc.setTransform(saveTransform);\n}\n", "nl": "draw a rectangle at the given anchor point at the given angle (in radiant)"}
{"code": "public static void readFully(InputStream in,byte[] bytes,int offset,int length) throws IOException {\n  if (length < 0) {\n    throw new IndexOutOfBoundsException();\n  }\n  int n=0;\n  while (n < length) {\n    int count=in.read(bytes,offset + n,length - n);\n    if (count < 0) {\n      throw new EOFException();\n    }\n    n+=count;\n  }\n}\n", "nl": "block until exactly <code>length</code> bytes read into <code>bytes</code>"}
{"code": "public static byte[] compressForZlib(String stringToCompress){\n  byte[] returnValues=null;\n  try {\n    returnValues=compressForZlib(stringToCompress.getBytes(\"UTF-8\"));\n  }\n catch (  UnsupportedEncodingException uee) {\n    uee.printStackTrace();\n  }\n  return returnValues;\n}\n", "nl": "zlib compress 2 byte"}
{"code": "private boolean checkPlayerSkill(final Player player,final GatherableTemplate template){\n  int harvestSkillId=template.getHarvestSkill();\n  if (!player.getSkillList().isSkillPresent(harvestSkillId)) {\n    if (harvestSkillId == 30001) {\n      PacketSendUtility.sendPacket(player,SM_SYSTEM_MESSAGE.STR_GATHER_INCORRECT_SKILL);\n    }\n else {\n      PacketSendUtility.sendPacket(player,new SM_SYSTEM_MESSAGE(1330054,new DescriptionId(DataManager.SKILL_DATA.getSkillTemplate(harvestSkillId).getNameId())));\n    }\n    return false;\n  }\n  if (player.getSkillList().getSkillLevel(harvestSkillId) < template.getSkillLevel()) {\n    PacketSendUtility.sendPacket(player,new SM_SYSTEM_MESSAGE(1330001,new DescriptionId(DataManager.SKILL_DATA.getSkillTemplate(harvestSkillId).getNameId())));\n    return false;\n  }\n  return true;\n}\n", "nl": "Checks whether player have needed skill for gathering and skill level is sufficient"}
{"code": "public static PageRespJson buildSuccessResponse(Object data,Integer reqId,Integer totalRecords){\n  PageRespJson respJson=new PageRespJson();\n  respJson.setCode(ResponseCode.SUCCESS.getCode());\n  respJson.setData(data);\n  respJson.setMsg(StringConstant.EMPTY_STRING);\n  respJson.setReqId(reqId);\n  respJson.setRecordsTotal(totalRecords);\n  respJson.setRecordsFiltered(totalRecords);\n  return respJson;\n}\n", "nl": "Construct Success Response"}
{"code": "public void close(){\n  try {\n    if (textStorageReader != null)     textStorageReader.closeAllFiles();\n    if (dataIndexReader != null)     dataIndexReader.close();\n    if (classDumpReader != null)     classDumpReader.close();\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n}\n", "nl": "close associated file or database"}
{"code": "public void dumpPAGForMethod(String fName,String cName,String mName) throws FileNotFoundException {\n  FileOutputStream fos=new FileOutputStream(new File(fName));\n  PrintStream ps=new PrintStream(fos);\n  ps.println(\"digraph G {\");\n  ps.println(\"\\trankdir=LR;\");\n  dumpLocalPAG(cName,mName,ps);\n  ps.print(\"}\");\n  try {\n    fos.close();\n  }\n catch (  IOException e) {\n  }\n  ps.close();\n}\n", "nl": "Dump the PAG for some method in the program in dot format"}
{"code": "public static void removeStoneStats(Set<? extends ManaStone> itemStones,CreatureGameStats<?> cgs){\n  if (itemStones == null || itemStones.size() == 0) {\n    return;\n  }\n  for (  ManaStone stone : itemStones) {\n    List<StatFunction> modifiers=stone.getModifiers();\n    if (modifiers != null) {\n      cgs.endEffect(stone);\n    }\n  }\n}\n", "nl": "All modifiers of stones will be removed"}
{"code": "public static String concatStrFromList(List<String> strList,String concatCharacter){\n  if (concatCharacter == null)   concatCharacter=StringConstant.DEFAULT_STRING_SEPARATOR;\n  if (strList != null && !strList.isEmpty()) {\n    StringBuilder sb=new StringBuilder();\n    int size=strList.size();\n    for (int i=0; i < size; ++i) {\n      sb.append(strList.get(i));\n      if (i < size - 1)       sb.append(concatCharacter);\n    }\n    return sb.toString();\n  }\n  return StringConstant.EMPTY_STRING;\n}\n", "nl": "Concat string from array list"}
{"code": "private SegmentNode generate_many_to_all(SegmentNode mp){\n  long left, right, t;\n  SegmentNode p;\n  left=mp.I1;\n  right=left + mp.L;\n  p=mp.next;\n  while (p != null) {\n    if (p.I1 < left)     left=p.I1;\n    t=p.I1 + p.L;\n    if (t > right)     right=t;\n    p=p.next;\n  }\n  mp.I1=left;\n  mp.I2=0;\n  mp.L=right - left;\n  mp.next=null;\n  return mp;\n}\n", "nl": "The result is in the form: (p, q, I, 0, L)"}
{"code": "private int calculateLayoutWidth(int widthSize,int mode){\n  initResourcesIfNecessary();\n  itemsLayout.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT));\n  itemsLayout.measure(MeasureSpec.makeMeasureSpec(widthSize,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  int width=itemsLayout.getMeasuredWidth();\n  if (mode == MeasureSpec.EXACTLY) {\n    width=widthSize;\n  }\n else {\n    width+=2 * PADDING;\n    width=Math.max(width,getSuggestedMinimumWidth());\n    if (mode == MeasureSpec.AT_MOST && widthSize < width) {\n      width=widthSize;\n    }\n  }\n  itemsLayout.measure(MeasureSpec.makeMeasureSpec(width - 2 * PADDING,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  return width;\n}\n", "nl": "Calculates control width and creates text layouts"}
{"code": "@Override public int hashCode(){\n  if (generateHashCode) {\n    cachedHashCode=0;\n    if (getEntityName() != null) {\n      cachedHashCode+=getEntityName().hashCode() >> 1;\n    }\n    cachedHashCode+=fields.hashCode() >> 1;\n    generateHashCode=false;\n  }\n  return cachedHashCode;\n}\n", "nl": "Creates a hashCode for the entity, using the default String hashCode and Map hashCode, overrides the default hashCode"}
{"code": "public void finish(){\n  try {\n    queryExecutor.finish();\n  }\n catch (  QueryExecutionException e) {\n    LOGGER.error(e,\"Problem while finish: \");\n  }\n  clearDictionaryFromQueryModel();\n}\n", "nl": "Below method will be used for cleanup"}
{"code": "public void invalidateCache(@NotNull LocalResourceRepository repository,@Nullable ResourceType... types){\n  assert myChildren.contains(repository) : repository;\nsynchronized (this) {\n    if (types == null || types.length == 0) {\n      myCachedTypeMaps.clear();\n      myCachedHasResourcesOfType.clear();\n    }\n else {\n      for (      ResourceType type : types) {\n        myCachedTypeMaps.remove(type);\n        myCachedHasResourcesOfType.remove(type);\n      }\n    }\n  }\n  myItems=null;\n  myGeneration=ourModificationCounter.incrementAndGet();\n  invalidateItemCaches(types);\n}\n", "nl": "Notifies this delegating repository that the given dependent repository has invalidated resources of the given types (empty means all)"}
{"code": "public void mouseMoved(float x,float y){\n  if (mMoveOnlyMode) {\n    return;\n  }\n  mClickListener.mEnableBaseline=false;\n  mHoverListener.mEnableBaseline=false;\n  mBaselineTimer.restart();\n  updateFromHoverListener(mViewTransform.getSwingFX(x),mViewTransform.getSwingFY(y));\n}\n", "nl": "Mouse moved handling"}
{"code": "public boolean filterOut(final SAMRecord record){\n  if (include) {\n    if (record.getMateUnmappedFlag()) {\n      return false;\n    }\n  }\n else {\n    if (!record.getMateUnmappedFlag()) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "private boolean showRequiredScreensIfNeeded(){\n  if (TutorialActivity.shouldShowTutorial(this)) {\n    Intent intent=new Intent(this,TutorialActivity.class);\n    startActivity(intent);\n    finish();\n    return true;\n  }\n else   if (AgeVerifier.shouldShowUserAge(this)) {\n    Intent intent=new Intent(this,AgeVerifier.class);\n    startActivity(intent);\n    finish();\n    return true;\n  }\n  return false;\n}\n", "nl": "If we haven't seen all the required screens, opens the next required activity, and finishes this activity"}
{"code": "public int rank(){\n  double eps=Math.pow(2.0,-52.0);\n  double tol=Math.max(m,n) * s[0] * eps;\n  int r=0;\n  for (int i=0; i < s.length; i++) {\n    if (s[i] > tol) {\n      r++;\n    }\n  }\n  return r;\n}\n", "nl": "Effective numerical matrix rank"}
{"code": "public static void write(String fileName,Table table,String missing) throws IOException {\n  try (CSVWriter writer=new CSVWriter(new FileWriter(fileName))){\n    String[] header=new String[table.columnCount()];\n    for (int c=0; c < table.columnCount(); c++) {\n      header[c]=table.column(c).name();\n    }\n    writer.writeNext(header);\n    for (int r=0; r < table.rowCount(); r++) {\n      String[] entries=new String[table.columnCount()];\n      for (int c=0; c < table.columnCount(); c++) {\n        table.get(c,r);\n        entries[c]=table.get(c,r);\n      }\n      writer.writeNext(entries);\n    }\n  }\n }\n", "nl": "Writes the given table to a file with the given filename, using the given string to represent missing data"}
{"code": "public void startIndexFileRepoJobs(String uniquename){\n  try {\n    Scheduler scheduler=Singleton.getScheduler();\n    JobDetail job=newJob(IndexFileRepoJob.class).withIdentity(\"updateindex-file-\" + uniquename).build();\n    SimpleTrigger trigger=newTrigger().withIdentity(\"updateindex-file-\" + uniquename).withSchedule(simpleSchedule().withIntervalInSeconds(this.INDEXTIME).repeatForever()).build();\n    job.getJobDataMap().put(\"REPOLOCATIONS\",this.REPOLOCATION);\n    job.getJobDataMap().put(\"LOWMEMORY\",this.LOWMEMORY);\n    scheduler.scheduleJob(job,trigger);\n    scheduler.start();\n  }\n catch (  SchedulerException ex) {\n    LOGGER.severe(\" caught a \" + ex.getClass() + \"\\n with message: \"+ ex.getMessage());\n  }\n}\n", "nl": "Creates a file repo indexer job which will pull from the file queue and index"}
{"code": "public TextUnit createTextUnit(Long id,String name,String source,String note,String target,String targetBcp47Tag,XliffState state){\n  TextUnit textUnit=new TextUnit(id.toString(),source);\n  textUnit.setName(name);\n  if (note != null) {\n    textUnit.setSourceProperty(new Property(Property.NOTE,note));\n  }\n  if (target != null && targetBcp47Tag != null) {\n    LocaleId localeId=LocaleId.fromBCP47(targetBcp47Tag);\n    textUnit.setTarget(localeId,new TextContainer(target));\n    if (state != null) {\n      textUnit.setProperty(new Property(\"state\",state.toString()));\n    }\n  }\n  return textUnit;\n}\n", "nl": "Creates a textUnit to be used later to generate a XLIFF"}
{"code": "private static String[] selectColumnNames(List<String> names,ColumnType types[]){\n  List<String> header=new ArrayList<>();\n  for (int i=0; i < types.length; i++) {\n    if (types[i] != ColumnType.SKIP) {\n      header.add(names.get(i));\n    }\n  }\n  String[] result=new String[header.size()];\n  return header.toArray(result);\n}\n", "nl": "Reads column names from header, skipping any for which the type == SKIP"}
{"code": "public void applyConstraints(ScoutWidget[] list){\n  pickColumnWidgets(list);\n  pickCenterOverlap(list);\n  pickBaseLineConnections(list);\n  pickCenteredConnections(list,true);\n  pickMarginConnections(list,10);\n  pickCenteredConnections(list,false);\n  pickMarginConnections(list,100);\n  if (DEBUG) {\n    printBaseTable(list);\n  }\n}\n", "nl": "This applies a constraint set suggested by the Inference tables"}
{"code": "public int deflateString2ByteArray(String inputString,byte[] bytes){\n  byte[] input;\n  try {\n    input=inputString.getBytes(\"UTF-8\");\n  }\n catch (  UnsupportedEncodingException e) {\n    input=new byte[inputString.length()];\n    for (int i=0; i < bytes.length; i++)     input[i]=(byte)inputString.charAt(i);\n  }\n  return deflateString2ByteArray(input,0,input.length,bytes);\n}\n", "nl": "compresses a string to an array of bytes"}
{"code": "private static int endOfTagMatch(String string,int fromIndex,String tag){\n  int pos=string.indexOf(tag,fromIndex);\n  if (pos != -1) {\n    while (pos < string.length() && Character.isWhitespace(string.charAt(pos)))     pos++;\n    return pos + tag.length();\n  }\n  if (tag.contains(\" \")) {\n    tag=tag.replaceAll(\" \",\"\");\n    pos=string.indexOf(tag);\n    if (pos != -1) {\n      while (pos < string.length() && Character.isWhitespace(string.charAt(pos)))       pos++;\n      return pos + tag.length();\n    }\n  }\n  return -1;\n}\n", "nl": "matches tag to string (allowing spaces inside tag to be missing in string)"}
{"code": "public static Map<String,Object> alwaysBadCardNumberProcessor(DispatchContext dctx,Map<String,? extends Object> context){\n  Locale locale=(Locale)context.get(\"locale\");\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  BigDecimal processAmount=(BigDecimal)context.get(\"processAmount\");\n  Debug.logInfo(\"Test Processor Bad Card Number Credit Card\",module);\n  String refNum=UtilDateTime.nowAsString();\n  result.put(\"authResult\",Boolean.FALSE);\n  result.put(\"resultBadCardNumber\",Boolean.TRUE);\n  result.put(\"processAmount\",processAmount);\n  result.put(\"authRefNum\",refNum);\n  result.put(\"authAltRefNum\",refNum);\n  result.put(\"authFlag\",\"N\");\n  result.put(\"authMessage\",UtilProperties.getMessage(resource,\"AccountingPaymentTestBadCardNumber\",locale));\n  return result;\n}\n", "nl": "Always bad card number processor"}
{"code": "public void acquireWriteLockOnKey(K id){\n  if (id == null) {\n    LOGGER.error(\"Trying to acquire write lock with a NULL key - throwing an exception!\");\n    throw new IllegalArgumentException(\"Acquiring write lock with null key!\");\n  }\n  if (LOGGER.isTraceEnabled()) {\n    LOGGER.trace(cache.getName() + \" Acquiring WRITE lock for id=\" + String.valueOf(id));\n  }\n  cache.acquireWriteLockOnKey(id);\n  if (LOGGER.isTraceEnabled()) {\n    LOGGER.trace(cache.getName() + \" Got WRITE lock for id=\" + String.valueOf(id));\n  }\n}\n", "nl": "Acquires the proper write lock for a given cache key"}
{"code": "private List<List<byte[]>> prepareData(){\n  List<List<byte[]>> dictionaryChunks=new ArrayList<>();\n  List<byte[]> chunks=new ArrayList<>();\n  chunks.add(\"d\".getBytes());\n  chunks.add(\"b\".getBytes());\n  chunks.add(\"c\".getBytes());\n  chunks.add(\"a\".getBytes());\n  dictionaryChunks.add(chunks);\n  return dictionaryChunks;\n}\n", "nl": "The method returns the list<List<byte[]>>"}
{"code": "public static boolean matchName(byte[] queryName,int queryNameLength,byte[] line,int lineLength){\n  int start=0;\n  if (line[start] == '>' || line[0] == '@')   start++;\n  while (Character.isWhitespace(line[start]) && start < lineLength)   start++;\n  int end=start;\n  while (!Character.isWhitespace(line[end]) && end < lineLength) {\n    end++;\n  }\n  if (end - start != queryNameLength)   return false;\n  for (int i=0; i < queryNameLength; i++) {\n    if (queryName[i] != line[start + i])     return false;\n  }\n  return true;\n}\n", "nl": "match header line with query name"}
{"code": "private boolean isRequestingSensorEventData(String nodeId,String sensorName){\n  if (!isRequestingSensorEventData(nodeId)) {\n    return false;\n  }\n  boolean sensorIsRequested=false;\n  for (  DeviceSensor deviceSensor : selectedSensors.get(nodeId)) {\n    if (!deviceSensor.getName().equals(sensorName)) {\n      continue;\n    }\n    sensorIsRequested=true;\n  }\n  return sensorIsRequested;\n}\n", "nl": "Returns true if the app is requesting data by the specified sensor from the device with the specified node id"}
{"code": "public void draw(Canvas c,Rect bounds){\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mPaint.setColor(mColors[mColorIndex]);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n  if (mAlpha < 255) {\n    mCirclePaint.setColor(mBackgroundColor);\n    mCirclePaint.setAlpha(255 - mAlpha);\n    c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  }\n}\n", "nl": "Draw the progress spinner"}
{"code": "public TimeColumn time(){\n  TimeColumn newColumn=TimeColumn.create(this.name() + \" time\");\n  for (int r=0; r < this.size(); r++) {\n    long c1=this.getLong(r);\n    if (c1 == MISSING_VALUE) {\n      newColumn.add(TimeColumn.MISSING_VALUE);\n    }\n else {\n      newColumn.add(PackedLocalDateTime.time(c1));\n    }\n  }\n  return newColumn;\n}\n", "nl": "Returns a TimeColumn containing the time portion of each dateTime in this DateTimeColumn"}
{"code": "public static int computeId(String cName,float minScore,float maxExpected,float minPercentIdentity,IReadBlock readBlock){\n  if (readBlock.getNumberOfMatches() == 0)   return IdMapper.NOHITS_ID;\n  for (int i=0; i < readBlock.getNumberOfAvailableMatchBlocks(); i++) {\n    IMatchBlock match=readBlock.getMatchBlock(i);\n    if (match.getBitScore() >= minScore && match.getExpected() <= maxExpected && match.getPercentIdentity() >= minPercentIdentity) {\n      int id=match.getId(cName);\n      if (id != 0)       return id;\n    }\n  }\n  return IdMapper.UNASSIGNED_ID;\n}\n", "nl": "compute the class id for a read from its matches matches"}
{"code": "public static void spawnAll(){\n  if (!DeveloperConfig.SPAWN_ENABLE) {\n    log.info(\"Spawns are disabled\");\n    return;\n  }\n  for (  WorldMapTemplate worldMapTemplate : DataManager.WORLD_MAPS_DATA) {\n    if (worldMapTemplate.isInstance()) {\n      continue;\n    }\n    spawnBasedOnTemplate(worldMapTemplate);\n  }\n  DataManager.SPAWNS_DATA2.clearTemplates();\n  printWorldSpawnStats();\n  ConquestSpawnManager.spawnAll();\n}\n", "nl": "Spawn all NPC's from templates"}
{"code": "public static List<? extends Element> childElementList(DocumentFragment fragment){\n  if (fragment == null)   return null;\n  List<Element> elements=new LinkedList<Element>();\n  Node node=fragment.getFirstChild();\n  if (node != null) {\n    do {\n      if (node.getNodeType() == Node.ELEMENT_NODE) {\n        Element childElement=(Element)node;\n        elements.add(childElement);\n      }\n    }\n while ((node=node.getNextSibling()) != null);\n  }\n  return elements;\n}\n", "nl": "Return a List of Element objects that are children of the given DocumentFragment"}
{"code": "static int calcExpr(int a,int b,int c,int d){\n  if (d == 0) {\n    System.out.println(\"Error: Division by zero\");\n    return -1;\n  }\n else {\n    return a * (b + (c / d));\n  }\n}\n", "nl": "calculating a * (b + (c / d))"}
{"code": "@Transactional public Repository createRepository(TestIdWatcher testIdWatcher) throws RepositoryNameAlreadyUsedException {\n  Repository repository=repositoryService.createRepository(testIdWatcher.getEntityName(\"repository\"));\n  try {\n    repositoryService.addRepositoryLocale(repository,\"fr-FR\");\n    repositoryService.addRepositoryLocale(repository,\"ja-JP\");\n  }\n catch (  RepositoryLocaleCreationException e) {\n    throw new RuntimeException(e);\n  }\n  return repository;\n}\n", "nl": "Creates a repo supporting few languages and a TM"}
{"code": "public static double[] pageRank(MatrixInterface preparedMatrix,int maxIteration,double d,double[] init,double[] impact){\n  double[] result=new double[init.length];\n  for (int i=0; i != init.length; i++)   result[i]=init[i];\n  int iteration=0;\n  while (iteration < maxIteration) {\n    iteration++;\n    result=preparedMatrix.multiply(result);\n    for (int i=0; i != result.length; i++)     result[i]=impact[i] * (1.0 - d) + d * result[i];\n  }\n  return result;\n}\n", "nl": "Call prepareMatrix or prepareSparseMatrix first"}
{"code": "public ArmorCursor queryArmorSearch(String search){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=false;\n  qh.Columns=null;\n  qh.Selection=\"i.\" + S.COLUMN_ITEMS_NAME + \" LIKE ?\";\n  qh.SelectionArgs=new String[]{'%' + search + '%'};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new ArmorCursor(wrapJoinHelper(builderArmor(),qh));\n}\n", "nl": "****************************** ARMOR QUERIES"}
{"code": "private void selectRec(Node v,Set<String> selected){\n  for (Edge e=v.getFirstAdjacentEdge(); e != null; e=v.getNextAdjacentEdge(e)) {\n    Node w=e.getOpposite(v);\n    String label=((NodeData)w.getData()).getLabel();\n    if (!selected.contains(label)) {\n      selected.add(label);\n      selectRec(w,selected);\n    }\n  }\n}\n", "nl": "recursively select all nodes in the same component"}
{"code": "public void testWriteReadEmpty() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(empty);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  FailOverPolicy copy=(FailOverPolicy)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(empty,copy));\n}\n", "nl": "Test read and write empty ClusterPolicy object"}
{"code": "public BoxFolder createFolder(String folderName,String parentId) throws BoxSDKServiceException {\n  try {\n    BoxFolder parentFolder=new BoxFolder(getBoxAPIConnection(),parentId);\n    BoxFolder.Info createFolderInfo=parentFolder.createFolder(folderName);\n    logger.debug(\"created: \" + createFolderInfo.getID() + \", name: \"+ createFolderInfo.getName());\n    return createFolderInfo.getResource();\n  }\n catch (  BoxAPIException e) {\n    throw new BoxSDKServiceException(\"Can't create folder: \" + folderName,e);\n  }\n}\n", "nl": "Creates a folder inside the given parent folder"}
{"code": "public static boolean isYesterday(Date date){\n  Calendar calendar=Calendar.getInstance();\n  calendar.add(Calendar.DAY_OF_MONTH,-1);\n  int nowYear=calendar.get(Calendar.YEAR);\n  int nowMonth=calendar.get(Calendar.MONTH);\n  int nowMonthDay=calendar.get(Calendar.DAY_OF_MONTH);\n  calendar.setTimeInMillis(date.getTime());\n  int thenYear=calendar.get(Calendar.YEAR);\n  int thenMonth=calendar.get(Calendar.MONTH);\n  int thenMonthDay=calendar.get(Calendar.DAY_OF_MONTH);\n  return (thenYear == nowYear) && (thenMonth == nowMonth) && (thenMonthDay == nowMonthDay);\n}\n", "nl": "Is the specific date yesterday"}
{"code": "private void startList(boolean isOrderedList,Attributes attributes){\n  boolean isIndentation=isIndentation(attributes);\n  ParagraphType newType=isIndentation && isOrderedList ? ParagraphType.INDENTATION_OL : isIndentation && !isOrderedList ? ParagraphType.INDENTATION_UL : isOrderedList ? ParagraphType.NUMBERING : ParagraphType.BULLET;\n  AccumulatedParagraphStyle currentStyle=mParagraphStyles.isEmpty() ? null : mParagraphStyles.peek();\n  if (currentStyle == null) {\n    AccumulatedParagraphStyle newStyle=new AccumulatedParagraphStyle(newType,1,1);\n    mParagraphStyles.push(newStyle);\n  }\n else   if (currentStyle.getType() == newType) {\n    currentStyle.setAbsoluteIndent(currentStyle.getAbsoluteIndent() + 1);\n    currentStyle.setRelativeIndent(currentStyle.getRelativeIndent() + 1);\n  }\n else {\n    AccumulatedParagraphStyle newStyle=new AccumulatedParagraphStyle(newType,currentStyle.getAbsoluteIndent() + 1,1);\n    mParagraphStyles.push(newStyle);\n  }\n}\n", "nl": "Handles OL and UL start tags"}
{"code": "public static Sample loadBinary(DataInputStream dis) throws IOException {\n  int frameDataSize=dis.readInt();\n  short[] frameData=new short[frameDataSize];\n  for (int i=0; i < frameData.length; i++) {\n    frameData[i]=dis.readShort();\n  }\n  int residualDataSize=dis.readInt();\n  byte[] residualData=new byte[residualDataSize];\n  for (int i=0; i < residualData.length; i++) {\n    residualData[i]=dis.readByte();\n  }\n  return new Sample(frameData,residualData,residualDataSize);\n}\n", "nl": "Loads the samples from the given channel"}
{"code": "private void buildViewForMeasuring(){\n  if (itemsLayout != null) {\n    recycle.recycleItems(itemsLayout,firstItem,new ItemsRange());\n  }\n else {\n    createItemsLayout();\n  }\n  int addItems=visibleItems / 2;\n  for (int i=currentItem + addItems; i >= currentItem - addItems; i--) {\n    if (addViewItem(i,true)) {\n      firstItem=i;\n    }\n  }\n}\n", "nl": "Builds view for measuring"}
{"code": "public static void writePrimitiveArray(PbsOutputStream output,Object[] array){\n  if (array == null)   output.writeInt(-1);\n else {\n    output.writeInt(array.length);\n    for (int i=0; i < array.length; ++i) {\n      PbsEntryFormatter.writeFieldValue(output,array[i]);\n    }\n  }\n}\n", "nl": "Serialize a primitive (PbsFormatter primitive types) to the given stream"}
{"code": "public static boolean hadInitFreeline(Project project){\n  if (project != null) {\n    String projectPath=project.getBasePath();\n    File freelineDir=new File(projectPath,\"freeline\");\n    File freeline_py=new File(projectPath,\"freeline.py\");\n    if (freelineDir.exists() && freeline_py.exists()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "if had init freeline return true"}
{"code": "private SourceTargetPair[] vocalizationF0DistanceComputer(VocalizationCandidate[] suitableCandidates,VocalizationCandidate[] suitableF0Candidates,Element domElement){\n  int noPossibleImpositions=suitableCandidates.length * suitableF0Candidates.length;\n  SourceTargetPair[] imposeF0Data=new SourceTargetPair[noPossibleImpositions];\n  int count=0;\n  for (int i=0; i < suitableCandidates.length; i++) {\n    for (int j=0; j < suitableF0Candidates.length; j++) {\n      int sourceIndex=suitableCandidates[i].unitIndex;\n      int targetIndex=suitableF0Candidates[j].unitIndex;\n      double contourCost=getContourCostDistance(sourceIndex,targetIndex);\n      double mergeCost=getMergeCost(sourceIndex,targetIndex,domElement);\n      double cost=(contourCost * contourCostWeight) + (mergeCost * (1 - contourCostWeight));\n      Log.d(Mary.LOG,\"Unit Index \" + sourceIndex + \" & Contour Index \"+ targetIndex+ \" :: Countour cost: \"+ df.format(contourCost)+ \" + Merge Cost: \"+ df.format(mergeCost)+ \" --> TotalCost: \"+ df.format(cost));\n      imposeF0Data[count++]=new SourceTargetPair(sourceIndex,targetIndex,cost);\n    }\n  }\n  Arrays.sort(imposeF0Data);\n  return imposeF0Data;\n}\n", "nl": "polynomial distance computer between two units"}
{"code": "public static ByteBuffer processInboundPackage(ByteBuffer roData,int exchangeId,boolean connectionOk){\n  roData.rewind();\n  if (BuildConfig.DEBUG) {\n    XposedBridge.log(\"Processing inbound package of size \" + Integer.toString(roData.remaining()));\n  }\n  try {\nsynchronized (sync) {\n    }\n  }\n catch (  Throwable e) {\n    XposedBridge.log(e);\n  }\n  return null;\n}\n", "nl": "Processes single package going from server to client roData is created by allocate and had to have array"}
{"code": "public static AttackStatus calculateMagicalStatus(Creature attacker,Creature attacked,int criticalProb,boolean isSkill){\n  if (!isSkill) {\n    if (Rnd.get(0,1000) < StatFunctions.calculateMagicalResistRate(attacker,attacked,0)) {\n      return AttackStatus.RESIST;\n    }\n  }\n  if (StatFunctions.calculateMagicalCriticalRate(attacker,attacked,criticalProb)) {\n    return AttackStatus.CRITICAL;\n  }\n  return AttackStatus.NORMALHIT;\n}\n", "nl": "Every + 100 delta of (MR - MA) = + 10% to resist<br> if the difference is 1000 = 100% resist"}
{"code": "public void flushAndCancel(){\nsynchronized (this.sourceDataTag) {\n    if (LOGGER.isDebugEnabled()) {\n      LOGGER.debug(\"\\tscheduler[\" + this.sourceDataTag.getId() + \"] : flush and reset\");\n    }\n    this.cancel();\n    this.run();\n    this.lastSourceDataTag=null;\n  }\n}\n", "nl": "flushes and resets the scheduler"}
{"code": "private ResultPoint[] centerEdges(ResultPoint y,ResultPoint z,ResultPoint x,ResultPoint t){\n  float yi=y.getX();\n  float yj=y.getY();\n  float zi=z.getX();\n  float zj=z.getY();\n  float xi=x.getX();\n  float xj=x.getY();\n  float ti=t.getX();\n  float tj=t.getY();\n  if (yi < width / 2.0f) {\n    return new ResultPoint[]{new ResultPoint(ti - CORR,tj + CORR),new ResultPoint(zi + CORR,zj + CORR),new ResultPoint(xi - CORR,xj - CORR),new ResultPoint(yi + CORR,yj - CORR)};\n  }\n else {\n    return new ResultPoint[]{new ResultPoint(ti + CORR,tj + CORR),new ResultPoint(zi + CORR,zj - CORR),new ResultPoint(xi - CORR,xj + CORR),new ResultPoint(yi - CORR,yj - CORR)};\n  }\n}\n", "nl": "recenters the points of a constant distance towards the center"}
{"code": "public void createLog(){\n  List<String> commandList=new ArrayList<String>();\n  commandList.add(\"logcat\");\n  commandList.add(\"-f\");\n  commandList.add(getLogPath());\n  commandList.add(\"-v\");\n  commandList.add(\"time\");\n  try {\n    process=Runtime.getRuntime().exec(commandList.toArray(new String[commandList.size()]));\n  }\n catch (  Exception e) {\n    Log.e(TAG,e.getMessage(),e);\n  }\n}\n", "nl": "write the log"}
{"code": "public static List<String> parseRolesString(String roles){\n  List<String> result=new ArrayList<String>();\n  StringTokenizer st=new StringTokenizer(roles,\",\");\n  for (; st.hasMoreTokens(); ) {\n    String role=st.nextToken().trim();\n    if (!result.contains(role) && (role.equalsIgnoreCase(String.valueOf(SecurityContext.PERMISSION_WRITE)) || role.equalsIgnoreCase(String.valueOf(SecurityContext.PERMISSION_READ)) || role.equalsIgnoreCase(String.valueOf(SecurityContext.PERMISSION_EXECUTE))))     result.add(role.toUpperCase());\n  }\n  return result;\n}\n", "nl": "Return list of inherit system roles for user defined role"}
{"code": "private void removeHelpersSpawn(){\n  for (  Integer object : spawnedNpc) {\n    VisibleObject npc=World.getInstance().findVisibleObject(object);\n    if (npc != null && npc.isSpawned()) {\n      npc.getController().onDelete();\n    }\n  }\n  spawnedNpc.clear();\n}\n", "nl": "Remove Helpers"}
{"code": "private void compareDictionaryValueFromSortedIndex(List<String> data,Dictionary forwardDictionary){\n  int expectedSurrogateKey=0;\n  for (int i=0; i < data.size(); i++) {\n    expectedSurrogateKey++;\n    String expectedDictionaryValue=data.get(i);\n    int actualSurrogateKey=forwardDictionary.getSurrogateKey(expectedDictionaryValue);\n    assertTrue(actualSurrogateKey == expectedSurrogateKey);\n    int sortedIndex=forwardDictionary.getSortedIndex(actualSurrogateKey);\n    String actualDictionaryValue=forwardDictionary.getDictionaryValueFromSortedIndex(sortedIndex);\n    assertTrue(expectedDictionaryValue.equals(actualDictionaryValue));\n  }\n}\n", "nl": "This method will get the dictionary value from sorted index and compare with the data set"}
{"code": "public List<LocalDate> top(int n){\n  List<LocalDate> top=new ArrayList<>();\n  int[] values=data.toIntArray();\n  IntArrays.parallelQuickSort(values,ReverseIntComparator.instance());\n  for (int i=0; i < n && i < values.length; i++) {\n    top.add(PackedLocalDate.asLocalDate(values[i]));\n  }\n  return top;\n}\n", "nl": "Returns the largest (\"top\") n values in the column"}
{"code": "public void testPerFieldMaxPassages() throws Exception {\n  deleteAllDocs();\n  long gen=addDocument(\"{fields: {body: 'This sentence has test.  This one does not.  Here is test again.', authors: ['This sentence has test.  This one does not.  Here is test again.']}}\");\n  JSONObject result=send(\"search\",\"{queryText: 'test', retrieveFields: [{field: authors, highlight: snippets, maxPassages: 1}, {field: body, highlight: snippets, maxPassages: 2}], searcher: {indexGen: \" + gen + \"}}\");\n  assertEquals(1,getInt(result,\"totalHits\"));\n  assertEquals(1,getInt(result,\"hits[0].fields.authors.length\"));\n  assertEquals(\"Here is <b>test</b> again.\",renderHighlight(getArray(result,\"hits[0].fields.authors\")));\n  assertEquals(2,getInt(result,\"hits[0].fields.body.length\"));\n  assertEquals(\"This sentence has <b>test</b>.  ...Here is <b>test</b> again.\",renderHighlight(getArray(result,\"hits[0].fields.body\")));\n}\n", "nl": "Make sure we can use a different maxPassages per field"}
{"code": "public static double euclideanDistance(double[] p,double[] q){\n  double ret=0;\n  for (int i=0; i < p.length; i++) {\n    double diff=(q[i] - p[i]);\n    double sq=Math.pow(diff,2);\n    ret+=sq;\n  }\n  return ret;\n}\n", "nl": "This returns the euclidean distance of two vectors sum(i=1,n)   (q_i - p_i)^2"}
{"code": "public ImageIcon loadImage(String imageName){\n  try {\n    ClassLoader classloader=getClass().getClassLoader();\n    java.net.URL url=classloader.getResource(imageName);\n    if (url != null) {\n      ImageIcon icon=new ImageIcon(url);\n      return icon;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  throw new IllegalArgumentException(\"Unable to load image: \" + imageName);\n}\n", "nl": "Helper method to load an image file from the CLASSPATH"}
{"code": "private boolean canAppointRank(Player activePlayer,int targetObjId){\n  Legion legion=activePlayer.getLegion();\n  if (!isBrigadeGeneral(activePlayer)) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_CHANGE_MEMBER_RANK_DONT_HAVE_RIGHT);\n    return false;\n  }\n  if (isSelf(activePlayer,targetObjId)) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_CHANGE_MASTER_ERROR_SELF);\n    return false;\n  }\n else   if (!legion.isMember(targetObjId)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "This method checks all restrictions for appointing rank"}
{"code": "@Produces @VenueList @Named(value=\"venueList\") public List<Venue> produceVenues(){\n  final List<Venue> venues=new ArrayList<>();\n  try {\n    venues.add(new VenueJavaOne2016());\n  }\n catch (  final MalformedURLException e) {\n    this.log.log(Level.SEVERE,\"Failed to produce a Venue\",e);\n  }\n  return venues;\n}\n", "nl": "Support for eventually having more than one venue"}
{"code": "private static int rootDistance(ConstraintWidget widget){\n  int rootHeight=widget.getParent().getHeight();\n  int rootWidth=widget.getParent().getWidth();\n  int aX=widget.getX();\n  int aY=widget.getY();\n  int aWidth=widget.getWidth();\n  int aHeight=widget.getHeight();\n  int minx=Math.min(aX,rootWidth - (aX + aWidth));\n  int miny=Math.min(aY,rootHeight - (aY + aHeight));\n  return Math.min(minx,miny);\n}\n", "nl": "Get the distance to the root for a widget"}
{"code": "public static boolean isCardMatch(String cardType,String cardNumberPassed){\n  if (isEmpty(cardType))   return defaultEmptyOK;\n  if (isEmpty(cardNumberPassed))   return defaultEmptyOK;\n  String cardNumber=stripCharsInBag(cardNumberPassed,creditCardDelimiters);\n  if ((\"CCT_VISA\".equalsIgnoreCase(cardType)) && (isVisa(cardNumber)))   return true;\n  if ((\"CCT_MASTERCARD\".equalsIgnoreCase(cardType)) && (isMasterCard(cardNumber)))   return true;\n  if (((\"CCT_AMERICANEXPRESS\".equalsIgnoreCase(cardType)) || (\"CCT_AMEX\".equalsIgnoreCase(cardType))) && (isAmericanExpress(cardNumber)))   return true;\n  if ((\"CCT_DISCOVER\".equalsIgnoreCase(cardType)) && (isDiscover(cardNumber)))   return true;\n  if ((\"CCT_JCB\".equalsIgnoreCase(cardType)) && (isJCB(cardNumber)))   return true;\n  if (((\"CCT_DINERSCLUB\".equalsIgnoreCase(cardType)) || (\"CCT_DINERS\".equalsIgnoreCase(cardType))) && (isDinersClub(cardNumber)))   return true;\n  if ((\"CCT_CARTEBLANCHE\".equalsIgnoreCase(cardType)) && (isCarteBlanche(cardNumber)))   return true;\n  if ((\"CCT_ENROUTE\".equalsIgnoreCase(cardType)) && (isEnRoute(cardNumber)))   return true;\n  if ((\"CCT_SOLO\".equalsIgnoreCase(cardType)) && (isSolo(cardNumber)))   return true;\n  if ((\"CCT_SWITCH\".equalsIgnoreCase(cardType)) && (isswitch(cardNumber)))   return true;\n  if ((\"CCT_VISAELECTRON\".equalsIgnoreCase(cardType)) && (isVisaElectron(cardNumber)))   return true;\n  return false;\n}\n", "nl": "Checks to see if the cc number is a valid number for the specified type"}
{"code": "@Override public Schema transform(Schema inputSchema){\n  Schema.Builder newSchema=new Schema.Builder();\n  for (int i=0; i < inputSchema.numColumns(); i++) {\n    if (inputSchema.getType(i) == ColumnType.String) {\n      newSchema.addColumnDouble(inputSchema.getMetaData(i).getName());\n    }\n else     newSchema.addColumn(inputSchema.getMetaData(i));\n  }\n  return newSchema.build();\n}\n", "nl": "Get the output schema for this transformation, given an input schema"}
{"code": "@Override public void end(@SwingCoordinate int x,@SwingCoordinate int y,@InputEventMask int modifiers,boolean canceled){\n  super.end(x,y,modifiers,canceled);\n  ConstraintModel model=ConstraintModel.getConstraintModel(myScreenView.getModel());\n  if (canceled) {\n    model.rollbackXml();\n    return;\n  }\n  final int ax=Coordinates.getAndroidX(myScreenView,x);\n  final int ay=Coordinates.getAndroidY(myScreenView,y);\n  DrawConstraintModel drawConstraintModel=ConstraintModel.getDrawConstraintModel(myScreenView);\n  drawConstraintModel.updateModifiers(modifiers);\n  drawConstraintModel.mouseReleased(ax,ay);\n  model.saveToXML(false);\n  myScreenView.getSurface().repaint();\n}\n", "nl": "Ends the mouse interaction and commit the modifications if any"}
{"code": "public void onProcessConfiguration(){\n  LOGGER.info(\"onProcessConfiguration - Configuration\");\n  LOGGER.info(\"{}\",this.processConnectionRequest);\n  String xmlProcessConfigurationResponse=this.supervisionManager.onProcessConfiguration(this.processConfigurationRequest);\n  assertNotNull(xmlProcessConfigurationResponse);\n  LOGGER.info(xmlProcessConfigurationResponse);\n  try {\n    this.processConfigurationResponse=(ProcessConfigurationResponse)this.xmlConverter.fromXml(xmlProcessConfigurationResponse);\n  }\n catch (  Exception e) {\n    LOGGER.error(e.toString());\n  }\n  assertNotNull(this.processConfigurationResponse);\n  LOGGER.info(this.processConfigurationResponse.toString());\n}\n", "nl": "Process Configuration call"}
{"code": "public static void hideProgressDialog(String tag){\n  if (tag == null)   return;\nsynchronized (sLock) {\n    ProgressDialog dialog=findDialog(tag);\n    if (dialog != null) {\n      if (isAlive(dialog) && dialog.isShowing())       dialog.dismiss();\n      sDialogs.remove(dialog);\n    }\n  }\n}\n", "nl": "Hide dialog with specific tag"}
{"code": "private void runCleaning(){\n  log.info(\"DatabaseCleaningService: Executing database cleaning\");\n  startTime=System.currentTimeMillis();\n  int periodInDays=CleaningConfig.CLEANING_PERIOD;\n  int SECURITY_MINIMUM_PERIOD=30;\n  if (periodInDays > SECURITY_MINIMUM_PERIOD) {\n    delegateToThreads(CleaningConfig.CLEANING_THREADS,dao.getInactiveAccounts(periodInDays,CleaningConfig.CLEANING_LIMIT));\n    monitoringProcess();\n  }\n else {\n    log.warn(\"The configured days for database cleaning is to low. For security reasons the service will only execute with periods over 30 days!\");\n  }\n}\n", "nl": "Cleans the databse from inactive player data"}
{"code": "public static void ignorm(double c1[],double c2[],int m,double ng){\n  if (ng != 0.0) {\n    double k=Math.pow(c1[0],ng);\n    for (int i=m; i >= 1; i--)     c2[i]=k * c1[i];\n    c2[0]=(k - 1.0) / ng;\n  }\n else {\n    System.arraycopy(c1,1,c2,1,m - 1);\n    c2[0]=Math.log(c1[0]);\n  }\n}\n", "nl": "ignorm: inverse gain normalization"}
{"code": "public static int createProxyObject(int luaState,String implem) throws LuaException {\n  LuaState L=LuaStateFactory.getExistingState(luaState);\nsynchronized (L) {\n    try {\n      if (!(L.isTable(2)))       throw new LuaException(\"Parameter is not a table. Can't create proxy.\");\n      LuaObject luaObj=L.getLuaObject(2);\n      Object proxy=luaObj.createProxy(implem);\n      L.pushJavaObject(proxy);\n    }\n catch (    Exception e) {\n      throw new LuaException(e);\n    }\n    return 1;\n  }\n}\n", "nl": "Function that creates an object proxy and pushes it into the stack"}
{"code": "public void writeAuxBlocks(IOutputWriter writer,Map<String,byte[]> name2AuxData) throws IOException {\n  setCount(name2AuxData.size());\n  for (  String name : name2AuxData.keySet()) {\n    writer.writeString(name);\n    byte[] bytes=name2AuxData.get(name);\n    writer.writeInt(bytes.length);\n    writer.write(bytes,0,bytes.length);\n  }\n}\n", "nl": "auxiliary method that can be used to write auxblocks to RMA3 file"}
{"code": "void storeFence(@NonNull StorableFence fence){\n  Set<String> setTmp=mPrefs.getStringSet(mPrefix + FENCE_ID_SET_KEY,null);\n  HashSet<String> fenceIdSet;\n  if (setTmp == null) {\n    fenceIdSet=new HashSet<>();\n  }\n else {\n    fenceIdSet=new HashSet<>(setTmp);\n  }\n  SharedPreferences.Editor editor=mPrefs.edit();\n  editor.putString(mPrefix + fence.getId(),StorableFence.fenceToString(fence));\n  fenceIdSet.add(fence.getId());\n  editor.putStringSet(mPrefix + FENCE_ID_SET_KEY,fenceIdSet);\n  editor.apply();\n}\n", "nl": "Store a fence in the store"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"select samples=\");\n  String what=np.getWordMatchesIgnoringCase(\"all none\");\n  np.matchRespectCase(\";\");\n  if (getViewer() instanceof GroupsViewer) {\n    GroupsViewer viewer=(GroupsViewer)getViewer();\n    if (what.equalsIgnoreCase(\"all\"))     viewer.getGroupsPanel().selectAll();\n else     if (what.equals(\"none\"))     viewer.getGroupsPanel().selectNone();\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public Map<String,List<ChartObject>> groupByDate(List<ChartObject> input,Period period){\n  HashMap<String,List<ChartObject>> result=new LinkedHashMap<>();\n  Map<String,ChartObject> range=buildRange(input,period);\n  for (  ChartObject anInput : input) {\n    String group=new DateTime(Long.valueOf(anInput.getStartTime())).toString(DATE_PATTERN);\n    ChartObject axisObject=range.get(group);\n    Map<String,String> values=axisObject.getValues();\n    Map<String,String> updated=new HashMap<>();\n    for (    String key : anInput.getValues().keySet()) {\n      updated.put(key,String.valueOf(Double.valueOf(anInput.getValues().get(key)) + Double.valueOf(values.get(key))));\n    }\n    axisObject.setValues(updated);\n    range.put(group,axisObject);\n  }\n  range.keySet().stream().forEach(null);\n  return result;\n}\n", "nl": "Return lists of objects grouped by specified period"}
{"code": "public void stopTasks(){\n  if (task != null) {\n    task.cancel(false);\n    task=null;\n  }\n  if (periodicTasks != null) {\n    for (    Future<?> periodicTask : this.periodicTasks) {\n      if (periodicTask != null) {\n        periodicTask.cancel(false);\n        periodicTask=null;\n      }\n    }\n  }\n  stopPeriodicActions();\n}\n", "nl": "Stop all scheduled tasks"}
{"code": "private void updateParentItems(TreeItem item){\n  if (item != null) {\n    Item[] children=getChildren(item);\n    boolean containsChecked=false;\n    boolean containsUnchecked=false;\n    for (int i=0; i < children.length; i++) {\n      TreeItem curr=(TreeItem)children[i];\n      containsChecked|=curr.getChecked();\n      containsUnchecked|=(!curr.getChecked() || curr.getGrayed());\n    }\n    item.setChecked(containsChecked);\n    item.setGrayed(containsChecked && containsUnchecked);\n    updateParentItems(item.getParentItem());\n  }\n}\n", "nl": "Updates the check / gray state of all parent items"}
{"code": "private String clean(String name){\n  StringBuffer buf=new StringBuffer();\n  for (int i=0; i < name.length(); i++) {\n    char ch=name.charAt(i);\nswitch (ch) {\ncase '&':\n      buf.append(\"&amp;\");\n    break;\ndefault :\n  buf.append(ch);\nbreak;\n}\n}\nreturn buf.toString();\n}\n", "nl": "buggy javascript sanitization routine"}
{"code": "public static boolean isEmptyOrBlanks(String string){\n  if (string == null || string.length() == 0) {\n    return true;\n  }\n  for (int i=0; i < string.length(); i++) {\n    char c=string.charAt(i);\n    if (!Character.isWhitespace(c)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Checks if the given string is null, empty or contains whitespace only"}
{"code": "private void movePos(float deltaY){\n  if ((deltaY < 0 && mPtrIndicator.isInStartPosition())) {\n    if (DEBUG) {\n      PtrCLog.e(LOG_TAG,String.format(\"has reached the top\"));\n    }\n    return;\n  }\n  int to=mPtrIndicator.getCurrentPosY() + (int)deltaY;\n  if (mPtrIndicator.willOverTop(to)) {\n    if (DEBUG) {\n      PtrCLog.e(LOG_TAG,String.format(\"over top\"));\n    }\n    to=PtrIndicator.POS_START;\n  }\n  mPtrIndicator.setCurrentPos(to);\n  int change=to - mPtrIndicator.getLastPosY();\n  updatePos(change);\n}\n", "nl": "if deltaY > 0, move the content down"}
{"code": "private String buildText(boolean useCurrentValue){\n  StringBuilder itemsText=new StringBuilder();\n  int addItems=visibleItems / 2 + 1;\n  for (int i=currentItem - addItems; i <= currentItem + addItems; i++) {\n    if (useCurrentValue || i != currentItem) {\n      String text=getTextItem(i);\n      if (text != null) {\n        itemsText.append(text);\n      }\n    }\n    if (i < currentItem + addItems) {\n      itemsText.append(\"\\n\");\n    }\n  }\n  return itemsText.toString();\n}\n", "nl": "Builds text depending on current value"}
{"code": "private List<List<Sweet>> sortSweets(List<Sweet> messySweets,double colStep){\n  List<List<Sweet>> grid=new ArrayList<>();\n  minHeight=Integer.MAX_VALUE;\n  minWidth=Integer.MAX_VALUE;\n  for (  Sweet sweet : messySweets) {\n    if (sweet.getY() < minHeight) {\n      minHeight=(int)sweet.getY();\n    }\n    if (sweet.getX() < minWidth) {\n      minWidth=(int)sweet.getX();\n    }\n  }\n  fillGrid(messySweets,colStep,grid);\n  return grid;\n}\n", "nl": "Shared functions"}
{"code": "public static X509Certificate decodeCertificate(String certificate) throws CertificateException {\n  certificate=certificate != null ? certificate.trim() : null;\n  if (certificate != null && (certificate=certificate.trim()).length() > 0) {\n    if (!certificate.startsWith(\"-----BEGIN\")) {\n      String cert_begin=\"-----BEGIN CERTIFICATE-----\\n\";\n      String end_cert=\"\\n-----END CERTIFICATE-----\";\n      certificate=String.format(\"%s%s%s\",cert_begin,certificate,end_cert);\n    }\n    return decodeCertificate(certificate.getBytes());\n  }\n  return null;\n}\n", "nl": "Decodes certificate"}
{"code": "public void reset(){\n  MATRIX[MSCALE_X]=1;\n  MATRIX[MSKEW_X]=0;\n  MATRIX[MTRANS_X]=0;\n  MATRIX[MSKEW_Y]=1;\n  MATRIX[MSCALE_Y]=0;\n  MATRIX[MTRANS_Y]=0;\n  MATRIX[MPERSP_0]=0;\n  MATRIX[MPERSP_1]=0;\n  MATRIX[MPERSP_2]=1;\n}\n", "nl": "Set the matrix to identity"}
{"code": "public ImageIcon loadImage(String imageName){\n  try {\n    ClassLoader classloader=getClass().getClassLoader();\n    java.net.URL url=classloader.getResource(imageName);\n    if (url != null) {\n      ImageIcon icon=new ImageIcon(url);\n      return icon;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  throw new IllegalArgumentException(\"Unable to load image: \" + imageName);\n}\n", "nl": "Helper method to load an image file from the CLASSPATH"}
{"code": "public LicensePanel(URL url){\n  this.url=url;\n  initComponents();\n  initAccessibility();\n  try {\n    jEditorPane1.setPage(url);\n  }\n catch (  IOException exc) {\n    LOGGER.throwing(LicensePanel.class.getName(),\"<init>\",exc);\n  }\n}\n", "nl": "Creates new form LicensePanel"}
{"code": "public void principalComponentAnalysis(Vector<Double> data,int rows,int cols,boolean eigen,boolean scale){\n  if (data == null)   throw new NullPointerException(\"Null data\");\n  if (rows < 0 || cols < 0)   throw new IllegalArgumentException(\"Number of rows and cols must be greater than 0\");\n  Matrix dataX=new Matrix(rows,cols);\n  int n=0;\n  for (int i=0; i < rows; i++) {\n    for (int j=0; j < cols; j++)     dataX.set(i,j,data.elementAt(n++));\n  }\n  boolean debug=false;\n  if (eigen)   eigenPCA(dataX,scale,debug);\n else   svdPCA(dataX,scale,debug);\n}\n", "nl": "perform principal component analysis"}
{"code": "public void paintSelection(Graphics g0){\n  Graphics2D g=(Graphics2D)g0;\n  SelectedBlock selectedBlock=getSelectedBlock();\n  if (selectedBlock.isSelected()) {\n    Rectangle2D rect=new Rectangle2D.Double(Math.max(0,getX(selectedBlock.getFirstCol())),0,0,0);\n    rect.add(Math.min(getX(selectedBlock.getLastCol() + 1),getSize().getWidth()),getSize().height);\n    g.setColor(highlightColorSemiTransparent);\n    g.fill(rect);\n    g.setColor(highlightColor);\n    g.draw(rect);\n  }\n}\n", "nl": "paint the selection rectangle"}
{"code": "public String requestServiceFromThirdPartyWebApp() throws Exception {\n  String url=ConsumerWebAppURL + \"?scope=\" + URLEncoder.encode(EndUserResourceURL,\"UTF-8\");\n  WebTarget target=ClientBuilder.newClient().target(url);\n  Response response=target.request().get();\n  response.close();\n  if (302 != response.getStatus()) {\n    throw new RuntimeException(\"Service request has failed - redirection is expected\");\n  }\n  String authorizationURI=response.getStringHeaders().getFirst(\"Location\");\n  if (authorizationURI == null) {\n    throw new RuntimeException(\"Token authorization URI is missing\");\n  }\n  return authorizationURI;\n}\n", "nl": "End user requests that a well-known 3rd party web application does something useful on its behalf"}
{"code": "public static Set<String> toSet(String s){\n  Set<String> newSet=new LinkedHashSet<String>();\n  if (s.startsWith(\"[\") && s.endsWith(\"]\")) {\n    s=s.substring(1,s.length() - 1);\n    String[] entries=s.split(\"\\\\,\\\\s\");\n    for (    String entry : entries) {\n      newSet.add(entry);\n    }\n  }\n else {\n    throw new IllegalArgumentException(\"String is not from Set.toString()\");\n  }\n  return newSet;\n}\n", "nl": "Reads a String version of a Set (should contain only strings) and creates a new Set"}
{"code": "private int calculateLayoutHeight(int heightSize,int mode){\n  mItemsLayout.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT));\n  mItemsLayout.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(heightSize,MeasureSpec.UNSPECIFIED));\n  int height=mItemsLayout.getMeasuredHeight();\n  if (mode == MeasureSpec.EXACTLY) {\n    height=heightSize;\n  }\n else {\n    height+=2 * mItemsPadding;\n    height=Math.max(height,getSuggestedMinimumHeight());\n    if (mode == MeasureSpec.AT_MOST && heightSize < height) {\n      height=heightSize;\n    }\n  }\n  mItemsLayout.measure(MeasureSpec.makeMeasureSpec(400,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(height - 2 * mItemsPadding,MeasureSpec.EXACTLY));\n  return height;\n}\n", "nl": "Calculates control height and creates text layouts"}
{"code": "public void discardRecording(){\n  if (recorder != null) {\n    try {\n      recorder.stop();\n      recorder.release();\n      recorder=null;\n      if (file != null && file.exists() && !file.isDirectory()) {\n        file.delete();\n      }\n    }\n catch (    IllegalStateException e) {\n    }\ncatch (    RuntimeException e) {\n    }\n    isRecording=false;\n  }\n}\n", "nl": "stop the recoding"}
{"code": "public void destroy(){\n  if (mDomThread != null && mDomThread.isWXThreadAlive()) {\n    mDomThread.quit();\n  }\n  if (mDomRegistries != null) {\n    mDomRegistries.clear();\n  }\n  mDomHandler=null;\n  mDomThread=null;\n}\n", "nl": "Destroy current instance"}
{"code": "public static Classification load(String name,String treeFile,String mapFile,ProgressListener progress){\nsynchronized (name2classification) {\n    Classification classification=name2classification.get(name);\n    if (classification == null) {\n      classification=new Classification(name);\n      name2classification.put(name,classification);\n    }\n    classification.load(treeFile,mapFile,progress);\n    return classification;\n  }\n}\n", "nl": "loads the named files and setups up the given classification (if not already present)"}
{"code": "@deprecated public final void reset(int start,int count) throws IllegalArgumentException {\n  int len=0;\n  if (this.text != null) {\n    len=this.text.length;\n  }\n  if ((start < 0) || (count < 0) || (start > len - count)) {\n    throw new IllegalArgumentException();\n  }\n  this.textStart=start;\n  this.textLimit=(start + count);\n  reset();\n}\n", "nl": "/*    "}
{"code": "private int measureHeightSize(int measureSpec){\n  int defSize=dp2px(DEFAULT_HEIGHT);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int result=0;\nswitch (specMode) {\ncase MeasureSpec.UNSPECIFIED:\ncase MeasureSpec.AT_MOST:\n    result=Math.min(defSize,specSize);\n  break;\ncase MeasureSpec.EXACTLY:\nresult=specSize;\nbreak;\n}\nreturn result;\n}\n", "nl": "measure height"}
{"code": "public static byte[] int2buff(int n){\n  byte[] bs;\n  bs=new byte[4];\n  bs[0]=(byte)((n >> 24) & 0xFF);\n  bs[1]=(byte)((n >> 16) & 0xFF);\n  bs[2]=(byte)((n >> 8) & 0xFF);\n  bs[3]=(byte)(n & 0xFF);\n  return bs;\n}\n", "nl": "int convert to buff (big-endian)"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set dir=\");\n  String result=np.getAbsoluteFileName();\n  np.matchIgnoreCase(\";\");\n  if (!(new File(result)).isDirectory()) {\n    System.err.println(\"No such directory: \" + result);\n  }\n else {\n    System.setProperty(\"user.dir\",result);\n    System.err.println(\"user.dir set to: \" + result);\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private void tryLoadData(){\n  if (fullBookModel != null) {\n    onLoadDataSuccess(fullBookModel);\n  }\n else   if (isSubscriptionInactive(loadFullBookSubscription)) {\n    getView().showLoading();\n    loadData();\n  }\n else {\n    getView().showLoading();\n  }\n}\n", "nl": "example of request, which load main data for screen"}
{"code": "public static void injectToData(Object target,Bundle data){\n  if (target == null || data == null)   return;\n  ParcelInjector injector;\n  try {\n    injector=getInjectorByClass(target.getClass());\n    injector.injectDataToBundle(target,data);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(String.format(\"inject failed : %s\",e.getMessage()),e);\n  }\n}\n", "nl": "inject some data from target to data"}
{"code": "Node(Node<K,V> parent,K key,Node<K,V> next,Node<K,V> prev){\n  this.parent=parent;\n  this.key=key;\n  this.height=1;\n  this.next=next;\n  this.prev=prev;\n  prev.next=this;\n  next.prev=this;\n}\n", "nl": "Create a regular entry"}
{"code": "public Object clone(){\n  Object newObject=null;\n  try {\n    newObject=super.clone();\n  }\n catch (  CloneNotSupportedException e) {\n    e.printStackTrace();\n  }\n  return newObject;\n}\n", "nl": "Allow to copy the object"}
{"code": "public void onProcessConnection(){\n  LOGGER.info(\"onProcessConnection - Connection\");\n  LOGGER.info(\"{}\",this.processConnectionRequest);\n  String xmlprocessConnectionResponse=this.supervisionManager.onProcessConnection(this.processConnectionRequest);\n  assertNotNull(xmlprocessConnectionResponse);\n  LOGGER.info(xmlprocessConnectionResponse);\n  try {\n    this.processConnectionResponse=(ProcessConnectionResponse)this.xmlConverter.fromXml(xmlprocessConnectionResponse);\n  }\n catch (  Exception e) {\n    LOGGER.error(e.toString());\n  }\n  assertNotNull(this.processConnectionResponse);\n  LOGGER.info(this.processConnectionResponse.toString());\n}\n", "nl": "Process Connection call"}
{"code": "private int calculateLayoutWidth(int widthSize,int mode){\n  initResourcesIfNecessary();\n  itemsLayout.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT));\n  itemsLayout.measure(MeasureSpec.makeMeasureSpec(widthSize,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  int width=itemsLayout.getMeasuredWidth();\n  if (mode == MeasureSpec.EXACTLY) {\n    width=widthSize;\n  }\n else {\n    width+=2 * PADDING;\n    width=Math.max(width,getSuggestedMinimumWidth());\n    if (mode == MeasureSpec.AT_MOST && widthSize < width) {\n      width=widthSize;\n    }\n  }\n  itemsLayout.measure(MeasureSpec.makeMeasureSpec(width - 2 * PADDING,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  return width;\n}\n", "nl": "Calculates control width and creates text layouts"}
{"code": "public void dismiss(boolean tappedTarget){\n  pulseAnimation.cancel();\n  expandAnimation.cancel();\n  if (tappedTarget) {\n    dismissConfirmAnimation.start();\n  }\n else {\n    dismissAnimation.start();\n  }\n}\n", "nl": "Dismiss this view"}
{"code": "public static void main(String[] args){\n  byte[] json=\"{\\\"name\\\":\\\"Elvis\\\"}\".getBytes(StandardCharsets.UTF_8);\n  JsonParser parser=new JsonParser();\n  PrettyPrinter prettyPrinter=new PrettyPrinter();\n  int i=0;\n  int event;\n  do {\n    while ((event=parser.nextEvent()) == JsonEvent.NEED_MORE_INPUT) {\n      i+=parser.getFeeder().feed(json,i,json.length - i);\n      if (i == json.length) {\n        parser.getFeeder().done();\n      }\n    }\n    prettyPrinter.onEvent(event,parser);\n  }\n while (event != JsonEvent.EOF);\n  System.out.println(prettyPrinter.getResult());\n}\n", "nl": "Main method demonstrating how to use the pretty-printer"}
{"code": "@Override public boolean isEnemyFrom(Player enemy){\n  if (this.getObjectId() == enemy.getObjectId()) {\n    return false;\n  }\n else   if ((this.getAdminEnmity() > 1 || enemy.getAdminEnmity() > 1)) {\n    return false;\n  }\n else   if (canPvP(enemy) || this.getController().isDueling(enemy)) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Player enemies:<br> - different race<br> - duel partner<br> - in pvp zone - in ffa zone"}
{"code": "public boolean selectedFragmentPicture(){\n  Intent intent=new Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);\n  intent.setType(\"image/*\");\n  if (intent.resolveActivity(this.activity.getPackageManager()) != null) {\n    this.intentFragment=intent;\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "This call the intent to selected the picture"}
{"code": "private int findMax(int[] lastPositions){\n  int max=lastPositions[0];\n  for (  int value : lastPositions) {\n    if (value > max) {\n      max=value;\n    }\n  }\n  return max;\n}\n", "nl": "find the max pos"}
{"code": "public String timestamp(){\n  float totalSeconds=this.length();\n  float second=totalSeconds % 60;\n  int minute=(int)totalSeconds / 60 % 60;\n  int hour=(int)(totalSeconds / 3600);\n  StringBuilder sb=new StringBuilder();\n  if (hour > 0) {\n    sb.append(hour + \":\");\n  }\n  if (minute > 0) {\n    sb.append(minute + \":\");\n  }\n  sb.append(second);\n  return sb.toString();\n}\n", "nl": "Timestamp of the wave length"}
{"code": "public void testWriteReadEmpty() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(empty);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  LoadBalancingPolicy.LoadBalancingPolicyDescription copy=(LoadBalancingPolicy.LoadBalancingPolicyDescription)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(empty,copy));\n}\n", "nl": "Test read and write empty ClusterPolicy object"}
{"code": "public static void checkAndCreateCarbonDataLocation(String carbonStorePath,String dbName,String tableName,int partitionCount,String segmentId){\n  CarbonTable carbonTable=CarbonMetadata.getInstance().getCarbonTable(dbName + CarbonCommonConstants.UNDERSCORE + tableName);\n  CarbonTableIdentifier carbonTableIdentifier=carbonTable.getCarbonTableIdentifier();\n  CarbonTablePath carbonTablePath=CarbonStorePath.getCarbonTablePath(carbonStorePath,carbonTableIdentifier);\n  for (int i=0; i < partitionCount; i++) {\n    String carbonDataDirectoryPath=carbonTablePath.getCarbonDataDirectoryPath(String.valueOf(i),segmentId);\n    CarbonUtil.checkAndCreateFolder(carbonDataDirectoryPath);\n  }\n}\n", "nl": "This method will get the store location for the given path, segment id and partition id"}
{"code": "private static long addNonStackableItem(Player player,ItemTemplate itemTemplate,long count,Item sourceItem,ItemUpdatePredicate predicate){\n  Storage inventory=player.getInventory();\n  while (!inventory.isFull(itemTemplate.getExtraInventoryId()) && count > 0) {\n    Item newItem=ItemFactory.newItem(itemTemplate.getTemplateId());\n    if (newItem.getExpireTime() != 0) {\n      ExpireTimerTask.getInstance().addTask(newItem,player);\n    }\n    if (sourceItem != null) {\n      copyItemInfo(sourceItem,newItem);\n    }\n    predicate.changeItem(newItem);\n    inventory.add(newItem,predicate.getAddType());\n    count--;\n  }\n  return count;\n}\n", "nl": "Add non-stackable item to inventory"}
{"code": "public List<Contentlet> executeSafe(){\n  try {\n    return APILocator.getContentletAPI().search(query.toString(),this.limit,this.offset,this.sortBy,APILocator.getUserAPI().getSystemUser(),false);\n  }\n catch (  DotDataException|DotSecurityException e) {\n    Logger.warn(this,\"Exception while executing query\",e);\n  }\n  return new ArrayList<Contentlet>();\n}\n", "nl": "Executes the query"}
{"code": "public boolean closeRemoteService(String url){\n  url=url.replace(\".*://\",\"\");\n  for (int i=0; i < tabbedPane.getTabCount(); i++) {\n    if (tabbedPane.getComponentAt(i) instanceof ServicePanel) {\n      final ServicePanel panel=(ServicePanel)tabbedPane.getComponentAt(i);\n      if (panel.getService().getServerURL().equalsIgnoreCase(url)) {\n{\n          RemoteServiceManager.removeNode(url);\n          tabbedPane.remove(panel);\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n", "nl": "close the named service"}
{"code": "final public int rebound(String... names){\n  int count=0;\n  if (names != null && names.length > 0) {\n    for (    String name : names) {\n      set(name,this.getString(name));\n      count++;\n    }\n  }\n else {\n    for (    String name : this.getNames()) {\n      set(name,this.getString(name));\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Rebound the request parameters to response"}
{"code": "public void ensureCapacity(int capacity){\n  if (mGarbage && mSize >= mKeys.length) {\n    gc();\n  }\n  if (mKeys.length < capacity) {\n    int[] nkeys=new int[capacity];\n    Object[] nvalues=new Object[capacity];\n    System.arraycopy(mKeys,0,nkeys,0,mKeys.length);\n    System.arraycopy(mValues,0,nvalues,0,mValues.length);\n    mKeys=nkeys;\n    mValues=nvalues;\n  }\n}\n", "nl": "Increases the size of the underlying storage if needed, to ensure that it can hold the specified number of items without having to allocate additional memory"}
{"code": "@deprecated public AlphabeticIndex(ULocale locale,RuleBasedCollator collator,UnicodeSet exemplarChars){\n  this.hasPinyin=false;\n  this.collatorOriginal=(collator != null ? collator : (RuleBasedCollator)Collator.getInstance(locale));\n  try {\n    this.collatorPrimaryOnly=((RuleBasedCollator)this.collatorOriginal.clone());\n  }\n catch (  Exception e) {\n    throw new IllegalStateException(\"Collator cannot be cloned\",e);\n  }\n  this.collatorPrimaryOnly.setStrength(0);\n  if (exemplarChars == null) {\n    exemplarChars=getIndexExemplars(locale);\n  }\n  addLabels(exemplarChars);\n}\n", "nl": "/*     "}
{"code": "public int convert(String value){\n  if (Strings.isNullOrEmpty(value) || TypeUtils.MISSING_INDICATORS.contains(value) || value.equals(\"-1\")) {\n    return (int)ColumnType.LOCAL_DATE.getMissingValue();\n  }\n  value=Strings.padStart(value,4,'0');\n  if (selectedFormatter == null) {\n    selectedFormatter=TypeUtils.getDateFormatter(value);\n  }\n  LocalDate date;\n  try {\n    date=LocalDate.parse(value,selectedFormatter);\n  }\n catch (  DateTimeParseException e) {\n    selectedFormatter=TypeUtils.DATE_FORMATTER;\n    date=LocalDate.parse(value,selectedFormatter);\n  }\n  return PackedLocalDate.pack(date);\n}\n", "nl": "Returns a PackedDate as converted from the given string"}
{"code": "public void finish() throws CarbonDataWriterException {\n  if (this.entryCount > 0) {\n    producerExecutorServiceTaskList.add(producerExecutorService.submit(new Producer(blockletDataHolder,dataRows,++writerTaskSequenceCounter)));\n    blockletProcessingCount.incrementAndGet();\n    processedDataCount+=entryCount;\n  }\n  closeWriterExecutionService(producerExecutorService);\n  processWriteTaskSubmitList(producerExecutorServiceTaskList);\n  processingComplete=true;\n}\n", "nl": "below method will be used to finish the data handler"}
{"code": "public void createDevices(@NotNull List<Device> devices){\n  if (!initIfNecessary()) {\n    return;\n  }\n  for (  Device device : devices) {\n    String deviceIdBase=device.getId();\n    String deviceNameBase=device.getDisplayName();\n    int i=2;\n    while (isUserDevice(device)) {\n      String id=String.format(Locale.getDefault(),\"%1$s_%2$d\",deviceIdBase,i);\n      String name=String.format(Locale.getDefault(),\"%1$s_%2$d\",deviceNameBase,i);\n      device=cloneDeviceWithNewIdAndName(device,id,name);\n    }\n    ourDeviceManager.addUserDevice(device);\n  }\n  ourDeviceManager.saveUserDevices();\n}\n", "nl": "Create the given devices"}
{"code": "public JsonRequestParams(Object params){\n  if (params == null)   return;\n  if (params instanceof Map<?,?>) {\n    urlParamsWithObjects.putAll((Map<String,Object>)params);\n  }\n else {\n    this.mCriteria=params;\n  }\n}\n", "nl": "Constructs a new JsonRequestParams instance from a object"}
{"code": "public String toString(){\n  StringBuilder buf=new StringBuilder();\n  buf.append(\"Splits (\").append(nsplits).append(\"):\\n\");\n  for (Iterator it=iterator(); it.hasNext(); ) {\n    Split split=(Split)it.next();\n    buf.append(split).append(\"\\n\");\n  }\n  return buf.toString();\n}\n", "nl": "gets a string representation"}
{"code": "public CASCDistanceCalculator() throws IOException {\n  Process p=Runtime.getRuntime().exec(PathToCasc);\n  try {\n    p.waitFor();\n  }\n catch (  InterruptedException iee) {\n    return;\n  }\n}\n", "nl": "Creates a new instance of CASCDistanceCalculator"}
{"code": "public long increaseEquippedItemCount(Item item,long count){\n  if (item.getItemTemplate().getCategory() != ItemCategory.SHARD) {\n    return count;\n  }\n  long leftCount=item.increaseItemCount(count);\n  ItemPacketService.updateItemAfterInfoChange(owner,item,ItemUpdateType.STATS_CHANGE);\n  setPersistentState(PersistentState.UPDATE_REQUIRED);\n  return leftCount;\n}\n", "nl": "increase item count and return left count"}
{"code": "private Map<String,Map<String,AbstractIndex>> addTableSegmentMap(AbsoluteTableIdentifier absoluteTableIdentifier){\n  Object lockObject=tableLockMap.get(absoluteTableIdentifier);\n  Map<String,Map<String,AbstractIndex>> tableSegmentMapTemp=tableSegmentMap.get(absoluteTableIdentifier);\n  if (null == tableSegmentMapTemp) {\nsynchronized (lockObject) {\n      tableSegmentMapTemp=tableSegmentMap.get(absoluteTableIdentifier);\n      if (null == tableSegmentMapTemp) {\n        tableSegmentMapTemp=new ConcurrentHashMap<String,Map<String,AbstractIndex>>();\n        tableSegmentMap.put(absoluteTableIdentifier,tableSegmentMapTemp);\n      }\n    }\n  }\n  return tableSegmentMapTemp;\n}\n", "nl": "Below method will be used to get the table segment map if table segment is not present then it will add and return"}
{"code": "public String upload_file1(String group_name,byte[] file_buff,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String parts[]=this.upload_file(group_name,file_buff,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload file to storage server (by file buff)"}
{"code": "public void toggleSelection(int position){\n  if (selectedItems.get(position,false)) {\n    selectedItems.delete(position);\n  }\n else {\n    selectedItems.put(position,true);\n  }\n  notifyItemChanged(position);\n}\n", "nl": "Toggle the selection status of the item at a given position"}
{"code": "private void drawCenterRect(Canvas canvas){\n  int center=getHeight() / 2;\n  int offset=(int)(getItemHeight() / 2 * 1.2);\n  Paint paint=new Paint();\n  paint.setColor(getResources().getColor(R.color.province_line_border));\n  paint.setStrokeWidth((float)3);\n  canvas.drawLine(0,center - offset,getWidth(),center - offset,paint);\n  canvas.drawLine(0,center + offset,getWidth(),center + offset,paint);\n}\n", "nl": "Draws rect for current value"}
{"code": "private void sendBroadcastDownloadFinished(DownloadFileOperation download,RemoteOperationResult downloadResult,String unlinkedFromRemotePath){\n  Intent end=new Intent(getDownloadFinishMessage());\n  end.putExtra(EXTRA_DOWNLOAD_RESULT,downloadResult.isSuccess());\n  end.putExtra(ACCOUNT_NAME,download.getAccount().name);\n  end.putExtra(EXTRA_REMOTE_PATH,download.getRemotePath());\n  end.putExtra(EXTRA_FILE_PATH,download.getSavePath());\n  if (unlinkedFromRemotePath != null) {\n    end.putExtra(EXTRA_LINKED_TO_PATH,unlinkedFromRemotePath);\n  }\n  sendStickyBroadcast(end);\n}\n", "nl": "Sends a broadcast when a download finishes in order to the interested activities can update their view"}
{"code": "private void startList(boolean isOrderedList,Attributes attributes){\n  boolean isIndentation=isIndentation(attributes);\n  ParagraphType newType=isIndentation && isOrderedList ? ParagraphType.INDENTATION_OL : isIndentation && !isOrderedList ? ParagraphType.INDENTATION_UL : isOrderedList ? ParagraphType.NUMBERING : ParagraphType.BULLET;\n  AccumulatedParagraphStyle currentStyle=mParagraphStyles.isEmpty() ? null : mParagraphStyles.peek();\n  if (currentStyle == null) {\n    AccumulatedParagraphStyle newStyle=new AccumulatedParagraphStyle(newType,1,1);\n    mParagraphStyles.push(newStyle);\n  }\n else   if (currentStyle.getType() == newType) {\n    currentStyle.setAbsoluteIndent(currentStyle.getAbsoluteIndent() + 1);\n    currentStyle.setRelativeIndent(currentStyle.getRelativeIndent() + 1);\n  }\n else {\n    AccumulatedParagraphStyle newStyle=new AccumulatedParagraphStyle(newType,currentStyle.getAbsoluteIndent() + 1,1);\n    mParagraphStyles.push(newStyle);\n  }\n}\n", "nl": "Handles OL and UL start tags"}
{"code": "private void openChooseRootDialog(){\n  ChooseRootUrlDialog dialog=new ChooseRootUrlDialog(getShell(),location.getUrl());\n  if (dialog.open() == Window.OK) {\n    SVNUrl url=dialog.getRootUrl();\n    if (url == null) {\n      repositoryRootText.setText(\"\");\n    }\n else {\n      repositoryRootText.setText(dialog.getRootUrl().toString());\n    }\n  }\n}\n", "nl": "open a dialog for the user to choose the root repository url"}
{"code": "@deprecated protected int write(int offset,int length){\n  int newLength=this.bytesLength + length;\n  ensureCapacity(newLength);\n  this.bytesLength=newLength;\n  int bytesOffset=this.bytes.length - this.bytesLength;\n  while (length > 0) {\n    this.bytes[(bytesOffset++)]=((byte)this.strings.charAt(offset++));\n    length--;\n  }\n  return this.bytesLength;\n}\n", "nl": "/*    "}
{"code": "public static String readStreamContent(InputStream stream) throws IOException {\n  StringBuilder str=new StringBuilder();\n  BufferedReader reader=new BufferedReader(new InputStreamReader(stream));\n  String line;\n  while ((line=reader.readLine()) != null) {\n    str.append(line + \"\\n\");\n  }\n  String response=str.toString();\n  return response;\n}\n", "nl": "Read Stream content"}
{"code": "public void updateProfile(PlayerData playerData){\n  this.playerData=playerData;\n  avatar=new PlayerAvatar(playerData.getAvatar());\n  dailyBonus=new DailyBonus(playerData.getDailyBonus());\n  contactSettings=new ContactSettings(playerData.getContactSettings());\n  for (  CurrencyOuterClass.Currency currency : playerData.getCurrenciesList()) {\n    try {\n      addCurrency(currency.getName(),currency.getAmount());\n    }\n catch (    InvalidCurrencyException e) {\n      Log.w(TAG,\"Error adding currency. You can probably ignore this.\",e);\n    }\n  }\n  tutorialState=new TutorialState(playerData.getTutorialStateList());\n}\n", "nl": "Update the profile with the given player data"}
{"code": "public Matrix uminus(){\n  Matrix X=new Matrix(m,n);\n  double[][] C=X.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      C[i][j]=-A[i][j];\n    }\n  }\n  return X;\n}\n", "nl": "Unary minus"}
{"code": "default Column distance(Column column2){\n  FloatColumn newColumn=FloatColumn.create(name() + column2.name() + \"[distance]\");\n  for (int r=0; r < size(); r++) {\n    String value1=getString(r);\n    String value2=column2.getString(r);\n    newColumn.set(r,StringUtils.getLevenshteinDistance(value1,value2));\n  }\n  return newColumn;\n}\n", "nl": "Returns a column containing the levenshtein distance between the two given string columns"}
{"code": "public void closeServer(ServerInfo server){\n  if (server.sock == null || this.keep_alive) {\n    return;\n  }\n  try {\n    server.sock.close();\n    server.sock=null;\n  }\n catch (  IOException ex) {\n    System.err.println(\"close socket error: \" + ex.getMessage());\n  }\n}\n", "nl": "close server"}
{"code": "public static void appendBlocks(DAAHeader header,BlockType[] types,byte[][] blocks,int[] sizes) throws IOException {\n  try (OutputStream outs=new BufferedOutputStream(new FileOutputStream(header.getFileName(),true))){\n    for (int i=0; i < blocks.length; i++) {\n      final byte[] bytes=blocks[i];\n      final int size=sizes[i];\n      final int index=header.getFirstAvailableBlockIndex();\n      header.setBlockTypeRank(index,BlockType.rank(types[i]));\n      header.setBlockSize(index,size);\n      outs.write(bytes,0,size);\n    }\n  }\n   header.save();\n}\n", "nl": "add new blocks"}
{"code": "public void writeHeader(String creator,BlastMode blastMode,String[] matchClassificationNames,boolean isPairedReads) throws IOException {\n  final HeaderSectionRMA6 headerSection=getHeaderSectionRMA6();\n  headerSection.setCreationDate(System.currentTimeMillis());\n  headerSection.setCreator(creator);\n  headerSection.setBlastMode(blastMode);\n  headerSection.setMatchClassNames(matchClassificationNames);\n  headerSection.setIsPairedReads(isPairedReads);\n  this.isPairedReads=isPairedReads;\n  numberOfClassificationNames=matchClassificationNames.length;\n  File file=new File(fileName);\n  if (file.exists() && !file.delete())   throw new IOException(\"Can't delete existing file: \" + file);\n  readerWriter=new OutputWriter(new File(fileName));\n  readerWriter.setUseCompression(useCompression);\n  getFooterSectionRMA6().setStartHeaderSection(readerWriter.getPosition());\n  getHeaderSectionRMA6().write(readerWriter);\n  getFooterSectionRMA6().setEndHeaderSection(readerWriter.getPosition());\n}\n", "nl": "setup and write the header"}
{"code": "public static Pair<Float,Float> computeAverageNandK(LinkedList<Pair<Number,Number>> values){\n  if (values.size() == 0)   return new Pair<>(0f,0f);\n  double n=0;\n  double k=0;\n  for (  Pair<Number,Number> pair : values) {\n    n+=pair.get1().doubleValue();\n    k+=pair.get2().doubleValue();\n  }\n  return new Pair<>((float)(n / values.size()),(float)(k / values.size()));\n}\n", "nl": "compute the average k and N values"}
{"code": "public Session store(){\n  long expired=Global.getLong(\"session.alive\",X.AWEEK);\n  if (expired > 0) {\n    expired=System.currentTimeMillis() + expired;\n  }\n else {\n    expired=-1;\n  }\n  return store(expired);\n}\n", "nl": "Store the session with configured expired"}
{"code": "@Override public void close(){\n  try {\n    raf.close();\n    System.err.println(\"Closing file: \" + file.getName() + \" (\"+ pages+ \"/\"+ data.length+ \" pages)\");\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n}\n", "nl": "close the array"}
{"code": "protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  int end=getYearMonth(str,0,len,date);\n  date.day=DAY;\n  parseTimeZone(str,end,len,date);\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != 'Z') {\n    normalize(date);\n  }\n  date.position=0;\n  return date;\n}\n", "nl": "Parses, validates and computes normalized version of gYearMonth object"}
{"code": "public PotionData(PotionType type,boolean extended,boolean upgraded){\n  Validate.notNull(type,\"Potion Type must not be null\");\n  Validate.isTrue(!upgraded || type.isUpgradeable(),\"Potion Type is not upgradable\");\n  Validate.isTrue(!extended || type.isExtendable(),\"Potion Type is not extendable\");\n  Validate.isTrue(!upgraded || !extended,\"Potion cannot be both extended and upgraded\");\n  this.type=type;\n  this.extended=extended;\n  this.upgraded=upgraded;\n}\n", "nl": "Instantiates a final PotionData object to contain information about a Potion"}
{"code": "public void testWriteReadFull() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(full);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  FailOverPolicy copy=(FailOverPolicy)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(full,copy));\n}\n", "nl": "Test read and write full ClusterPolicy object"}
{"code": "public CubicBezier(BezierRenderer renderer,FloatBuffer vboBuffer,float p0x,float p0y,float p3x,float p3y,float p1x,float p1y,float p2x,float p2y,float[] color){\n  this.mRenderer=renderer;\n  this.starEndPoints=new float[]{p0x,p0y,p3x,p3y};\n  this.controlPoints=new float[]{p1x,p1y,p2x,p2y};\n  this.color=color;\n  final int buffers[]=new int[1];\n  GLES20.glGenBuffers(1,buffers,0);\n  GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,buffers[0]);\n  GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER,vboBuffer.capacity() * Const.BYTES_PER_FLOAT,vboBuffer,GLES20.GL_STATIC_DRAW);\n  GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,0);\n  mBufferId=buffers[0];\n  vboBuffer=null;\n}\n", "nl": "Creates a cubic bezier renderable"}
{"code": "private int assignComplexOrdinal(CarbonDimension parentDimension,int complexDimensionOrdianl){\n  for (int i=0; i < parentDimension.getNumberOfChild(); i++) {\n    CarbonDimension dimension=parentDimension.getListOfChildDimensions().get(i);\n    if (dimension.getNumberOfChild() > 0) {\n      dimension.setComplexTypeOridnal(++complexDimensionOrdianl);\n      complexDimensionOrdianl=assignComplexOrdinal(dimension,complexDimensionOrdianl);\n    }\n else {\n      parentDimension.getListOfChildDimensions().get(i).setComplexTypeOridnal(++complexDimensionOrdianl);\n    }\n  }\n  return complexDimensionOrdianl;\n}\n", "nl": "Read all primitive/complex children and set it as list of child carbon dimension to parent dimension"}
{"code": "@Override public void writeString(byte[] str,int offset,int length) throws IOException {\n  if (str == null)   writeInt(0);\n else {\n    if (useCompression && length >= Compressor.MIN_SIZE_FOR_DEFLATION) {\n      if (byteBuffer.length < length)       byteBuffer=new byte[2 * length];\n      int numberOfBytes=compressor.deflateString2ByteArray(str,offset,length,byteBuffer);\n      writeInt(numberOfBytes);\n      io.write(byteBuffer,0,Math.abs(numberOfBytes));\n    }\n else {\n      writeInt(length);\n      io.write(str,offset,length);\n    }\n  }\n}\n", "nl": "write a string, compressed, if long enough"}
{"code": "private void storeLegionMember(LegionMember legionMember,boolean newMember){\n  if (newMember) {\n    addCachedLegionMember(legionMember);\n    DAOManager.getDAO(LegionMemberDAO.class).saveNewLegionMember(legionMember);\n  }\n else {\n    DAOManager.getDAO(LegionMemberDAO.class).storeLegionMember(legionMember.getObjectId(),legionMember);\n  }\n}\n", "nl": "Stores legion member data into db or saves a new one"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"scrollTo node=\");\n  String name=np.getWordRespectCase();\n  np.matchWordIgnoreCase(\";\");\n  if (getViewer() instanceof ViewerBase) {\n    ViewerBase viewerBase=(ViewerBase)getViewer();\n    for (Node v=viewerBase.getGraph().getFirstNode(); v != null; v=v.getNext()) {\n      String label=viewerBase.getLabel(v);\n      if (label != null && label.equals(name)) {\n        viewerBase.scrollToNode(v);\n        break;\n      }\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public CacheHeader(String key,Entry entry){\n  this.key=key;\n  this.size=entry.data.length;\n  this.etag=entry.etag;\n  this.serverDate=entry.serverDate;\n  this.lastModified=entry.lastModified;\n  this.ttl=entry.ttl;\n  this.softTtl=entry.softTtl;\n  this.responseHeaders=entry.responseHeaders;\n}\n", "nl": "Instantiates a new CacheHeader object"}
{"code": "public static String parseCharset(Map<String,String> headers,String defaultCharset){\n  String contentType=headers.get(HTTP.CONTENT_TYPE);\n  if (contentType != null) {\n    String[] params=contentType.split(\";\");\n    for (int i=1; i < params.length; i++) {\n      String[] pair=params[i].trim().split(\"=\");\n      if (pair.length == 2) {\n        if (pair[0].equals(\"charset\")) {\n          return pair[1];\n        }\n      }\n    }\n  }\n  return defaultCharset;\n}\n", "nl": "Retrieve a charset from headers"}
{"code": "public void addListener(AirMapTrafficListener listener){\n  if (listeners.isEmpty()) {\n    listeners.add(listener);\n    connect();\n  }\n else {\n    listeners.add(listener);\n  }\n}\n", "nl": "Add a listener to be notified of traffic events"}
{"code": "private void drawCircle(Canvas canvas,int index,Paint paint,float radius){\n  if (isIllegalIndex(index)) {\n    return;\n  }\n  int x=getXByIndex(index);\n  int y=getYByIndex(index);\n  float centreY=cellHeight + (y - 1) * cellHeight + cellHeight * 0.5f;\n  float centreX=cellWidth * (x - 1) + cellWidth * 0.5f;\n  canvas.drawCircle(centreX,centreY,radius,paint);\n}\n", "nl": "draw circle, around the middle of the cell decided by the index"}
{"code": "public void toggleLockConstraints(ConstraintWidget widget){\n  int constraintsCreator=getMainConstraintsCreator(widget);\n  if (constraintsCreator == ConstraintAnchor.USER_CREATOR) {\n    setConstraintsCreator(widget,ConstraintAnchor.AUTO_CONSTRAINT_CREATOR);\n  }\n else   if (constraintsCreator == ConstraintAnchor.AUTO_CONSTRAINT_CREATOR) {\n    setConstraintsCreator(widget,ConstraintAnchor.USER_CREATOR);\n  }\n  mSelection.selectionHasChanged();\n}\n", "nl": "Toggle the constraints of the given widget"}
{"code": "@Override public void notationDecl(String name,XMLResourceIdentifier identifier,Augmentations augs) throws XNIException {\n  try {\n    if (fDTDHandler != null) {\n      String publicId=identifier.getPublicId();\n      String systemId=fResolveDTDURIs ? identifier.getExpandedSystemId() : identifier.getLiteralSystemId();\n      fDTDHandler.notationDecl(name,publicId,systemId);\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n}\n", "nl": "A notation declaration"}
{"code": "public static int insertCollection(String table,Collection<V> values){\n  MongoCollection<Document> c=getCollection(table);\n  if (c != null) {\n    List<Document> list=new ArrayList<Document>(values.size());\n    for (    V v : values) {\n      list.add(new Document(v.m));\n    }\n    try {\n      c.insertMany(list);\n      if (log.isDebugEnabled())       log.debug(\"inserted collection=\" + table + \", list=\"+ list);\n      return 1;\n    }\n catch (    Exception e) {\n      if (log.isErrorEnabled())       log.error(e.getMessage(),e);\n    }\n  }\n  return 0;\n}\n", "nl": "batch insert data"}
{"code": "public void onError(int taskId,String reason){\n  PlayerTransferRequest request=this.transfers.remove(taskId);\n  PlayerTransferTask task=this.tasks.remove(taskId);\n  task.status=PlayerTransferTask.STATUS_ERROR;\n  task.comment=reason;\n  this.dao.update(task);\n  GameServerInfo targetServer=GameServerTable.getGameServerInfo(request.targetServerId);\n  if (targetServer == null || targetServer.getConnection() == null) {\n    log.error(\"Player transfer requests offline server! #\" + request.targetServerId);\n    return;\n  }\n  request.account.setActivated((byte)1);\n  request.saccount.setActivated((byte)1);\n  DAOManager.getDAO(AccountDAO.class).updateAccount(request.account);\n  DAOManager.getDAO(AccountDAO.class).updateAccount(request.saccount);\n  targetServer.getConnection().sendPacket(new SM_PTRANSFER_RESPONSE(PlayerTransferResultStatus.ERROR,taskId,reason));\n}\n", "nl": "response from target server after cloning character"}
{"code": "public void straightenSelectedItem(Animator.AnimatorListener listener){\n  if (selectedItemPosition == RecyclerView.NO_POSITION || isSelectAnimationInProcess || isDeselectAnimationInProcess || isSelectedItemStraightened || isWaitingToDeselectAnimation || isWaitingToSelectAnimation || isViewCollapsing) {\n    return;\n  }\n  View viewToRotate=null;\n  View view;\n  for (int count=getChildCount(), i=0; i < count; i++) {\n    view=getChildAt(i);\n    if (selectedItemPosition == getPosition(view)) {\n      viewToRotate=view;\n    }\n  }\n  if (viewToRotate != null) {\n    animationHelper.straightenView(viewToRotate,listener);\n    isSelectedItemStraightened=true;\n  }\n}\n", "nl": "Method need to remove bounce item radius"}
{"code": "public void testWriteReadFull() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(full);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  ActiveElectionConfig copy=(ActiveElectionConfig)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(full,copy));\n}\n", "nl": "Test read and write full ClusterPolicy object"}
{"code": "@SuppressWarnings({\"unchecked\",\"cast\"}) public TypeDecl lookupLibType(String packageName,String typeName){\n  java.util.List _parameters=new java.util.ArrayList(2);\n  _parameters.add(packageName);\n  _parameters.add(typeName);\n  if (lookupLibType_String_String_values == null)   lookupLibType_String_String_values=new java.util.HashMap(4);\n  if (lookupLibType_String_String_values.containsKey(_parameters)) {\n    return (TypeDecl)lookupLibType_String_String_values.get(_parameters);\n  }\n  ASTNode$State state=state();\n  int num=state.boundariesCrossed;\n  boolean isFinal=this.is$Final();\n  TypeDecl lookupLibType_String_String_value=lookupLibType_compute(packageName,typeName);\n  if (isFinal && num == state().boundariesCrossed)   lookupLibType_String_String_values.put(_parameters,lookupLibType_String_String_value);\n  return lookupLibType_String_String_value;\n}\n", "nl": "Lookup types in the library"}
{"code": "@deprecated public CompactByteArray(char[] indexArray,byte[] newValues){\n  if (indexArray.length != 512)   throw new IllegalArgumentException(\"Index out of bounds.\");\n  for (int i=0; i < 512; i++) {\n    char index=indexArray[i];\n    if ((index < 0) || (index >= newValues.length + 128))     throw new IllegalArgumentException(\"Index out of bounds.\");\n  }\n  this.indices=indexArray;\n  this.values=newValues;\n  this.isCompact=true;\n}\n", "nl": "/*    "}
{"code": "public Matrix plus(Matrix B){\n  checkMatrixDimensions(B);\n  Matrix X=new Matrix(m,n);\n  double[][] C=X.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      C[i][j]=A[i][j] + B.A[i][j];\n    }\n  }\n  return X;\n}\n", "nl": "C = A + B"}
{"code": "public void testWriteReadEmpty() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(empty);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  ClusterPolicy copy=(ClusterPolicy)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(empty,copy));\n}\n", "nl": "Test read and write empty ClusterPolicy object"}
{"code": "public static JsonNode removeChild(JsonNode original,String key){\n  Map<JsonStringNode,JsonNode> existingFields=original.getFields();\n  Map<JsonStringNode,JsonNode> newMap=new HashMap<>();\n  for (  Entry<JsonStringNode,JsonNode> entry : existingFields.entrySet()) {\n    if (!entry.getKey().toString().equals(key)) {\n      newMap.put(entry.getKey(),entry.getValue());\n    }\n  }\n  return JsonNodeFactories.object(newMap);\n}\n", "nl": "Remove a child (or children) from the current json node given the key to remove"}
{"code": "@Override public int countMissing(){\n  int count=0;\n  for (int i=0; i < size(); i++) {\n    if (getInt(i) == MISSING_VALUE) {\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Returns the count of missing values in this column"}
{"code": "private void drawCenterRect(Canvas canvas){\n  int center=getHeight() / 2;\n  int offset=(int)(getItemHeight() / 2 * 1.2);\n  Paint paint=new Paint();\n  paint.setColor(getResources().getColor(R.color.province_line_border));\n  paint.setStrokeWidth((float)3);\n  canvas.drawLine(0,center - offset,getWidth(),center - offset,paint);\n  canvas.drawLine(0,center + offset,getWidth(),center + offset,paint);\n}\n", "nl": "Draws rect for current value"}
{"code": "SubMap(FastConcurrentSkipListMap<K,V> map,K fromKey,boolean fromInclusive,K toKey,boolean toInclusive,boolean isDescending){\n  if (fromKey != null && toKey != null && map.compare(fromKey,toKey) > 0)   throw new IllegalArgumentException(\"inconsistent range\");\n  this.m=map;\n  this.lo=fromKey;\n  this.hi=toKey;\n  this.loInclusive=fromInclusive;\n  this.hiInclusive=toInclusive;\n  this.isDescending=isDescending;\n}\n", "nl": "Creates a new submap, initializing all fields"}
{"code": "private static boolean resolveBoolean(Context context,@AttrRes int attr,boolean fallback){\n  TypedArray a=context.getTheme().obtainStyledAttributes(new int[]{attr});\n  try {\n    return a.getBoolean(0,fallback);\n  }\n  finally {\n    a.recycle();\n  }\n}\n", "nl": "Gets the required boolean value from the current context, if possible/available"}
{"code": "@Deprecated private static SecretKey generatePBEKey(char[] passphraseOrPin,byte[] salt,String algorthm,int iterations,int keyLength) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {\n  if (iterations == 0) {\n    iterations=1000;\n  }\n  SecretKeyFactory secretKeyFactory=SecretKeyFactory.getInstance(algorthm,PROVIDER);\n  KeySpec keySpec=new PBEKeySpec(passphraseOrPin,salt,iterations,keyLength);\n  SecretKey secretKey=secretKeyFactory.generateSecret(keySpec);\n  return secretKey;\n}\n", "nl": "Derive a secure key based on the passphraseOrPin"}
{"code": "private static String toString(double[] values){\n  StringBuilder buf=new StringBuilder();\n  boolean first=true;\n  for (  double value : values) {\n    if (first)     first=false;\n else     buf.append(\", \");\n    buf.append(String.format(\"%.3f\",value + 0.00001));\n  }\n  return buf.toString();\n}\n", "nl": "write numbers as string"}
{"code": "private void increaseEventCount(Map<String,Integer> eventCounts,Predicate<String> predicate){\n  int impressionCount=eventCounts.getOrDefault(\"impression\",0);\n  int impressionUniqueCount=Math.min(impressionCount,1);\n  int jointCounts=0;\n  if (!predicate.test(\"click\")) {\n    jointCounts+=eventCounts.getOrDefault(\"click\",0);\n  }\n  if (!predicate.test(\"love it\")) {\n    jointCounts+=eventCounts.getOrDefault(\"love it\",0);\n  }\n  int jointUniqueCount=Math.min(jointCounts,1);\n  impressionCounts.put(\"eventCount\",impressionCounts.getOrDefault(\"eventCount\",0) + impressionCount);\n  impressionCounts.put(\"uniqueUserCount\",impressionCounts.getOrDefault(\"uniqueUserCount\",0) + impressionUniqueCount);\n  jointActionCounts.put(\"eventCount\",jointActionCounts.getOrDefault(\"eventCount\",0) + jointCounts);\n  jointActionCounts.put(\"uniqueUserCount\",jointActionCounts.getOrDefault(\"uniqueUserCount\",0) + jointUniqueCount);\n}\n", "nl": "this method is used to update the reference count of the actions"}
{"code": "@Override public void notationDecl(String name,XMLResourceIdentifier identifier,Augmentations augs) throws XNIException {\n  if (fValidation) {\n    DTDGrammar grammar=(fDTDGrammar != null ? fDTDGrammar : fGrammarBucket.getActiveGrammar());\n    if (grammar.getNotationDeclIndex(name) != -1) {\n      fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\"UniqueNotationName\",new Object[]{name},XMLErrorReporter.SEVERITY_ERROR);\n    }\n  }\n  if (fDTDGrammar != null)   fDTDGrammar.notationDecl(name,identifier,augs);\n  if (fDTDHandler != null) {\n    fDTDHandler.notationDecl(name,identifier,augs);\n  }\n}\n", "nl": "A notation declaration"}
{"code": "public static Activity scanForActivity(Context context){\n  if (context == null)   return null;\n  if (context instanceof Activity) {\n    return (Activity)context;\n  }\n else   if (context instanceof ContextWrapper) {\n    return scanForActivity(((ContextWrapper)context).getBaseContext());\n  }\n  return null;\n}\n", "nl": "Get activity from context object"}
{"code": "public static boolean writeFile(String filePath,String content,boolean append){\n  if (StringUtil.isEmpty(content)) {\n    return false;\n  }\n  FileWriter fileWriter=null;\n  try {\n    makeDirs(filePath);\n    fileWriter=new FileWriter(filePath,append);\n    fileWriter.write(content);\n    return true;\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"IOException occurred. \",e);\n  }\n finally {\n    IOUtil.close(fileWriter);\n  }\n}\n", "nl": "write file"}
{"code": "public void reportJSException(String instanceId,String function,String exception){\n  if (WXEnvironment.isApkDebugable()) {\n    WXLogUtils.e(\"reportJSException >>>> instanceId:\" + instanceId + \", exception function:\"+ function+ \", exception:\"+ exception);\n  }\n  WXSDKInstance instance=WXSDKManager.getInstance().getSDKInstance(instanceId);\n  if (instance != null) {\n    instance.onJSException(null,function,exception);\n  }\n  WXErrorCode.WX_ERR_JS_EXECUTE.appendErrMsg(exception);\n  commitJSBridgeAlarmMonitor(instanceId,WXErrorCode.WX_ERR_JS_EXECUTE);\n}\n", "nl": "Report JavaScript Exception"}
{"code": "public List<CodeResult> formatResults(List<CodeResult> codeResult,String matchTerms,boolean highlightLine){\n  List<String> lstMatchTerms=splitTerms(matchTerms);\n  List<CodeResult> results=new ArrayList<>();\n  for (  CodeResult code : codeResult) {\n    List<CodeMatchResult> result=matchResults(code.getCode(),lstMatchTerms,highlightLine);\n    if (result != null) {\n      code.setMatchingResults(result);\n      results.add(code);\n    }\n  }\n  return results;\n}\n", "nl": "Entry point for matching lines"}
{"code": "public void calculateDayTime(){\n  int hour=getHour();\n  if (hour > 21 || hour < 4) {\n    dayTime=DayTime.NIGHT;\n  }\n else   if (hour > 16) {\n    dayTime=DayTime.EVENING;\n  }\n else   if (hour > 8) {\n    dayTime=DayTime.AFTERNOON;\n  }\n else {\n    dayTime=DayTime.MORNING;\n  }\n}\n", "nl": "Calculate the day time"}
{"code": "public void nullify(){\n  for (int iNGramSize=MinSize; iNGramSize <= MaxSize; iNGramSize++) {\n    UniqueVertexGraph gCurLevel=getGraphLevelByNGramSize(iNGramSize);\n    java.util.Iterator iIter=gCurLevel.getEdgeSet().iterator();\n    while (iIter.hasNext()) {\n      WeightedEdge weEdge=(WeightedEdge)iIter.next();\n      weEdge.setWeight(0.0);\n    }\n  }\n}\n", "nl": "Sets all weights in all graphs to zero"}
{"code": "public static int limit(int number,int between,int and){\n  if (number <= between) {\n    return between;\n  }\n  if (number >= and) {\n    return and;\n  }\n  return number;\n}\n", "nl": "Limits the given <b>number</b> between the other values"}
{"code": "private void onActivePointerUp(){\n  if (STATUS.isSwipingToRefresh(mStatus)) {\n    scrollSwipingToRefreshToDefault();\n  }\n else   if (STATUS.isSwipingToLoadMore(mStatus)) {\n    scrollSwipingToLoadMoreToDefault();\n  }\n else   if (STATUS.isReleaseToRefresh(mStatus)) {\n    mRefreshCallback.onRelease();\n    scrollReleaseToRefreshToRefreshing();\n  }\n else   if (STATUS.isReleaseToLoadMore(mStatus)) {\n    mLoadMoreCallback.onRelease();\n    scrollReleaseToLoadMoreToLoadingMore();\n  }\n}\n", "nl": "on active finger up"}
{"code": "public SM_MESSAGE(Player player,String message,ChatType chatType){\n  this.player=player;\n  this.senderObjectId=player.getObjectId();\n  this.senderName=player.getName();\n  this.message=message;\n  this.race=player.getRace();\n  this.chatType=chatType;\n  this.x=player.getX();\n  this.y=player.getY();\n  this.z=player.getZ();\n}\n", "nl": "Constructs new <tt>SM_MESSAGE </tt> packet"}
{"code": "private static boolean resolveBoolean(Context context,@AttrRes int attr,boolean fallback){\n  TypedArray a=context.getTheme().obtainStyledAttributes(new int[]{attr});\n  try {\n    return a.getBoolean(0,fallback);\n  }\n  finally {\n    a.recycle();\n  }\n}\n", "nl": "Gets the required boolean value from the current context, if possible/available"}
{"code": "private static void copyFile(File file,InputStream is,String mode) throws IOException, InterruptedException {\n  final String abspath=file.getAbsolutePath();\n  final FileOutputStream out=new FileOutputStream(file);\n  byte buf[]=new byte[1024];\n  int len;\n  while ((len=is.read(buf)) > 0) {\n    out.write(buf,0,len);\n  }\n  out.close();\n  is.close();\n  Runtime.getRuntime().exec(\"chmod \" + mode + \" \"+ abspath).waitFor();\n}\n", "nl": "copy file to destination"}
{"code": "public static Map<String,Object> testCCProcessorCaptureAlwaysDecline(DispatchContext dctx,Map<String,? extends Object> context){\n  Locale locale=(Locale)context.get(\"locale\");\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  BigDecimal processAmount=(BigDecimal)context.get(\"captureAmount\");\n  Debug.logInfo(\"Test Processor Declining Credit Card capture\",module);\n  String refNum=UtilDateTime.nowAsString();\n  result.put(\"captureResult\",Boolean.FALSE);\n  result.put(\"captureAmount\",processAmount);\n  result.put(\"captureRefNum\",refNum);\n  result.put(\"captureAltRefNum\",refNum);\n  result.put(\"captureFlag\",\"D\");\n  result.put(\"captureMessage\",UtilProperties.getMessage(resource,\"AccountingPaymentTestCaptureDeclined\",locale));\n  return result;\n}\n", "nl": "Always decline processor"}
{"code": "public static void multiply(Matrix a,Matrix b,Matrix result){\n  for (int ri=0; ri < result.rows; ri++) {\n    for (int rc=0; rc < result.cols; rc++) {\n      double sum=0;\n      for (int j=0; j < b.rows; j++) {\n        sum+=a.get(ri,j) * b.get(j,rc);\n      }\n      result.set(ri,rc,sum);\n    }\n  }\n}\n", "nl": "Matrix multiplication result = a * b"}
{"code": "public static int delete(File f) throws IOException {\n  int count=0;\n  if (f.isFile()) {\n    f.delete();\n    count++;\n  }\n else   if (f.isDirectory()) {\n    File[] ff=f.listFiles();\n    if (ff != null && ff.length > 0) {\n      for (      File f1 : ff) {\n        count+=delete(f1);\n      }\n    }\n    f.delete();\n    count++;\n  }\n  return count;\n}\n", "nl": "delete the file or the path"}
{"code": "private void initPaint(){\n  mProgressTextPaint.setTextAlign(Paint.Align.CENTER);\n  mProgressTextPaint.setTextSize(mProgressTextSize);\n  mProgressPaint.setStyle(mStyle == SOLID ? Paint.Style.FILL : Paint.Style.STROKE);\n  mProgressPaint.setStrokeWidth(mProgressStrokeWidth);\n  mProgressPaint.setColor(mProgressStartColor);\n  mProgressPaint.setStrokeCap(mCap);\n  mProgressBackgroundPaint.setStyle(mStyle == SOLID ? Paint.Style.FILL : Paint.Style.STROKE);\n  mProgressBackgroundPaint.setStrokeWidth(mProgressStrokeWidth);\n  mProgressBackgroundPaint.setColor(mProgressBackgroundColor);\n  mProgressBackgroundPaint.setStrokeCap(mCap);\n  mBackgroundPaint.setStyle(Paint.Style.FILL);\n  mBackgroundPaint.setColor(mBackgroundColor);\n}\n", "nl": "Paint initialization"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  AlignmentViewer alignmentViewer=(AlignmentViewer)getViewer();\n  int nSequences=alignmentViewer.getAlignment().getNumberOfSequences();\n  int step=1;\n  if (nSequences > 10000 && nSequences <= 20000)   step=2;\n else   if (nSequences > 20000 && nSequences <= 30000)   step=4;\n else   if (nSequences > 30000)   step=6;\n  execute(\"chart wordCount kmer=25 step=\" + step + \" mindepth=10;\");\n}\n", "nl": "action to be performed"}
{"code": "public void goToPreviousBackStack() throws NavigatorException {\n  FragmentManager fragmentManager=((FragmentActivity)mContextReference.getContext()).getSupportFragmentManager();\n  if (canGoBack(fragmentManager)) {\n    fragmentManager.popBackStack();\n  }\n else {\n    throw new NavigatorException(\"You don't go back to this point\");\n  }\n}\n", "nl": "Return to previous point"}
{"code": "public static void wrap(ConstraintWidgetContainer root){\n  ArrayList<ConstraintWidget> widgets=root.getChildren();\n  Rectangle all=ScoutArrange.getBoundingBox(widgets);\n  all.x-=sMargin;\n  all.y-=sMargin;\n  all.width+=sMargin * 2;\n  all.height+=sMargin * 2;\n  for (  ConstraintWidget widget : widgets) {\n    widget.setX(widget.getX() - all.x);\n    widget.setY(widget.getY() - all.y);\n  }\n  root.setHorizontalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.FIXED);\n  root.setVerticalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.FIXED);\n  root.setWidth(all.width);\n  root.setHeight(all.height);\n}\n", "nl": "Shrink Wraps around containing widgets"}
{"code": "public SkillTreeCursor querySkillTrees(){\n  QueryHelper qh=new QueryHelper();\n  qh.Distinct=true;\n  qh.Table=S.TABLE_SKILL_TREES;\n  qh.Columns=null;\n  qh.Selection=null;\n  qh.SelectionArgs=null;\n  qh.GroupBy=S.COLUMN_SKILL_TREES_NAME;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new SkillTreeCursor(wrapHelper(qh));\n}\n", "nl": "****************************** SKILL TREE QUERIES"}
{"code": "public static void closeReader(){\n  try {\n    if (reader != null) {\n      reader.close();\n      reader=null;\n    }\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Close the reader"}
{"code": "private void writeFileClean(){\n  PrintWriter pw;\n  try {\n    pw=new PrintWriter(Settings.sServerInfo);\n    pw.println(\" \");\n    pw.close();\n  }\n catch (  FileNotFoundException e) {\n    System.out.println(\"serverinfo.jrc do not exist\");\n  }\ncatch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "serverinfo file clean"}
{"code": "public static KeyStore createEmptyKeyStore(){\n  try {\n    KeyStore keyStore=KeyStore.getInstance(KeyStore.getDefaultType());\n    keyStore.load(null);\n    return keyStore;\n  }\n catch (  KeyStoreException|NoSuchAlgorithmException|CertificateException|IOException e) {\n    throw new RuntimeException(\"Failed to create empty keystore\",e);\n  }\n}\n", "nl": "Create an empty key store"}
{"code": "public Boolean deleteStock(EntityManager em,String id){\n  Boolean status=true;\n  Stock stock=null;\n  try {\n    if (!em.getTransaction().isActive()) {\n      em.getTransaction().begin();\n    }\n    stock=em.find(Stock.class,id);\n    em.remove(stock);\n    em.getTransaction().commit();\n  }\n catch (  Exception e) {\n    status=false;\n    logger.error(\"Error occured during delete of Stock. Detailed info: \" + e);\n  }\n  return status;\n}\n", "nl": "Helper method to delete Stock"}
{"code": "private int measureShort(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(2 * mRadius + getPaddingTop() + getPaddingBottom() + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the height of this view"}
{"code": "private static String unwrap(String expression){\n  if (expression.startsWith(\"((\")) {\n    expression=expression.substring(expression.indexOf(\")\") + 1,expression.length() - 1);\n    if (expression.endsWith(\"]\")) {\n      expression=expression.substring(0,expression.lastIndexOf(\"[\"));\n    }\n else {\n      expression=expression.substring(0,expression.lastIndexOf(\".\"));\n    }\n  }\n  return expression;\n}\n", "nl": "Removes the outermost property from a nested getter expression"}
{"code": "public static void openSendSmsActivity(Context context,String phoneNumber,String body){\n  Intent intent=new Intent(Intent.ACTION_VIEW);\n  String phone=phoneNumber != null ? phoneNumber : \"\";\n  intent.setData(Uri.parse(\"sms:\" + phone));\n  if (StringUtils.isNotBlank(body)) {\n    intent.putExtra(\"sms_body\",body);\n  }\n  startIntentIfPossible(context,intent);\n}\n", "nl": "Open SMS activity to send SMS"}
{"code": "private void logAndHandle(Throwable t,boolean passToHandler){\n  if (Thread.getDefaultUncaughtExceptionHandler() == null) {\n    LOG.error(\"Unhandled exception on thread {}\",Thread.currentThread().getName(),t);\n  }\n else {\n    LOG.info(\"Unhandled exception on thread {}\",Thread.currentThread().getName(),t);\n    if (passToHandler) {\n      Thread.getDefaultUncaughtExceptionHandler().uncaughtException(Thread.currentThread(),t);\n    }\n  }\n}\n", "nl": "The executor re-throws exceptions thrown by the task to the uncaught exception handler so we only need to do anything if uncaught exception handler has not been se"}
{"code": "public Builder add(String property,Attributes attributes){\n  Map<String,String> map=attributes.getAttributes();\n  StringBuilder stringBuilder=new StringBuilder();\n  stringBuilder.append(property);\n  stringBuilder.append('.');\n  stringBuilder.append(Utils.join(map,'.','(',')'));\n  properties.add(stringBuilder.toString());\n  return this;\n}\n", "nl": "Add property and attribute you need"}
{"code": "@SuppressWarnings(\"unchecked\") public List<String> onTabComplete(Sender sender,List<String> args){\n  final List<MainCommand> mains=mainCommands.stream().filter(null).collect(Collectors.toList());\n  if (args.size() <= 1) {\n    if (args.isEmpty() || args.get(0).equalsIgnoreCase(\"\")) {\n      return mains.stream().map(null).collect(Collectors.toList());\n    }\n    return mains.stream().map(null).filter(null).collect(Collectors.toList());\n  }\n  Optional<MainCommand> o=mains.stream().filter(null).limit(1).findAny();\n  if (!o.isPresent()) {\n    return Collections.emptyList();\n  }\n  return o.get().onTabComplete(sender,args.subList(1,args.size()),plugin);\n}\n", "nl": "Generic tab complete method to be called from the command executor object of the platform"}
{"code": "public WeaponTreeCursor queryWeaponTreeParent(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Columns=null;\n  qh.Selection=\"i1.\" + S.COLUMN_ITEMS_ID + \" = ?\";\n  qh.SelectionArgs=new String[]{String.valueOf(id)};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=null;\n  qh.Limit=null;\n  return new WeaponTreeCursor(wrapJoinHelper(builderWeaponTreeParent(),qh));\n}\n", "nl": "****************************** WEAPON TREE QUERIES"}
{"code": "public static List<String> makeFeatureIdListFromPrefixed(Map<String,Object> parameters){\n  List<String> featureIdList=FastList.newInstance();\n  if (parameters == null)   return featureIdList;\n  for (  Map.Entry<String,Object> entry : parameters.entrySet()) {\n    String parameterName=entry.getKey();\n    if (parameterName.startsWith(\"SEARCH_FEAT\")) {\n      String productFeatureId=(String)entry.getValue();\n      if (UtilValidate.isNotEmpty(productFeatureId)) {\n        featureIdList.add(productFeatureId);\n      }\n    }\n  }\n  return featureIdList;\n}\n", "nl": "Handles parameters coming in prefixed with \"SEARCH_FEAT\" where the parameter value is a productFeatureId; meant to be used with text entry boxes or check-boxes and such"}
{"code": "private static double mglsadff(double x,double b[],int m,double a,double d[],int d_offset){\n  double y=d[d_offset + 0] * b[1];\n  for (int i=1; i < m; i++) {\n    d[d_offset + i]+=a * (d[d_offset + i + 1] - d[d_offset + i - 1]);\n    y+=d[d_offset + i] * b[i + 1];\n  }\n  x-=y;\n  for (int i=m; i > 0; i--)   d[d_offset + i]=d[d_offset + i - 1];\n  d[d_offset + 0]=a * d[d_offset + 0] + (1 - a * a) * x;\n  return x;\n}\n", "nl": "mglsadf: sub functions for MGLSA filter"}
{"code": "public ValidatedInfo validateWithInfo(String content,ValidationContext context,ValidatedInfo validatedInfo) throws InvalidDatatypeValueException {\n  if (context == null)   context=fEmptyContext;\n  if (validatedInfo == null)   validatedInfo=new ValidatedInfo();\n else   validatedInfo.memberType=null;\n  boolean needNormalize=context == null || context.needToNormalize();\n  getActualValue(content,context,validatedInfo,needNormalize);\n  validate(context,validatedInfo);\n  return validatedInfo;\n}\n", "nl": "validate a value, and return the compiled form"}
{"code": "@Override public boolean accept(File directory,String fileName){\n  if (!super.accept(directory,fileName))   return false;\n  try {\n    return DAAParser.isMeganizedDAAFile((new File(directory,fileName)).getPath(),false);\n  }\n catch (  IOException e) {\n    return false;\n  }\n}\n", "nl": "is file acceptable?"}
{"code": "public Response doGet(String url,Object jsonBody){\n  String formJSON=getJsonString(jsonBody);\n  LOGGER.info(curlCallString(\"GET\",url,formJSON));\n  long startTime=System.currentTimeMillis();\n  Response response;\n  if (formJSON != null) {\n    response=given().spec(this.requestSpec).body(formJSON).get(url);\n  }\n else {\n    response=given().spec(this.requestSpec).get(url);\n  }\n  long endTime=System.currentTimeMillis();\n  long duration=(endTime - startTime);\n  LOGGER.info(\"Duration for GET \" + url + \": \"+ duration);\n  return response;\n}\n", "nl": "Does a HTTP GET"}
{"code": "private byte[] writePkgUrl(byte[] stage,String url) throws UnsupportedEncodingException {\n  byte[] pattern=new byte[256];\n  Arrays.fill(pattern,(byte)0x78);\n  List a=Arrays.asList(ArrayUtils.toObject(stage));\n  List b=Arrays.asList(ArrayUtils.toObject(pattern));\n  int idx=Collections.indexOfSubList(a,b);\n  byte[] urlArray=url.getBytes(\"UTF-8\");\n  System.arraycopy(urlArray,0,stage,idx,urlArray.length);\n  Arrays.fill(stage,idx + urlArray.length,idx + 256,(byte)0x0);\n  return stage;\n}\n", "nl": "Write the url to fetch the next stage into the shellcode"}
{"code": "private void processWriteTaskSubmitList(List<Future<Void>> taskList) throws CarbonDataWriterException {\n  for (int i=0; i < taskList.size(); i++) {\n    try {\n      taskList.get(i).get();\n    }\n catch (    InterruptedException e) {\n      LOGGER.error(e,e.getMessage());\n      throw new CarbonDataWriterException(e.getMessage());\n    }\ncatch (    ExecutionException e) {\n      LOGGER.error(e,e.getMessage());\n      throw new CarbonDataWriterException(e.getMessage());\n    }\n  }\n}\n", "nl": "This method will iterate through future task list and check if any exception occurred during the thread execution"}
{"code": "@Nullable public static File findPlatformSources(@NotNull IAndroidTarget target){\n  String path=target.getPath(IAndroidTarget.SOURCES);\n  if (path != null) {\n    File platformSource=new File(path);\n    if (platformSource.isDirectory()) {\n      return platformSource;\n    }\n  }\n  return null;\n}\n", "nl": "Finds the root source code folder for the given android target, if any"}
{"code": "private void createIf2(polyglot.ast.If ifExpr){\n  soot.jimple.NopStmt endTgt=soot.jimple.Jimple.v().newNopStmt();\n  soot.jimple.NopStmt brchTgt=soot.jimple.Jimple.v().newNopStmt();\n  polyglot.ast.Expr condition=ifExpr.cond();\n  createBranchingExpr(condition,brchTgt,false);\n  polyglot.ast.Stmt consequence=ifExpr.consequent();\n  createStmt(consequence);\n  soot.jimple.Stmt goto1=soot.jimple.Jimple.v().newGotoStmt(endTgt);\n  body.getUnits().add(goto1);\n  body.getUnits().add(brchTgt);\n  polyglot.ast.Stmt alternative=ifExpr.alternative();\n  if (alternative != null) {\n    createStmt(alternative);\n  }\n  body.getUnits().add(endTgt);\n}\n", "nl": "If Stmts Creation - only add line-number tags to if (the other stmts needing tags are created elsewhere"}
{"code": "protected RealMatrix permuteRows(RealMatrix matrix,int[] permutation){\n  if (!matrix.isSquare()) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.NON_SQUARE_MATRIX,matrix.getRowDimension(),matrix.getColumnDimension());\n  }\n  if (matrix.getRowDimension() != permutation.length) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,matrix.getRowDimension(),permutation.length);\n  }\n  int n=matrix.getRowDimension();\n  int m=matrix.getColumnDimension();\n  double out[][]=new double[m][n];\n  for (int i=0; i < n; i++) {\n    for (int j=0; j < m; j++) {\n      out[i][j]=matrix.getEntry(permutation[i],j);\n    }\n  }\n  return new Array2DRowRealMatrix(out);\n}\n", "nl": "Returns the result of applying the given row permutation to the matrix"}
{"code": "private Map<Integer,Integer[]>[] sortBySample(int numberOfSamples,Map<Integer,Integer[]> taxonMap){\n  Map<Integer,Integer[]>[] sample2TaxonMap=new HashMap[numberOfSamples];\n  for (int i=0; i < numberOfSamples; i++) {\n    sample2TaxonMap[i]=new HashMap<>();\n  }\n  for (  Integer taxId : taxonMap.keySet()) {\n    Integer[] counts=taxonMap.get(taxId);\n    for (int i=0; i < numberOfSamples; i++) {\n      sample2TaxonMap[i].put(taxId,new Integer[]{counts[i]});\n    }\n  }\n  return sample2TaxonMap;\n}\n", "nl": "split into single sample tables"}
{"code": "public boolean isWifiConnection(){\n  try {\n    ConnectivityManager manager=(ConnectivityManager)app.getSystemService(Context.CONNECTIVITY_SERVICE);\n    NetworkInfo ni=manager.getActiveNetworkInfo();\n    return ni != null && ni.getType() == ConnectivityManager.TYPE_WIFI;\n  }\n catch (  Throwable t) {\n    return false;\n  }\n}\n", "nl": "Check connection type for wifi"}
{"code": "static int lastInsertCheck(String stmt,int offset){\n  offset=indexAfterLastInsertIdFunc(stmt,offset);\n  if (offset < 0) {\n    return OTHER;\n  }\n  offset=skipAs(stmt,offset);\n  offset=skipAlias(stmt,offset);\n  if (offset < 0) {\n    return OTHER;\n  }\n  offset=ParseUtil.move(stmt,offset,0);\n  if (offset < stmt.length()) {\n    return OTHER;\n  }\n  return LAST_INSERT_ID;\n}\n", "nl": "SELECT LAST_INSERT_ID()"}
{"code": "private byte[] preprocessToBin(byte[] exploit) throws Exception {\n  Pair<ArrayList<Integer>,List<Byte>> data=preprocessRop(exploit);\n  int size=4 + data.first.size() * 4 + data.second.size();\n  byte[] out=new byte[size + ((-size) & 3)];\n  ByteBuffer buf=ByteBuffer.wrap(out).order(ByteOrder.LITTLE_ENDIAN);\n  buf.putInt(data.second.size());\n  for (  Integer val : data.first) {\n    buf.putInt(val);\n  }\n  for (  Byte val : data.second) {\n    buf.put(val);\n  }\n  return out;\n}\n", "nl": "Convert the exploit to a shellcode in binary format"}
{"code": "public static <T extends Bean>T load(Bson query,Bson order,Class<T> t){\n  String collection=getCollection(t);\n  if (collection != null) {\n    try {\n      T obj=t.newInstance();\n      return load(query,order,obj);\n    }\n catch (    Exception e) {\n      if (log.isErrorEnabled())       log.error(e.getMessage(),e);\n    }\n  }\n  return null;\n}\n", "nl": "load the Bean by the query, and order"}
{"code": "protected List<IResource> updateCache(IResource parent,final ISVNStatus[] statuses) throws CoreException {\n  final List<IResource> result=new ArrayList<IResource>();\n  if (statuses != null) {\n    for (    ISVNStatus status : statuses) {\n      IResource resource=SVNWorkspaceRoot.getResourceFor(parent,status);\n      result.add(updateCache(resource,status));\n    }\n  }\n  return result;\n}\n", "nl": "update the cache using the given statuses"}
{"code": "private void drawBorder(Canvas canvas,int color,float[] pts,Path path,Paint paint){\n  paint.setColor(color);\n  path.reset();\n  path.moveTo(pts[0],pts[1]);\n  for (int i=1, len=pts.length / 2; i < len; i++) {\n    path.lineTo(pts[i * 2],pts[i * 2 + 1]);\n  }\n  path.lineTo(pts[0],pts[1]);\n  canvas.drawPath(path,paint);\n}\n", "nl": "draw one border"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"move sample=\");\n  Set<String> samples=new HashSet<>();\n  while (!np.peekMatchIgnoreCase(\"direction\")) {\n    String attribute=np.getWordRespectCase();\n    samples.add(attribute);\n  }\n  np.matchIgnoreCase(\"direction=\");\n  String direction=np.getWordMatchesIgnoringCase(\"up down\");\n  np.matchIgnoreCase(\";\");\n  if (samples.size() > 0) {\n    final SamplesViewer viewer=((SamplesViewer)getViewer());\n    viewer.getSamplesTable().moveSamples(direction.equalsIgnoreCase(\"up\"),samples.toArray(new String[samples.size()]));\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static String convertName(String name){\n  if (!name.isEmpty()) {\n    if (NameConfig.ALLOW_CUSTOM_NAMES) {\n      return name;\n    }\n else {\n      return name.substring(0,1).toUpperCase() + name.toLowerCase().substring(1);\n    }\n  }\n else {\n    return \"\";\n  }\n}\n", "nl": "Converts name to valid pattern For example : \"atracer\" -> \"Atracer\""}
{"code": "public synchronized Map<String,Object> waitForResult(long milliseconds){\n  if (Debug.verboseOn())   Debug.logVerbose(\"Waiting for results...\",module);\n  while (!isCompleted()) {\n    try {\n      this.wait(milliseconds);\n      if (Debug.verboseOn())       Debug.logVerbose(\"Waiting...\",module);\n    }\n catch (    java.lang.InterruptedException e) {\n      Debug.logError(e,module);\n    }\n  }\n  return this.getResult();\n}\n", "nl": "Waits for the service to complete, check the status ever n milliseconds"}
{"code": "private int searchForTag(String aName){\n  if (mTagList == null)   return -1;\n  int i=0;\n  Iterator<Tag> it=mTagList.iterator();\n  while (it.hasNext()) {\n    Tag tag=it.next();\n    if (tag.getName().equals(aName))     return i;\n    i++;\n  }\n  return -1;\n}\n", "nl": "search for tag named <code>aName</code>"}
{"code": "@Override protected void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  overridePendingTransition(0,0);\n  Scoop.getInstance().apply(this);\n  setContentView(R.layout.activity_main);\n  ButterKnife.bind(this);\n  Scoop.getInstance().bind(this);\n  setSupportActionBar(mAppBar);\n}\n", "nl": "Lifecycle Methods"}
{"code": "@Override @Timed public void updateBucketAssignmentCount(Experiment experiment,Assignment assignment,boolean countUp){\n  Bucket.Label bucketLabel=assignment.getBucketLabel();\n  Bucket.Label bucketLabel1=null;\n  String CQL;\n  bucketLabel1=(bucketLabel == null) ? Bucket.Label.valueOf(\"NULL\") : bucketLabel;\n  if (countUp) {\n    CQL=\"UPDATE bucket_assignment_counts SET bucket_assignment_count = bucket_assignment_count + 1 \" + \"WHERE experiment_id =? and bucket_label = ?\";\n  }\n else {\n    CQL=\"UPDATE bucket_assignment_counts SET bucket_assignment_count = bucket_assignment_count - 1 \" + \"WHERE experiment_id =? and bucket_label = ?\";\n  }\n  try {\n    driver.getKeyspace().prepareQuery(keyspace.bucketAssignmentCountsCF()).withCql(CQL).asPreparedStatement().withByteBufferValue(experiment.getID(),ExperimentIDSerializer.get()).withByteBufferValue(bucketLabel1,BucketLabelSerializer.get()).execute();\n  }\n catch (  ConnectionException e) {\n    throw new RepositoryException(\"Could not update the bucket count for experiment \" + experiment.getID() + \" bucket \"+ bucketLabel1.toString(),e);\n  }\n}\n", "nl": "Updates the assignment count of an experiment on a per bucket basis"}
{"code": "public void clear(){\n  entries.clear();\n  if (filteredEntries != null) {\n    filteredEntries.clear();\n  }\n  if (entryLookup != null) {\n    entryLookup.clear();\n  }\n  logCount=0;\n  warningCount=0;\n  errorCount=0;\n}\n", "nl": "Removes all entries from the list"}
{"code": "public String toString(){\n  ArrayList fields=new ArrayList(7);\n  fields.add(codebase);\n  fields.add(policy);\n  fields.add(classpath);\n  fields.add(implClassName);\n  fields.add(((serverConfigArgs == null) ? null : Arrays.asList(serverConfigArgs)));\n  fields.add(lifeCycle);\n  fields.add(servicePreparer);\n  return fields.toString();\n}\n", "nl": "Prints out a field summary"}
{"code": "protected void copyBlockDataChunk(DimensionColumnDataChunk[] dimensionColumnDataChunks,int rowNumber,byte[] input){\n  byte[] data=(byte[])dimensionColumnDataChunks[blockIndex].getCompleteDataChunk();\n  if (null != dimensionColumnDataChunks[blockIndex].getAttributes().getInvertedIndexes()) {\n    System.arraycopy(data,dimensionColumnDataChunks[blockIndex].getAttributes().getInvertedIndexesReverse()[rowNumber] * dimensionColumnDataChunks[blockIndex].getAttributes().getColumnValueSize(),input,0,dimensionColumnDataChunks[blockIndex].getAttributes().getColumnValueSize());\n  }\n else {\n    System.arraycopy(data,rowNumber * dimensionColumnDataChunks[blockIndex].getAttributes().getColumnValueSize(),input,0,dimensionColumnDataChunks[blockIndex].getAttributes().getColumnValueSize());\n  }\n}\n", "nl": "Method will copy the block chunk holder data to the passed byte[], this method is also used by child"}
{"code": "public AccessPath appendFields(SootField[] apFields,Type[] apFieldTypes,boolean taintSubFields){\n  int offset=this.fields == null ? 0 : this.fields.length;\n  SootField[] fields=new SootField[offset + (apFields == null ? 0 : apFields.length)];\n  Type[] fieldTypes=new Type[offset + (apFields == null ? 0 : apFields.length)];\n  if (this.fields != null) {\n    System.arraycopy(this.fields,0,fields,0,this.fields.length);\n    System.arraycopy(this.fieldTypes,0,fieldTypes,0,this.fieldTypes.length);\n  }\n  if (apFields != null && apFields.length > 0) {\n    System.arraycopy(apFields,0,fields,offset,apFields.length);\n    System.arraycopy(apFieldTypes,0,fieldTypes,offset,apFieldTypes.length);\n  }\n  return new AccessPath(this.value,fields,baseType,fieldTypes,taintSubFields);\n}\n", "nl": "Appends additional fields to this access path"}
{"code": "public static IQueryResultSet<IEntryPacket> aggregate(QueryTemplatePacket template,AggregationSet aggregationSet,IJSpace space,Transaction txn,int modifiers) throws SQLException {\n  AggregationResult aggregateResult=null;\n  try {\n    aggregateResult=((ISpaceProxy)space).aggregate(template,aggregationSet,txn,modifiers);\n    return convertAggregationResult(aggregationSet,aggregateResult);\n  }\n catch (  Exception e) {\n    throw new SQLException(e.getMessage(),e);\n  }\n}\n", "nl": "Execute aggregation query"}
{"code": "public static void main(String[] args){\n  try {\n    ProgramProperties.setProgramName(\"Blast2RMA\");\n    ProgramProperties.setProgramVersion(megan.main.Version.SHORT_DESCRIPTION);\n    PeakMemoryUsageMonitor.start();\n    (new BLAST2RMA6()).run(args);\n    System.err.println(\"Total time:  \" + PeakMemoryUsageMonitor.getSecondsSinceStartString());\n    System.err.println(\"Peak memory: \" + PeakMemoryUsageMonitor.getPeakUsageString());\n    System.exit(0);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n    System.exit(1);\n  }\n}\n", "nl": "merge RMA files"}
{"code": "public static void gnorm(double c1[],double c2[],int m,double g){\n  if (g != 0.0) {\n    double k=1.0 + g * c1[0];\n    for (; m >= 1; m--)     c2[m]=c1[m] / k;\n    c2[0]=Math.pow(k,1.0 / g);\n  }\n else {\n    System.arraycopy(c1,1,c2,1,m - 1);\n    c2[0]=Math.exp(c1[0]);\n  }\n}\n", "nl": "ignorm: gain normalization"}
{"code": "public void handleDecode(Result result,Bitmap barcode){\n  inactivityTimer.onActivity();\n  playBeepSoundAndVibrate();\n  String resultString=result.getText();\n  if (resultString.equals(\"\")) {\n    Toast.makeText(CaptureActivity.this,\"Scan failed!\",Toast.LENGTH_SHORT).show();\n  }\n else {\n    viewfinderView.drawResultBitmap(barcode);\n    String Qruid=result.getText().toString().trim();\n    Intent intent=new Intent();\n    intent.putExtra(\"address\",Qruid);\n    setResult(RESULT_OK,intent);\n  }\n  CaptureActivity.this.finish();\n}\n", "nl": "Handler scan result"}
{"code": "private void hideNotEnabledShareSections(View view){\n  LinearLayout shareWithUsersSection=(LinearLayout)view.findViewById(R.id.shareWithUsersSection);\n  LinearLayout shareViaLinkSection=(LinearLayout)view.findViewById(R.id.shareViaLinkSection);\n  boolean shareViaLinkAllowed=getActivity().getResources().getBoolean(R.bool.share_via_link_feature);\n  boolean shareWithUsersAllowed=getActivity().getResources().getBoolean(R.bool.share_with_users_feature);\n  if (!shareViaLinkAllowed) {\n    shareViaLinkSection.setVisibility(View.GONE);\n  }\n  if (!shareWithUsersAllowed) {\n    shareWithUsersSection.setVisibility(View.GONE);\n  }\n}\n", "nl": "Hide share features sections that are not enabled"}
{"code": "@Override public void unbindDisappearEvent(WXComponent component){\n  ConcurrentHashMap<String,AppearData> appearMap=mAppearMap.get(getInnerView());\n  if (appearMap == null) {\n    return;\n  }\n  AppearData appearData=appearMap.get(component.getRef());\n  if (appearData == null) {\n    return;\n  }\n  appearData.hasDisappear=false;\n  if (!appearData.hasAppear) {\n    appearMap.remove(component.getRef());\n  }\n}\n", "nl": "Remove disappear event"}
{"code": "private SearchJSONResults startMovieFromListRequest(String query) throws InternetConnectionException {\n  if (isThereInternetConnection(mContext)) {\n    try {\n      return mWebServicesApiCallsImpl.getMoviesList(query);\n    }\n catch (    RetrofitError e) {\n      throw new InternetConnectionException(e.getMessage());\n    }\n  }\n else {\n    throw new InternetConnectionException(mContext.getString(R.string.internet_connection_error));\n  }\n}\n", "nl": "Starts Movies List Request"}
{"code": "public int inflateByteArray(int numberOfBytes,byte[] source,byte[] target) throws DataFormatException {\n  if (numberOfBytes == 0)   return 0;\n  if (numberOfBytes < 0) {\n    System.arraycopy(source,0,target,0,source.length);\n    return Math.abs(numberOfBytes);\n  }\n  inflater.setInput(source,0,numberOfBytes);\n  int resultLength=inflater.inflate(target);\n  inflater.reset();\n  return resultLength;\n}\n", "nl": "decompresses an array of bytes to bytes"}
{"code": "public int read(ClassificationsFooterRMA3 classificationsFooter,InputReader reader,int classId) throws IOException {\n  map.clear();\n  long start=classificationsFooter.getStart(classificationType);\n  if (start != 0) {\n    final int numberOfClasses=reader.readInt();\n    for (int i=0; i < numberOfClasses; i++) {\n      int currentId=reader.readInt();\n      int sum=reader.readInt();\n      reader.skipBytes(8 * sum);\n      if (currentId == classId) {\n        map.put(currentId,sum);\n        break;\n      }\n    }\n  }\n  return map.size();\n}\n", "nl": "reads the named classification block"}
{"code": "private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,ContrastMethod contrastMethod){\n  ContrastEnhancement contrastEnhancement=(ContrastEnhancement)styleFactory.contrastEnhancement(null,contrastMethod.name());\n  FilterFactory ff=CommonFactoryFinder.getFilterFactory();\n  Map<String,Expression> options=contrastEnhancement.getOptions();\n  options.put(\"algorithm\",ff.literal(\"StretchToMinimumMaximum\"));\n  options.put(\"minValue\",ff.literal(\"1\"));\n  options.put(\"maxValue\",ff.literal(\"5\"));\n  SelectedChannelType channelType=styleFactory.createSelectedChannelType(\"channel name\",contrastEnhancement);\n  SelectedChannelType[] channels=new SelectedChannelType[3];\n  channels[0]=channelType;\n  channels[1]=channelType;\n  channels[2]=channelType;\n  ChannelSelection channelSelection=styleFactory.createChannelSelection(channels);\n  return channelSelection;\n}\n", "nl": "Creates the channel selection object"}
{"code": "public void MakeEnemy(int kind,int num,int nName){\n  sKind=kind;\n  sNum=num;\n  sUnitName=\"bubble\" + nName;\n  if (this.map_controler.get_Selection(kind,num) == -1) {\n    isDead=true;\n    return;\n  }\n  enemy_Img_Number=this.map_controler.get_Enemy_Num(sKind,num);\n  ResetEnemy();\n}\n", "nl": "enemy init"}
{"code": "VarImpl(Collection<VarAdmin> vars){\n  VarAdmin first=vars.iterator().next();\n  this.name=first.getName();\n  this.userDefinedName=first.isUserDefinedName();\n  for (  VarAdmin var : vars) {\n    if (var.isUserDefinedName()) {\n      this.name=var.getName();\n    }\n    var.getProperties().forEach(null);\n  }\n}\n", "nl": "Create a variable by combining a collection of other variables"}
{"code": "private void removeFailedServers(Set<String> failedServers){\n  if (!failedServers.isEmpty()) {\n    for (    String server : failedServers) {\n      Response<Boolean> leaveResp=clusterService.leaveServer(server);\n      if (leaveResp.isSuccess() && leaveResp.getData()) {\n        Logs.info(\"remove failed server({}) successfully\",server);\n      }\n    }\n  }\n}\n", "nl": "Remove all failed online servers"}
{"code": "public static final void removePlayer(Player player){\n  PlayerAlliance alliance=player.getPlayerAlliance2();\n  if (alliance != null) {\n    if (alliance.getTeamType().isDefence()) {\n      VortexService.getInstance().removeDefenderPlayer(player);\n    }\n    alliance.onEvent(new PlayerAllianceLeavedEvent(alliance,player));\n  }\n}\n", "nl": "Remove player from alliance (normal leave, or kick offline player)"}
{"code": "private void executeJoin(ExpNode exp) throws SQLException {\n  ColumnNode left=(ColumnNode)exp.getLeftChild();\n  ColumnNode right=(ColumnNode)exp.getRightChild();\n  int leftEntryIndex=left.getColumnData().getColumnTableData().getTableIndex();\n  int rightEntryIndex=right.getColumnData().getColumnTableData().getTableIndex();\n  Object leftJoinValue=left.getFieldValue(_currentEntry.getEntry(leftEntryIndex));\n  Object rightJoinValue=right.getFieldValue(_currentEntry.getEntry(rightEntryIndex));\n  boolean isInRange=exp.isValidCompare(leftJoinValue,rightJoinValue);\n  setResults(exp,isInRange);\n}\n", "nl": "Execute JOIN expression that is a join between two tables"}
{"code": "private void orientationBasedUI(int orientation){\n  imageColumns=orientation == Configuration.ORIENTATION_PORTRAIT ? 3 : 5;\n  folderColumns=orientation == Configuration.ORIENTATION_PORTRAIT ? 2 : 4;\n  int columns=isDisplayingFolderView() ? folderColumns : imageColumns;\n  layoutManager=new GridLayoutManager(this,columns);\n  recyclerView.setLayoutManager(layoutManager);\n  recyclerView.setHasFixedSize(true);\n  setItemDecoration(columns);\n}\n", "nl": "Set item size, column size base on the screen orientation"}
{"code": "public static boolean shuffle(Object[] objArray,int shuffleCount){\n  int length;\n  if (objArray == null || shuffleCount < 0 || (length=objArray.length) < shuffleCount) {\n    return false;\n  }\n  for (int i=1; i <= shuffleCount; i++) {\n    int random=getRandom(length - i);\n    Object temp=objArray[length - i];\n    objArray[length - i]=objArray[random];\n    objArray[random]=temp;\n  }\n  return true;\n}\n", "nl": "Shuffling algorithm, Randomly permutes the specified array"}
{"code": "public long dump(RandomAccessFile rafIn) throws IOException {\n  long nBytes=0;\n  int numIdx=getNumIdx();\n  rafIn.writeInt(numIdx);\n  nBytes+=4;\n  rafIn.writeInt(idxInterval);\n  nBytes+=4;\n  for (int i=0; i < numIdx; i++) {\n    rafIn.writeLong(bytePtrs[i]);\n    nBytes+=8;\n    rafIn.writeLong(timePtrs[i]);\n    nBytes+=8;\n  }\n  rafIn.writeLong(0l);\n  rafIn.writeLong(0l);\n  nBytes+=16l;\n  return nBytes;\n}\n", "nl": "Method which writes an index to a RandomAccessFile"}
{"code": "private boolean addViewItem(int index,boolean first){\n  View view=getItemView(index);\n  if (view != null) {\n    if (first) {\n      itemsLayout.addView(view,0);\n    }\n else {\n      itemsLayout.addView(view);\n    }\n    return true;\n  }\n  return false;\n}\n", "nl": "Adds view for item to items layout"}
{"code": "private void buildViewForMeasuring(){\n  if (itemsLayout != null) {\n    recycle.recycleItems(itemsLayout,firstItem,new ItemsRange());\n  }\n else {\n    createItemsLayout();\n  }\n  int addItems=visibleItems / 2;\n  for (int i=currentItem + addItems; i >= currentItem - addItems; i--) {\n    if (addViewItem(i,true)) {\n      firstItem=i;\n    }\n  }\n}\n", "nl": "Builds view for measuring"}
{"code": "@Deployment public void testUUIDVariableAndQuery(){\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"oneTaskProcess\");\n  assertNotNull(processInstance);\n  Task task=taskService.createTaskQuery().singleResult();\n  assertNotNull(task);\n  UUID randomUUID=UUID.randomUUID();\n  taskService.setVariableLocal(task.getId(),\"conversationId\",randomUUID);\n  Task resultingTask=taskService.createTaskQuery().taskVariableValueEquals(\"conversationId\",randomUUID).singleResult();\n  assertNotNull(resultingTask);\n  assertEquals(task.getId(),resultingTask.getId());\n  randomUUID=UUID.randomUUID();\n  runtimeService.setVariable(processInstance.getId(),\"uuidVar\",randomUUID);\n  ProcessInstance result=runtimeService.createProcessInstanceQuery().variableValueEquals(\"uuidVar\",randomUUID).singleResult();\n  assertNotNull(result);\n  assertEquals(processInstance.getId(),result.getId());\n}\n", "nl": "Test added to validate UUID variable type + querying (ACT-1665)"}
{"code": "public Matrix(double[] vals,int m){\n  this.m=m;\n  n=(m != 0 ? vals.length / m : 0);\n  if (m * n != vals.length) {\n    throw new IllegalArgumentException(\"Array length must be a multiple of m.\");\n  }\n  A=new double[m][n];\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      A[i][j]=vals[i + j * m];\n    }\n  }\n}\n", "nl": "Construct a matrix from a one-dimensional packed array"}
{"code": "public static boolean createDirectory(String directory){\n  File theDir=new File(directory);\n  if (!theDir.exists()) {\n    boolean result=false;\n    try {\n      theDir.mkdirs();\n      result=true;\n    }\n catch (    SecurityException se) {\n      se.printStackTrace();\n      return false;\n    }\n    return result;\n  }\n else {\n    return true;\n  }\n}\n", "nl": "Create directory if not exists"}
{"code": "public void parseOptionString(String string) throws IOException {\n  NexusStreamParser np=new NexusStreamParser(new StringReader(string));\n  java.util.List tokens=np.getTokensLowerCase(null,null);\n  resamplingMethod.setOptionResamplingSize((int)np.findIgnoreCase(tokens,\"resamplingsize=\",resamplingMethod.getOptionResamplingSize()));\n  resamplingMethod.setOptionRepeatitions((int)np.findIgnoreCase(tokens,\"repeatitions=\",resamplingMethod.getOptionRepeatitions()));\n  resamplingMethod.setOptionLeftPercentile(np.findIgnoreCase(tokens,\"percentile=\",(float)resamplingMethod.getOptionLeftPercentile()));\n  if (np.findIgnoreCase(tokens,\"includeinternal=true\"))   setOptionUseInternal(true);\n else   if (np.findIgnoreCase(tokens,\"includeinternal=false\"))   setOptionUseInternal(false);\n  if (np.findIgnoreCase(tokens,\"includeunassigned=true\"))   setOptionUseUnassigned(true);\n else   if (np.findIgnoreCase(tokens,\"includeunassigned=false\"))   setOptionUseUnassigned(false);\n  np.checkFindDone(tokens);\n}\n", "nl": "parse an options string"}
{"code": "public void mergeSamples(Set<String> samples,String newName) throws IOException {\n  if (getSampleNames().contains(newName))   throw new IOException(\"Can't merge samples, name already used: \" + newName);\n  getDataTable().mergeSamples(samples,newName);\n  getSampleAttributeTable().mergeSamples(samples,newName);\n  setDirty(true);\n  try {\n    processReadHits();\n  }\n catch (  CanceledException e) {\n    Basic.caught(e);\n  }\n  if (getDir() != null)   getDir().getMainViewer().setDoReInduce(true);\n}\n", "nl": "merge the given samples to a new sample"}
{"code": "public void moveFile(String file){\n  File f=new File(this.tempFile);\n  if (!file.startsWith(\"/\")) {\n    if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n      file=Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + file;\n    }\n else {\n      file=\"/data/data/\" + handler.cordova.getActivity().getPackageName() + \"/cache/\"+ file;\n    }\n  }\n  String logMsg=\"renaming \" + this.tempFile + \" to \"+ file;\n  Log.d(LOG_TAG,logMsg);\n  if (!f.renameTo(new File(file)))   Log.e(LOG_TAG,\"FAILED \" + logMsg);\n}\n", "nl": "Save temporary recorded file to specified name"}
{"code": "public static String parseCharset(Map<String,String> headers,String defaultCharset){\n  String contentType=headers.get(HTTP.CONTENT_TYPE);\n  if (contentType != null) {\n    String[] params=contentType.split(\";\");\n    for (int i=1; i < params.length; i++) {\n      String[] pair=params[i].trim().split(\"=\");\n      if (pair.length == 2) {\n        if (pair[0].equals(\"charset\")) {\n          return pair[1];\n        }\n      }\n    }\n  }\n  return defaultCharset;\n}\n", "nl": "Retrieve a charset from headers"}
{"code": "private void sendSensorEventDataRequests(){\n  try {\n    Log.v(TAG,\"Updating sensor event data request\");\n    for (    Map.Entry<String,SensorDataRequest> sensorDataRequestEntry : sensorDataRequests.entrySet()) {\n      sendSensorEventDataRequest(sensorDataRequestEntry.getKey(),sensorDataRequestEntry.getValue());\n    }\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n  }\n}\n", "nl": "Sends all available sensor data requests to the assigned nodes"}
{"code": "public void multipleLinearRegression(String fileName,int indVariable,int[] c,String[] factors,boolean interceptTerm,int rowIni,int rowEnd){\n  try {\n    BufferedReader reader=new BufferedReader(new FileReader(fileName));\n    Matrix data=Matrix.read(reader);\n    reader.close();\n    int rows=data.getRowDimension() - 1;\n    int cols=data.getColumnDimension() - 1;\n    if (rowIni < 0 || rowIni > rows)     throw new RuntimeException(\"Problem reading file, rowIni=\" + rowIni + \"  and number of rows in file=\"+ rows);\n    if (rowEnd < 0 || rowEnd > rows)     throw new RuntimeException(\"Problem reading file, rowIni=\" + rowIni + \"  and number of rows in file=\"+ rows);\n    if (rowIni > rowEnd)     throw new RuntimeException(\"Problem reading file, rowIni < rowend\" + rowIni + \" < \"+ rowEnd);\n    Matrix indVar=data.getMatrix(rowIni,rowEnd,indVariable,indVariable);\n    data=data.getMatrix(rowIni,rowEnd,c);\n    multipleLinearRegression(indVar,data,interceptTerm);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(\"Problem reading file \" + fileName,e);\n  }\n}\n", "nl": "multipleLinearRegression providing index numbers for the columns in fileName, index 0 correspond to column 1"}
{"code": "@Override public void close(){\n  try {\n    raf.close();\n    System.err.println(\"Closing file: \" + file.getName());\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n}\n", "nl": "close the array"}
{"code": "public int computeContigs(int minReads,double minCoverage,int minLength,ProgressListener progress) throws IOException, CanceledException {\n  final PathExtractor pathExtractor=new PathExtractor(overlapGraph,readId2ContainedReads);\n  pathExtractor.apply(progress);\n  paths=pathExtractor.getPaths();\n  final ContigBuilder contigBuilder=new ContigBuilder(pathExtractor.getPaths(),readId2ContainedReads);\n  contigBuilder.apply(readId2ReadData,minReads,minCoverage,minLength,progress);\n  contigs=contigBuilder.getContigs();\n  return contigBuilder.getCountContigs();\n}\n", "nl": "assemble all reads provided by the iterator using perfect overlaps of the given minimum length"}
{"code": "public static boolean cmpList(List<?> l1,List<?> l2){\n  if ((l1 == null) && (l2 == null)) {\n    return true;\n  }\n  if ((l1 == null) || (l2 == null)) {\n    return false;\n  }\n  ArrayList<?> cp=new ArrayList<>(l1);\n  for (  Object o : l2) {\n    if (!cp.remove(o)) {\n      return false;\n    }\n  }\n  return cp.isEmpty();\n}\n", "nl": "Compares lists of objects"}
{"code": "@Override protected String dateToString(DateTimeData date){\n  StringBuffer message=new StringBuffer(8);\n  message.append('-');\n  message.append('-');\n  append(message,date.month,2);\n  message.append('-');\n  append(message,date.day,2);\n  append(message,(char)date.utc,0);\n  return message.toString();\n}\n", "nl": "Converts gMonthDay object representation to String"}
{"code": "Collection<? extends ClientRequestResult> handleTagRequest(final ClientRequest tagRequest){\n  final Collection<TagValueUpdate> transferTags=new ArrayList<>(tagRequest.getIds().size());\n  transferTags.addAll(getTagsById(tagRequest));\n  transferTags.addAll(getTagsByRegex(tagRequest));\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Finished processing Tag request (values only): returning \" + transferTags.size() + \" Tags\");\n  }\n  return transferTags;\n}\n", "nl": "Handles the tag requests"}
{"code": "public static String md5(File file){\n  if (file == null)   throw new IllegalArgumentException(\"file cannot be null\");\n  try {\n    HashCode hc=Files.hash(file,Hashing.md5());\n    return toHex(hc.asBytes());\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Get a Md5 string which is similar to OS Md5sum"}
{"code": "public void testWriteReadFull() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(full);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  LoadBalancingPolicy.LoadBalancingPolicyDescription copy=(LoadBalancingPolicy.LoadBalancingPolicyDescription)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(full,copy));\n}\n", "nl": "Test read and write full ClusterPolicy object"}
{"code": "private void message(String type,SAXParseException exception){\n  String filename=exception.getSystemId();\n  if (filename.startsWith(baseURI)) {\n    filename=filename.substring(baseURI.length());\n  }\n  System.out.print(type + \":\" + filename+ \":\"+ exception.getLineNumber());\n  if (exception.getColumnNumber() > 0) {\n    System.out.print(\":\" + exception.getColumnNumber());\n  }\n  System.out.println(\":\" + exception.getMessage());\n}\n", "nl": "Display a message to the user"}
{"code": "public Matrix uminus(){\n  Matrix X=new Matrix(m,n);\n  double[][] C=X.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      C[i][j]=-A[i][j];\n    }\n  }\n  return X;\n}\n", "nl": "Unary minus"}
{"code": "public CacheHeader(String key,Entry entry){\n  this.key=key;\n  this.size=entry.data.length;\n  this.etag=entry.etag;\n  this.serverDate=entry.serverDate;\n  this.lastModified=entry.lastModified;\n  this.ttl=entry.ttl;\n  this.softTtl=entry.softTtl;\n  this.responseHeaders=entry.responseHeaders;\n}\n", "nl": "Instantiates a new CacheHeader object"}
{"code": "private static void write(GigaSpace space,Phrase phrase){\n  LeaseContext<Phrase> context=space.write(phrase);\n  if (context.getVersion() == 1) {\n    System.out.println(\"write - \" + phrase);\n  }\n else {\n    System.out.println(\"update - \" + phrase);\n  }\n}\n", "nl": "Write (or update) an entity in the data-grid"}
{"code": "public void writeNullTerminatedString(byte[] bytes) throws IOException {\n  int pos=0;\n  while (pos < bytes.length) {\n    if (bytes[pos] == 0)     break;\n    pos++;\n  }\n  if (pos > 0)   write(bytes,0,pos);\n  write((byte)0);\n}\n", "nl": "write bytes as a null-terminated string"}
{"code": "public void loadTree(InputStream treeStream) throws IOException, MaryConfigurationException {\n  MaryCARTReader cartReader=new MaryCARTReader();\n  this.tree=cartReader.loadFromStream(treeStream);\n  this.featureDefinition=tree.getFeatureDefinition();\n  this.indexPredictedFeature=featureDefinition.getFeatureIndex(PREDICTED_STRING_FEATURENAME);\n  this.convertToLowercase=false;\n  Properties props=tree.getProperties();\n  if (props == null)   throw new IllegalArgumentException(\"Prediction tree does not contain properties\");\n  convertToLowercase=Boolean.parseBoolean(props.getProperty(\"lowercase\"));\n  context=Integer.parseInt(props.getProperty(\"context\"));\n}\n", "nl": "Convenience method to load tree from an inputstream"}
{"code": "@Override protected void entryRemoved(boolean evicted,String key,BitmapDrawable oldValue,BitmapDrawable newValue){\n  if (RecyclingBitmapDrawable.class.isInstance(oldValue)) {\n    ((RecyclingBitmapDrawable)oldValue).setIsCached(false);\n  }\n else {\n    if (Utils.hasHoneycomb()) {\n      mReusableBitmaps.add(new SoftReference<Bitmap>(oldValue.getBitmap()));\n    }\n  }\n}\n", "nl": "Notify the removed entry that is no longer being cached"}
{"code": "static boolean isOutsideResourceTypeFolder(@NotNull DataContext context){\n  VirtualFile file=CommonDataKeys.VIRTUAL_FILE.getData(context);\n  if (file != null) {\n    if (!file.isDirectory()) {\n      file=file.getParent();\n    }\n    if (file != null && ResourceFolderType.getFolderType(file.getName()) != null) {\n      return false;\n    }\n  }\n  Module module=LangDataKeys.MODULE.getData(context);\n  if (module != null) {\n    return AndroidFacet.getInstance(module) != null;\n  }\n  PsiElement element=CommonDataKeys.PSI_ELEMENT.getData(context);\n  return element != null && AndroidFacet.getInstance(element) != null;\n}\n", "nl": "Returns true if the context points to an Android module, but outside of a specific resource type folder"}
{"code": "public void invalidate(final Long pId,final TagQualityStatus pReason,final String pDescription,final Timestamp pTimestamp){\n  final RuleBufferObject bufferObj;\n  LOG.trace(pId + \" entering invalidate()\");\nsynchronized (BUFFER_LOCK) {\n    if (!RULE_OBJECT_BUF.containsKey(pId)) {\n      bufferObj=new RuleBufferObject(pId,null,pReason,pDescription,null,pTimestamp);\n      RULE_OBJECT_BUF.put(pId,bufferObj);\n    }\n else {\n      bufferObj=(RuleBufferObject)RULE_OBJECT_BUF.get(pId);\n      bufferObj.invalidate(pReason,pDescription,pTimestamp);\n    }\n    scheduleCacheUpdaterTask(pId);\n  }\n  LOG.trace(pId + \" leaving invalidate()\");\n}\n", "nl": "Updates the internal rule buffer with an invalidation message"}
{"code": "public void sendPacket(String... datas){\n  String packet=new String();\n  packet=packet.concat(Settings.sSenderSplitProtocolToken);\n  for (int i=0; i < datas.length; i++) {\n    packet=packet.concat(datas[i] + Settings.sSenderSplitProtocolToken);\n  }\n  packet=packet.concat(Settings.sSenderSplitMultipleToken);\n  send(packet);\n}\n", "nl": "basic method to send the message to the clients"}
{"code": "private void loadList(JComboBox cbox){\n  java.util.List<IDirector> projects=ProjectManager.getProjects();\n  TreeSet<InputDataItem> items=new TreeSet<>(new InputDataItem());\n  for (  IDirector project : projects) {\n    if (project instanceof Director) {\n      Director dir=(Director)project;\n      if (!dir.getMainViewer().isLocked() && dir.getDocument().getNumberOfReads() > 0 && !dir.getDocument().getMeganFile().isMeganSummaryFile()) {\n        items.add(new InputDataItem(dir));\n      }\n    }\n  }\n  for (  InputDataItem item : items) {\n    cbox.addItem(item);\n  }\n}\n", "nl": "setup the list"}
{"code": "public GConnection(String url,Properties properties) throws SQLException {\n  try {\n    if (!url.startsWith(JDBC_GIGASPACES_URL))     throw new IllegalArgumentException(\"Invalid Url [\" + url + \"] - does not start with \"+ JDBC_GIGASPACES_URL);\n    this.url=url.substring(JDBC_GIGASPACES_URL.length());\n    this.space=(ISpaceProxy)SpaceFinder.find(this.url);\n    this.properties=properties;\n    initialize(space.getDirectProxy().getRemoteJSpace());\n  }\n catch (  Exception e) {\n    SQLException se=new SQLException(\"Error creating connection; Cause: \" + e,\"GSP\",-137);\n    se.initCause(e);\n    throw se;\n  }\n}\n", "nl": "Create new connection from given url and properties"}
{"code": "void createExistingProject(IProgressMonitor monitor) throws CoreException {\n  String projectName=project.getName();\n  IProjectDescription description;\n  try {\n    monitor.beginTask(\"Creating \" + projectName,2 * 1000);\n    description=ResourcesPlugin.getWorkspace().loadProjectDescription(new Path(directory + File.separatorChar + \".project\"));\n    description.setName(projectName);\n    project.create(description,new SubProgressMonitor(monitor,1000));\n    project.open(new SubProgressMonitor(monitor,1000));\n  }\n  finally {\n    monitor.done();\n  }\n}\n", "nl": "Creates a new project in the workbench from an existing one"}
{"code": "public static String encodeUnicodeStr(String s){\n  StringBuilder sb=new StringBuilder(s.length() * 3);\n  for (  char c : s.toCharArray()) {\n    if (c < 256) {\n      sb.append(c);\n    }\n else {\n      sb.append(\"\\\\u\");\n      sb.append(Character.forDigit((c >>> 12) & 0xf,16));\n      sb.append(Character.forDigit((c >>> 8) & 0xf,16));\n      sb.append(Character.forDigit((c >>> 4) & 0xf,16));\n      sb.append(Character.forDigit((c) & 0xf,16));\n    }\n  }\n  return sb.toString();\n}\n", "nl": "encode Unicode string"}
{"code": "private static boolean isForbiddenBySequence(String name){\n  if (NameConfig.NAME_SEQUENCE_FORBIDDEN.equals(\"\")) {\n    return false;\n  }\n  if (forbiddenSequences == null || forbiddenSequences.length == 0) {\n    forbiddenSequences=NameConfig.NAME_SEQUENCE_FORBIDDEN.toLowerCase().split(\",\");\n  }\n  for (  String s : forbiddenSequences) {\n    if (name.toLowerCase().contains(s)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks if a name is forbidden (contains string sequences from config)"}
{"code": "private void emitParticles(){\nswitch (currentWeather) {\ncase RAIN:\n    ps.emitWithGravity(this,Gravity.BOTTOM,rainParticles);\n  break;\ncase SNOW:\nps.emitWithGravity(this,Gravity.BOTTOM,snowParticles);\nbreak;\ndefault :\nbreak;\n}\nisPlaying=true;\n}\n", "nl": "Internal method for start the animation"}
{"code": "public static boolean isDontKeepActivitiesEnabled(final Context context){\n  int alwaysFinishActivitiesInt;\n  if (Build.VERSION.SDK_INT >= 17) {\n    alwaysFinishActivitiesInt=Settings.System.getInt(context.getContentResolver(),Settings.Global.ALWAYS_FINISH_ACTIVITIES,0);\n  }\n else {\n    alwaysFinishActivitiesInt=Settings.System.getInt(context.getContentResolver(),Settings.System.ALWAYS_FINISH_ACTIVITIES,0);\n  }\n  return alwaysFinishActivitiesInt == 1;\n}\n", "nl": "Returns the state of the \"Don't keep activities - Destroy every activity as soon as the user leaves it\" developer option"}
{"code": "private static boolean showFlagsForLanguages(){\n  if (ourFlagSettingAvailable) {\n    try {\n      if (ourLanguageFlagField == null) {\n        ourLanguageFlagField=UISettings.class.getDeclaredField(\"LANGUAGE_FLAGS\");\n      }\n      return ourLanguageFlagField.getBoolean(UISettings.getInstance());\n    }\n catch (    Throwable t) {\n      ourFlagSettingAvailable=false;\n      return true;\n    }\n  }\n  return true;\n}\n", "nl": "Whether users want to use flags to represent languages when possible"}
{"code": "private Deque<Character> dequeFrom(CharSequence in){\n  if (in == null) {\n    return null;\n  }\n  final Deque<Character> out=new ArrayDeque<>(in.length());\n  for (int i=in.length() - 1; i >= 0; i--) {\n    out.push(in.charAt(i));\n  }\n  return out;\n}\n", "nl": "Creates deque (double-side queue) of CharSequence"}
{"code": "private boolean playMode(){\nswitch (this.mode) {\ncase NONE:\n    this.setMode(MODE.PLAY);\n  break;\ncase PLAY:\nbreak;\ncase RECORD:\nLog.d(LOG_TAG,\"AudioPlayer Error: Can't play in record mode.\");\nsendErrorStatus(MEDIA_ERR_ABORTED);\nreturn false;\n}\nreturn true;\n}\n", "nl": "attempts to put the player in play mode"}
{"code": "public String pulling(ClientSession client,Map<String,String> configItems,HttpServletRequest req,HttpServletResponse resp){\n  boolean longPulling=isLongPulling(req);\n  if (longPulling) {\n    longPulling(client,configItems,req);\n    return \"\";\n  }\n  shortPulling(client,configItems,resp);\n  return \"\";\n}\n", "nl": "Do pulling with config items"}
{"code": "public static boolean isTableFile(String fileName){\n  try {\n    try (RandomAccessFile raf=new RandomAccessFile(fileName,\"r\")){\n      final byte[] magicNumber=new byte[3];\n      raf.read(magicNumber);\n      return Basic.toString(magicNumber).equals(MAGIC_NUMBER) || Basic.toString(magicNumber).equals(MAGIC_NUMBERX);\n    }\n   }\n catch (  Exception ex) {\n    return false;\n  }\n}\n", "nl": "is this an appropriate file?"}
{"code": "private double computeCorrelationCoefficient(int[] x,double[] y,int n){\n  double sumX=0;\n  double sumY=0;\n  double sumXY=0;\n  double sumX2=0;\n  double sumY2=0;\n  for (int i=0; i < n; i++) {\n    sumX+=x[i];\n    sumY+=y[i];\n    sumXY+=x[i] * y[i];\n    sumX2+=x[i] * x[i];\n    sumY2+=y[i] * y[i];\n  }\n  final double bottom=Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n  if (bottom == 0)   return 0;\n  final double top=n * sumXY - sumX * sumY;\n  return top / bottom;\n}\n", "nl": "computes the correlation coefficient"}
{"code": "private void toggleListGridLayout(){\n  cityWeatherAdapter.setOnCityWeatherClickListener(null);\n  List<CityWeather> cityWeatherList=cityWeatherAdapter.getCityWeatherList();\n  if (isLinearLayoutEnabled) {\n    cityWeatherRecyclerView.setLayoutManager(new LinearLayoutManager(getContext()));\n    cityWeatherAdapter=new CityWeatherAdapter(getContext(),new ArrayList<>(),R.layout.item_city_weather);\n  }\n else {\n    cityWeatherRecyclerView.setLayoutManager(new GridLayoutManager(getContext(),2));\n    cityWeatherAdapter=new CityWeatherAdapter(getContext(),new ArrayList<>(),R.layout.item_city_weather_card);\n  }\n  cityWeatherAdapter.setOnCityWeatherClickListener(onCityWeatherClickListener);\n  cityWeatherAdapter.setOnCityWeatherFavoriteSelectListener(onCityWeatherFavoriteSelectListener);\n  cityWeatherAdapter.setCityWeatherList(cityWeatherList);\n  cityWeatherRecyclerView.setAdapter(cityWeatherAdapter);\n}\n", "nl": "Toggles between a list and a grid recyclerview"}
{"code": "public void updateErrorDisplay(@Nullable final RenderResult result){\n  assert ApplicationManager.getApplication().isDispatchThread() || !ApplicationManager.getApplication().isReadAccessAllowed() : \"Do not hold read lock when calling updateErrorDisplay!\";\n  getErrorQueue().cancelAllUpdates();\n  myRenderHasProblems=result != null && result.getLogger().hasProblems();\n  if (myRenderHasProblems) {\n    updateErrors(result);\n  }\n else {\n    UIUtil.invokeLaterIfNeeded(null);\n  }\n}\n", "nl": "Notifies the design surface that the given screen view (which must be showing in this design surface) has been rendered (possibly with errors)"}
{"code": "private List<Sweet> extractSweetsForFeature(Mat img,int feature,int i,int orientation){\n  List<Sweet> featureSweets=new ArrayList<>();\n  int rowLimit=adjustLimitAccordingToOrientation(orientation,img.rows());\n  for (int k=0; k < rowLimit; k+=WALK) {\n    for (int l=0; l < img.cols(); l+=WALK) {\n      lookForFeatureInPixel(img,feature,i,featureSweets,k,l);\n    }\n  }\n  return featureSweets;\n}\n", "nl": "Without OpenCV Version"}
{"code": "public void editItem(Configuration.Item item,ItemChangedListener listener){\n  Intent editIntent=new Intent(this,ItemActivity.class);\n  this.itemChangedListener=listener;\n  if (item != null) {\n    editIntent.putExtra(\"ITEM_TITLE\",item.title);\n    editIntent.putExtra(\"ITEM_LOCATION\",item.location);\n    editIntent.putExtra(\"ITEM_STATE\",item.state);\n  }\n  startActivityForResult(editIntent,REQUEST_ITEM_EDIT);\n}\n", "nl": "Start the item editor activity"}
{"code": "private void updateScrollPane(){\n  if (chartDrawer.getScrollBackReferenceRect() != null) {\n    chartDrawer.computeScrollBackReferenceRect();\n    if (chartDrawer.getScrollBackReferencePoint() != null && chartDrawer.getScrollBackWindowPoint() != null) {\n      Point2D apt=chartDrawer.convertReferenceToWindow(chartDrawer.getScrollBackReferencePoint());\n      int scrollX=(int)Math.round(apt.getX() - chartDrawer.getScrollBackWindowPoint().getX());\n      int scrollY=(int)Math.round(apt.getY() - chartDrawer.getScrollBackWindowPoint().getY());\n      chartDrawer.setScrollBackReferencePoint(null);\n      chartDrawer.setScrollBackWindowPoint(null);\n      if (scrollX != 0) {\n        scrollPane.getHorizontalScrollBar().setValue(scrollPane.getHorizontalScrollBar().getValue() + scrollX);\n      }\n      if (scrollY != 0) {\n        scrollPane.getVerticalScrollBar().setValue(scrollPane.getVerticalScrollBar().getValue() + scrollY);\n      }\n    }\n  }\n}\n", "nl": "update scroll pane after zoom to keep centered on mouse position"}
{"code": "public boolean isSet(_Fields field){\n  if (field == null) {\n    throw new IllegalArgumentException();\n  }\nswitch (field) {\ncase APPKEY:\n    return isSetAppkey();\ncase SEND_TIME:\n  return isSetSendTime();\ncase LOAD_INFO:\nreturn isSetLoadInfo();\ncase STATUS:\nreturn isSetStatus();\n}\nthrow new IllegalStateException();\n}\n", "nl": "Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise"}
{"code": "@Deprecated public static double[] combine(double[] x,double[] y){\n  int len=0;\n  if (x != null)   len+=x.length;\n  if (y != null)   len+=y.length;\n  double[] z=null;\n  if (len > 0) {\n    z=new double[len];\n    int currentPos=0;\n    if (x != null) {\n      System.arraycopy(x,0,z,currentPos,x.length);\n      currentPos=x.length;\n    }\n    if (y != null)     System.arraycopy(y,0,z,currentPos,y.length);\n  }\n  return z;\n}\n", "nl": "Returns the vector [x y]"}
{"code": "public void handleBtnLogin(ActionEvent event){\n  try {\n    Parent login=FXMLLoader.load(getClass().getResource(\"login.fxml\"));\n    StackPane root=(StackPane)btnLogin.getScene().getRoot();\n    root.getChildren().add(login);\n    login.setTranslateX(350);\n    Timeline timeline=new Timeline();\n    KeyValue keyValue=new KeyValue(login.translateXProperty(),0);\n    KeyFrame keyFrame=new KeyFrame(Duration.millis(100),keyValue);\n    timeline.getKeyFrames().add(keyFrame);\n    timeline.play();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "this function change the First Logo Scene to Main Server Scene and this function is used in the button listener"}
{"code": "public void onNotifyNpcSpawned(int questId,int npcId){\n  QuestHandler handler=questHandlers.get(questId);\n  if (handler == null || !(handler instanceof ConstantSpawnHandler)) {\n    return;\n  }\n  ConstantSpawnHandler checker=(ConstantSpawnHandler)handler;\n  HashSet<Integer> allNpcs=checker.getNpcIds();\n  if (allNpcs == null) {\n    return;\n  }\n  allNpcs.remove(npcId);\n}\n", "nl": "Called by Spawn Engine to check missing spawns"}
{"code": "public ArrayList<DataHolder> readGallery(final GalleryActivity activity){\n  ArrayList<DataHolder> listOfAllImages=new ArrayList<>();\n  prepareDataForReading();\n  if (activity.getType() == Const.GalleryType.IMAGE || activity.getType() == Const.GalleryType.IMAGE_VIDEO) {\n    listOfAllImages.addAll(getImages());\n  }\n  if (activity.getType() == Const.GalleryType.VIDEO || activity.getType() == Const.GalleryType.IMAGE_VIDEO) {\n    listOfAllImages.addAll(getVideos());\n  }\n  Collections.sort(listOfAllImages,new DataHolderComparator());\n  return listOfAllImages;\n}\n", "nl": "function for reading gallery"}
{"code": "public static void write(String fileName,Column column) throws IOException {\n  try (CSVWriter writer=new CSVWriter(new FileWriter(fileName))){\n    String[] header={column.name()};\n    writer.writeNext(header);\n    for (int r=0; r < column.size(); r++) {\n      String[] entries={column.getString(r)};\n      writer.writeNext(entries);\n    }\n  }\n }\n", "nl": "Writes the given column to a file with the given fileName as a single column CSV file"}
{"code": "private int measureLong(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=getItemCount();\n    result=(int)(getPaddingLeft() + getPaddingRight() + (count * 2 * mRadius)+ (count - 1) * mRadius + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the width of this view"}
{"code": "protected String encodeCookie(SerializableOkHttpCookies cookie){\n  if (cookie == null)   return null;\n  ByteArrayOutputStream os=new ByteArrayOutputStream();\n  try {\n    ObjectOutputStream outputStream=new ObjectOutputStream(os);\n    outputStream.writeObject(cookie);\n  }\n catch (  IOException e) {\n    Log.d(LOG_TAG,\"IOException in encodeCookie\",e);\n    return null;\n  }\n  return byteArrayToHexString(os.toByteArray());\n}\n", "nl": "cookies to string"}
{"code": "public static boolean isNetWorkConnected(Context context){\n  if (context != null) {\n    ConnectivityManager mConnectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);\n    NetworkInfo mNetworkInfo=mConnectivityManager.getActiveNetworkInfo();\n    if (mNetworkInfo != null) {\n      return mNetworkInfo.isAvailable() && mNetworkInfo.isConnected();\n    }\n  }\n  return false;\n}\n", "nl": "check if network avalable"}
{"code": "@deprecated public final TimeZone parse(String text) throws ParseException {\n  ParsePosition pos=new ParsePosition(0);\n  TimeZone tz=parse(text,pos);\n  if (pos.getErrorIndex() >= 0) {\n    throw new ParseException(\"Unparseable time zone: \\\"\" + text + \"\\\"\",0);\n  }\n  assert (tz != null);\n  return tz;\n}\n", "nl": "/*     "}
{"code": "@Override public int countMissing(){\n  int count=0;\n  for (int i=0; i < size(); i++) {\n    if (MISSING_VALUE.equals(get(i))) {\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Returns the count of missing values in this column"}
{"code": "private SegmentedListIterator<T> establishPos(SegmentedListIterator<T> res,boolean randomScan){\n  int startSegment=drawSegmentNumber(false);\n  res.setStartSegment((short)startSegment);\n  res._scanLimit=size() * 5;\n  res._randomScan=(randomScan && getNumSegments() == 1);\n  for (int seg=startSegment, i=0; i < getNumSegments(); i++, seg++) {\n    if (seg == getNumSegments())     seg=0;\n    res.setCurrentSegment((short)seg);\n    StoredListChainSegment<T> segment=_segments[seg];\n    if (segment.establishIterScanPos(res))     return res;\n  }\n  return null;\n}\n", "nl": "establish a scan position- select a segment"}
{"code": "public static void convertCustomSpacePropsToJProperties(String spaceName,Properties customProps,JSpaceAttributes spaceAttrib){\n  if (customProps != null) {\n    for (Enumeration e=customProps.propertyNames(); e.hasMoreElements(); ) {\n      String propName=(String)e.nextElement();\n      String propValue=customProps.getProperty(propName);\n      String spacePropKey=spaceName == null ? propName : spaceName + \".\" + propName;\n      if (propName.startsWith(Constants.SPACE_CONFIG_PREFIX))       spaceAttrib.setProperty(spacePropKey,propValue);\n    }\n  }\n}\n", "nl": "Convert space attributes according to custom properties"}
{"code": "public void ResetEnemy(){\n  velocity.set(new Math_Vector(0,0));\n  pNum=this.map_controler.get_Selection(sKind,sNum);\n  delay=this.map_controler.get_Delay(sKind,sNum);\n  shield=this.map_controler.get_Enemy_Life(sKind,sNum);\n  posX=this.map_controler.get_Pos_X(sKind,sNum);\n  posY=this.map_controler.get_Pos_Y(sKind,sNum);\n  GetPath(pNum);\n  status=ENTER;\n  isDead=false;\n}\n", "nl": "reset enemy state"}
{"code": "static void dump(String title,FloatList list){\n  System.out.println(title);\n  FloatList cur=list;\n  do {\n    System.out.println(\"Item: \" + cur.value);\n    cur=cur.next;\n  }\n while (cur != list);\n}\n", "nl": "prints out the contents of this list"}
{"code": "public void testEmpty() throws Exception {\n  send(\"setCommitUserData\",\"{userData: {a: c, b: d}}\");\n  send(\"getCommitUserData\");\n  assertEquals(\"c\",getString(\"a\"));\n  assertEquals(\"d\",getString(\"b\"));\n  bounceServer();\n  send(\"startIndex\");\n  send(\"getCommitUserData\");\n  assertEquals(\"c\",getString(\"a\"));\n  assertEquals(\"d\",getString(\"b\"));\n}\n", "nl": "Make sure we can set commit data even when there are not docs"}
{"code": "public String upload_file1(byte[] file_buff,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String parts[]=this.upload_file(file_buff,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload file to storage server (by file buff)"}
{"code": "public void clearSelection(String target){\nswitch (target.toLowerCase()) {\ncase \"series\":\n    clearSelectionSeries();\n  break;\ncase \"classes\":\nclearSelectionClasses();\nbreak;\ncase \"attributes\":\nclearSelectionAttributes();\nbreak;\n}\n}\n", "nl": "clear selection"}
{"code": "static public void closeAllDatabase(){\n  Log.i(tag,\"closeAllDatabase\");\n  if (mInstance != null) {\n    for (int i=0; i < mInstance.databases.size(); ++i) {\n      if (mInstance.databases.get(i) != null) {\n        mInstance.databases.get(i).close();\n      }\n    }\n    mInstance.databases.clear();\n  }\n}\n", "nl": "Close all assets database"}
{"code": "public CreateSiteWindow selectChapters(List<String> chapters){\n  List<WebElement> items=currentWindow.findElements(By.cssSelector(\".cq-msm_58chapterPages .x-form-check-wrap\"));\n  for (  WebElement item : items) {\n    WebElement label=item.findElement(By.tagName(\"label\"));\n    if (!chapters.contains(label.getText())) {\n      item.findElement(By.tagName(\"input\")).click();\n    }\n  }\n  return this;\n}\n", "nl": "Selects chapters on Chapters view"}
{"code": "public synchronized boolean respond(int messageId,int response){\n  RequestResponseHandler handler=map.get(messageId);\n  if (handler != null) {\n    map.remove(messageId);\n    log.debug(\"RequestResponseHandler triggered for response code \" + messageId + \" from \"+ player.getName());\n    handler.handle(player,response);\n    return true;\n  }\n  return false;\n}\n", "nl": "Responds to the given message ID with the given response Returns success"}
{"code": "private void closeCounterDataInputStream() throws DataFallbackException {\n  if (LOG.isDebugEnabled())   LOG.debug(\"Closing the counter file reader for the file \" + counterFile.getName());\n  if (dInput != null) {\n    try {\n      dInput.close();\n    }\n catch (    IOException e) {\n      throw new DataFallbackException(e.getMessage());\n    }\n finally {\n      dInput=null;\n    }\n  }\n}\n", "nl": "Close the input stream opened for the counter file"}
{"code": "private void captureImage(){\n  Intent intent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE);\n  if (intent.resolveActivity(getPackageManager()) != null) {\n    File imageFile=ImageUtils.createImageFile(imageDirectory);\n    if (imageFile != null) {\n      Uri uri=FileProvider.getUriForFile(this,getString(R.string.shared_file_provider),imageFile);\n      currentImagePath=\"file:\" + imageFile.getAbsolutePath();\n      intent.putExtra(MediaStore.EXTRA_OUTPUT,uri);\n      startActivityForResult(intent,Constants.REQUEST_CODE_CAPTURE);\n    }\n else {\n      Toast.makeText(this,getString(R.string.error_create_image_file),Toast.LENGTH_LONG).show();\n    }\n  }\n else {\n    Toast.makeText(this,getString(R.string.error_no_camera),Toast.LENGTH_LONG).show();\n  }\n}\n", "nl": "Start camera intent Create a temporary file and pass file Uri to camera intent"}
{"code": "private void updateDoneText(ArrayList<String> resultList){\n  int size=0;\n  if (resultList == null || resultList.size() <= 0) {\n    mSubmitButton.setText(R.string.action_done);\n    mSubmitButton.setEnabled(false);\n  }\n else {\n    size=resultList.size();\n    mSubmitButton.setEnabled(true);\n  }\n  mSubmitButton.setText(getString(R.string.action_button_string,getString(R.string.action_done),size,mDefaultCount));\n}\n", "nl": "Update done button by select image data"}
{"code": "public void runAllSlot(){\n  moveToId(0);\n  System.out.println(\"== runAllSlot start at \" + currentSlot + \" ==\");\n  while (isValidSlot()) {\n    if (currentSlot % 10 == 0)     System.out.print(currentSlot + \": \");\n    int flag=(Integer)getVal(currentPos(),INTEGER).asJavaVal();\n    System.out.print(flag + \" \");\n    if ((currentSlot + 1) % 10 == 0)     System.out.println();\n    currentSlot++;\n  }\n  System.out.println(\"== runAllSlot end at \" + currentSlot + \" ==\");\n}\n", "nl": "Print all Slot IN_USE or EMPTY, for debugging"}
{"code": "@Override public boolean hasNext(){\n  if (done)   return false;\n  if (nextMatches == null)   nextMatches=getNext();\n  if (nextMatches == sentinel) {\n    done=true;\n    nextMatches=null;\n  }\n  return !done;\n}\n", "nl": "is there more data?"}
{"code": "public <K,V>Cache<K,V> createCache(CacheType cacheType,String carbonStorePath){\n  if (!dictionaryCacheAlreadyExists(cacheType)) {\nsynchronized (lock) {\n      if (!dictionaryCacheAlreadyExists(cacheType)) {\n        if (null == cacheTypeToLRUCacheMap.get(cacheType)) {\n          createLRULevelCacheInstance(cacheType);\n        }\n        createDictionaryCacheForGivenType(cacheType,carbonStorePath);\n      }\n    }\n  }\n  return cacheTypeToCacheMap.get(cacheType);\n}\n", "nl": "This method will check if a cache already exists for given cache type and create in case it is not present in the map"}
{"code": "public static void init(String conf_filename) throws FileNotFoundException, IOException, MyException {\n  IniFileReader iniReader;\n  iniReader=new IniFileReader(conf_filename);\n  g_network_timeout=iniReader.getIntValue(\"network_timeout\",DEFAULT_NETWORK_TIMEOUT);\n  if (g_network_timeout < 0) {\n    g_network_timeout=DEFAULT_NETWORK_TIMEOUT;\n  }\n  g_network_timeout*=1000;\n  g_charset=iniReader.getStrValue(\"charset\");\n  if (g_charset == null || g_charset.length() == 0) {\n    g_charset=\"ISO8859-1\";\n  }\n  g_server_group=ServerGroup.loadFromFile(iniReader);\n}\n", "nl": "load global variables"}
{"code": "protected void createSeparator(Composite parent,int verticalSpace){\n  Label label=new Label(parent,SWT.NONE);\n  GridData data=new GridData();\n  data.heightHint=verticalSpace;\n  label.setLayoutData(data);\n  label=new Label(parent,SWT.SEPARATOR | SWT.HORIZONTAL);\n  data=new GridData(GridData.FILL_HORIZONTAL);\n  label.setLayoutData(data);\n}\n", "nl": "Utility method to create a full width separator preceeded by a blank space"}
{"code": "private void updateOCVersion(){\n  UpdateOCVersionOperation update=new UpdateOCVersionOperation(getAccount(),getContext());\n  RemoteOperationResult result=update.execute(getClient());\n  if (!result.isSuccess()) {\n    mLastFailedResult=result;\n  }\n else {\n    mIsShareSupported=update.getOCVersion().isSharedSupported();\n  }\n}\n", "nl": "Updates the locally stored version value of the ownCloud server"}
{"code": "private static long hash(String string){\n  long upper=((long)string.hashCode()) << 32;\n  int len=string.length();\n  StringBuilder dest=new StringBuilder(len);\n  for (int index=(len - 1); index >= 0; index--) {\n    dest.append(string.charAt(index));\n  }\n  long lower=((long)dest.toString().hashCode()) - ((long)Integer.MIN_VALUE);\n  return upper + lower;\n}\n", "nl": "Hash the given string"}
{"code": "private void initResourcesIfNecessary(){\n  if (centerDrawable == null) {\n    centerDrawable=getContext().getResources().getDrawable(wheelForeground);\n  }\n  if (topShadow == null) {\n    topShadow=new GradientDrawable(Orientation.TOP_BOTTOM,SHADOWS_COLORS);\n  }\n  if (bottomShadow == null) {\n    bottomShadow=new GradientDrawable(Orientation.BOTTOM_TOP,SHADOWS_COLORS);\n  }\n  setBackgroundResource(wheelBackground);\n}\n", "nl": "Initializes resources"}
{"code": "private void processTextUnitDTOsBatch(List<TextUnitDTOWithComments> textUnitDTOsWithComments,List<TextUnitDTO> textUnitDTOsForBatch,List<Long> tmTextUnitVariantIdsForBatch){\n  Multimap<Long,TMTextUnitVariantComment> textUnitVariantCommentsMap=ArrayListMultimap.create();\n  List<TMTextUnitVariantComment> textUnitVariantComments=new ArrayList<>();\n  if (!tmTextUnitVariantIdsForBatch.isEmpty()) {\n    textUnitVariantComments=tmTextUnitVariantCommentRepository.findByTmTextUnitVariantIdIn(tmTextUnitVariantIdsForBatch);\n  }\n  for (  TMTextUnitVariantComment tmTextUnitVariantComment : textUnitVariantComments) {\n    Long tmTextUnitVariantId=tmTextUnitVariantComment.getTmTextUnitVariant().getId();\n    textUnitVariantCommentsMap.put(tmTextUnitVariantId,tmTextUnitVariantComment);\n  }\n  mergeCommentsIntoTextUnitDTOs(textUnitDTOsWithComments,textUnitDTOsForBatch,textUnitVariantCommentsMap);\n}\n", "nl": "Updates the given list of DTOs with their associated comments"}
{"code": "private int measureHeight(){\n  int dayOfWeek=calendar.get(Calendar.DAY_OF_WEEK);\n  int daysOfMonth=daysOfCurrentMonth();\n  int n=-1;\n  if (dayOfWeek >= 2 && dayOfWeek <= 7) {\n    n=daysOfMonth - (8 - dayOfWeek + 1);\n  }\n else   if (dayOfWeek == 1) {\n    n=daysOfMonth - 1;\n  }\n  int lines=2 + n / 7 + (n % 7 == 0 ? 0 : 1);\n  return (int)(cellHeight * lines);\n}\n", "nl": "calculate the total height of the widget"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set magnifier=\");\n  boolean state=np.getBoolean();\n  np.matchIgnoreCase(\";\");\n  if (getViewer() instanceof ViewerBase) {\n    ViewerBase viewer=(ViewerBase)getViewer();\n    viewer.trans.getMagnifier().setInRectilinearMode(true);\n    viewer.trans.getMagnifier().setActive(state);\n    viewer.repaint();\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private static float standardDeviation(float[] pos){\n  float sum=0.f;\n  float sumSqr=0.f;\n  int count=0;\n  for (  float po : pos) {\n    if (Float.isNaN(po)) {\n      continue;\n    }\n    count++;\n    sum+=po;\n    sumSqr+=po * po;\n  }\n  return (float)Math.sqrt(sumSqr / count - (sum / count) * (sum / count));\n}\n", "nl": "Calculate the standard deviation skipping Nan floats"}
{"code": "public MarkerOptions build(){\n  MarkerOptions options=new MarkerOptions();\n  options.icon=this.icon;\n  options.clickable=this.clickable;\n  options.draggable=this.draggable;\n  options.keyboard=this.keyboard;\n  options.title=this.title;\n  options.alt=this.alt;\n  options.zIndexOffset=this.zIndexOffset;\n  options.opacity=this.opacity;\n  options.riseOnHover=this.riseOnHover;\n  options.riseOffset=this.riseOffset;\n  return options;\n}\n", "nl": "Builds the MarkerOptions new instace"}
{"code": "public ClientKey(final InputStream inputStream,final String password) throws InvalidKeystoreException {\n  this.password=password;\n  final KeyStore keystore=getKeyStore(inputStream,password);\n  final Enumeration<String> aliases=getAliases(keystore);\n  if (aliases.hasMoreElements()) {\n    this.alias=aliases.nextElement();\n    logger.info(\"Client certificate serial number: \" + getCertificateInfo(keystore,alias));\n  }\n else {\n    throw new InvalidKeystoreException(\"Keystore doesn't contain any keys!\");\n  }\n  this.keyStore=keystore;\n  this.clientPasswordCallback=new ClientPasswordCallback(alias,password);\n}\n", "nl": "Create new ClientKey instance based on data provided in the stream together with the password"}
{"code": "public Object clone(){\n  System.err.println(this.getClass().getName() + \": The clone() method should be checked...\");\n  DocumentNGramDistroGraph gRes=new DocumentNGramDistroGraph(MinSize,MaxSize,CorrelationWindow);\n  gRes.DataString=DataString;\n  gRes.DegradedEdges.putAll(this.DegradedEdges);\n  gRes.NGramGraphArray=this.NGramGraphArray.clone();\n  gRes.Normalizer=this.Normalizer;\n  gRes.TextPreprocessor=this.TextPreprocessor;\n  gRes.WordEvaluator=this.WordEvaluator;\n  gRes.EdgeDistros=(HashMap)this.EdgeDistros.clone();\n  return gRes;\n}\n", "nl": "TODO: CHECK"}
{"code": "private Text createText(Composite parent,int widthHint){\n  Text textControl=new Text(parent,SWT.SINGLE | SWT.BORDER);\n  GridData gridData=new GridData();\n  gridData.horizontalAlignment=GridData.FILL;\n  gridData.widthHint=widthHint;\n  gridData.grabExcessHorizontalSpace=true;\n  textControl.setLayoutData(gridData);\n  return textControl;\n}\n", "nl": "creates a Text control"}
{"code": "void findFixed(WXDomObject obj){\n  WXDomObject rootDom=mRegistry.get(WXDomObject.ROOT);\n  if (rootDom == null) {\n    return;\n  }\n  if (obj.isFixed()) {\n    rootDom.add2FixedDomList(obj.ref);\n  }\n  int childrenCount=obj.childCount();\n  if (childrenCount > 0) {\n    for (int i=0; i < childrenCount; i++) {\n      findFixed(obj.getChild(i));\n    }\n  }\n}\n", "nl": "Find fixed node and tell root dom"}
{"code": "public static String byteToHexString(byte[] byteArray){\n  StringBuilder builder=new StringBuilder();\n  for (int i=0; i < byteArray.length; i++) {\n    int byteCode=byteArray[i] & 0xFF;\n    if (byteCode < 0x10) {\n      builder.append(0);\n    }\n    builder.append(Integer.toHexString(byteCode));\n  }\n  return builder.toString();\n}\n", "nl": "byte to hex string"}
{"code": "public BlockBTreeLeafNode(BTreeBuilderInfo builderInfos,int metadataIndex,long nodeNumber){\n  DataFileFooter footer=builderInfos.getFooterList().get(metadataIndex);\n  BlockletMinMaxIndex minMaxIndex=footer.getBlockletIndex().getMinMaxIndex();\n  maxKeyOfColumns=minMaxIndex.getMaxValues();\n  minKeyOfColumns=minMaxIndex.getMinValues();\n  numberOfKeys=1;\n  this.nodeNumber=nodeNumber;\n  this.blockInfo=footer.getBlockInfo();\n}\n", "nl": "Create a leaf node"}
{"code": "protected void initializeDefaultPageImageDescriptor(){\n  String iconPath;\n  iconPath=\"icons/full/\";\n  try {\n    URL installURL=SVNUIPlugin.getPlugin().getBundle().getEntry(\"/\");\n    URL url=new URL(installURL,iconPath + \"wizards/newconnect_wiz.gif\");\n    ImageDescriptor desc=ImageDescriptor.createFromURL(url);\n    setDefaultPageImageDescriptor(desc);\n  }\n catch (  MalformedURLException e) {\n  }\n}\n", "nl": "Declares the wizard banner iamge descriptor"}
{"code": "protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  date.year=YEAR;\n  date.month=MONTH;\n  date.day=15;\n  getTime(str,0,len,date);\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != 'Z') {\n    normalize(date);\n    date.day=15;\n  }\n  date.position=2;\n  return date;\n}\n", "nl": "Parses, validates and computes normalized version of time object"}
{"code": "@Override public void innerDelete(){\n  scopes().forEach(null);\n  Set<CastingImpl> castings=getMappingCasting();\n  for (  CastingImpl casting : castings) {\n    InstanceImpl<?,?> instance=casting.getRolePlayer();\n    if (instance != null) {\n      for (      EdgeImpl edge : instance.getEdgesOfType(Direction.BOTH,Schema.EdgeLabel.SHORTCUT)) {\n        if (edge.getProperty(Schema.EdgeProperty.RELATION_ID).equals(getId())) {\n          edge.delete();\n        }\n      }\n    }\n  }\n  super.innerDelete();\n}\n", "nl": "Deletes the concept as a Relation"}
{"code": "@NotNull private Device buildDevice(){\n  String deviceName=myDeviceData.name().get();\n  myBuilder.setName(deviceName);\n  myBuilder.setId(deviceName);\n  myBuilder.addSoftware(myDeviceData.software().getValue());\n  myBuilder.setManufacturer(myDeviceData.manufacturer().get());\n  IdDisplay tag=myDeviceData.deviceType().getValueOrNull();\n  myBuilder.setTagId((SystemImage.DEFAULT_TAG.equals(tag) || tag == null) ? null : tag.getId());\n  List<State> states=generateStates(new AvdHardwareData(myDeviceData).buildHardware());\n  myBuilder.addAllState(states);\n  return myBuilder.build();\n}\n", "nl": "Once we finish editing the device, we set it to its final configuration"}
{"code": "public static Map<Writable,Long> sampleMostFrequentFromColumn(int nMostFrequent,String columnName,Schema schema,JavaRDD<List<Writable>> data){\n  int columnIdx=schema.getIndexOfColumn(columnName);\n  JavaPairRDD<Writable,Long> keyedByWritable=data.mapToPair(new ColumnToKeyPairTransform(columnIdx));\n  JavaPairRDD<Writable,Long> reducedByWritable=keyedByWritable.reduceByKey(new SumLongsFunction2());\n  List<Tuple2<Writable,Long>> list=reducedByWritable.takeOrdered(nMostFrequent,new Tuple2Comparator<Writable>(false));\n  List<Tuple2<Writable,Long>> sorted=new ArrayList<>(list);\n  Collections.sort(sorted,new Tuple2Comparator<Writable>(false));\n  Map<Writable,Long> map=new LinkedHashMap<>();\n  for (  Tuple2<Writable,Long> t2 : sorted) {\n    map.put(t2._1(),t2._2());\n  }\n  return map;\n}\n", "nl": "Sample the N most frequently occurring values in the specified column"}
{"code": "protected String domain(){\n  if (uri.getPath().startsWith(\"queues/\")) {\n    return \"queue\";\n  }\n else   if (uri.getPath().startsWith(\"topics/\")) {\n    return \"topic\";\n  }\n else   if (uri.getPath().startsWith(\"persistent/\")) {\n    return \"persistent\";\n  }\n else {\n    throw new RestException(Status.INTERNAL_SERVER_ERROR,\"domain() invoked from wrong resource\");\n  }\n}\n", "nl": "Get the domain of the destination (whether it's queue or topic)"}
{"code": "public static byte[] compressForZlib(byte[] bytesToCompress){\n  Deflater deflater=new Deflater();\n  deflater.setInput(bytesToCompress);\n  deflater.finish();\n  byte[] bytesCompressed=new byte[Short.MAX_VALUE];\n  int numberOfBytesAfterCompression=deflater.deflate(bytesCompressed);\n  byte[] returnValues=new byte[numberOfBytesAfterCompression];\n  System.arraycopy(bytesCompressed,0,returnValues,0,numberOfBytesAfterCompression);\n  return returnValues;\n}\n", "nl": "zlib compress 2 byte"}
{"code": "public DOTInteroperator() throws IOException {\n  Process p=Runtime.getRuntime().exec(\"dot -V\");\n  try {\n    p.waitFor();\n  }\n catch (  InterruptedException iee) {\n    return;\n  }\n}\n", "nl": "Creates a new instance of DOTInteroperator"}
{"code": "private void decodeToken(String jwt){\n  JwtConsumer consumer=new JwtConsumerBuilder().setSkipAllValidators().setDisableRequireSignature().setSkipSignatureVerification().build();\n  try {\n    JwtClaims claims=consumer.processToClaims(jwt);\n    userId=claims.getSubject();\n  }\n catch (  InvalidJwtException|MalformedClaimException e) {\n    Log.e(\"AirMap\",\"Invalid auth token\");\n  }\n}\n", "nl": "Decodes the JWT Auth Token and parses it to get the user ID"}
{"code": "private void initializeConductor(){\n  activeDelays=new LinkedList<Float>();\n  float randomDelay=MathUtils.random(2f,4.5f);\n  currentDelay=randomDelay;\n  totalDelay+=randomDelay;\n  activeDelays.add(randomDelay);\n  do {\n    float delayPercentage=totalDelay / timeTilVictory;\n    randomDelay=this.max_delay - delayPercentage * (this.max_delay - this.min_delay);\n    activeDelays.add(randomDelay);\n    totalDelay+=randomDelay;\n  }\n while (totalDelay < timeTilVictory);\n  turnOffAllTracks();\n}\n", "nl": "Initialize and queue the data needed for the Train Rush map"}
{"code": "private void parseObjectMetrics(String namePrefix,JSONObject obj){\n  for (  Object key : obj.keySet()) {\n    Object val=obj.get(key);\n    if (val instanceof JSONObject) {\n      parseObjectMetrics(namePrefix + \"__\" + key,(JSONObject)val);\n    }\n else {\n      if (gaugeFilter.get().contains((String)key)) {\n        processGaugeMetric(namePrefix + \"__\" + (String)key,(Long)val);\n      }\n else {\n        processCounterMetric(namePrefix + \"__\" + (String)key,(Long)val);\n      }\n    }\n  }\n}\n", "nl": "Helper to recursively flatten out a metric from a nested collection"}
{"code": "public void testWriteReadFull() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(full);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  MirrorServiceConfig copy=(MirrorServiceConfig)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(full,copy));\n}\n", "nl": "Test read and write full ClusterPolicy object"}
{"code": "private static void writeCopyState(CopyState state,DataOutput out) throws IOException {\n  out.writeVInt(state.infosBytes.length);\n  out.writeBytes(state.infosBytes,0,state.infosBytes.length);\n  out.writeVLong(state.gen);\n  out.writeVLong(state.version);\n  CopyFilesHandler.writeFilesMetaData(out,state.files);\n  out.writeVInt(state.completedMergeFiles.size());\n  for (  String fileName : state.completedMergeFiles) {\n    out.writeString(fileName);\n  }\n  out.writeVLong(state.primaryGen);\n}\n", "nl": "Pushes CopyState on the wire"}
{"code": "protected String[] upload_file(byte cmd,String group_name,String local_filename,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  File f=new File(local_filename);\n  FileInputStream fis=new FileInputStream(f);\n  if (file_ext_name == null) {\n    int nPos=local_filename.lastIndexOf('.');\n    if (nPos > 0 && local_filename.length() - nPos <= ProtoCommon.FDFS_FILE_EXT_NAME_MAX_LEN + 1) {\n      file_ext_name=local_filename.substring(nPos + 1);\n    }\n  }\n  try {\n    return this.do_upload_file(cmd,group_name,null,null,file_ext_name,f.length(),new UploadStream(fis,f.length()),meta_list);\n  }\n  finally {\n    fis.close();\n  }\n}\n", "nl": "upload file to storage server (by file name)"}
{"code": "public boolean unpinIfNeeded(Context context,IEntryHolder entry,ITemplateHolder template,IEntryCacheInfo pEntry){\n  if (!isEvictableCachePolicy() && !entry.isOffHeapEntry())   return false;\n  if (template != null) {\n    if (template.isTakeOperation() && entry.isDeleted())     return false;\n  }\n  if (useRecentUpdatesForPinning() && isEntryInRecentUpdates(entry))   return false;\n  if (pEntry == null)   pEntry=entry.isOffHeapEntry() ? ((IOffHeapEntryHolder)entry).getOffHeapResidentPart() : getEntryCacheInfo(entry);\n  if (pEntry == null || !pEntry.isPinned())   return false;\n  if (useRecentDeletes() && pEntry.isRecentDelete())   return false;\n  if (entry.isOffHeapEntry() && ((IOffHeapRefCacheInfo)pEntry).isInBulk())   return false;\n  if (pEntry.getEntryHolder(this).isMaybeUnderXtn() || pEntry.getEntryHolder(this).isHasWaitingFor())   return false;\n  if (isEvictableCachePolicy())   pEntry.setPinned(false);\n else   ((IOffHeapRefCacheInfo)pEntry).unLoadFullEntryIfPossible(this,context);\n  return true;\n}\n", "nl": "if relevant-unpin the entry method is called after each operation or xtn termination entry should be locked when method is called"}
{"code": "private boolean hasConcatenationAsIndex(ArrayAccessExpression objExpression){\n  PsiElement objExpressionToInspect=objExpression;\n  while (objExpressionToInspect instanceof ArrayAccessExpression) {\n    ArrayIndex objIndex=((ArrayAccessExpression)objExpressionToInspect).getIndex();\n    if (null != objIndex && objIndex.getValue() instanceof BinaryExpression) {\n      PsiElement objOperation=((BinaryExpression)objIndex.getValue()).getOperation();\n      if (null != objOperation && objOperation.getNode().getElementType() == PhpTokenTypes.opCONCAT) {\n        return true;\n      }\n    }\n    objExpressionToInspect=objExpressionToInspect.getParent();\n  }\n  return false;\n}\n", "nl": "TODO: iterator for array access expression"}
{"code": "public static void verifyToken(String token,AirMapCallback<Void> listener){\n  String url=String.format(pilotVerifyUrl,AirMap.getUserId());\n  JSONObject params=new JSONObject();\n  try {\n    params.put(\"token\",Integer.valueOf(token));\n  }\n catch (  JSONException e) {\n    e.printStackTrace();\n  }\n  AirMap.getClient().postWithJsonBody(url,params,new VoidCallback(listener));\n}\n", "nl": "Verify that the text message the user received was the correct one"}
{"code": "private void removeExcess(){\n  int outing=size - maxSize;\n  Link<E> previous=voidLink.next;\n  for (int i=0; i < outing; i++) {\n    previous=previous.next;\n  }\n  voidLink.next=previous;\n  previous.previous=voidLink;\n  size=maxSize;\n  modCount++;\n}\n", "nl": "Remove excess"}
{"code": "protected boolean newWritableStorageConnection(String group_name) throws IOException, MyException {\n  if (this.storageServer != null) {\n    return false;\n  }\n else {\n    TrackerClient tracker=new TrackerClient();\n    this.storageServer=tracker.getStoreStorage(this.trackerServer,group_name);\n    if (this.storageServer == null) {\n      throw new MyException(\"getStoreStorage fail, errno code: \" + tracker.getErrorCode());\n    }\n    return true;\n  }\n}\n", "nl": "check storage socket, if null create a new connection"}
{"code": "private boolean addViewItem(int index,boolean first){\n  View view=getItemView(index);\n  if (view != null) {\n    if (first) {\n      itemsLayout.addView(view,0);\n    }\n else {\n      itemsLayout.addView(view);\n    }\n    return true;\n  }\n  return false;\n}\n", "nl": "Adds view for item to items layout"}
{"code": "@Override public void update(@SwingCoordinate int x,@SwingCoordinate int y,@InputEventMask int modifiers){\n  super.update(x,y,modifiers);\n  DrawConstraintModel drawModel=ConstraintModel.getDrawConstraintModel(myScreenView);\n  drawModel.updateModifiers(modifiers);\n  int androidX=Coordinates.getAndroidX(myScreenView,x);\n  int androidY=Coordinates.getAndroidY(myScreenView,y);\n  drawModel.mouseDragged(androidX,androidY);\n  ConstraintModel.getConstraintModel(myScreenView.getModel()).updateXml();\n}\n", "nl": "Update the mouse interaction"}
{"code": "public ArrayList<MonsterStatus> queryMonsterStatus(long id){\n  ArrayList<MonsterStatus> monsterStatuses=new ArrayList<MonsterStatus>();\n  MonsterStatusCursor cursor=mHelper.queryMonsterStatus(id);\n  cursor.moveToFirst();\n  while (!cursor.isAfterLast()) {\n    monsterStatuses.add(cursor.getStatus());\n    cursor.moveToNext();\n  }\n  cursor.close();\n  return monsterStatuses;\n}\n", "nl": "MONSTER STATUS QUERIES"}
{"code": "public int read(long position,IInputReader reader) throws IOException {\n  map2Weight.clear();\n  reader.seek(position);\n  final int numberOfClasses=reader.readInt();\n  for (int i=0; i < numberOfClasses; i++) {\n    final int classId=reader.readInt();\n    final int weight=reader.readInt();\n    final int count=reader.readInt();\n    reader.skipBytes(count * 8);\n    map2Weight.put(classId,weight);\n  }\n  return map2Weight.size();\n}\n", "nl": "reads the named classification block"}
{"code": "public void addPages(){\n  mainPage=new NewRemoteFolderWizardMainPage(\"newRemoteFolderPage1\",Policy.bind(\"NewRemoteFolderWizard.heading\"),SVNUIPlugin.getPlugin().getImageDescriptor(ISVNUIConstants.IMG_WIZBAN_NEW_FOLDER));\n  mainPage.setParentFolder(selection);\n  addPage(mainPage);\n  String pageTitle=Policy.bind(\"CommentCommitWizardPage.pageTitle\");\n  String pageDescription=Policy.bind(\"CommentCommitWizardPage.pageDescription\");\n  ImageDescriptor image=SVNUIPlugin.getPlugin().getImageDescriptor(ISVNUIConstants.IMG_WIZBAN_NEW_FOLDER);\n  commitCommentPage=new CommentCommitWizardPage(parentDialog,pageTitle,pageTitle,image,pageDescription);\n  addPage(commitCommentPage);\n}\n", "nl": "Creates the wizard pages"}
{"code": "public void goToStep(int stepNumber,boolean restoration){\n  if (activeStep != stepNumber || restoration) {\n    if (hideKeyboard) {\n      hideSoftKeyboard();\n    }\n    boolean previousStepsAreCompleted=arePreviousStepsCompleted(stepNumber);\n    if (stepNumber == 0 || previousStepsAreCompleted) {\n      openStep(stepNumber,restoration);\n    }\n  }\n}\n", "nl": "Go to the selected step"}
{"code": "@Override public void onDestroy(){\n  Log_OC.v(TAG,\"Destroying service\");\n  mBinder=null;\n  mServiceHandler=null;\n  mServiceLooper.quit();\n  mServiceLooper=null;\n  mNotificationManager=null;\n  AccountManager am=AccountManager.get(getApplicationContext());\n  am.removeOnAccountsUpdatedListener(this);\n  super.onDestroy();\n}\n", "nl": "Service clean up"}
{"code": "protected void init(){\n  fSchemeName=null;\n  fSchemeData=null;\n  fShortHandPointerName=null;\n  fIsResolveElement=false;\n  fIsElementFound=false;\n  fWasOnlyEmptyElementFound=false;\n  fFoundDepth=0;\n  fCurrentChildPosition=1;\n  fCurrentChildDepth=0;\n  fIsFragmentResolved=false;\n  fShortHandPointer=null;\n  initErrorReporter();\n}\n", "nl": "Initializes the element scheme processor"}
{"code": "private FilePart rollOver() throws IOException {\n  if (currentLastBytePos > -1) {\n    throw new IllegalStateException(\"Current currentLastCharPos unexpectedly positive... \" + \"last readLine() should have returned something! currentLastCharPos=\" + currentLastBytePos);\n  }\n  if (no > 1) {\n    return new FilePart(no - 1,blockSize,leftOver);\n  }\n else {\n    if (leftOver != null) {\n      throw new IllegalStateException(\"Unexpected leftover of the last block: leftOverOfThisFilePart=\" + new String(leftOver,encoding));\n    }\n    return null;\n  }\n}\n", "nl": "Handles block rollover"}
{"code": "public static float[] centroid(float pts[],int len){\n  float[] c=new float[]{0,0};\n  for (int i=0; i < len; i+=2) {\n    c[0]+=pts[i];\n    c[1]+=pts[i + 1];\n  }\n  c[0]/=len / 2;\n  c[1]/=len / 2;\n  return c;\n}\n", "nl": "Computes the mean, or centroid, of a set of points"}
{"code": "public static String makeEnumHumanReadable(final String enumName){\n  StringBuilder builder=new StringBuilder(enumName.length() + 1);\n  for (  String word : enumName.split(\"_\")) {\n    if (word.length() <= 2) {\n      builder.append(word);\n    }\n else {\n      builder.append(word.charAt(0));\n      builder.append(word.substring(1).toLowerCase());\n    }\n    builder.append(' ');\n  }\n  return builder.substring(0,enumName.length());\n}\n", "nl": "Makes an enum name human readable (fixes spaces, capitalization, etc)"}
{"code": "private boolean processWidgets(List<WidgetObject> widgets,String searchingId,boolean isRemove){\n  Iterator<WidgetObject> iterator=widgets.iterator();\n  boolean isFound=false;\n  while (iterator.hasNext()) {\n    WidgetObject widget=iterator.next();\n    if (widget.getWidgetId().equalsIgnoreCase(searchingId)) {\n      if (isRemove) {\n        iterator.remove();\n      }\n      isFound=true;\n      break;\n    }\n  }\n  return isFound;\n}\n", "nl": "Iterate over Widget's Set find widget with specified id and remove it if required"}
{"code": "@Nullable public static Bitmap toBitmap(@Nullable final View view){\n  if (view == null) {\n    return null;\n  }\n  final int width=view.getWidth();\n  final int height=view.getHeight();\n  final Bitmap bitmapToExport=Bitmap.createBitmap(width > 0 ? width : DEFAULT_BITMAP_WIDTH,height > 0 ? height : DEFAULT_BITMAP_HEIGHT,Bitmap.Config.ARGB_8888);\n  final Canvas canvas=new Canvas(bitmapToExport);\n  view.draw(canvas);\n  return bitmapToExport;\n}\n", "nl": "Convert the specified view to a drawable, if possible"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  final ChartViewer viewer=(ChartViewer)getViewer();\n  final LabelsJList list=viewer.getActiveLabelsJList();\n  previousValue=Math.min(list.getAllLabels().size(),previousValue);\n  final String result=JOptionPane.showInputDialog(viewer.getFrame(),\"Set number of top items to select\",previousValue);\n  if (result != null && Basic.isInteger(result)) {\n    execute(\"select top='\" + result + \"';\");\n    previousValue=Basic.parseInt(result);\n  }\n}\n", "nl": "action to be performed"}
{"code": "@ObjectiveCName(\"join:\") private static String join(String[] list){\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < list.length; i++) {\n    if (i == list.length - 1) {\n      sb.append(list[i]);\n    }\n else {\n      sb.append(list[i]);\n      sb.append(MessageBuilder.MPS);\n    }\n  }\n  return sb.toString();\n}\n", "nl": "Joins all the elements of the list together with the given sequence"}
{"code": "public long writeTo(DataOutput output) throws IOException {\n  long nBytes=0;\n  assert this.hasLegalType() : \"Unknown Mary file type [\" + type + \"].\";\n  output.writeInt(magic);\n  nBytes+=4;\n  output.writeInt(version);\n  nBytes+=4;\n  output.writeInt(type);\n  nBytes+=4;\n  return (nBytes);\n}\n", "nl": "Mary header writer"}
{"code": "public static Bitmap punchARoundedHoleInABitmap(Context context,int screenWidth,int screenHeight,int x,int y,int holeDiameter,int backgroundColor){\n  Bitmap bitmap=Bitmap.createBitmap(screenWidth,screenHeight,Bitmap.Config.ARGB_8888);\n  Canvas canvas=new Canvas(bitmap);\n  Paint paint=new Paint();\n  paint.setAntiAlias(true);\n  canvas.drawColor(context.getResources().getColor(backgroundColor));\n  paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));\n  canvas.drawCircle(x + holeDiameter / 2,y + holeDiameter / 2,holeDiameter / 2,paint);\n  return bitmap;\n}\n", "nl": "Create a fullscreen image and punch a hole inside"}
{"code": "public SDTTimeDeadbandScheduler(final SourceDataTag sourceDataTag,final IProcessMessageSender processMessageSender,final EquipmentSenderFilterModule equipmentSenderFilterModule,final Timer timeDeadbandTimer,final DataTagValueFilter dataTagValueFilter,final IDynamicTimeDeadbandFilterer dynamicTimeDeadbandFilterer){\n  this.dataTagValueFilter=dataTagValueFilter;\n  this.processMessageSender=processMessageSender;\n  this.equipmentSenderFilterModule=equipmentSenderFilterModule;\n  this.dynamicTimeDeadbandFilterer=dynamicTimeDeadbandFilterer;\n  this.timeDeadbandTimer=timeDeadbandTimer;\n  if (LOGGER.isDebugEnabled()) {\n    LOGGER.debug(\"creating time-deadband scheduler for tag : \" + sourceDataTag.getId());\n  }\n  this.sourceDataTag=sourceDataTag;\n}\n", "nl": "Creates a new SDTTimeDeadbandscheduler"}
{"code": "public void toggleSelection(final int position){\n  if (mSelectedItems.get(position,false)) {\n    mSelectedItems.delete(position);\n  }\n else {\n    mSelectedItems.put(position,true);\n  }\n  notifyItemChanged(position);\n}\n", "nl": "Toggle the selection status of the item at a given position"}
{"code": "public boolean put(String columnIdentifier,Cacheable cacheInfo,long requiredSize){\n  boolean columnKeyAddedSuccessfully=false;\n  if (freeMemorySizeForAddingCache(requiredSize)) {\nsynchronized (lruCacheMap) {\n      currentSize=currentSize + requiredSize;\n      if (null == lruCacheMap.get(columnIdentifier)) {\n        lruCacheMap.put(columnIdentifier,cacheInfo);\n      }\n      columnKeyAddedSuccessfully=true;\n    }\n    LOGGER.debug(\"Added level entry to InMemory level lru cache :: \" + columnIdentifier);\n  }\n else {\n    LOGGER.error(\"Size not available. Column cannot be added to level lru cache :: \" + columnIdentifier + \" .Required Size = \"+ requiredSize+ \" Size available \"+ (lruCacheMemorySize - currentSize));\n  }\n  return columnKeyAddedSuccessfully;\n}\n", "nl": "This method will check if required size is available in the memory and then add the given cacheable to object to lru cache"}
{"code": "public void apply(Predicate<TM> predicate){\n  lock();\n  try {\n    for (    TM member : members.values()) {\n      if (!predicate.apply(member)) {\n        return;\n      }\n    }\n  }\n  finally {\n    unlock();\n  }\n}\n", "nl": "Apply some predicate on all group members<br> Should be used only to change state of the group or its members"}
{"code": "public AbortJob(Transaction tr,TaskManager pool,WakeupManager wm,ClientLog log,ParticipantHandle[] handles,boolean directCall,Object xid){\n  super(pool,wm,directCall);\n  if (log == null)   throw new IllegalArgumentException(\"AbortJob: AbortJob: \" + \"log is null\");\n  this.log=log;\n  if (!(tr instanceof ServerTransaction))   throw new IllegalArgumentException(\"PrepareJob: PrepareJob: \" + \"must be a ServerTransaction\");\n  this.tr=(ServerTransaction)tr;\n  if (handles == null)   throw new IllegalArgumentException(\"PrepareJob: PrepareJob: \" + \"must have participants\");\n  if (handles.length == 0)   throw new IllegalArgumentException(\"PrepareJob: PrepareJob: \" + \"must have participants\");\n  this.handles=handles;\n  if (_directCall)   this.results=new Integer[1];\n  _xid=xid;\n}\n", "nl": "Constructs an <code>AbortJob</code>"}
{"code": "protected CarbonDictionaryColumnMetaChunk readLastChunkFromDictionaryMetadataFile(DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier) throws IOException {\n  DictionaryService dictService=CarbonCommonFactory.getDictionaryService();\n  CarbonDictionaryMetadataReader columnMetadataReaderImpl=dictService.getDictionaryMetadataReader(dictionaryColumnUniqueIdentifier.getCarbonTableIdentifier(),dictionaryColumnUniqueIdentifier.getColumnIdentifier(),carbonStorePath);\n  CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk=null;\n  try {\n    carbonDictionaryColumnMetaChunk=columnMetadataReaderImpl.readLastEntryOfDictionaryMetaChunk();\n  }\n  finally {\n    columnMetadataReaderImpl.close();\n  }\n  return carbonDictionaryColumnMetaChunk;\n}\n", "nl": "This method will read dictionary metadata file and return the dictionary meta chunks"}
{"code": "public static byte[] compressForZlib(String stringToCompress){\n  byte[] returnValues=null;\n  try {\n    returnValues=compressForZlib(stringToCompress.getBytes(\"UTF-8\"));\n  }\n catch (  UnsupportedEncodingException uee) {\n    uee.printStackTrace();\n  }\n  return returnValues;\n}\n", "nl": "zlib compress 2 byte"}
{"code": "public static void apply(Map<Integer,Integer> tax2count,int minSupport,final ProgressListener progressListener){\n  MinSupportAlgorithm algorithm=new MinSupportAlgorithm(tax2count,minSupport,progressListener);\n  try {\n    Map<Integer,Integer> lowSupportTaxa2HighSupportTaxa=algorithm.apply();\n    for (    Integer lowTaxon : lowSupportTaxa2HighSupportTaxa.keySet()) {\n      Integer highTaxon=lowSupportTaxa2HighSupportTaxa.get(lowTaxon);\n      Integer count=tax2count.get(highTaxon);\n      if (count == null)       tax2count.put(highTaxon,tax2count.get(lowTaxon));\n else       tax2count.put(highTaxon,count + tax2count.get(lowTaxon));\n    }\n    tax2count.keySet().removeAll(lowSupportTaxa2HighSupportTaxa.keySet());\n  }\n catch (  CanceledException e) {\n    Basic.caught(e);\n  }\n}\n", "nl": "applies the min-support algorithm to the given taxonomic analysis"}
{"code": "public boolean addAttribute(String attribute,Object value,boolean allowReplaceAttribute){\n  boolean change=false;\n  if (allowReplaceAttribute || !table.columnKeySet().contains(attribute)) {\n    for (    String sample : getSampleOrder()) {\n      put(sample,attribute,value);\n    }\n    change=true;\n  }\n  return change;\n}\n", "nl": "add an attribute with same value to all samples"}
{"code": "private void init(){\n  mPaint=new Paint();\n  mPath=new Path();\n  startPoint=new Point(300,150);\n  endPoint=new Point(900,150);\n  assistPoint1=new Point(500,450);\n  assistPoint2=new Point(700,450);\n  mPaint.setAntiAlias(true);\n  mPaint.setDither(true);\n}\n", "nl": "150         startPoint(300,150)                                         endPoint(900,150) <p/> <p/> <p/> 450                   assistPoint1(500,450)   assistPoint2(700,450)"}
{"code": "public SampleAttributeTable copy(){\n  final SampleAttributeTable sampleAttributeTable=new SampleAttributeTable();\n  try (StringWriter w=new StringWriter()){\n    write(w,false,true);\n    sampleAttributeTable.read(new StringReader(w.toString()),getSampleOrder(),false);\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n  return sampleAttributeTable;\n}\n", "nl": "get a copy"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  megan.remote.ServicePanel servicePanel=((megan.remote.RemoteServiceBrowser)getViewer()).getServicePanel();\n  if (servicePanel != null) {\n    TreePath[] paths=servicePanel.getFileTree().getSelectionPaths();\n    if (paths != null)     servicePanel.collapse(paths);\n else     servicePanel.collapse((DefaultMutableTreeNode)servicePanel.getFileTree().getModel().getRoot());\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public void apply(PGraphicsOpenGL src,PGraphicsOpenGL dst,float[] kernel){\n  if (src == dst) {\n    System.out.println(\"Convolution error: read-write race\");\n    return;\n  }\n  if (kernel.length < 9)   return;\n  Texture tex_src=src.getTexture();\n  if (!tex_src.available())   return;\n  dst.beginDraw();\n  context.begin();\n  apply(tex_src.glName,dst.width,dst.height,kernel);\n  context.end(\"Convolution.apply\");\n  dst.endDraw();\n}\n", "nl": "kernel: 0 1 2 3 4 5 6 7 8"}
{"code": "public boolean filterOut(final SAMRecord record){\n  if (include) {\n    if (record.getMateNegativeStrandFlag()) {\n      return false;\n    }\n  }\n else {\n    if (!record.getMateNegativeStrandFlag()) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "public static Bitmap rotateBitmap(Bitmap bitmap,int degrees){\n  if (bitmap != null) {\n    Matrix m=new Matrix();\n    m.postRotate(degrees);\n    bitmap=Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),m,true);\n    return bitmap;\n  }\n  return null;\n}\n", "nl": "rotate the bitmap"}
{"code": "public static SSLContext createSSLContext(TrustManager trustManager,KeyManager keyManager){\n  try {\n    SSLContext ctx=SSLContext.getInstance(\"TLS\");\n    ctx.init(new KeyManager[]{keyManager},new TrustManager[]{trustManager},null);\n    return ctx;\n  }\n catch (  NoSuchAlgorithmException|KeyManagementException e) {\n    throw new RuntimeException(\"Failed to create SSLContext\",e);\n  }\n}\n", "nl": "Create an SSLContext for the given TrustManager and KeyManager"}
{"code": "void createVMPanel_Convert_To(JTabbedPane jTabbedPane_name,final String name){\n  JTabbedPane j=new JTabbedPane(SwingConstants.TOP);\n  j=jTabbedPane_name;\n  if (name.equalsIgnoreCase(\"view\")) {\n    VDICalculator.functionsobj.jPanelComponentPropertyChange(j,JComboBox.class,\"vmvramcombo\",true,null,0);\n    final String[] s={\"Linked\",\"Full\"};\n    VDICalculator.functionsobj.jPanelComponentPropertyChange(j,JComboBox.class,\"desktoppooltypecombo\",true,s,0);\n  }\n else   if (name.equalsIgnoreCase(\"xen\")) {\n    VDICalculator.functionsobj.jPanelComponentPropertyChange(j,JComboBox.class,\"vmvramcombo\",false,null,0);\n    final String[] s={\"Pooled\",\"Assigned\"};\n    VDICalculator.functionsobj.jPanelComponentPropertyChange(j,JComboBox.class,\"desktoppooltypecombo\",true,s,0);\n  }\n}\n", "nl": "Convert a CreateVMPanel to specific hypervizor model"}
{"code": "@Override public void put(K key,V value){\n  Item cur=map.get(key);\n  if (cur != null) {\n    cur.value=value;\n    moveToHead(cur);\n    return;\n  }\n  if (map.size() >= maxSize && maxSize != 0) {\n    cur=endItem.previous;\n    map.remove(cur.key);\n    removeItem(cur);\n  }\n  Item item=new Item(key,value);\n  insertHead(item);\n  map.put(key,item);\n}\n", "nl": "Adds or renews a cache item pair"}
{"code": "public static String encodeQueryValue(String query){\n  String retString;\n  retString=replaceString(query,\"%\",\"%25\");\n  retString=replaceString(retString,\" \",\"%20\");\n  retString=replaceString(retString,\"&\",\"%26\");\n  retString=replaceString(retString,\"?\",\"%3F\");\n  retString=replaceString(retString,\"=\",\"%3D\");\n  return retString;\n}\n", "nl": "Encodes a single HTTP URL query value, replacing characters used for other things in HTTP URL query strings"}
{"code": "private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,ContrastMethod contrastMethod){\n  ContrastEnhancement contrastEnhancement=(ContrastEnhancement)styleFactory.contrastEnhancement(null,contrastMethod.name());\n  FilterFactory ff=CommonFactoryFinder.getFilterFactory();\n  Map<String,Expression> options=contrastEnhancement.getOptions();\n  options.put(\"algorithm\",ff.literal(\"StretchToMinimumMaximum\"));\n  options.put(\"minValue\",ff.literal(\"1\"));\n  options.put(\"maxValue\",ff.literal(\"5\"));\n  SelectedChannelType channelType=styleFactory.createSelectedChannelType(\"channel name\",contrastEnhancement);\n  SelectedChannelType[] channels=new SelectedChannelType[3];\n  channels[0]=channelType;\n  channels[1]=channelType;\n  channels[2]=channelType;\n  ChannelSelection channelSelection=styleFactory.createChannelSelection(channels);\n  return channelSelection;\n}\n", "nl": "Creates the channel selection object"}
{"code": "@deprecated public boolean equals(Object obj){\n  if (obj == null)   return false;\n  if (this == obj)   return true;\n  if (getClass() != obj.getClass())   return false;\n  CompactByteArray other=(CompactByteArray)obj;\n  for (int i=0; i < 65536; i++) {\n    if (elementAt((char)i) != other.elementAt((char)i))     return false;\n  }\n  return true;\n}\n", "nl": "/*    "}
{"code": "public static Map<String,Object> testCapture(DispatchContext dctx,Map<String,? extends Object> context){\n  Locale locale=(Locale)context.get(\"locale\");\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  Debug.logInfo(\"Test Capture Process\",module);\n  String refNum=UtilDateTime.nowAsString();\n  result.put(\"captureResult\",Boolean.TRUE);\n  result.put(\"captureAmount\",context.get(\"captureAmount\"));\n  result.put(\"captureRefNum\",refNum);\n  result.put(\"captureAltRefNum\",refNum);\n  result.put(\"captureFlag\",\"C\");\n  result.put(\"captureMessage\",UtilProperties.getMessage(resource,\"AccountingPaymentTestCapture\",locale));\n  return result;\n}\n", "nl": "Test capture service (returns true)"}
{"code": "public String upload_file1(String local_filename,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  String parts[]=this.upload_file(local_filename,file_ext_name,meta_list);\n  if (parts != null) {\n    return parts[0] + SPLIT_GROUP_NAME_AND_FILENAME_SEPERATOR + parts[1];\n  }\n else {\n    return null;\n  }\n}\n", "nl": "upload file to storage server (by file name)"}
{"code": "public static String saveCartToAutoSaveList(HttpServletRequest request,HttpServletResponse response){\n  LocalDispatcher dispatcher=(LocalDispatcher)request.getAttribute(\"dispatcher\");\n  ShoppingCart cart=ShoppingCartEvents.getCartObject(request);\n  try {\n    fillAutoSaveList(cart,dispatcher);\n  }\n catch (  GeneralException e) {\n    Debug.logError(e,\"Error saving the cart to the auto-save list: \" + e.toString(),module);\n  }\n  return \"success\";\n}\n", "nl": "Saves the shopping cart to the specialized (auto-save) shopping list"}
{"code": "public static void main(String[] args){\n  OkHttpClient http=new OkHttpClient();\n  try {\n    GoogleUserCredentialProvider provider=new GoogleUserCredentialProvider(http);\n    System.out.println(\"Please go to \" + provider.LOGIN_URL);\n    System.out.println(\"Enter authorisation code:\");\n    Scanner sc=new Scanner(System.in);\n    String access=sc.nextLine();\n    provider.login(access);\n    System.out.println(\"Refresh token:\" + provider.getRefreshToken());\n  }\n catch (  LoginFailedException|RemoteServerException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Example on how to login with Google by asking a token from the user"}
{"code": "private void init(String scope,String category,String name){\n  if (scope == null) {\n    throw new IllegalArgumentException(\"Scope cannot be null\");\n  }\n  if (category == null) {\n    throw new IllegalArgumentException(\"Cagegory cannot be null\");\n  }\n  if (name == null) {\n    throw new IllegalArgumentException(\"Name cannot be null\");\n  }\n  this.scope=scope;\n  this.category=category;\n  this.name=name;\n  this.ts=System.currentTimeMillis();\n}\n", "nl": "Initializes this event"}
{"code": "MyImageIcon(String label){\n  final BufferedImage image=new BufferedImage(16,16,BufferedImage.TYPE_INT_ARGB);\n  Graphics2D g=image.createGraphics();\n  g.setColor((new JButton()).getBackground());\n  g.fillRect(0,0,16,16);\n  g.setFont(new Font(\"Arial\",Font.PLAIN,15));\n  g.setColor(Color.BLACK);\n  g.drawString(label.substring(0,1).toUpperCase(),1,13);\n  g.dispose();\n  setImage(image);\n}\n", "nl": "construct icon"}
{"code": "static int parseMemberID(String nodeName){\n  int id=-1;\n  String[] parts=nodeName.split(\"_\");\n  if (parts.length > 0) {\n    try {\n      id=Integer.parseInt(parts[parts.length - 1]);\n    }\n catch (    NumberFormatException nfe) {\n      id=Integer.MAX_VALUE;\n    }\n  }\n  return id;\n}\n", "nl": "Parse member id generated by zookeeper from given <i>nodeName</i>"}
{"code": "protected void calcModulus(){\n  if (mXAxis == null || !mXAxis.isEnabled())   return;\n  if (!mXAxis.isAxisModulusCustom()) {\n    float[] values=new float[9];\n    mViewPortHandler.getMatrixTouch().getValues(values);\n    mXAxis.mAxisLabelModulus=(int)Math.ceil((mData.getXValCount() * mXAxis.mLabelRotatedWidth) / (mViewPortHandler.contentWidth() * values[Matrix.MSCALE_X]));\n  }\n  if (mLogEnabled)   Log.i(LOG_TAG,\"X-Axis modulus: \" + mXAxis.mAxisLabelModulus + \", x-axis label width: \"+ mXAxis.mLabelWidth+ \", x-axis label rotated width: \"+ mXAxis.mLabelRotatedWidth+ \", content width: \"+ mViewPortHandler.contentWidth());\n  if (mXAxis.mAxisLabelModulus < 1)   mXAxis.mAxisLabelModulus=1;\n}\n", "nl": "calculates the modulus for x-labels and grid"}
{"code": "public void addBitmapToCache(final String data,final BitmapDrawable value,final boolean addBitmapToDisk){\n  if ((data == null) || (value == null)) {\n    return;\n  }\n  if (getBitmapFromMemCache(data) == null) {\n    mMemCache.put(data,value);\n  }\n  if (!addBitmapToDisk) {\n    return;\n  }\nsynchronized (mDiskCacheLock) {\n    if (mDiskLruCache != null && mDiskLruCache.get(data) == null) {\n      mDiskLruCache.put(data,value.getBitmap());\n    }\n  }\n}\n", "nl": "function  for adding bitmap to cache"}
{"code": "synchronized public void saveRobotList(List<RobotUser> robotList){\n  SQLiteDatabase db=dbHelper.getWritableDatabase();\n  if (db.isOpen()) {\n    db.delete(UserDao.ROBOT_TABLE_NAME,null,null);\n    for (    RobotUser item : robotList) {\n      ContentValues values=new ContentValues();\n      values.put(UserDao.ROBOT_COLUMN_NAME_ID,item.getUsername());\n      if (item.getNick() != null)       values.put(UserDao.ROBOT_COLUMN_NAME_NICK,item.getNick());\n      if (item.getAvatar() != null)       values.put(UserDao.ROBOT_COLUMN_NAME_AVATAR,item.getAvatar());\n      db.replace(UserDao.ROBOT_TABLE_NAME,null,values);\n    }\n  }\n}\n", "nl": "Save Robot list"}
{"code": "@Override public void onCreate(){\n  super.onCreate();\n  Log_OC.d(TAG,\"Creating service\");\n  mNotificationManager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);\n  HandlerThread thread=new HandlerThread(\"FileUploaderThread\",Process.THREAD_PRIORITY_BACKGROUND);\n  thread.start();\n  mServiceLooper=thread.getLooper();\n  mServiceHandler=new ServiceHandler(mServiceLooper,this);\n  mBinder=new FileUploaderBinder();\n  mUploadsStorageManager=new UploadsStorageManager(getContentResolver());\n  int failedCounter=mUploadsStorageManager.failInProgressUploads(UploadResult.SERVICE_INTERRUPTED);\n  if (failedCounter > 0) {\n    resurrection();\n  }\n  AccountManager am=AccountManager.get(getApplicationContext());\n  am.addOnAccountsUpdatedListener(this,null,false);\n}\n", "nl": "Service initialization"}
{"code": "private void installSelectorForProtocol(Dict proxySettings,ProtocolDispatchSelector ps,String protocol){\n  String prefix=protocol.trim();\n  if (isActive(proxySettings.get(prefix + \"Enable\"))) {\n    String proxyHost=(String)proxySettings.get(prefix + \"Proxy\");\n    int proxyPort=(Integer)proxySettings.get(prefix + \"Port\");\n    FixedProxySelector fp=new FixedProxySelector(proxyHost,proxyPort);\n    ps.setSelector(protocol.toLowerCase(),fp);\n    Logger.log(getClass(),LogLevel.TRACE,\"OSX uses for {0} the proxy {1}:{2}\",protocol,proxyHost,proxyPort);\n  }\n}\n", "nl": "Installs a proxy selector for the given protocoll on the ProtocolDispatchSelector"}
{"code": "synchronized void store(long maxTxId) throws IOException {\n  if (enabled && currentMax < maxTxId) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Setting maxTxId to \" + maxTxId);\n    }\n    String txidStr=Long.toString(maxTxId);\n    try {\n      zkc.get().setData(path,txidStr.getBytes(\"UTF-8\"),-1);\n      currentMax=maxTxId;\n    }\n catch (    Exception e) {\n      LOG.error(\"Error writing new MaxTxId value {}\",maxTxId,e);\n    }\n  }\n}\n", "nl": "Store the highest TxID encountered so far so that we can enforce the monotonically non-decreasing property This is best effort as this enforcement is only done"}
{"code": "@Override public void onCreate(){\n  super.onCreate();\n  Log_OC.d(TAG,\"Creating service\");\n  HandlerThread thread=new HandlerThread(\"Operations thread\",Process.THREAD_PRIORITY_BACKGROUND);\n  thread.start();\n  mOperationsHandler=new ServiceHandler(thread.getLooper(),this);\n  mOperationsBinder=new OperationsServiceBinder(mOperationsHandler);\n  thread=new HandlerThread(\"Syncfolder thread\",Process.THREAD_PRIORITY_BACKGROUND);\n  thread.start();\n  mSyncFolderHandler=new SyncFolderHandler(thread.getLooper(),this);\n}\n", "nl": "Service initialization"}
{"code": "public synchronized void resetWeather(){\n  Set<WeatherKey> loadedWeathers=new HashSet<WeatherKey>(worldZoneWeathers.keySet());\n  for (  WeatherKey key : loadedWeathers) {\n    WeatherEntry[] oldEntries=worldZoneWeathers.get(key);\n    for (int i=0; i < oldEntries.length; i++) {\n      oldEntries[i]=new WeatherEntry(oldEntries[i].getZoneId(),0);\n    }\n    onWeatherChange(key.getMapId(),null);\n  }\n}\n", "nl": "Allows server to reinitialize Weathers for all regions TODO: not thread safe if run by admin"}
{"code": "public void updateFonts(){\n  final Set<String> openFiles=getCurrentlyOpenRemoteFiles();\n  for (int i=0; i < fileTree.getRowCount(); i++) {\n    DefaultMutableTreeNode v=(DefaultMutableTreeNode)fileTree.getPathForRow(i).getLastPathComponent();\n    String file=leaf2file.get(v);\n    if (file != null) {\n      if (openFiles.contains(service.getServerAndFileName(file))) {\n        int pos=file.lastIndexOf(File.separator);\n        if (pos == -1)         v.setUserObject(file);\n else         v.setUserObject(file.substring(pos + 1));\n      }\n else {\n        String user=v.getUserObject().toString();\n        if (!user.startsWith(\"<html>\"))         v.setUserObject(\"<html><b>\" + user + \"</b></html>\");\n      }\n    }\n  }\n}\n", "nl": "updates fonts used in tree"}
{"code": "public static <T extends GenericEntity>List<T> orderBy(Collection<T> values,List<String> orderBy){\n  if (values == null)   return null;\n  if (values.size() == 0)   return new LinkedList<T>();\n  if (UtilValidate.isEmpty(orderBy)) {\n    List<T> newList=new LinkedList<T>();\n    newList.addAll(values);\n    return newList;\n  }\n  List<T> result=new LinkedList<T>();\n  result.addAll(values);\n  if (Debug.verboseOn())   Debug.logVerbose(\"Sorting \" + values.size() + \" values, orderBy=\"+ orderBy.toString(),module);\n  Collections.sort(result,new OrderByList(orderBy));\n  return result;\n}\n", "nl": "returns the values in the order specified"}
{"code": "public void discardRecording(){\n  if (recorder != null) {\n    try {\n      recorder.stop();\n      recorder.release();\n      recorder=null;\n      if (file != null && file.exists() && !file.isDirectory()) {\n        file.delete();\n      }\n    }\n catch (    IllegalStateException e) {\n    }\ncatch (    RuntimeException e) {\n    }\n    isRecording=false;\n  }\n}\n", "nl": "stop the recoding"}
{"code": "private void writeSudoUserinformationToFile(){\n  PrintWriter pw;\n  try {\n    pw=new PrintWriter(Settings.sServerInfo);\n    pw.println(EncryptionManager.encrypt64bits(sSudoID));\n    pw.println(EncryptionManager.encrypt64bits(sSudoPassword));\n    pw.println(EncryptionManager.encrypt64bits(sEmailAddress));\n    pw.println(EncryptionManager.encrypt64bits(Boolean.toString(isMakeSudoId)));\n    pw.close();\n  }\n catch (  FileNotFoundException e) {\n    System.out.println(\"serverinfo.jrc do not exist\");\n  }\ncatch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "write sudo user information to serverinfo file"}
{"code": "static Buffer fromCSVBuffer(String s) throws IOException {\n  if (s.charAt(0) != '#') {\n    throw new IOException(\"Error deserializing buffer.\");\n  }\n  if (s.length() == 1) {\n    return new Buffer();\n  }\n  int blen=(s.length() - 1) / 2;\n  byte[] barr=new byte[blen];\n  for (int idx=0; idx < blen; idx++) {\n    char c1=s.charAt(2 * idx + 1);\n    char c2=s.charAt(2 * idx + 2);\n    barr[idx]=(byte)Integer.parseInt(\"\" + c1 + c2,16);\n  }\n  return new Buffer(barr);\n}\n", "nl": "Converts a CSV-serialized representation of buffer to a new Buffer"}
{"code": "public static void configurePeriodicSync(Context context,int syncInterval,int flexTime){\n  Account account=getSyncAccount(context);\n  String authority=context.getString(R.string.content_authority);\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n    SyncRequest request=new SyncRequest.Builder().syncPeriodic(syncInterval,flexTime).setSyncAdapter(account,authority).setExtras(new Bundle()).build();\n    ContentResolver.requestSync(request);\n  }\n else {\n    ContentResolver.addPeriodicSync(account,authority,new Bundle(),syncInterval);\n  }\n}\n", "nl": "Helper method to schedule the sync adapter periodic execution"}
{"code": "public boolean sendKeepAlive(){\n  try {\n    if (!isConnected())     return false;\n    _requestPacket.set(LRMIRuntime.DUMMY_OBJECT_ID,0,new Object[]{},true,false,_dummyMethod,-1,OperationPriority.REGULAR,_serviceVersion);\n    _writer.writeRequest(_requestPacket);\n    return true;\n  }\n catch (  Throwable t) {\n    if (_logger.isLoggable(Level.FINE)) {\n      String exMessage=\"LRMI over NIO broken connection with ServerEndPoint: \" + getConnectionURL();\n      _logger.log(Level.FINE,exMessage,t);\n    }\n    return false;\n  }\n}\n", "nl": "Sends a dummy one way request to the server - to check if it's alive"}
{"code": "@Deprecated public static float[] combine(float[] x,float[] y){\n  int len=0;\n  if (x != null)   len+=x.length;\n  if (y != null)   len+=y.length;\n  float[] z=null;\n  if (len > 0) {\n    z=new float[len];\n    int currentPos=0;\n    if (x != null) {\n      System.arraycopy(x,0,z,currentPos,x.length);\n      currentPos=x.length;\n    }\n    if (y != null)     System.arraycopy(y,0,z,currentPos,y.length);\n  }\n  return z;\n}\n", "nl": "Returns the vector [x y]"}
{"code": "public void createJoinIndex(ExpNode root){\n  if (root == null)   return;\n  Stack<ExpNode> stack=new Stack<ExpNode>();\n  stack.push(root);\n  while (!stack.isEmpty()) {\n    ExpNode curr=stack.pop();\n    boolean processChildren=curr.createJoinIndex(this);\n    if (!processChildren)     continue;\n    if (curr.getLeftChild() != null)     stack.push(curr.getLeftChild());\n    if (curr.getRightChild() != null)     stack.push(curr.getRightChild());\n  }\n}\n", "nl": "Traverse the expression root(preorder) and create a join index for given table if possible"}
{"code": "public static TransferTagValueImpl createTransferTagValue(final TagWithAlarms tagWithAlarms){\n  Tag tag=tagWithAlarms.getTag();\n  TransferTagValueImpl tagValue=null;\n  if (tag != null) {\n    tagValue=new TransferTagValueImpl(tag.getId(),tag.getValue(),tag.getValueDescription(),(DataTagQualityImpl)tag.getDataTagQuality(),getTagMode(tag),tag.getTimestamp(),tag instanceof DataTag ? ((DataTag)tag).getDaqTimestamp() : null,tag.getCacheTimestamp(),tag.getDescription());\n    String dataType=isKnownClass(tag.getDataType()) ? getType(tag.getDataType()).getName() : tag.getDataType();\n    tagValue.setValueClassName(dataType);\n    addAlarmValues(tagValue,tagWithAlarms.getAlarms());\n    tagValue.setSimulated(tag.isSimulated());\n  }\n  return tagValue;\n}\n", "nl": "Creates a <code>TransferTagValueImpl</code> object for the given parameters"}
{"code": "@Override public void close(){\n  try {\n    raf.close();\n    System.err.println(\"Closing file: \" + file.getName());\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n}\n", "nl": "close the array"}
{"code": "private boolean addViewItem(int index,boolean first){\n  View view=getItemView(index);\n  if (view != null) {\n    if (first) {\n      itemsLayout.addView(view,0);\n    }\n else {\n      itemsLayout.addView(view);\n    }\n    return true;\n  }\n  return false;\n}\n", "nl": "Adds view for item to items layout"}
{"code": "private static void processPackage(String tbName,Packages pkg){\n  String classNamePrefix=StringUtil.parseHumpName(tbName,true,isHumpModelClass);\n  pkg.setDao(packagePrefix + (StringUtil.isEmpty(packagePrefix) || StringUtil.isEmpty(packageDao) ? \"\" : \".\") + packageDao);\n  pkg.setDaoName(classNamePrefix + daoSuffix);\n  pkg.setModel(packagePrefix + (StringUtil.isEmpty(packagePrefix) || StringUtil.isEmpty(packageModel) ? \"\" : \".\") + packageModel);\n  pkg.setModelName(classNamePrefix + modelSuffix);\n  pkg.setMapperXml(packagePrefix + (StringUtil.isEmpty(packagePrefix) || StringUtil.isEmpty(packageMapperXml) ? \"\" : \".\") + packageMapperXml);\n  pkg.setMapperXmlName(classNamePrefix + mapperXmlSuffix);\n  pkg.setModelNameLowerFirst(StringUtil.lowerFirst(pkg.getModelName()));\n}\n", "nl": "process package and fileName"}
{"code": "@PostConstruct private void init(){\nsynchronized (timerSync) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"init() : Initialising heartbeat mechanism\");\n    }\n    this.lastHeartbeatReceived=System.currentTimeMillis();\n    this.lastHeartbeatEvent=new Heartbeat();\n    this.heartbeatTimer=new Timer();\n    this.heartbeatTimer.scheduleAtFixedRate(this,Heartbeat.getHeartbeatInterval(),Heartbeat.getHeartbeatInterval());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"init() : Heartbeat mechanism started.\");\n    }\n    jmsProxy.registerHeartbeatListener(this);\n  }\n}\n", "nl": "Called by Spring after having created the service"}
{"code": "static FloatList createList(int size){\n  FloatList prev=null;\n  FloatList first=null;\n  for (int i=0; i < size; i++) {\n    FloatList cur=new FloatList();\n    cur.prev=prev;\n    if (prev == null) {\n      first=cur;\n    }\n else {\n      prev.next=cur;\n    }\n    prev=cur;\n  }\n  first.prev=prev;\n  prev.next=first;\n  return first;\n}\n", "nl": "Creates a circular list of nodes of the given size"}
{"code": "private boolean tryToNotifyReset(){\n  if ((mStatus == PTR_STATUS_COMPLETE || mStatus == PTR_STATUS_PREPARE) && mPtrIndicator.isInStartPosition()) {\n    if (mPtrUIHandlerHolder.hasHandler()) {\n      mPtrUIHandlerHolder.onUIReset(this);\n      if (DEBUG) {\n        PtrCLog.i(LOG_TAG,\"PtrUIHandler: onUIReset\");\n      }\n    }\n    mStatus=PTR_STATUS_INIT;\n    clearFlag();\n    return true;\n  }\n  return false;\n}\n", "nl": "If at the top and not in loading, reset"}
{"code": "private void drawTexts(String[] strings,Canvas canvas,float x,float y){\n  Paint.FontMetrics fontMetrics=textPaint.getFontMetrics();\n  float top=fontMetrics.top;\n  float bottom=fontMetrics.bottom;\n  int length=strings.length;\n  float total=(length - 1) * (-top + bottom) + (-fontMetrics.ascent + fontMetrics.descent);\n  float offset=total / 2 - bottom;\n  for (int i=0; i < length; i++) {\n    float yAxis=-(length - i - 1) * (-top + bottom) + offset;\n    canvas.drawText(strings[i],x,y + yAxis,textPaint);\n  }\n}\n", "nl": "draw texts in rows"}
{"code": "@SuppressWarnings(\"unchecked\") public static <T>T newInstance(Class<T> theClass,Configuration conf){\n  T result;\n  try {\n    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);\n    if (meth == null) {\n      meth=theClass.getDeclaredConstructor(EMPTY_ARRAY);\n      meth.setAccessible(true);\n      CONSTRUCTOR_CACHE.put(theClass,meth);\n    }\n    result=meth.newInstance();\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n  setConf(result,conf);\n  return result;\n}\n", "nl": "Create an object for the given class and initialize it from conf"}
{"code": "public VersionChecker(Context ctx,String versionUrl,int iconResId,int uniqueNotificationId,String notificationUrl){\n  handler=new LeakGuardHandlerWrapper<Context>(ctx);\n  this.userAgent=new OkHttpClient();\n  this.versionUrl=versionUrl;\n  this.iconResId=iconResId;\n  this.notificationUrl=notificationUrl;\n  this.uniqueNotificationId=uniqueNotificationId;\n  try {\n    this.currentVersion=ctx.getPackageManager().getPackageInfo(ctx.getPackageName(),0).versionCode;\n  }\n catch (  NameNotFoundException e) {\n  }\n}\n", "nl": "Creates a simple version checker"}
{"code": "public static void skipFully(DataInput in,int len) throws IOException {\n  int total=0;\n  int cur=0;\n  while ((total < len) && ((cur=in.skipBytes(len - total)) > 0)) {\n    total+=cur;\n  }\n  if (total < len) {\n    throw new IOException(\"Not able to skip \" + len + \" bytes, possibly \"+ \"due to end of input.\");\n  }\n}\n", "nl": "Skip <i>len</i> number of bytes in input stream<i>in</i>"}
{"code": "public void formAst(String fullPath,List<String> locations,String className){\n  JavaToJimple jtj=new JavaToJimple();\n  polyglot.frontend.ExtensionInfo extInfo=jtj.initExtInfo(fullPath,locations);\n  if (compiler == null) {\n    compiler=new polyglot.frontend.Compiler(extInfo);\n  }\n  astNode=jtj.compile(compiler,fullPath,extInfo);\n  resolveAST();\n}\n", "nl": "Invokes polyglot and gets the AST for the source given in fullPath"}
{"code": "public synchronized static AccessToken buildAccessToken(String accessToken){\n  if (accessToken == null || \"\".equals(accessToken)) {\n    return null;\n  }\n  try {\n    JSONObject jsonObject=new JSONObject(accessToken);\n    return new AccessToken(jsonObject);\n  }\n catch (  JSONException e) {\n    Log.d(TAG,e.getMessage());\n    return null;\n  }\n}\n", "nl": "build an accessToken from a previously retrieved value"}
{"code": "public void testWriteReadFull() throws Exception {\n  ByteArrayOutputStream out=new ByteArrayOutputStream(0);\n  ObjectOutputStream os=new ObjectOutputStream(out);\n  os.writeObject(full);\n  ObjectInputStream is=new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n  NIOConfiguration copy=(NIOConfiguration)is.readObject();\n  is.close();\n  os.close();\n  assertTrue(helper.areEquals(full,copy));\n}\n", "nl": "Test read and write full ClusterPolicy object"}
{"code": "public boolean recomputeValue(){\n  if (mResourceValue != null) {\n    mResourceValue=null;\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Clears the cached value, if any, and returns true if the value was cleared"}
{"code": "public static String grabNext(String text,String key,String key2){\n  int pos=text.indexOf(key);\n  int length=key.length();\n  if (pos == -1 && key2 != null) {\n    pos=text.indexOf(key2);\n    length=key2.length();\n  }\n  if (pos == -1)   return null;\n else   return new StringTokenizer(text.substring(pos + length).trim()).nextToken();\n}\n", "nl": "grab the next  token after the one in key"}
{"code": "public static JavaRDD<List<List<Writable>>> zeroMeanUnitVarianceSequence(Schema schema,JavaRDD<List<List<Writable>>> sequence,List<String> excludeColumns){\n  DataFrame frame=DataFrames.toDataFrameSequence(schema,sequence);\n  if (excludeColumns == null)   excludeColumns=Arrays.asList(DataFrames.SEQUENCE_UUID_COLUMN,DataFrames.SEQUENCE_INDEX_COLUMN);\n else {\n    excludeColumns=new ArrayList<>(excludeColumns);\n    excludeColumns.add(DataFrames.SEQUENCE_UUID_COLUMN);\n    excludeColumns.add(DataFrames.SEQUENCE_INDEX_COLUMN);\n  }\n  frame=zeromeanUnitVariance(frame,excludeColumns);\n  return DataFrames.toRecordsSequence(frame).getSecond();\n}\n", "nl": "Normalize the sequence by zero mean unit variance"}
{"code": "private void solveConstraints(){\n  IWorklist ptaList=worklist;\n  while (ptaList.has_job()) {\n    IVarAbstraction pn=ptaList.next();\n    pn.do_before_propagation();\n    pn.propagate(this,ptaList);\n    pn.do_after_propagation();\n  }\n}\n", "nl": "We iteratively update the call graph and the constraints list until our demand is satisfied"}
{"code": "public static String encrypt64bits(String Data){\n  Key key;\n  Cipher c;\n  byte[] encVal=null;\n  try {\n    key=generateKey64bits();\n    c=Cipher.getInstance(Settings.ALGO);\n    c.init(Cipher.ENCRYPT_MODE,key);\n    encVal=c.doFinal(Data.getBytes());\n    String encryptedValue=DatatypeConverter.printBase64Binary(encVal);\n    return encryptedValue;\n  }\n catch (  Exception e) {\n    System.out.println(e);\n  }\n  return null;\n}\n", "nl": "this method change the message String to encrypt String using 64bits AES"}
{"code": "static public boolean doesMatch(FindSelection findSelection,IReadBlock readBlock,Pattern pattern){\n  try {\n    if (findSelection.useReadName && matches(pattern,readBlock.getReadName()))     return true;\n    if (findSelection.useReadHeader && matches(pattern,readBlock.getReadHeader()))     return true;\n    if (findSelection.useReadSequence && matches(pattern,readBlock.getReadSequence()))     return true;\n    if (findSelection.useMatchText) {\n      for (int i=0; i < readBlock.getNumberOfAvailableMatchBlocks(); i++) {\n        if (matches(pattern,readBlock.getMatchBlock(i).getText()))         return true;\n      }\n    }\n  }\n catch (  Exception e) {\n  }\n  return false;\n}\n", "nl": "does the given readBlock match the given pattern"}
{"code": "public boolean copyAlignment(){\n  final SelectedBlock selectedBlock=getSelectedBlock();\n  if (selectedBlock.isSelected()) {\n    StringSelection ss=new StringSelection(getSelectedAlignment());\n    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss,null);\n    return true;\n  }\n  return false;\n}\n", "nl": "copy selected alignment to clip-board"}
{"code": "public static String store(String name,File file) throws IOException {\n  FileInputStream in=null;\n  try {\n    in=new FileInputStream(file);\n    String id=id();\n    store(X.EMPTY,id,name,X.EMPTY,0,in.available(),in,-1,true,-1);\n    return id;\n  }\n  finally {\n    if (in != null) {\n      in.close();\n    }\n  }\n}\n", "nl": "store the file in repo"}
{"code": "private static boolean fieldExtendedMatchLimitValue(Object entryValue,Object rangeValue,short matchCode,boolean includeRange){\n  int compareResult=((Comparable)entryValue).compareTo(rangeValue);\nswitch (matchCode) {\ncase TemplateMatchCodes.LE:\ncase TemplateMatchCodes.LT:\n    return (includeRange ? compareResult >= 0 : compareResult > 0);\ncase TemplateMatchCodes.GE:\ncase TemplateMatchCodes.GT:\n  return (includeRange ? compareResult <= 0 : compareResult < 0);\n}\nreturn false;\n}\n", "nl": "check the limit of a range condition in extended matching Note- currently we support only inclusive range at the \"TO\" endpoint"}
{"code": "public void writeString(String str) throws IOException {\n  if (str == null)   writeInt(0);\n else {\n    if (useCompression && str.length() >= Compressor.MIN_SIZE_FOR_DEFLATION) {\n      byte[] bytes=compressor.deflateString2ByteArray(str);\n      writeInt(-bytes.length);\n      outs.write(bytes,0,bytes.length);\n      position+=bytes.length;\n    }\n else {\n      byte[] bytes=str.getBytes(\"UTF-8\");\n      writeInt(bytes.length);\n      outs.write(bytes,0,bytes.length);\n      position+=bytes.length;\n    }\n  }\n}\n", "nl": "write a string, compressed, if long enough"}
{"code": "@Override public void load(InputStream fis) throws IOException {\n  Scanner in=new Scanner(fis);\n  ByteArrayOutputStream out=new ByteArrayOutputStream();\n  while (in.hasNext()) {\n    out.write(in.nextLine().trim().getBytes());\n    out.write(\"\\n\".getBytes());\n  }\n  in.close();\n  InputStream is=new ByteArrayInputStream(out.toByteArray());\n  super.load(is);\n}\n", "nl": "removes trailing whitespace"}
{"code": "public static Map<String,Object> testSOAPService(DispatchContext dctx,Map<String,?> context){\n  Delegator delegator=dctx.getDelegator();\n  Map<String,Object> response=ServiceUtil.returnSuccess();\n  List<GenericValue> testingNodes=new LinkedList<GenericValue>();\n  for (int i=0; i < 3; i++) {\n    GenericValue testingNode=delegator.makeValue(\"TestingNode\");\n    testingNode.put(\"testingNodeId\",\"TESTING_NODE\" + i);\n    testingNode.put(\"description\",\"Testing Node \" + i);\n    testingNode.put(\"createdStamp\",UtilDateTime.nowTimestamp());\n    testingNodes.add(testingNode);\n  }\n  response.put(\"testingNodes\",testingNodes);\n  return response;\n}\n", "nl": "Generic Test SOAP Service"}
{"code": "public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set flipV=\");\n  boolean flip=np.getBoolean();\n  np.matchIgnoreCase(\";\");\n  getViewer().getPcoaTab().setFlipV(flip);\n  try {\n    getViewer().updateDistances();\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static void notifyListChange(String name){\n  java.util.List<String> list=new LinkedList<>();\n  StringTokenizer st=new StringTokenizer(ProgramProperties.get(name,\"\"),\";\");\n  while (st.hasMoreTokens()) {\n    list.add(st.nextToken());\n  }\nsynchronized (propertieslistListeners) {\n    for (    PropertiesListListener listener : propertieslistListeners) {\n      if (listener.isInterested(name))       listener.hasChanged(list);\n    }\n  }\n}\n", "nl": "notify listeners that list of values for the given name has changed"}
{"code": "@Override public MeasureColumnDataChunk readMeasureChunk(FileHolder fileReader,int blockIndex){\n  MeasureColumnDataChunk datChunk=new MeasureColumnDataChunk();\n  ValueCompressonHolder.UnCompressValue copy=values[blockIndex].getNew();\n  copy.setValue(fileReader.readByteArray(filePath,measureColumnChunk.get(blockIndex).getDataPageOffset(),measureColumnChunk.get(blockIndex).getDataPageLength()));\n  CarbonReadDataHolder measureDataHolder=copy.uncompress(compressionModel.getChangedDataType()[blockIndex]).getValues(compressionModel.getDecimal()[blockIndex],compressionModel.getMaxValue()[blockIndex]);\n  datChunk.setMeasureDataHolder(measureDataHolder);\n  datChunk.setNullValueIndexHolder(measureColumnChunk.get(blockIndex).getNullValueIndexForColumn());\n  return datChunk;\n}\n", "nl": "Method to read the blocks data based on block index"}
{"code": "public boolean isSet(_Fields field){\n  if (field == null) {\n    throw new IllegalArgumentException();\n  }\nswitch (field) {\ncase SEQUENCE_ID:\n    return isSetSequenceId();\ncase STATUS:\n  return isSetStatus();\ncase MESSAGE:\nreturn isSetMessage();\n}\nthrow new IllegalStateException();\n}\n", "nl": "Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise"}
{"code": "public void notifyUnlockInput(){\n  if (locked) {\nsynchronized (directorListeners) {\n      IDirectorListener[] listeners=directorListeners.toArray(new IDirectorListener[directorListeners.size()]);\n      for (      IDirectorListener directorListener : listeners) {\n        if (directorListener != this)         directorListener.unlockUserInput();\n      }\n    }\n  }\n  locked=false;\n}\n", "nl": "notify listeners to allow user input"}
{"code": "public void write(IOutputWriter writer,Map<Integer,ListOfLongs> classId2locations) throws IOException {\n  writer.writeInt(map2Weight.size());\n  for (  Object key : map2Weight.keySet()) {\n    writer.writeInt((Integer)key);\n    final Integer sum=map2Weight.get(key);\n    writer.writeInt(sum);\n    if (classId2locations != null) {\n      final ListOfLongs list=classId2locations.get(key);\n      writer.writeInt(list.size());\n      for (int i=0; i < list.size(); i++)       writer.writeLong(list.get(i));\n    }\n else     writer.writeInt(0);\n  }\n}\n", "nl": "write to file"}
{"code": "@RequestMapping(value=\"/apps\",method=RequestMethod.POST) public JsonResponse saveApp(@RequestParam(\"appName\") String appName,@RequestParam(\"appKey\") String appKey,@RequestParam(\"appDesc\") String appDesc,@RequestParam(value=\"inheritAppId\",defaultValue=\"\") Long inheritAppId){\n  App app=new App();\n  app.setAppName(appName);\n  app.setAppKey(appKey);\n  app.setAppDesc(appDesc);\n  Response<Long> saveResp=appService.save(app);\n  if (!saveResp.isSuccess()) {\n    Logs.error(\"failed to save app({}), cause: {}\",app,saveResp.getErr());\n    return JsonResponse.notOk(saveResp.getErr());\n  }\n  appService.inheritConfigs(inheritAppId,saveResp.getData());\n  return JsonResponse.ok(saveResp.getData());\n}\n", "nl": "Save the app"}
{"code": "public Map<String,Object> finalizeOrderEntryOptions(int shipGroupIndex,String shippingMethod,String shippingInstructions,String maySplit,String giftMessage,String isGift,String internalCode,String shipBeforeDate,String shipAfterDate,String orderAdditionalEmails){\n  List<String> errorMessages=new ArrayList<String>();\n  orderAdditionalEmails=cleanVerifyEmailListToString(orderAdditionalEmails,errorMessages);\n  if (errorMessages.size() > 0) {\n    return ServiceUtil.returnError(errorMessages);\n  }\n  this.cart.setOrderAdditionalEmails(orderAdditionalEmails);\n  return finalizeOrderEntryOptions(shipGroupIndex,shippingMethod,shippingInstructions,maySplit,giftMessage,isGift,internalCode,shipBeforeDate,shipAfterDate,null,null);\n}\n", "nl": "Sets the options associated with the order for a given ship group"}
{"code": "@Override protected void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  toolbar=(Toolbar)findViewById(R.id.toolbar);\n  setSupportActionBar(toolbar);\n  getSupportActionBar().setDisplayShowHomeEnabled(true);\n  setupNavigationDrawer();\n  setFragmentContent(currentFragment);\n  showIntro();\n}\n", "nl": "* Overrided Method Letakkan Overrided Method di bawah line ini *"}
{"code": "public void onClick(int id){\nswitch (id) {\ncase 1:\n    startLocationUpdates();\n  break;\ncase 0:\nstopLocationUpdates();\nbreak;\n}\n}\n", "nl": "Called to handle the button clicks in the view"}
{"code": "public List<GenericValue> makeAllOrderItemContactMechs(){\n  List<GenericValue> allOrderContactMechs=new LinkedList<GenericValue>();\n  for (  ShoppingCartItem item : cartLines) {\n    Map<String,String> itemContactMechIds=item.getOrderItemContactMechIds();\n    if (itemContactMechIds != null) {\n      for (      Map.Entry<String,String> entry : itemContactMechIds.entrySet()) {\n        GenericValue orderContactMech=getDelegator().makeValue(\"OrderItemContactMech\");\n        orderContactMech.set(\"contactMechPurposeTypeId\",entry.getKey());\n        orderContactMech.set(\"contactMechId\",entry.getValue());\n        orderContactMech.set(\"orderItemSeqId\",item.getOrderItemSeqId());\n        allOrderContactMechs.add(orderContactMech);\n      }\n    }\n  }\n  return allOrderContactMechs;\n}\n", "nl": "make a list of OrderContactMechs from the ShoppingCart and the ShoppingCartItems"}
{"code": "public static void i(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_INFO) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.i(tag,msg);\n}\n", "nl": "Send an INFO log message"}
{"code": "private boolean hasTextOnlyChildren(Node node){\n  Node child=node;\n  if (child == null) {\n    return false;\n  }\n  child=child.getFirstChild();\n  while (child != null) {\n    int type=child.getNodeType();\n    if (type == Node.ENTITY_REFERENCE_NODE) {\n      return hasTextOnlyChildren(child);\n    }\n else     if (type != Node.TEXT_NODE && type != Node.CDATA_SECTION_NODE && type != Node.ENTITY_REFERENCE_NODE) {\n      return false;\n    }\n    child=child.getNextSibling();\n  }\n  return true;\n}\n", "nl": "Check if an EntityReference node has Text Only child nodes"}
{"code": "public static int currentPlatform(){\n  String os=System.getProperty(\"os.name\");\n  if (os.startsWith(\"Mac OS\")) {\n    return PLATFORM_DARWIN;\n  }\n else   if (os.startsWith(\"Windows\")) {\n    return PLATFORM_WINDOWS;\n  }\n else   if (os.startsWith(\"Linux\")) {\n    return PLATFORM_LINUX;\n  }\n  return PLATFORM_UNKNOWN;\n}\n", "nl": "Returns current platform"}
{"code": "@Override public void onMessageReceived(MessageEvent messageEvent){\n  Bundle data=new Bundle();\n  data.putString(MessageHandler.KEY_PATH,messageEvent.getPath());\n  data.putString(MessageHandler.KEY_SOURCE_NODE_ID,messageEvent.getSourceNodeId());\n  data.putByteArray(MessageHandler.KEY_DATA,messageEvent.getData());\n  Message message=new Message();\n  message.setData(data);\n  notifyMessageHandlers(message);\n}\n", "nl": "Will be called from the Message API if a connected Google API node sent a message to this device"}
{"code": "public void scrollOnce(){\n  if (null != mAdapter && mAdapter.getCount() > 1) {\n    int totalCount=mAdapter.getCount();\n    int currentItem=getCurrentItem();\n    int nextItem=currentItem % totalCount + 1;\n    setCurrentItem(nextItem,true);\n  }\n else {\n    stopAutoScroll();\n  }\n}\n", "nl": "scroll only once"}
{"code": "public void collapseToTop(){\n  getCollapsedIds().clear();\n  if (getTree().getRoot() != null) {\n    for (Edge e=getTree().getRoot().getFirstOutEdge(); e != null; e=getTree().getRoot().getNextOutEdge(e)) {\n      getCollapsedIds().add((Integer)e.getTarget().getInfo());\n    }\n    updateTree();\n  }\n}\n", "nl": "collapse all  nodes at subsystem level"}
{"code": "public Object createProxy(String implem) throws ClassNotFoundException, LuaException {\nsynchronized (L) {\n    if (!isTable())     throw new LuaException(\"Invalid Object. Must be Table.\");\n    StringTokenizer st=new StringTokenizer(implem,\",\");\n    Class[] interfaces=new Class[st.countTokens()];\n    ClassLoader loader=ModuleContext.getInstance().getBaseClassLoader();\n    for (int i=0; st.hasMoreTokens(); i++) {\n      if (loader != null) {\n        interfaces[i]=loader.loadClass(st.nextToken());\n      }\n else {\n        interfaces[i]=Class.forName(st.nextToken());\n      }\n    }\n    InvocationHandler handler=new LuaInvocationHandler(this);\n    return Proxy.newProxyInstance(this.getClass().getClassLoader(),interfaces,handler);\n  }\n}\n", "nl": "Function that creates a java proxy to the object represented by <code>this</code>"}
{"code": "private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,ContrastMethod contrastMethod){\n  ContrastEnhancement contrastEnhancement=(ContrastEnhancement)styleFactory.contrastEnhancement(null,contrastMethod.name());\n  FilterFactory ff=CommonFactoryFinder.getFilterFactory();\n  Map<String,Expression> options=contrastEnhancement.getOptions();\n  options.put(\"algorithm\",ff.literal(\"StretchToMinimumMaximum\"));\n  options.put(\"minValue\",ff.literal(\"1\"));\n  options.put(\"maxValue\",ff.literal(\"5\"));\n  SelectedChannelType channelType=styleFactory.createSelectedChannelType(\"channel name\",contrastEnhancement);\n  SelectedChannelType[] channels=new SelectedChannelType[3];\n  channels[0]=channelType;\n  channels[1]=channelType;\n  channels[2]=channelType;\n  ChannelSelection channelSelection=styleFactory.createChannelSelection(channels);\n  return channelSelection;\n}\n", "nl": "Creates the channel selection object"}
{"code": "public long convert(String value){\n  if (Strings.isNullOrEmpty(value) || TypeUtils.MISSING_INDICATORS.contains(value) || value.equals(\"-1\")) {\n    return MISSING_VALUE;\n  }\n  value=Strings.padStart(value,4,'0');\n  if (selectedFormatter == null) {\n    selectedFormatter=TypeUtils.getDateTimeFormatter(value);\n  }\n  LocalDateTime time;\n  try {\n    time=LocalDateTime.parse(value,selectedFormatter);\n  }\n catch (  DateTimeParseException e) {\n    selectedFormatter=TypeUtils.DATE_TIME_FORMATTER;\n    time=LocalDateTime.parse(value,selectedFormatter);\n  }\n  return PackedLocalDateTime.pack(time);\n}\n", "nl": "Returns a PackedDateTime as converted from the given string"}
{"code": "@Override public int onPatchReceived(String path,boolean isUpgrade){\n  int returnCode=patchCheck(path,isUpgrade);\n  if (returnCode == ShareConstants.ERROR_PATCH_OK) {\n    TinkerPatchService.runPatchService(context,path,isUpgrade);\n  }\n else {\n    Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path),returnCode,isUpgrade);\n  }\n  return returnCode;\n}\n", "nl": "when we receive a patch, what would we do? you can overwrite it"}
{"code": "public boolean duplicateAttribute(String attribute,String newName,boolean allowReplaceSample){\n  if (allowReplaceSample || !table.columnKeySet().contains(newName)) {\n    Map<String,Object> samples2values=table.column(attribute);\n    boolean result=addAttribute(newName,samples2values,true,false);\n    if (result)     attribute2type.put(newName,attribute2type.get(attribute));\n    return result;\n  }\n  return false;\n}\n", "nl": "duplicate an existing attribute"}
{"code": "public void renew(long extension) throws LeaseDeniedException, UnknownLeaseException {\n  _leaseRenewed=true;\n  _leaseRenewedExtension=extension;\n  str.setLease(extension);\n  ParticipantHandle[] phs=parthandles();\n  if (phs == null)   return;\n  for (  ParticipantHandle ph : phs) {\n    renewParticipantLease(ph,extension);\n  }\n}\n", "nl": "Sends renew event to all transaction participants"}
{"code": "XSComplexTypeDecl traverseLocal(Element complexTypeNode,XSDocumentInfo schemaDoc,SchemaGrammar grammar){\n  Object[] attrValues=fAttrChecker.checkAttributes(complexTypeNode,false,schemaDoc);\n  String complexTypeName=genAnonTypeName(complexTypeNode);\n  contentBackup();\n  XSComplexTypeDecl type=traverseComplexTypeDecl(complexTypeNode,complexTypeName,attrValues,schemaDoc,grammar);\n  contentRestore();\n  grammar.addComplexTypeDecl(type,fSchemaHandler.element2Locator(complexTypeNode));\n  type.setIsAnonymous();\n  fAttrChecker.returnAttrArray(attrValues,schemaDoc);\n  return type;\n}\n", "nl": "Traverse local complexType declarations"}
{"code": "public void transform(MatrixN mat){\n  final VectorN tmp=new VectorN(size());\n  for (int i=0; i < size(); i++) {\n    double f=0d;\n    for (int j=0; j < size(); j++)     f+=mat.get(i,j) * get(j);\n    tmp.set(i,f);\n  }\n  set(tmp);\n}\n", "nl": "multiple by given matrix"}
{"code": "public ImageIcon loadImage(String imageName){\n  try {\n    ClassLoader classloader=getClass().getClassLoader();\n    java.net.URL url=classloader.getResource(imageName);\n    if (url != null) {\n      ImageIcon icon=new ImageIcon(url);\n      return icon;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  throw new IllegalArgumentException(\"Unable to load image: \" + imageName);\n}\n", "nl": "Helper method to load an image file from the CLASSPATH"}
{"code": "public static boolean copyFile(String sourceFilePath,String destFilePath){\n  InputStream inputStream=null;\n  try {\n    inputStream=new FileInputStream(sourceFilePath);\n  }\n catch (  FileNotFoundException e) {\n    throw new RuntimeException(\"FileNotFoundException occurred. \",e);\n  }\n  return writeFile(destFilePath,inputStream);\n}\n", "nl": "copy file"}
{"code": "private Director findOpenDirector(String daaFile){\n  final File file=new File(daaFile);\n  if (file.isFile()) {\n    for (    IDirector dir : ProjectManager.getProjects()) {\n      File aFile=new File(((Director)dir).getDocument().getMeganFile().getFileName());\n      if (aFile.isFile() && aFile.equals(file))       return (Director)dir;\n    }\n  }\n  return null;\n}\n", "nl": "get directory if this file is currently open"}
{"code": "protected void remove_impl(Segment<T> segment,ObjectInfo<T> oi){\n  if (oi.isDeleted())   throw new RuntimeException(\" Stored list- called remove but element already deleted !\");\n  if (segment.getSize() == 0)   throw new RuntimeException(\" Stored list- called remove but list is empty !\");\n  oi.setSubject(null);\n  if (oi.getForwardRef() != null)   oi.getForwardRef().setBackwardRef(oi.getBackwardRef());\n  if (oi.getBackwardRef() != null)   oi.getBackwardRef().setForwardRef(oi.getForwardRef());\n  if (segment.getTail() == oi)   segment.setTail(oi.getBackwardRef());\n  segment.decrementSize();\n  _size.decrementAndGet();\n  oi.setDeleted();\n}\n", "nl": "remove an element described by ObjectInfo"}
{"code": "public void takePicture() throws NullPointerException {\n  Intent takePictureIntent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE);\n  if (takePictureIntent.resolveActivity(activity.getPackageManager()) != null) {\n    File photoFile=Utils.createImageFile(context,dirName,imageName,imageType);\n    if (photoFile != null) {\n      cameraBitmapPath=photoFile.getAbsolutePath();\n      takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT,Uri.fromFile(photoFile));\n      activity.startActivityForResult(takePictureIntent,REQUEST_TAKE_PHOTO);\n    }\n else {\n      throw new NullPointerException(\"Bitmap received from camera is null\");\n    }\n  }\n else {\n    throw new NullPointerException(\"Unable to open camera\");\n  }\n}\n", "nl": "Initiate the existing camera apps"}
{"code": "static public void createOutputFiles(Result[] result,String fileDst,boolean bAppend) throws IOException {\n  BufferedWriter output=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileDst,bAppend)));\n  for (  Result res : result) {\n    output.write(\"Gen\" + res.getGenNum() + \":  scale of \"+ res.getScale()+ \"  \"+ res.getRemark()+ \"\\n\");\n  }\n  output.close();\n  System.err.println();\n  System.err.println(\"Results saved to file: \" + fileDst);\n}\n", "nl": "creat the output files"}
{"code": "@Override public void create(final SubEquipmentCacheObject subEquipment) throws SubEquipmentException {\n  if (LOGGER.isDebugEnabled()) {\n    LOGGER.debug(\"create() - Create a subEquipment with the id: \" + subEquipment.getId());\n  }\n  try {\n    subEquipmentMapper.insertSubEquipment(subEquipment);\n  }\n catch (  DataAccessException e) {\n    throw new SubEquipmentException(e.getMessage());\n  }\n}\n", "nl": "Creates a new subEquipment entity in the database"}
{"code": "public static void d(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_DEBUG) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.d(tag,msg);\n}\n", "nl": "Send a DEBUG log message"}
{"code": "protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  int end=indexOf(str,0,len,'T');\n  int dateEnd=getDate(str,0,end,date);\n  getTime(str,end + 1,len,date);\n  if (dateEnd != end) {\n    throw new RuntimeException(str + \" is an invalid dateTime dataype value. \" + \"Invalid character(s) seprating date and time values.\");\n  }\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != 'Z') {\n    normalize(date);\n  }\n  return date;\n}\n", "nl": "Parses, validates and computes normalized version of dateTime object"}
{"code": "private static String addFormatIfAbsent(String sql,String format){\n  sql=sql.trim();\n  String woSemicolon=Patterns.SEMICOLON.matcher(sql).replaceAll(\"\").trim();\n  if (isSelect(sql) && !woSemicolon.endsWith(\" TabSeparatedWithNamesAndTypes\") && !woSemicolon.endsWith(\" TabSeparated\")&& !woSemicolon.endsWith(\" JSONCompact\")) {\n    if (sql.endsWith(\";\")) {\n      sql=sql.substring(0,sql.length() - 1);\n    }\n    sql+=\" FORMAT \" + format + ';';\n  }\n  return sql;\n}\n", "nl": "Adding  FORMAT TabSeparatedWithNamesAndTypes if not added adds format only to select queries"}
{"code": "private void notifyUploadStart(UploadFileOperation upload){\n  mLastPercent=0;\n  mNotificationBuilder=NotificationUtils.newNotificationBuilder(this);\n  mNotificationBuilder.setOngoing(true).setSmallIcon(R.drawable.notification_icon).setTicker(getString(R.string.uploader_upload_in_progress_ticker)).setContentTitle(getString(R.string.uploader_upload_in_progress_ticker)).setProgress(100,0,false).setContentText(String.format(getString(R.string.uploader_upload_in_progress_content),0,upload.getFileName()));\n  Intent showUploadListIntent=new Intent(this,UploadListActivity.class);\n  showUploadListIntent.putExtra(FileActivity.EXTRA_FILE,upload.getFile());\n  showUploadListIntent.putExtra(FileActivity.EXTRA_ACCOUNT,upload.getAccount());\n  showUploadListIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n  mNotificationBuilder.setContentIntent(PendingIntent.getActivity(this,(int)System.currentTimeMillis(),showUploadListIntent,0));\n  if (!upload.isInstantPicture() && !upload.isInstantVideo()) {\n    mNotificationManager.notify(R.string.uploader_upload_in_progress_ticker,mNotificationBuilder.build());\n  }\n}\n", "nl": "Creates a status notification to show the upload progress"}
{"code": "private void parseFuncallSuffix(){\n  PsiBuilder.Marker mark=builder.mark();\n  expect(TokenKind.LPAREN,true);\n  if (matches(TokenKind.RPAREN)) {\n    mark.done(BuildElementTypes.ARGUMENT_LIST);\n    return;\n  }\n  parseFuncallArgument();\n  while (!atAnyOfTokens(FUNCALL_TERMINATOR_SET)) {\n    expect(TokenKind.COMMA);\n    if (atAnyOfTokens(FUNCALL_TERMINATOR_SET)) {\n      break;\n    }\n    parseFuncallArgument();\n  }\n  expect(TokenKind.RPAREN,true);\n  mark.done(BuildElementTypes.ARGUMENT_LIST);\n}\n", "nl": "funcall_suffix ::= '(' arg_list? ')' arg_list ::= ((arg ',')* arg ','? )?"}
{"code": "private void buildViewForMeasuring(){\n  if (itemsLayout != null) {\n    recycle.recycleItems(itemsLayout,firstItem,new ItemsRange());\n  }\n else {\n    createItemsLayout();\n  }\n  int addItems=visibleItems / 2;\n  for (int i=currentItem + addItems; i >= currentItem - addItems; i--) {\n    if (addViewItem(i,true)) {\n      firstItem=i;\n    }\n  }\n}\n", "nl": "Builds view for measuring"}
{"code": "public void startIndexGitRepoJobs(String uniquename){\n  try {\n    Scheduler scheduler=Singleton.getScheduler();\n    JobDetail job=newJob(IndexGitRepoJob.class).withIdentity(\"updateindex-git-\" + uniquename).build();\n    SimpleTrigger trigger=newTrigger().withIdentity(\"updateindex-git-\" + uniquename).withSchedule(simpleSchedule().withIntervalInSeconds(this.INDEXTIME).repeatForever()).build();\n    job.getJobDataMap().put(\"REPOLOCATIONS\",this.REPOLOCATION);\n    job.getJobDataMap().put(\"LOWMEMORY\",this.LOWMEMORY);\n    scheduler.scheduleJob(job,trigger);\n    scheduler.start();\n  }\n catch (  SchedulerException ex) {\n    LOGGER.severe(\" caught a \" + ex.getClass() + \"\\n with message: \"+ ex.getMessage());\n  }\n}\n", "nl": "Creates a git repo indexer job which will pull from the list of git repositories and start indexing them"}
{"code": "@Override public void run(){\n  if (log.isDebugEnabled()) {\n    log.debug(\"[{}] [{}] [{}] Persisted message. cnx {}, sequenceId {}\",producer.topic,producer.producerName,producer.producerId,producer.cnx,sequenceId);\n  }\n  rateIn.recordMultipleEvents(batchSize,msgSize);\n  producer.cnx.ctx().writeAndFlush(Commands.newSendReceipt(producer.producerId,sequenceId,ledgerId,entryId),producer.cnx.ctx().voidPromise());\n  producer.cnx.completedSendOperation();\n  producer.publishOperationCompleted();\n  recycle();\n}\n", "nl": "Executed from I/O thread when sending receipt back to client"}
{"code": "private boolean labelToKeepRec(Node v,Set<Integer> ids,NodeSet keep){\n  boolean hasBelow=false;\n  int id=(Integer)v.getInfo();\n  if (ids.size() == 0 || ids.contains(id))   hasBelow=true;\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    Node w=e.getTarget();\n    if (labelToKeepRec(w,ids,keep))     hasBelow=true;\n  }\n  if (hasBelow)   keep.add(v);\n  return hasBelow;\n}\n", "nl": "label all nodes in tree that we must keep in induced tree"}
{"code": "public void printResults(Writer wr) throws IOException {\n  for (  ResultSinkInfo sink : this.results.keySet()) {\n    wr.write(\"Found a flow to sink \" + sink + \", from the following sources:\\n\");\n    for (    ResultSourceInfo source : this.results.get(sink)) {\n      wr.write(\"\\t- \" + source.getSource() + \"\\n\");\n      if (source.getPath() != null && !source.getPath().isEmpty())       wr.write(\"\\t\\ton Path \" + source.getPath() + \"\\n\");\n    }\n  }\n}\n", "nl": "Prints all results stored in this object to the given writer"}
{"code": "@deprecated public static String canonicalize(String id){\n  initRegionData();\n  String result=(String)territoryAliasMap.get(id);\n  if ((result != null) && (regionIndexMap.containsKey(result))) {\n    return result;\n  }\n  if (regionIndexMap.containsKey(id)) {\n    return id;\n  }\n  return \"ZZ\";\n}\n", "nl": "/*    "}
{"code": "public static FloatList createList(int size){\n  FloatList prev=null;\n  FloatList first=null;\n  for (int i=0; i < size; i++) {\n    FloatList cur=new FloatList();\n    cur.prev=prev;\n    if (prev == null) {\n      first=cur;\n    }\n else {\n      prev.next=cur;\n    }\n    prev=cur;\n  }\n  first.prev=prev;\n  prev.next=first;\n  return first;\n}\n", "nl": "Creates a circular list of nodes of the given size"}
{"code": "public static JavaRDD<List<List<Writable>>> normalizeSequence(Schema schema,JavaRDD<List<List<Writable>>> data,double min,double max,List<String> excludeColumns){\n  if (excludeColumns == null)   excludeColumns=Arrays.asList(DataFrames.SEQUENCE_UUID_COLUMN,DataFrames.SEQUENCE_INDEX_COLUMN);\n else {\n    excludeColumns=new ArrayList<>(excludeColumns);\n    excludeColumns.add(DataFrames.SEQUENCE_UUID_COLUMN);\n    excludeColumns.add(DataFrames.SEQUENCE_INDEX_COLUMN);\n  }\n  DataFrame frame=DataFrames.toDataFrameSequence(schema,data);\n  return DataFrames.toRecordsSequence(normalize(frame,min,max,excludeColumns)).getSecond();\n}\n", "nl": "Normalize each column of a sequence, based on min/max"}
{"code": "public void deactivate(){\n  if (!inSelection) {\n    inSelection=true;\n    try {\n      chartSelection.clearSelectionSeries();\n      this.repaint();\n    }\n  finally {\n      inSelection=false;\n    }\n  }\n}\n", "nl": "call this when tab containing list is deactivated"}
{"code": "private void initializeWebView(){\n  mWebViewClient=new FacebookWebViewClient();\n  setWebViewClient(mWebViewClient);\n  mWebChromeClient=new FacebookWebChromeClient(mContext);\n  setWebChromeClient(mWebChromeClient);\n  mWebSettings=getSettings();\n  mInitialized=true;\n  setDefaults();\n}\n", "nl": "Initialize this WebView and set default values"}
{"code": "public Response doDelete(String url,Object jsonBody){\n  String formJSON=getJsonString(jsonBody);\n  LOGGER.info(curlCallString(\"DELETE\",url,formJSON));\n  long startTime=System.currentTimeMillis();\n  Response response;\n  if (formJSON != null) {\n    response=given().spec(this.requestSpec).body(formJSON).delete(url);\n  }\n else {\n    response=given().spec(this.requestSpec).delete(url);\n  }\n  long endTime=System.currentTimeMillis();\n  long duration=(endTime - startTime);\n  LOGGER.info(\"Duration for DELETE \" + url + \": \"+ duration);\n  return response;\n}\n", "nl": "Does a HTTP DELETE"}
{"code": "public void closeAllFiles(){\n  for (  InputReader r : fileId2raf) {\n    try {\n      if (r != null)       r.close();\n    }\n catch (    Exception ex) {\n    }\n  }\n}\n", "nl": "close all files used for fetching text"}
{"code": "private void removeHelpersSpawn(){\n  for (  Integer object : spawnedNpc) {\n    VisibleObject npc=World.getInstance().findVisibleObject(object);\n    if (npc != null && npc.isSpawned()) {\n      npc.getController().onDelete();\n    }\n  }\n  spawnedNpc.clear();\n}\n", "nl": "Remove Helpers"}
{"code": "ReggieStat(int type,long t,ServiceRegistrar reggie,String[] groups) throws RemoteException {\n  if (type < DISCOVERED || type > DISCARDED)   throw new IllegalArgumentException(\"bad type\");\n  if (reggie == null)   throw new NullPointerException(\"reggie is null\");\n  this.type=type;\n  eventTime=t;\n  this.groups=groups;\n  LookupLocator locator=reggie.getLocator();\n  machine=locator.getHost();\n  port=locator.getPort();\n  serviceID=reggie.getServiceID();\n}\n", "nl": "Create a RegieStat object"}
{"code": "protected GenomicCoords genomicCoordsAllChromMatchInGenome(String query,GenomicCoords currentGc) throws IOException, InvalidGenomicCoordsException {\n  List<IntervalFeature> matchedFeatures=findAllChromMatchInGenome(query,currentGc);\n  if (matchedFeatures.size() == 0) {\n    return currentGc;\n  }\n  String chrom=matchedFeatures.get(0).getChrom();\n  int startFrom=matchedFeatures.get(0).getFrom();\n  int endTo=matchedFeatures.get(matchedFeatures.size() - 1).getTo();\n  GenomicCoords allMatchesGc=new GenomicCoords(chrom,startFrom,endTo,currentGc.getSamSeqDict(),currentGc.getUserWindowSize(),currentGc.getFastaFile());\n  return allMatchesGc;\n}\n", "nl": "Execute findAllChromRegexInGenome() and return the extreme coordinates of the matched features"}
{"code": "public boolean filterOut(final SAMRecord record){\n  if (include) {\n    if (record.getSecondOfPairFlag()) {\n      return false;\n    }\n  }\n else {\n    if (!record.getSecondOfPairFlag()) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "private Map<Integer,Integer[]>[] sortBySample(int numberOfSamples,Map<Integer,Integer[]> taxonMap){\n  Map<Integer,Integer[]>[] sample2TaxonMap=new HashMap[numberOfSamples];\n  for (int i=0; i < numberOfSamples; i++) {\n    sample2TaxonMap[i]=new HashMap<>();\n  }\n  for (  Integer taxId : taxonMap.keySet()) {\n    Integer[] counts=taxonMap.get(taxId);\n    for (int i=0; i < numberOfSamples; i++) {\n      sample2TaxonMap[i].put(taxId,new Integer[]{counts[i]});\n    }\n  }\n  return sample2TaxonMap;\n}\n", "nl": "split into single sample tables"}
{"code": "@Override public String toString(){\n  StringBuilder sb=new StringBuilder();\n  List<String> fullCommand=new ArrayList<>();\n  fullCommand.add(command);\n  fullCommand.addAll(switches);\n  fullCommand.addAll(arguments);\n  sb.append(String.join(\" \",fullCommand));\n  return sb.toString();\n}\n", "nl": "Get the command as a single string"}
{"code": "public char charAt(int pos){\n  if (pos < getLeadingGaps() || pos >= getLength() - getTrailingGaps())   return 0;\n else   if (alignment == null || !alignment.isTranslate())   return block.charAt(pos - getLeadingGaps());\n else {\n    int which=pos - getLeadingGaps();\n    if ((which % 3) == 0) {\n      if (which + 2 < block.length()) {\n        return (char)SequenceUtils.getAminoAcid(block.charAt(which),block.charAt(which + 1),block.charAt(which + 2));\n      }\n else       return block.charAt(which);\n    }\n else     return ' ';\n  }\n}\n", "nl": "get the character at the given position"}
{"code": "private int calculateLayoutWidth(int widthSize,int mode){\n  mItemsLayout.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT));\n  mItemsLayout.measure(MeasureSpec.makeMeasureSpec(widthSize,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  int width=mItemsLayout.getMeasuredWidth();\n  if (mode == MeasureSpec.EXACTLY) {\n    width=widthSize;\n  }\n else {\n    width+=2 * mItemsPadding;\n    width=Math.max(width,getSuggestedMinimumWidth());\n    if (mode == MeasureSpec.AT_MOST && widthSize < width) {\n      width=widthSize;\n    }\n  }\n  mItemsLayout.measure(MeasureSpec.makeMeasureSpec(width - 2 * mItemsPadding,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  return width;\n}\n", "nl": "Calculates control width"}
{"code": "public static int indexOf(Object[] array,Object objectToFind){\n  if (array == null || array.length == 0 || objectToFind == null) {\n    return -1;\n  }\n  for (int i=0; i < array.length; i++) {\n    Object obj=array[i];\n    if (obj.equals(objectToFind)) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "nl": "Get the index of an object"}
{"code": "private void renewLegionRanking(){\n  Map<Integer,Integer> newLegionRankingCache=new HashMap<Integer,Integer>();\n  ArrayList<AbyssRankingResult> elyosRanking=getDAO().getAbyssRankingLegions(Race.ELYOS), asmoRanking=getDAO().getAbyssRankingLegions(Race.ASMODIANS);\n  legions.clear();\n  legions.put(Race.ASMODIANS,new SM_ABYSS_RANKING_LEGIONS(lastUpdate,asmoRanking,Race.ASMODIANS));\n  legions.put(Race.ELYOS,new SM_ABYSS_RANKING_LEGIONS(lastUpdate,elyosRanking,Race.ELYOS));\n  for (  AbyssRankingResult result : elyosRanking) {\n    newLegionRankingCache.put(result.getLegionId(),result.getRankPos());\n  }\n  for (  AbyssRankingResult result : asmoRanking) {\n    newLegionRankingCache.put(result.getLegionId(),result.getRankPos());\n  }\n  LegionService.getInstance().performRankingUpdate(newLegionRankingCache);\n}\n", "nl": "Renews the legion's rank and SM_ABYSS_RANKING_LEGIONS"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"select what=\");\n  final List<String> labels=new LinkedList<>();\n  if (np.peekMatchAnyTokenIgnoreCase(\"all none previous\")) {\n    labels.add(np.getWordMatchesIgnoringCase(\"all none previous\"));\n    np.matchIgnoreCase(\";\");\n  }\n else   labels.addAll(np.getTokensRespectCase(null,\";\"));\n  final ChartViewer viewer=(ChartViewer)getViewer();\n  final LabelsJList list=viewer.getActiveLabelsJList();\n  for (  String name : labels) {\n    if (name.equalsIgnoreCase(\"all\"))     viewer.getChartSelection().setSelected(list.getName(),list.getAllLabels(),true);\n else     if (name.equalsIgnoreCase(\"none\"))     viewer.getChartSelection().clearSelection(list.getName());\n else     if (name.equals(\"previous\"))     viewer.getChartSelection().setSelected(list.getName(),ProjectManager.getPreviouslySelectedNodeLabels(),true);\n else     viewer.getChartSelection().setSelected(list.getName(),Collections.singletonList(name),true);\n  }\n  viewer.repaint();\n}\n", "nl": "parses the given command and executes it"}
{"code": "private byte[] updateNoDictionaryStartAndEndKey(byte[] key){\n  if (key.length == 0) {\n    return key;\n  }\n  ByteBuffer buffer=ByteBuffer.wrap(key,2,key.length - 2);\n  ByteBuffer output=ByteBuffer.allocate(key.length - 2);\n  short numberOfByteToStorLength=2;\n  for (int i=0; i < numberOfNoDictionaryColumn; i++) {\n    output.putShort((short)(buffer.getShort() - numberOfByteToStorLength));\n  }\n  while (buffer.hasRemaining()) {\n    output.put(buffer.get());\n  }\n  output.rewind();\n  return output.array();\n}\n", "nl": "Below method will be used to update the no dictionary start and end key"}
{"code": "public static boolean moveDown(Alignment alignment,int firstRow,int lastRow){\n  firstRow=Math.max(0,firstRow);\n  if (lastRow >= alignment.getNumberOfSequences() - 1)   return false;\n else {\n    Integer[] array=new Integer[alignment.getNumberOfSequences()];\n    for (int i=0; i < alignment.getNumberOfSequences(); i++)     array[i]=alignment.getOrder(i);\n    int replaced=array[lastRow + 1];\n    System.arraycopy(array,firstRow,array,firstRow + 1,lastRow + 1 - firstRow);\n    array[firstRow]=replaced;\n    alignment.setOrder(Arrays.asList(array));\n    return true;\n  }\n}\n", "nl": "move the selected interval of sequences down one"}
{"code": "public static INDArray toArray(Collection<Writable> record,int size){\n  Iterator<Writable> writables=record.iterator();\n  Writable firstWritable=writables.next();\n  if (firstWritable instanceof NDArrayWritable) {\n    NDArrayWritable ret=(NDArrayWritable)firstWritable;\n    return ret.get();\n  }\n else {\n    INDArray vector=Nd4j.create(size);\n    vector.putScalar(0,firstWritable.toDouble());\n    int count=1;\n    while (writables.hasNext()) {\n      Writable w=writables.next();\n      vector.putScalar(count++,w.toDouble());\n    }\n    return vector;\n  }\n}\n", "nl": "Convert a record to an ndarray"}
{"code": "public PersistedServiceJob(DispatchContext dctx,GenericValue jobValue,GenericRequester req){\n  super(dctx,jobValue.getString(\"jobId\"),jobValue.getString(\"jobName\"),null,null,req);\n  this.delegator=dctx.getDelegator();\n  this.jobValue=jobValue;\n  Timestamp storedDate=jobValue.getTimestamp(\"runTime\");\n  this.startTime=storedDate.getTime();\n  this.maxRetry=jobValue.get(\"maxRetry\") != null ? jobValue.getLong(\"maxRetry\").longValue() : -1;\n  Long retryCount=jobValue.getLong(\"currentRetryCount\");\n  if (retryCount != null) {\n    this.currentRetryCount=retryCount.longValue();\n  }\n else {\n    this.currentRetryCount=getRetries(this.delegator);\n  }\n}\n", "nl": "Creates a new PersistedServiceJob"}
{"code": "public static int apply(final ViewerBase viewer,String method,final Distances distances) throws IOException {\n  System.err.println(\"Computing \" + method + \" distances\");\n  double[][] profiles=computeProfiles(viewer.getDocument(),viewer);\n  System.err.println(\"Samples: \" + profiles.length + \" classes: \"+ profiles[0].length);\n  for (int x=0; x < profiles.length; x++) {\n    distances.set(x + 1,x + 1,0);\n    for (int y=x + 1; y < profiles.length; y++) {\n      distances.set(x + 1,y + 1,Math.sqrt(computeJSD(profiles[x],profiles[y])));\n      distances.set(y + 1,x + 1,distances.get(x + 1,y + 1));\n    }\n  }\n  return profiles[0].length;\n}\n", "nl": "apply the named computation to the taxonomy"}
{"code": "private static String[] convert(String arg){\n  StringTokenizer tok=new StringTokenizer(arg,\" ,\");\n  String[] array=new String[tok.countTokens()];\n  int i=0;\n  while (tok.hasMoreTokens()) {\n    array[i]=tok.nextToken();\n    i++;\n  }\n  return (array);\n}\n", "nl": "Convert comma-separated String to array of Strings"}
{"code": "public HuntingRewardCursor queryHuntingRewardItem(long id){\n  QueryHelper qh=new QueryHelper();\n  qh.Columns=null;\n  qh.Table=S.TABLE_HUNTING_REWARDS;\n  qh.Selection=\"h.\" + S.COLUMN_HUNTING_REWARDS_ITEM_ID + \" = ? \";\n  qh.SelectionArgs=new String[]{\"\" + id};\n  qh.GroupBy=null;\n  qh.Having=null;\n  qh.OrderBy=\"m.\" + S.COLUMN_MONSTERS_ID + \" ASC, \"+ \"h.\"+ S.COLUMN_HUNTING_REWARDS_RANK+ \" DESC, \"+ \"h.\"+ S.COLUMN_HUNTING_REWARDS_ID+ \" ASC\";\n  qh.Limit=null;\n  return new HuntingRewardCursor(wrapJoinHelper(builderHuntingReward(),qh));\n}\n", "nl": "****************************** HUNTING REWARD QUERIES"}
{"code": "private static void generator(String vmFile,Packages pkg) throws Exception {\n  Template template=ve.getTemplate(vmFile);\n  VelocityContext vctx=new VelocityContext();\n  vctx.put(\"package\",pkg);\n  StringWriter sw=new StringWriter();\n  template.merge(vctx,sw);\n  String filePath=getFilePath(vmFile,pkg);\n  createFile(filePath,sw.toString());\n}\n", "nl": "generator file"}
{"code": "public void beforeFirst() throws GenericEntityException {\n  try {\n    resultSet.beforeFirst();\n  }\n catch (  SQLException e) {\n    if (!closed) {\n      this.close();\n      Debug.logWarning(\"Warning: auto-closed EntityListIterator because of exception: \" + e.toString(),module);\n    }\n    throw new GenericEntityException(\"Error setting the cursor to beforeFirst\",e);\n  }\n}\n", "nl": "Sets the cursor position to just before the first result so that next() will return the first result"}
{"code": "public double normInf(){\n  double f=0;\n  for (int i=0; i < m; i++) {\n    double s=0;\n    for (int j=0; j < n; j++) {\n      s+=Math.abs(A[i][j]);\n    }\n    f=Math.max(f,s);\n  }\n  return f;\n}\n", "nl": "Infinity norm"}
{"code": "public boolean closeDatabase(String dbfile){\n  if (databases.get(dbfile) != null) {\n    SQLiteDatabase db=(SQLiteDatabase)databases.get(dbfile);\n    db.close();\n    databases.remove(dbfile);\n    return true;\n  }\n  return false;\n}\n", "nl": "Close assets database"}
{"code": "public void addValue(double[] value) throws MathIllegalArgumentException {\n  MathUtils.checkNotNull(value,LocalizedCoreFormats.INPUT_ARRAY);\n  MathUtils.checkDimension(value.length,k);\n  sumImpl.increment(value);\n  sumSqImpl.increment(value);\n  minImpl.increment(value);\n  maxImpl.increment(value);\n  sumLogImpl.increment(value);\n  geoMeanImpl.increment(value);\n  meanImpl.increment(value);\n  covarianceImpl.increment(value);\n  n++;\n}\n", "nl": "Add an n-tuple to the data"}
{"code": "public IObjectInfo<T> add(T subject){\n  lock.lock();\n  try {\n    IObjectInfo<T> oi=store_impl(subject);\n    updateHashAfterInsertion(oi);\n    return oi;\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "store an element"}
{"code": "public static int countOccurrence(String input,char c){\n  if (input == null) {\n    return 0;\n  }\n  int count=0;\n  for (int i=0; i < input.length(); i++) {\n    count=(input.charAt(i) == c) ? (count + 1) : count;\n  }\n  return count;\n}\n", "nl": "Count occurrence of a character in a String"}
{"code": "private ColumnWithIntIndex[] createColumnWithIndexArray(byte[][] keyBlock,boolean isNoDictionary){\n  ColumnWithIntIndex[] columnWithIndexs;\n  if (isNoDictionary) {\n    columnWithIndexs=new ColumnWithIntIndexForHighCard[keyBlock.length];\n    for (int i=0; i < columnWithIndexs.length; i++) {\n      columnWithIndexs[i]=new ColumnWithIntIndexForHighCard(keyBlock[i],i);\n    }\n  }\n else {\n    columnWithIndexs=new ColumnWithIntIndex[keyBlock.length];\n    for (int i=0; i < columnWithIndexs.length; i++) {\n      columnWithIndexs[i]=new ColumnWithIntIndex(keyBlock[i],i);\n    }\n  }\n  return columnWithIndexs;\n}\n", "nl": "Create an object with each column array and respective index"}
{"code": "@Override public void uncaughtException(Thread thread,Throwable ex){\n  if (handleException(ex)) {\n    System.out.println(ex.toString());\n    deletefile(ExternalPath);\n    String fileName=saveCatchInfo2File(ex);\n    sendCrashLog2PM(ExternalPath + fileName);\n  }\n  if (mDefaultHandler != null) {\n    mDefaultHandler.uncaughtException(thread,ex);\n  }\n  android.os.Process.killProcess(android.os.Process.myPid());\n  System.exit(1);\n}\n", "nl": "UncaughtException occurs when the function will be transferred to handle"}
{"code": "public static byte[] inputStreamToByte(InputStream in) throws IOException {\n  ByteArrayOutputStream outStream=new ByteArrayOutputStream();\n  byte[] data=new byte[BUFFER_SIZE];\n  int count=-1;\n  while ((count=in.read(data,0,BUFFER_SIZE)) != -1) {\n    outStream.write(data,0,count);\n  }\n  data=null;\n  return outStream.toByteArray();\n}\n", "nl": "input stream to byte"}
{"code": "@NotNull public static ResizePolicy create(boolean top,boolean right,boolean bottom,boolean left,boolean preserve){\n  int mask=NONE;\n  if (top)   mask|=TOP_EDGE;\n  if (right)   mask|=RIGHT_EDGE;\n  if (bottom)   mask|=BOTTOM_EDGE;\n  if (left)   mask|=LEFT_EDGE;\n  if (preserve)   mask|=PRESERVE_RATIO;\n  return new ResizePolicy(mask);\n}\n", "nl": "Returns a resize policy with the specified resizability along the edges and the given aspect ratio behavior"}
{"code": "public static String join(String glue,String[] items){\n  if (glue == null || items == null) {\n    throw new NullPointerException(\"Null args\");\n  }\n  if (items.length == 0) {\n    return \"\";\n  }\n  StringBuilder sb=new StringBuilder();\n  sb.append(items[0]);\n  for (int i=1; i < items.length; i++) {\n    sb.append(glue).append(items[i]);\n  }\n  return sb.toString();\n}\n", "nl": "Join labels into string"}
{"code": "final public static int insertCollection(V v,Class<? extends Bean> t){\n  Table mapping=(Table)t.getAnnotation(Table.class);\n  if (mapping == null) {\n    if (log.isErrorEnabled())     log.error(\"mapping missed in [\" + t + \"] declaretion\");\n    return -1;\n  }\n  if (!X.isEmpty(mapping.name())) {\n    return insertCollection(mapping.name(),v);\n  }\n  return -1;\n}\n", "nl": "insert into the collection according to the Mapping(collection) declaration"}
{"code": "public static void stopPrisonTask(Player player,boolean save){\n  Future<?> prisonTask=player.getController().getTask(TaskId.PRISON);\n  if (prisonTask != null) {\n    if (save) {\n      long delay=player.getPrisonTimer();\n      if (delay < 0) {\n        delay=0;\n      }\n      player.setPrisonTimer(delay);\n    }\n    player.getController().cancelTask(TaskId.PRISON);\n  }\n}\n", "nl": "This method will stop the prison task"}
{"code": "public void cancelAllTasks(){\n  for (  int i : tasks.keySet()) {\n    Future<?> task=tasks.get(i);\n    if (task != null && i != TaskId.RESPAWN.ordinal()) {\n      task.cancel(false);\n    }\n  }\n  tasks.clear();\n}\n", "nl": "Cancel all tasks associated with this controller (when deleting object)"}
{"code": "public boolean filterOut(final SAMRecord record){\n  if (include) {\n    if (record.getReadNegativeStrandFlag()) {\n      return false;\n    }\n  }\n else {\n    if (!record.getReadNegativeStrandFlag()) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines whether a SAMRecord matches this filter"}
{"code": "private VarAdmin mergeVar(VarAdmin var){\n  boolean changed=true;\n  Set<VarAdmin> varsToMerge=new HashSet<>();\n  while (changed) {\n    List<VarAdmin> vars=varsByName.getOrDefault(var.getName(),Lists.newArrayList());\n    vars.add(var);\n    boolean byNameChange=varsToMerge.addAll(vars);\n    var=Patterns.mergeVars(varsToMerge);\n    boolean byIdChange=var.getId().map(null).orElse(false);\n    var=Patterns.mergeVars(varsToMerge);\n    changed=byNameChange | byIdChange;\n  }\n  return var;\n}\n", "nl": "Merge a variable with any other variables referred to with the same variable name or id"}
{"code": "private void initAndStartRegularSpace() throws Exception, RemoteException {\n  changeSpaceState(ISpaceState.STARTING,true,false);\n  for (int retries=1; retries <= RecoveryManager.RECOVERY_RETRIES; retries++) {\n    try {\n      SpaceRecoverStrategy strategy=_recoveryManager.getRecoveryStrategy(SpaceMode.NONE);\n      ISpaceSynchronizeReplicaState recoveryState=strategy.recover();\n      postRecoveryActions(recoveryState);\n      _componentManager.initComponents();\n      changeSpaceState(ISpaceState.STARTED,true,true);\n      _componentManager.startComponents();\n      break;\n    }\n catch (    Exception e) {\n      handleRecoveryFailure(e,retries);\n    }\n  }\n}\n", "nl": "Initialize and start space without primary election"}
{"code": "public boolean disableCharacteristicIndicate(BluetoothGattCharacteristic characteristic){\n  if (characteristic != null && (characteristic.getProperties() | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {\n    BleLog.w(TAG,\"characteristic.getProperties():\" + characteristic.getProperties());\n    return setCharacteristicIndication(getBluetoothGatt(),characteristic,false);\n  }\n else {\n    return false;\n  }\n}\n", "nl": "stop indicate"}
{"code": "public void testSingleLine() throws Exception {\n  deleteManifest();\n  myFixture.copyFileToProject(BASE_PATH_GLOBAL + \"deprecation/AndroidManifest.xml\",\"AndroidManifest.xml\");\n  myFixture.enableInspections(new AndroidLintInspectionToolProvider.AndroidLintDeprecatedInspection());\n  myFixture.configureFromExistingVirtualFile(myFixture.copyFileToProject(BASE_PATH + \"singleLine.xml\",\"res/layout/singleLine.xml\"));\n  final IntentionAction action=AndroidTestUtils.getIntentionAction(myFixture,\"Replace singleLine=\\\"true\\\" with maxLines=\\\"1\\\"\");\n  assertNotNull(action);\n  doTestWithAction(\"xml\",action);\n}\n", "nl": "Quick fix is available on singleLine=\"true\" and does the right thing"}
{"code": "private void updateTexts(DocumentEvent e){\n  Document doc=e.getDocument();\n  if (doc == projectNameTextField.getDocument() || doc == projectLocationTextField.getDocument()) {\n    String projectName=projectNameTextField.getText();\n    String projectFolder=projectLocationTextField.getText();\n    createdFolderTextField.setText(projectFolder + File.separatorChar + projectName);\n  }\n  panel.fireChangeEvent();\n}\n", "nl": "Handles changes in the Project name and project directory,"}
{"code": "private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,ContrastMethod contrastMethod){\n  ContrastEnhancement contrastEnhancement=(ContrastEnhancement)styleFactory.contrastEnhancement(null,contrastMethod.name());\n  FilterFactory ff=CommonFactoryFinder.getFilterFactory();\n  Map<String,Expression> options=contrastEnhancement.getOptions();\n  options.put(\"algorithm\",ff.literal(\"TestStretchToMinimumMaximum\"));\n  options.put(\"minValue\",ff.literal(\"1.0\"));\n  options.put(\"maxValue\",ff.literal(\"5.0\"));\n  SelectedChannelType channelType=styleFactory.createSelectedChannelType(\"channel name\",contrastEnhancement);\n  SelectedChannelType[] channels=new SelectedChannelType[3];\n  channels[0]=channelType;\n  channels[1]=channelType;\n  channels[2]=channelType;\n  ChannelSelection channelSelection=styleFactory.createChannelSelection(channels);\n  return channelSelection;\n}\n", "nl": "Creates the channel selection error object"}
{"code": "private int calculateLayoutWidth(int widthSize,int mode){\n  initResourcesIfNecessary();\n  itemsLayout.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT));\n  itemsLayout.measure(MeasureSpec.makeMeasureSpec(widthSize,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  int width=itemsLayout.getMeasuredWidth();\n  if (mode == MeasureSpec.EXACTLY) {\n    width=widthSize;\n  }\n else {\n    width+=2 * PADDING;\n    width=Math.max(width,getSuggestedMinimumWidth());\n    if (mode == MeasureSpec.AT_MOST && widthSize < width) {\n      width=widthSize;\n    }\n  }\n  itemsLayout.measure(MeasureSpec.makeMeasureSpec(width - 2 * PADDING,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  return width;\n}\n", "nl": "Calculates control width and creates text layouts"}
{"code": "public CASCDistanceCalculator(String sPathToCasc) throws IOException {\n  PathToCasc=sPathToCasc;\n  Process p=Runtime.getRuntime().exec(PathToCasc);\n  try {\n    p.waitFor();\n  }\n catch (  InterruptedException iee) {\n    return;\n  }\n}\n", "nl": "Creates a new instance of CASCDistanceCalculator"}
{"code": "public void close(){\n  try {\n    if (textStorageReader != null)     textStorageReader.closeAllFiles();\n    if (dataIndexReader != null)     dataIndexReader.close();\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n}\n", "nl": "close associated file or database"}
{"code": "public static String wordPunc(Item item) throws ProcessException {\n  Item ww=item.getItemAs(Relation.TOKEN);\n  if (ww != null && ww.getNext() != null) {\n    return \"\";\n  }\n else {\n    if (ww != null && ww.getParent() != null) {\n      return ww.getParent().getFeatures().getString(\"punc\");\n    }\n else {\n      return \"\";\n    }\n  }\n}\n", "nl": "Gets the punctuation associated with the word"}
{"code": "public static String formatDate(Date date){\n  String formatString=\"\";\n  Calendar cal=Calendar.getInstance();\n  cal.setTime(date);\n  if (cal.isSet(Calendar.MINUTE))   formatString=\"yyyyMMdd'T'hhmmss\";\n else   formatString=\"yyyyMMdd\";\n  SimpleDateFormat formatter=new SimpleDateFormat(formatString);\n  return formatter.format(date);\n}\n", "nl": "Returns a String from a Date object"}
{"code": "private void generateContentProviderLifecycle(Set<String> entryPoints,SootClass currentClass,JNopStmt endClassStmt,Local classLocal){\n  createIfStmt(endClassStmt);\n  JNopStmt startWhileStmt=new JNopStmt();\n  JNopStmt endWhileStmt=new JNopStmt();\n  body.getUnits().add(startWhileStmt);\n  createIfStmt(endWhileStmt);\n  boolean hasAdditionalMethods=false;\n  if (modelAdditionalMethods) {\n    for (    SootMethod currentMethod : currentClass.getMethods())     if (entryPoints.contains(currentMethod.toString()))     hasAdditionalMethods|=createPlainMethodCall(classLocal,currentMethod);\n  }\n  addCallbackMethods(currentClass);\n  body.getUnits().add(endWhileStmt);\n  if (hasAdditionalMethods)   createIfStmt(startWhileStmt);\n}\n", "nl": "Generates the lifecycle for an Android content provider class"}
{"code": "protected SybaseDatabaseType(){\n  String bulkType=System.getProperty(BULK_INSERT_TYPE_KEY,\"jtds\");\n  if (bulkType.equalsIgnoreCase(\"file\")) {\n    forceFile=true;\n  }\n  try {\n    Class<?> aClass=Class.forName(\"com.gs.fw.common.mithra.bulkloader.JtdsBcpBulkLoader\");\n    this.bulkConstructor=aClass.getDeclaredConstructor(String.class,String.class,String.class,Integer.TYPE,SybaseDatabaseType.class,Boolean.TYPE);\n  }\n catch (  Exception e) {\n    getLogger().info(\"Sybase bulk loader not found. Bulk loading disabled.\");\n  }\n}\n", "nl": "Extendable Singleton"}
{"code": "private boolean methodIsAndroidStub(SootMethod method){\n  if (!(Options.v().src_prec() == Options.src_prec_apk && method.getDeclaringClass().isLibraryClass() && SystemClassHandler.isClassInSystemPackage(method.getDeclaringClass().getName())))   return false;\n  for (  Unit u : method.getActiveBody().getUnits()) {\n    if (u instanceof DefinitionStmt) {\n      DefinitionStmt defStmt=(DefinitionStmt)u;\n      if (!(defStmt.getRightOp() instanceof ThisRef) && !(defStmt.getRightOp() instanceof ParameterRef) && !(defStmt.getRightOp() instanceof NewExpr))       return false;\n    }\n else     if (u instanceof InvokeStmt) {\n      InvokeStmt stmt=(InvokeStmt)u;\n      SootMethod callee=stmt.getInvokeExpr().getMethod();\n      if (!callee.getSubSignature().equals(\"void <init>(java.lang.String)\"))       if (!(method.getDeclaringClass().hasSuperclass() && callee.getDeclaringClass() == method.getDeclaringClass().getSuperclass() && callee.getName().equals(\"<init>\")))       return false;\n    }\n else     if (!(u instanceof ThrowStmt))     return false;\n  }\n  return true;\n}\n", "nl": "Checks whether the given method is a library stub method"}
{"code": "private void updateKeyWithLatestBlockKeygenerator(List<Object[]> listBasedResult){\n  try {\n    long[] data=null;\n    ByteArrayWrapper key=null;\n    for (int i=0; i < listBasedResult.size(); i++) {\n      key=(ByteArrayWrapper)listBasedResult.get(i)[0];\n      data=tableBlockExecutionInfos.getBlockKeyGenerator().getKeyArray(key.getDictionaryKey(),tableBlockExecutionInfos.getMaskedByteForBlock());\n      key.setDictionaryKey(QueryUtil.getMaskedKey(restructureInfos.getKeyGenerator().generateKey(data),restructureInfos.getMaxKey(),restructureInfos.getMaskByteRanges(),restructureInfos.getMaskByteRanges().length));\n    }\n  }\n catch (  KeyGenException e) {\n    LOGGER.error(e);\n  }\n}\n", "nl": "Below method will be used to update the fixed length key with the latest block key generator"}
{"code": "public INDArray asRowVector(BufferedImage image){\n  if (centerCropIfNeeded) {\n    image=centerCropIfNeeded(image);\n  }\n  image=scalingIfNeed(image,true);\n  if (channels == 3) {\n    return toINDArrayBGR(image).ravel();\n  }\n  int[][] ret=toIntArrayArray(image);\n  return NDArrayUtil.toNDArray(ArrayUtil.flatten(ret));\n}\n", "nl": "Convert an image in to a row vector"}
{"code": "public static void addRecentFile(String pathName){\n  int maxRecentFiles=ProgramProperties.get(MAXRECENTFILES,20);\n  StringTokenizer st=new StringTokenizer(ProgramProperties.get(RECENTFILES,\"\"),\";\");\n  int count=1;\n  java.util.List<String> recentFiles=new LinkedList<>();\n  recentFiles.add(pathName);\n  while (st.hasMoreTokens()) {\n    String next=st.nextToken();\n    if (!pathName.equals(next)) {\n      recentFiles.add(next);\n      if (++count == maxRecentFiles)       break;\n    }\n  }\n  StringBuilder buf=new StringBuilder();\n  for (  String recentFile : recentFiles)   buf.append(recentFile).append(\";\");\n  ProgramProperties.put(RECENTFILES,buf.toString());\n  notifyListChange(RECENTFILES);\n}\n", "nl": "add a file to the recent files list"}
{"code": "private boolean checkDatabase(){\n  SQLiteDatabase checkDB=null;\n  try {\n    String path=DB_PATH + DB_NAME;\n    checkDB=SQLiteDatabase.openDatabase(path,null,SQLiteDatabase.OPEN_READONLY);\n  }\n catch (  SQLException e) {\n    e.printStackTrace();\n    Log.e(\"DB_ERROR\",\"checkDatabase(): Could not open DB\");\n  }\n  if (checkDB != null)   checkDB.close();\n  return checkDB != null ? true : false;\n}\n", "nl": "check copy database process after copying to database in device"}
{"code": "public boolean containsThumbnail(int userPage,int page,float width,float height,RectF pageRelativeBounds){\n  PagePart fakePart=new PagePart(userPage,page,null,width,height,pageRelativeBounds,true,0);\nsynchronized (thumbnails) {\n    for (    PagePart part : thumbnails) {\n      if (part.equals(fakePart)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n", "nl": "Return true if already contains the described PagePart"}
{"code": "public boolean gotoNext(){\n  if (currentTaxonIterator == null) {\n    gotoFirst();\n  }\n else   if (currentTaxonIterator.hasNext())   currentTaxonId=currentTaxonIterator.next();\n else {\n    currentTaxonIterator=null;\n    currentTaxonId=null;\n  }\n  return isCurrentSet();\n}\n", "nl": "goto the next object"}
{"code": "public int findFirstVisibleItemPosition(){\n  LayoutManager manager=getLayoutManager();\n  int firstVisibleItems=0;\n  if (manager instanceof LinearLayoutManager) {\n    firstVisibleItems=((LinearLayoutManager)manager).findFirstVisibleItemPosition();\n  }\n else   if (manager instanceof GridLayoutManager) {\n    firstVisibleItems=((GridLayoutManager)manager).findFirstVisibleItemPosition();\n  }\n else   if (manager instanceof StaggeredGridLayoutManager) {\n    StaggeredGridLayoutManager sg=((StaggeredGridLayoutManager)manager);\n    int[] items=new int[sg.getSpanCount()];\n    items=((StaggeredGridLayoutManager)manager).findFirstVisibleItemPositions(items);\n    firstVisibleItems=items[0];\n  }\n  return firstVisibleItems;\n}\n", "nl": "if layout manager do not have this method , will return 0"}
{"code": "private static final AttackStatus calculateMainHandResult(Creature attacker,Creature attacked,AttackStatus attackerStatus,int damage,List<AttackResult> attackList){\n  AttackStatus mainHandStatus=attackerStatus;\n  if (mainHandStatus == null) {\n    mainHandStatus=calculatePhysicalStatus(attacker,attacked,true);\n  }\n  int mainHandHits=1;\n  if (attacker instanceof Player) {\n    Item mainHandWeapon=((Player)attacker).getEquipment().getMainHandWeapon();\n    if (mainHandWeapon != null) {\n      mainHandHits=Rnd.get(1,mainHandWeapon.getItemTemplate().getWeaponStats().getHitCount());\n    }\n  }\n else {\n    mainHandHits=Rnd.get(1,3);\n  }\n  splitPhysicalDamage(attacker,attacked,mainHandHits,damage,mainHandStatus,attackList);\n  return mainHandStatus;\n}\n", "nl": "Calculate physical attack status and damage of the MAIN hand"}
{"code": "public void gameServerDisconnected(){\nsynchronized (this) {\n    serverShutdown=true;\n    for (    AionConnection client : loginRequests.values()) {\n      client.close(true);\n    }\n    loginRequests.clear();\n    if (loginServer != null) {\n      loginServer.close(false);\n    }\n  }\n  log.info(\"GameServer disconnected from the Login Server...\");\n}\n", "nl": "When Game Server shutdown, have to close all pending client connection"}
{"code": "@Override public void onSuccess(DLSN value){\n  if (value.getLogSegmentSequenceNo() != currentLogSegmentSeqNo) {\n    LOG.error(\"Ledger Seq No: {}, Expected: {}\",value.getLogSegmentSequenceNo(),currentLogSegmentSeqNo);\n    errorsFound.set(true);\n  }\n  if (verifyEntryId && value.getEntryId() != currentEntryId) {\n    LOG.error(\"EntryId: {}, Expected: {}\",value.getEntryId(),currentEntryId);\n    errorsFound.set(true);\n  }\n  syncLatch.countDown();\n}\n", "nl": "Invoked if the computation completes successfully"}
{"code": "public void handleExceededBacklogQuota(PersistentTopic persistentTopic){\n  DestinationName destination=DestinationName.get(persistentTopic.getName());\n  String namespace=destination.getNamespace();\n  String policyPath=AdminResource.path(\"policies\",namespace);\n  BacklogQuota quota=getBacklogQuota(namespace,policyPath);\n  log.info(\"Backlog quota exceeded for topic [{}]. Applying [{}] policy\",persistentTopic.getName(),quota.getPolicy());\nswitch (quota.getPolicy()) {\ncase consumer_backlog_eviction:\n    dropBacklog(persistentTopic,quota);\n  break;\ncase producer_exception:\ncase producer_request_hold:\ndisconnectProducers(persistentTopic);\nbreak;\ndefault :\nbreak;\n}\n}\n", "nl": "Handle exceeded backlog by using policies set in the zookeeper for given topic"}
{"code": "public static <E>Type<E> valueOf(final Class<E> rawType){\n  if (rawType == null) {\n    return null;\n  }\n else   if (rawType.isAnonymousClass() && rawType.getGenericSuperclass() instanceof ParameterizedType) {\n    ParameterizedType genericSuper=(ParameterizedType)rawType.getGenericSuperclass();\n    return valueOf(genericSuper);\n  }\n else {\n    return intern(rawType,new java.lang.reflect.Type[0],new HashSet<java.lang.reflect.Type>());\n  }\n}\n", "nl": "Resolves the Type value of the specified raw Class type"}
{"code": "public static ITypeDesc checkTableExistence(String tableName,IJSpace space) throws SQLException {\n  try {\n    return ((ISpaceProxy)space).getDirectProxy().getTypeManager().getTypeDescByName(tableName);\n  }\n catch (  SpaceMetadataException ex) {\n    if (ex.getCause() instanceof UnknownTypeException)     throw new SQLException(\"Table [\" + tableName + \"] does not exist\",\"GSP\",-105);\n else     throw ex;\n  }\n}\n", "nl": "Checks if given table (class name) exists in space"}
{"code": "public Math_Vector rotate(double angle){\n  double rad=angle * TO_RADIANS;\n  double cos=Math.cos(rad);\n  double sin=Math.sin(rad);\n  double newX=this.x * cos - this.y * sin;\n  double newY=this.x * sin + this.y * cos;\n  this.x=newX;\n  this.y=newY;\n  return this;\n}\n", "nl": "rotate the vector using angle"}
{"code": "protected void stopJobAcquisitionThread(){\n  if (asyncJobAcquisitionThread != null) {\n    try {\n      asyncJobAcquisitionThread.join();\n    }\n catch (    InterruptedException e) {\n      log.warn(\"Interrupted while waiting for the async job acquisition thread to terminate\",e);\n    }\n    asyncJobAcquisitionThread=null;\n  }\n}\n", "nl": "Stops the acquisition thread"}
{"code": "public static boolean exists(String name){\n  if (cache.contains(name)) {\n    return true;\n  }\n  try {\n    if (Helper.exists(name,Access.class)) {\n      cache.add(name);\n      return true;\n    }\n  }\n catch (  Exception e1) {\n    log.error(e1.getMessage(),e1);\n  }\n  return false;\n}\n", "nl": "check exists of the name"}
{"code": "private void initializeClustering(){\n  assert dataPointSet != null;\n  assert clusterList != null;\n  Iterator<String> it=dataPointSet.iterator();\n  while (it.hasNext()) {\n    ArrayList<String> dataSet=new ArrayList<String>();\n    dataSet.add(it.next());\n    Cluster aCluster=new Cluster(dataSet);\n    clusterList.add(aCluster);\n  }\n}\n", "nl": "To initialize each sample as a single cluster"}
{"code": "public void releaseWriteLockOnKey(K id){\n  if (id != null) {\n    cache.releaseWriteLockOnKey(id);\n    if (LOGGER.isTraceEnabled()) {\n      LOGGER.trace(cache.getName() + \" Released WRITE lock for id=\" + String.valueOf(id));\n    }\n  }\n else {\n    LOGGER.error(\"Trying to release write lock with a NULL key - throwing an exception!\");\n    throw new IllegalArgumentException(\"Trying to release write lock with null key!\");\n  }\n}\n", "nl": "Release a held write lock for the passed in key"}
{"code": "private static long millisecondsToTimeUnit(long milliseconds,int timeUnit){\nswitch (timeUnit) {\ncase TU_MILLISECONDS:\ncase TU_SECONDS:\ncase TU_MINUTES:\ncase TU_HOURS:\ncase TU_DAYS:\n    return Math.abs(milliseconds) / timeUnit;\n}\nreturn -1;\n}\n", "nl": "Convert milliseconds to specific time unit"}
{"code": "private void writeNode(NodeVisitor parentNodeVisitor,AXmlNode node){\n  NodeVisitor childNodeVisitor=parentNodeVisitor.child(node.getNamespace(),node.getTag());\n  if (!node.isIncluded()) {\n    return;\n  }\n  for (  AXmlAttribute<?> attr : node.getAttributes().values()) {\n    String namespace=attr.getNamespace();\n    if (namespace != null && namespace.isEmpty())     namespace=null;\n    int resourceId=attr.getResourceId();\n    if (resourceId < 0 && !node.getTag().equals(\"manifest\"))     resourceId=getAttributeResourceId(attr.getName());\n    int attrType=attr.getAttributeType();\n    if (attrType < 0)     attrType=attr.getType();\n    childNodeVisitor.attr(namespace,attr.getName(),resourceId,attrType,attr.getValue());\n  }\n  for (  AXmlNode child : node.getChildren())   writeNode(childNodeVisitor,child);\n  childNodeVisitor.end();\n}\n", "nl": "Writes out the given node"}
{"code": "public SVNCheckedInChangeSet(SyncInfo[] infos){\n  super();\n  add(infos);\n  initData();\n  String formattedDate;\n  if (date == null)   formattedDate=\"n/a\";\n else   formattedDate=DateFormat.getInstance().format(date);\n  setName(revision + \"  [\" + author+ \"]  (\"+ formattedDate+ \")  \"+ comment);\n}\n", "nl": "Create a checked in change set from the given syncinfos"}
{"code": "public static String encodeXmlValue(String inString){\n  String retString=inString;\n  retString=StringUtil.replaceString(retString,\"&\",\"&amp;\");\n  retString=StringUtil.replaceString(retString,\"<\",\"&lt;\");\n  retString=StringUtil.replaceString(retString,\">\",\"&gt;\");\n  retString=StringUtil.replaceString(retString,\"\\\"\",\"&quot;\");\n  retString=StringUtil.replaceString(retString,\"'\",\"&apos;\");\n  return retString;\n}\n", "nl": "Encodes an XML string replacing the characters '<', '>', '\"', ''', '&'"}
{"code": "public void postMultiply(MatrixN mat){\n  final MatrixN tmp=new MatrixN(size());\n  for (int j=0; j < size(); j++)   for (int i=0; i < size(); i++) {\n    double f=0.;\n    for (int k=0; k < size(); k++)     f+=get(i,k) * mat.get(k,j);\n    tmp.set(i,j,f);\n  }\n  set(tmp);\n}\n", "nl": "post multiple this x mat"}
{"code": "private static int writeMatches(char separator,String readName,IReadBlock readBlock,Writer w) throws IOException {\n  int countMatches=0;\n  if (readBlock.getNumberOfAvailableMatchBlocks() == 0)   w.write(String.format(\"%s%c\\n\",readName,separator));\n else {\n    w.write(readName);\n    for (    IMatchBlock matchBlock : readBlock.getMatchBlocks()) {\n      w.write(String.format(\"%c%d%c%.2f\",separator,matchBlock.getTaxonId(),separator,matchBlock.getBitScore()));\n      countMatches++;\n    }\n    w.write(\"\\n\");\n  }\n  return countMatches;\n}\n", "nl": "write readname and matches to taxa"}
{"code": "private void initResource(){\n  Resources resources=getContext().getResources();\n  try {\n    AssetManager newManager=AssetManager.class.newInstance();\n    Method addAssetPath=newManager.getClass().getMethod(\"addAssetPath\",String.class);\n    addAssetPath.invoke(newManager,DynamicViewManager.getInstance().getUpdateFileFullPath());\n    Resources newResources=new Resources(newManager,resources.getDisplayMetrics(),resources.getConfiguration());\n    Reflect.onObject(getContext()).set(\"mResources\",newResources);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Replace the Resource class in Host Activity"}
{"code": "public static Matrix identity(int m,int n){\n  Matrix A=new Matrix(m,n);\n  double[][] X=A.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      X[i][j]=(i == j ? 1.0 : 0.0);\n    }\n  }\n  return A;\n}\n", "nl": "Generate identity matrix"}
{"code": "private static int computeCountRec(int pid,Node v,ClassificationViewer viewer,int top,NodeIntegerArray numbering){\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    top=computeCountRec(pid,e.getTarget(),viewer,top,numbering);\n  }\n  if (v.getOutDegree() == 0) {\n    NodeData data=viewer.getNodeData(v);\n    if (data != null && data.getSummarized() != null)     top+=data.getSummarized()[pid];\n  }\n  numbering.set(v,top);\n  return top;\n}\n", "nl": "each node is numbered by the count of reads that come before it"}
{"code": "public RTHtml<RTImage,RTAudio,RTVideo> convert(final Spanned text,RTFormat.Html rtFormat){\n  mText=text;\n  mRTFormat=rtFormat;\n  mOut=new StringBuilder();\n  mImages=new ArrayList<>();\n  mParagraphStyles.clear();\n  convertParagraphs();\n  return new RTHtml<>(rtFormat,mOut.toString(),mImages);\n}\n", "nl": "Converts a spanned text to HTML"}
{"code": "private boolean isBeforeEnd(FastConcurrentSkipListMap.Node<K,V> n){\n  if (n == null)   return false;\n  if (hi == null)   return true;\n  K k=n.key;\n  if (k == null)   return true;\n  int c=m.compare(k,hi);\n  if (c > 0 || (c == 0 && !hiInclusive))   return false;\n  return true;\n}\n", "nl": "Returns true if node key is less than upper bound of range"}
{"code": "public void actionPerformed(ActionEvent ev){\n  final File lastOpenFile=ProgramProperties.getFile(ClassificationManager.getMapFileKey(cName,mapType));\n  getDir().notifyLockInput();\n  ImportBlastDialog dialog=(ImportBlastDialog)getParent();\n  final String[] suffixes=(mapType == IdMapper.MapType.Accession ? new String[]{\"map\",\"abin\"} : new String[]{\"map\",\"bin\"});\n  final File file=ChooseFileDialog.chooseFileToOpen(dialog,lastOpenFile,new TextFileFilter(suffixes,true),new TextFileFilter(suffixes,true),ev,\"Open \" + mapType + \" File\");\n  getDir().notifyUnlockInput();\n  if (file != null) {\n    if (file.exists() && file.canRead()) {\n      ProgramProperties.put(ClassificationManager.getMapFileKey(cName,mapType),file);\n      execute(\"load mapFile='\" + file.getPath() + \"' mapType=\"+ mapType+ \" cName=\"+ cName+ \";\");\n    }\n else     NotificationsInSwing.showError(getViewer().getFrame(),\"Failed to open file: \" + file.getPath());\n  }\n}\n", "nl": "action to be performed"}
{"code": "public ConfigurationParser(boolean verify,ClassLoader loader) throws ParserConfigurationException {\n  factory=DocumentBuilderFactory.newInstance();\n  factory.setValidating(verify);\n  factory.setNamespaceAware(true);\n  factory.setExpandEntityReferences(true);\n  factory.setCoalescing(true);\n  builder=factory.newDocumentBuilder();\n  if (verify)   builder.setErrorHandler(new XMLErrorHandler());\n  if (loader == null)   throw new NullPointerException(\"loader is null\");\n}\n", "nl": "Create a new ConfigurationParser"}
{"code": "private static void initiateGatewayFields(final ApplicationContext context){\n  tagManager=context.getBean(TagManager.class);\n  supervisionManager=context.getBean(SupervisionManager.class);\n  commandManager=context.getBean(CommandManager.class);\n  alarmService=context.getBean(AlarmService.class);\n  configurationService=context.getBean(ConfigurationService.class);\n  statisticsService=context.getBean(StatisticsService.class);\n  tagService=context.getBean(TagService.class);\n}\n", "nl": "Initiate the static fields, retrieving it from the <code>context</code>"}
{"code": "public LongArrayList bottom(int n){\n  LongArrayList bottom=new LongArrayList();\n  long[] values=data.toLongArray();\n  LongArrays.parallelQuickSort(values);\n  for (int i=0; i < n && i < values.length; i++) {\n    bottom.add(values[i]);\n  }\n  return bottom;\n}\n", "nl": "Returns the smallest (\"bottom\") n values in the column"}
{"code": "private void inspectConditionsWithBooleans(LinkedList<PsiElement> objBranchConditions){\n  for (  PsiElement objExpression : objBranchConditions) {\n    if (!(objExpression instanceof ConstantReference)) {\n      continue;\n    }\n    if (ExpressionSemanticUtil.isBoolean((ConstantReference)objExpression)) {\n      holder.registerProblem(objExpression,strProblemDescriptionBooleans,ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n    }\n  }\n}\n", "nl": "Checks if any of conditions is boolean"}
{"code": "public void printVectors(double m[][],double v[][]){\n  for (int i=0; i < v.length; i++) {\n    System.out.print(\"  mean[\" + i + \"]: \");\n    for (int j=0; j < m[i].length; j++)     System.out.format(\"%.6f \",m[i][j]);\n    System.out.print(\"\\n  vari[\" + i + \"]: \");\n    for (int j=0; j < v[i].length; j++)     System.out.format(\"%.6f \",v[i][j]);\n    System.out.println();\n  }\n}\n", "nl": "Print mean and variance vectors"}
{"code": "public PDFView(Context context,AttributeSet set){\n  super(context,set);\n  if (isInEditMode()) {\n    return;\n  }\n  cacheManager=new CacheManager();\n  animationManager=new AnimationManager(this);\n  dragPinchManager=new DragPinchManager(this,animationManager);\n  paint=new Paint();\n  debugPaint=new Paint();\n  debugPaint.setStyle(Style.STROKE);\n  pdfiumCore=new PdfiumCore(context);\n  setWillNotDraw(false);\n}\n", "nl": "Construct the initial view"}
{"code": "public static void c2ir(double c[],int nc,double hh[],int leng){\n  hh[0]=Math.exp(c[0]);\n  for (int n=1; n < leng; n++) {\n    double d=0;\n    int upl=(n >= nc) ? nc - 1 : n;\n    for (int k=1; k <= upl; k++)     d+=k * c[k] * hh[n - k];\n    hh[n]=d / n;\n  }\n}\n", "nl": "c2ir: The minimum phase impulse response is evaluated from the minimum phase cepstrum"}
{"code": "public static boolean isFilterClass(String clzName){\n  if (clzName == null || clzName.length() == 0)   return false;\n  for (  String prefix : Constants.FILTER_PREFIX) {\n    if (clzName.startsWith(prefix)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "pass a class name to check if is a filter name"}
{"code": "protected void testAssertMappedValues(double[] data,Object[][] map,Double p,Double tolerance,NaNStrategy nanStrategy){\n  for (  Object[] o : map) {\n    Percentile.EstimationType e=(Percentile.EstimationType)o[0];\n    double expected=(Double)o[1];\n    try {\n      double result=new Percentile(p).withEstimationType(e).withNaNStrategy(nanStrategy).evaluate(data);\n      assertEquals(\"expected[\" + e + \"] = \"+ expected+ \" but was = \"+ result,expected,result,tolerance);\n    }\n catch (    Exception ex) {\n      fail(\"Exception occured for estimation type \" + e + \":\"+ ex.getLocalizedMessage());\n    }\n  }\n}\n", "nl": "Simple test assertion utility method"}
{"code": "@SuppressWarnings(\"ResourceType\") private void initFromAttributes(Context context,AttributeSet attrs){\n  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.CircleProgressBar);\n  mBackgroundColor=a.getColor(R.styleable.CircleProgressBar_background_color,Color.TRANSPARENT);\n  mDrawProgressText=a.getBoolean(R.styleable.CircleProgressBar_draw_progress_text,true);\n  mLineCount=a.getInt(R.styleable.CircleProgressBar_line_count,DEFAULT_LINE_COUNT);\n  mProgressTextFormatPattern=a.hasValue(R.styleable.CircleProgressBar_progress_text_format_pattern) ? a.getString(R.styleable.CircleProgressBar_progress_text_format_pattern) : DEFAULT_PATTERN;\n  mStyle=a.getInt(R.styleable.CircleProgressBar_style,LINE);\n  mShader=a.getInt(R.styleable.CircleProgressBar_progress_shader,LINEAR);\n  mCap=a.hasValue(R.styleable.CircleProgressBar_progress_stroke_cap) ? Paint.Cap.values()[a.getInt(R.styleable.CircleProgressBar_progress_stroke_cap,0)] : Paint.Cap.BUTT;\n  mLineWidth=a.getDimensionPixelSize(R.styleable.CircleProgressBar_line_width,UnitUtils.dip2px(getContext(),DEFAULT_LINE_WIDTH));\n  mProgressTextSize=a.getDimensionPixelSize(R.styleable.CircleProgressBar_progress_text_size,UnitUtils.dip2px(getContext(),DEFAULT_PROGRESS_TEXT_SIZE));\n  mProgressStrokeWidth=a.getDimensionPixelSize(R.styleable.CircleProgressBar_progress_stroke_width,UnitUtils.dip2px(getContext(),DEFAULT_PROGRESS_STROKE_WIDTH));\n  mProgressStartColor=a.getColor(R.styleable.CircleProgressBar_progress_start_color,Color.parseColor(COLOR_FFF2A670));\n  mProgressEndColor=a.getColor(R.styleable.CircleProgressBar_progress_end_color,Color.parseColor(COLOR_FFF2A670));\n  mProgressTextColor=a.getColor(R.styleable.CircleProgressBar_progress_text_color,Color.parseColor(COLOR_FFF2A670));\n  mProgressBackgroundColor=a.getColor(R.styleable.CircleProgressBar_progress_background_color,Color.parseColor(COLOR_FFD3D3D5));\n  a.recycle();\n}\n", "nl": "Basic data initialization"}
{"code": "public Matrix refresh(Matrix newMatrix,View chart,boolean invalidate){\n  mMatrixTouch.set(newMatrix);\n  limitTransAndScale(mMatrixTouch,mContentRect);\n  if (invalidate) {\n    chart.invalidate();\n  }\n  newMatrix.set(mMatrixTouch);\n  return newMatrix;\n}\n", "nl": "call this method to refresh the graph with a given matrix"}
{"code": "private int calcNumberOfLines() throws DataFallbackException {\n  int lines=0;\n  openFallbackInputStream();\n  try {\n    while (getInput().readLine() != null) {\n      lines++;\n    }\n  }\n catch (  IOException e) {\n    throw new DataFallbackException();\n  }\n finally {\n    closeFallbackInputStream();\n  }\n  return lines;\n}\n", "nl": "It checks the number of lines that the fallback log file has"}
{"code": "public Matrix minus(Matrix B){\n  checkMatrixDimensions(B);\n  Matrix X=new Matrix(m,n);\n  double[][] C=X.getArray();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < n; j++) {\n      C[i][j]=A[i][j] - B.A[i][j];\n    }\n  }\n  return X;\n}\n", "nl": "C = A - B"}
{"code": "public void closeConnector(){\n  if (getMeganFile().hasDataConnector()) {\n    try {\n      if (isDirty()) {\n        if (getMeganFile().isReadOnly())         System.err.println(\"File is read-only, discarding changes\");\n else {\n          saveAuxiliaryData();\n        }\n      }\n      MeganFile.removeUIdFromSetOfOpenFiles(getMeganFile().getName(),getMeganFile().getDataConnector().getUId());\n      getMeganFile().setFileName(\"\");\n    }\n catch (    IOException e) {\n      Basic.caught(e);\n    }\n  }\n}\n", "nl": "close connector, if there is one"}
{"code": "static protected Action findAction(String name){\n  if (kit == null)   kit=new DefaultEditorKit();\n  Action[] actions=kit.getActions();\n  for (int i=0; i < kit.getActions().length; i++) {\n    Action action=actions[i];\n    if (action.getValue(AbstractAction.NAME).equals(name))     return action;\n  }\n  return null;\n}\n", "nl": "find the action"}
{"code": "private static String capitalize(String s){\n  if (s == null || s.length() == 0) {\n    return \"\";\n  }\n  char first=s.charAt(0);\n  if (Character.isUpperCase(first)) {\n    return s;\n  }\n else {\n    return Character.toUpperCase(first) + s.substring(1);\n  }\n}\n", "nl": "INTERNAL method that capitalizes the first character of a string"}
{"code": "private void updateNotification(String content){\n  String ticker=String.format(getString(R.string.media_notif_ticker),getString(R.string.app_name));\n  Intent showDetailsIntent=new Intent(this,FileDisplayActivity.class);\n  showDetailsIntent.putExtra(FileActivity.EXTRA_FILE,mFile);\n  showDetailsIntent.putExtra(FileActivity.EXTRA_ACCOUNT,mAccount);\n  showDetailsIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n  mNotificationBuilder.setContentIntent(PendingIntent.getActivity(getApplicationContext(),(int)System.currentTimeMillis(),showDetailsIntent,PendingIntent.FLAG_UPDATE_CURRENT));\n  mNotificationBuilder.setWhen(System.currentTimeMillis());\n  mNotificationBuilder.setTicker(ticker);\n  mNotificationBuilder.setContentTitle(ticker);\n  mNotificationBuilder.setContentText(content);\n  mNotificationManager.notify(R.string.media_notif_ticker,mNotificationBuilder.build());\n}\n", "nl": "Updates the status notification"}
{"code": "private void initialize(Collection<OrganisationUnit> sources,Collection<Period> periods,Collection<ValidationRule> rules){\n  addPeriodsToContext(periods);\n  boolean surveillanceRulesPresent=addRulesToContext(rules);\n  removeAnyUnneededPeriodTypes();\n  addSourcesToContext(sources,true);\n  countOfSourcesToValidate=sources.size();\n  if (surveillanceRulesPresent) {\n    Set<OrganisationUnit> otherDescendants=getAllOtherDescendants(sources);\n    addSourcesToContext(otherDescendants,false);\n  }\n}\n", "nl": "Initializes context values based on sources, periods and rules"}
{"code": "@deprecated public Object clone(){\n  try {\n    CompactByteArray other=(CompactByteArray)super.clone();\n    other.values=((byte[])this.values.clone());\n    other.indices=((char[])this.indices.clone());\n    if (this.hashes != null)     other.hashes=((int[])this.hashes.clone());\n    return other;\n  }\n catch (  CloneNotSupportedException e) {\n    throw new IllegalStateException();\n  }\n}\n", "nl": "/*    "}
{"code": "private Map<String,List<ChartObject>> assembleData(Map<String,Integer> data){\n  Map<String,String> values=new HashMap<>();\n  data.keySet().stream().forEach(null);\n  ChartObject chartObject=new ChartObject();\n  chartObject.setValues(values);\n  Map<String,List<ChartObject>> result=new HashMap<>();\n  result.put(RESULT,Collections.singletonList(chartObject));\n  return result;\n}\n", "nl": "Transform handler output in widget content format"}
{"code": "public void lockUserInput(){\n  locked=true;\n  statusbar.setText1(\"\");\n  statusbar.setText2(\"Busy...\");\n  searchManager.getFindDialogAsToolBar().setEnableCritical(false);\n  if (bottomToolBar != null)   bottomToolBar.setEnabled(false);\n  getCommandManager().setEnableCritical(false);\n  setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n  getContentPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n}\n", "nl": "ask view to prevent user input"}
{"code": "public ReplaceDialog(JTextComponent text,FindReplaceActions finderActions){\n  super(ActionUtils.getFrameFor(text),false);\n  initComponents();\n  registerKeyAction(this);\n  textComponent=text;\n  finder=finderActions;\n  textComponent.addCaretListener(this);\n  setLocationRelativeTo(text.getRootPane());\n}\n", "nl": "Creates new form FindDialog"}
{"code": "private boolean considerTaskExecution(int keyCode){\n  if (keyCode == Config.HALT_TASK && config.isEnabledHaltingKeyPressed()) {\n    currentKeyChain.getKeys().clear();\n    haltAllTasks();\n    return true;\n  }\n  if (disablingFunction.apply(null)) {\n    return true;\n  }\n  UserDefinedAction action=actionMap.get(currentKeyChain);\n  if (action != null) {\n    action.setInvoker(TaskActivation.newBuilder().withHotKey(currentKeyChain.clone()).build());\n    action.setInvokingKeyChain(currentKeyChain.clone());\n  }\n  return startExecutingAction(action);\n}\n", "nl": "Given a new key code coming in, consider start executing an action based on its hotkey"}
{"code": "public void removeContainer(ConstraintWidgetContainer container){\n  ConstraintWidgetContainer parent=(ConstraintWidgetContainer)container.getParent();\n  if (parent == null) {\n    return;\n  }\n  for (  ConstraintWidget widget : mWidgets.values()) {\n    widget.disconnectWidget(container);\n  }\n  ArrayList<ConstraintWidget> children=new ArrayList<>(container.getChildren());\n  for (  ConstraintWidget child : children) {\n    parent.add(child);\n    child.resetAnchors();\n    child.setX(child.getX() + container.getX());\n    child.setY(child.getY() + container.getY());\n  }\n  parent.remove(container);\n  mWidgets.remove(getTag(container));\n}\n", "nl": "Remove container and move its children to the same level"}
{"code": "void applyFacets1(XSFacets facets,short presentFacet,short fixedFacet){\n  try {\n    applyFacets(facets,presentFacet,fixedFacet,SPECIAL_PATTERN_NONE,fDummyContext);\n  }\n catch (  InvalidDatatypeFacetException e) {\n    throw new RuntimeException(\"internal error\");\n  }\n  fIsImmutable=true;\n}\n", "nl": "built-in derived types by restriction"}
{"code": "private void closeStreams(Closeable... streams){\n  if (null != streams) {\n    for (    Closeable stream : streams) {\n      if (null != stream) {\n        try {\n          stream.close();\n        }\n catch (        IOException e) {\n          LOG.error(\"Error while closing stream\" + stream);\n        }\n      }\n    }\n  }\n}\n", "nl": "This method closes the streams"}
{"code": "public void addInsertion(int position,Insertion insert){\n  setHasNewItems(true);\n  int insertPosition=calcInsertPosition(position);\n  if (insertPosition == getItemCount()) {\n    mInserts.add(insert);\n    getItems().add(null);\n  }\n else {\n    mInserts.add(insertPosition,insert);\n    getItems().add(insertPosition,null);\n  }\n  updateCounter(insert);\n  notifyIfNeed();\n}\n", "nl": "Add custom view insertion to adapter"}
