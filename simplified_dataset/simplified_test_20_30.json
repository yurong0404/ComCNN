{"code": "public void appendClass(int classificationId,int srcClassId,int tarClassId){\n  int newSize=getSize(classificationId,srcClassId) + getSize(classificationId,tarClassId);\n  if (newSize > 0) {\n    UpdateItem firstItemSrc=getFirst(classificationId,srcClassId);\n    if (firstItemSrc == null) {\n      System.err.println(\"Warning: srcClassId=\" + srcClassId + \", tarClassId=\"+ tarClassId+ \" firstItemSrc=null\");\n      return;\n    }\n    long readUid=firstItemSrc.getReadUId();\n    while (readUid != 0) {\n      UpdateItem item=readUid2UpdateItem.get(readUid);\n      item.setClassId(classificationId,tarClassId);\n      readUid=item.getNextInClassification(classificationId);\n    }\n    UpdateItem firstItemTar=getFirst(classificationId,tarClassId);\n    if (firstItemTar == null)     setFirst(classificationId,tarClassId,firstItemSrc);\n    UpdateItem lastItemTar=getLast(classificationId,tarClassId);\n    if (lastItemTar != null)     lastItemTar.setNextInClassifaction(classificationId,firstItemSrc.getReadUId());\n    UpdateItem lastItemSrc=getLast(classificationId,srcClassId);\n    setLast(classificationId,tarClassId,lastItemSrc);\n    setSize(classificationId,tarClassId,newSize);\n    removeClass(classificationId,srcClassId);\n    sortChain(classificationId,tarClassId);\n  }\n}\n", "nl": "append the src class to the target class"}
{"code": "public void zoom(float factorX,float factorY,Point center){\n  if (getChartDrawer().isXYLocked()) {\n    if (factorX == 1)     factorX=factorY;\n else     if (factorY == 1)     factorY=factorX;\n  }\n  if (getChartDrawer().getScrollBackReferenceRect() != null) {\n    if (center == null)     center=new Point((int)contentPanel.getBounds().getCenterX(),(int)contentPanel.getBounds().getCenterY());\n    getChartDrawer().setScrollBackWindowPoint(center);\n    getChartDrawer().setScrollBackReferencePoint(getChartDrawer().convertWindowToReference(center));\n  }\n  Dimension size=contentPanel.getSize();\n  int newWidth=Math.max(100,(Math.round(factorX * size.width)));\n  int newHeight=Math.max(100,(Math.round(factorY * size.height)));\n  size=new Dimension(newWidth,newHeight);\n  contentPanel.setSize(size);\n  contentPanel.setPreferredSize(size);\n  contentPanel.validate();\n  updateScrollPane();\n}\n", "nl": "zoom in or out (making panel larger or smaller)"}
{"code": "private void onInbox(int resultCode,Intent data){\n  if (resultCode != Activity.RESULT_OK) {\n    if (data != null && data.hasExtra(Multiplayer.EXTRA_INVITATION)) {\n      Invitation invitation=data.getExtras().getParcelable(Multiplayer.EXTRA_INVITATION);\n      onInvitationRemoved(invitation.getInvitationId());\n    }\n    if (future != null) {\n      future.happen();\n      future=null;\n    }\n    updateInvites();\n    return;\n  }\n  final RoomController c=controller;\n  if (c != null) {\n    throw new IllegalStateException(\"tried to create new game, but there was already another!\");\n  }\n  Invitation invitation=data.getExtras().getParcelable(Multiplayer.EXTRA_INVITATION);\n  joinRoom(invitation);\n  updateInvites();\n}\n", "nl": "on main thread"}
{"code": "public static Map<String,Object> findPartyById(DispatchContext ctx,Map<String,Object> context){\n  Delegator delegator=ctx.getDelegator();\n  String idToFind=(String)context.get(\"idToFind\");\n  String partyIdentificationTypeId=(String)context.get(\"partyIdentificationTypeId\");\n  String searchPartyFirstContext=(String)context.get(\"searchPartyFirst\");\n  String searchAllIdContext=(String)context.get(\"searchAllId\");\n  boolean searchPartyFirst=UtilValidate.isNotEmpty(searchPartyFirstContext) && \"N\".equals(searchPartyFirstContext) ? false : true;\n  boolean searchAllId=UtilValidate.isNotEmpty(searchAllIdContext) && \"Y\".equals(searchAllIdContext) ? true : false;\n  GenericValue party=null;\n  List<GenericValue> partiesFound=null;\n  try {\n    partiesFound=PartyWorker.findPartiesById(delegator,idToFind,partyIdentificationTypeId,searchPartyFirst,searchAllId);\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,module);\n    return ServiceUtil.returnError(e.getMessage());\n  }\n  if (UtilValidate.isNotEmpty(partiesFound)) {\n    party=EntityUtil.getFirst(partiesFound);\n    partiesFound.remove(0);\n  }\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  result.put(\"party\",party);\n  result.put(\"partiesFound\",partiesFound);\n  return result;\n}\n", "nl": "Finds partyId(s) corresponding to a party reference, partyId or a GoodIdentification idValue"}
{"code": "private void callTrains(int trackCode){\n  boolean directionFlipped=false;\n  for (int i=0; i < tracks.length; i++) {\n    if ((1 << i & trackCode) != 0) {\n      if (!directionFlipped) {\n        CGCWorld.getBF().createCar(trainAnchors[i],50,1.25f + (i * 1.7f),false,true);\n        CGCWorld.getBF().createCar(trainAnchors[i],55.5f,1.25f + (i * 1.7f),false,true);\n        CGCWorld.getBF().createCar(trainAnchors[i],61,1.25f + (i * 1.7f),false,true);\n      }\n else {\n        CGCWorld.getBF().createCar(trainAnchors[i],-30,1.25f + (i * 1.7f),false,false);\n        CGCWorld.getBF().createCar(trainAnchors[i],-35.5f,1.25f + (i * 1.7f),false,false);\n        CGCWorld.getBF().createCar(trainAnchors[i],-41,1.25f + (i * 1.7f),false,false);\n      }\n      directionFlipped=!directionFlipped;\n      CGCWorld.getBF().summonTrain(trainIndex);\n      trainIndex++;\n    }\n  }\n}\n", "nl": "Summons a train in a given direction (determined by GetNextByte()) upon the track passed in"}
{"code": "private synchronized void updateResults(){\n  if (mDatabaseUpdated) {\n    return;\n  }\n  final SQLiteDatabase database=mMusicDatabase.getWritableDatabase();\n  database.beginTransaction();\n  int oldestWeekWeCareAbout=mNumberOfWeeksSinceEpoch - NUM_WEEKS + 1;\n  database.delete(SongPlayCountColumns.NAME,SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX + \" < \" + oldestWeekWeCareAbout,null);\n  Cursor cursor=database.query(SongPlayCountColumns.NAME,new String[]{SongPlayCountColumns.ID},null,null,null,null,null);\n  if (cursor != null && cursor.moveToFirst()) {\n    do {\n      updateExistingRow(database,cursor.getLong(0),false);\n    }\n while (cursor.moveToNext());\n    cursor.close();\n    cursor=null;\n  }\n  mDatabaseUpdated=true;\n  database.setTransactionSuccessful();\n  database.endTransaction();\n}\n", "nl": "This updates all the results for the getTopPlayedResults so that we can get an accurate list of the top played results"}
{"code": "@Override @Timed public void assignUserToExports(Assignment assignment,Date date){\n  final String CQL;\n  CQL=\"insert into user_assignment_export \" + \"(experiment_id, user_id, context, created, day_hour, bucket_label, is_bucket_null) \" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n  try {\n    DateHour dateHour=new DateHour();\n    dateHour.setDateHour(date);\n    Date day_hour=dateHour.getDayHour();\n    PreparedCqlQuery<ExperimentsKeyspace.ExperimentIDDayHourComposite,String> query=driver.getKeyspace().prepareQuery(keyspace.userAssignmentExport()).withCql(CQL).asPreparedStatement().withByteBufferValue(assignment.getExperimentID().getRawID(),UUIDSerializer.get()).withByteBufferValue(assignment.getUserID(),UserIDSerializer.get()).withStringValue(assignment.getContext().getContext()).withByteBufferValue(date,DateSerializer.get()).withByteBufferValue(day_hour,DateSerializer.get());\n    if (assignment.getBucketLabel() != null) {\n      query.withByteBufferValue(assignment.getBucketLabel(),BucketLabelSerializer.get());\n      query.withBooleanValue(false);\n    }\n else {\n      query.withStringValue(\"NO_ASSIGNMENT\");\n      query.withBooleanValue(true);\n    }\n    query.execute();\n  }\n catch (  ConnectionException e) {\n    throw new RepositoryException(\"Could not save user assignment in user_assignment_export \\\"\" + assignment + \"\\\"\",e);\n  }\n}\n", "nl": "This column family is meant to be used for exporting user assignments"}
{"code": "public Color mixColors(Color... colors){\n  Validate.noNullElements(colors,\"Colors cannot be null\");\n  int totalRed=this.getRed();\n  int totalGreen=this.getGreen();\n  int totalBlue=this.getBlue();\n  int totalMax=Math.max(Math.max(totalRed,totalGreen),totalBlue);\n  for (  Color color : colors) {\n    totalRed+=color.getRed();\n    totalGreen+=color.getGreen();\n    totalBlue+=color.getBlue();\n    totalMax+=Math.max(Math.max(color.getRed(),color.getGreen()),color.getBlue());\n  }\n  float averageRed=totalRed / (colors.length + 1);\n  float averageGreen=totalGreen / (colors.length + 1);\n  float averageBlue=totalBlue / (colors.length + 1);\n  float averageMax=totalMax / (colors.length + 1);\n  float maximumOfAverages=Math.max(Math.max(averageRed,averageGreen),averageBlue);\n  float gainFactor=averageMax / maximumOfAverages;\n  return Color.fromRGB((int)(averageRed * gainFactor),(int)(averageGreen * gainFactor),(int)(averageBlue * gainFactor));\n}\n", "nl": "Creates a new color with its RGB components changed as if it was dyed with the colors passed in, replicating vanilla workbench dyeing"}
{"code": "public static int removeLastRowsTable(JTable table){\n  if (table.getRowCount() == 0) {\n    return 0;\n  }\n  DefaultTableModel model=(DefaultTableModel)table.getModel();\n  int count=0;\n  while (true) {\n    boolean remove=true;\n    for (int i=0; i < table.getColumnCount(); i++) {\n      String data=getStringValueTable(table,table.getRowCount() - 1,i);\n      if (!data.equals(\"\")) {\n        remove=false;\n        break;\n      }\n    }\n    if (remove) {\n      count++;\n      model.removeRow(model.getRowCount() - 1);\n    }\n else {\n      break;\n    }\n  }\n  return count;\n}\n", "nl": "Remove the last rows of the table that do not contain any data"}
{"code": "private void transfer(Entry[] src,Entry[] dest){\n  for (int j=0; j < src.length; ++j) {\n    Entry e=src[j];\n    src[j]=null;\n    while (e != null) {\n      Entry next=e.next;\n      Object key=e.get();\n      if (key == null || (timeToLive > 0 && ((TimedEntry)e).isExpired(timeToLive))) {\n        e.next=null;\n        size--;\n      }\n else {\n        int i=indexFor(e.hash,dest.length);\n        e.next=dest[i];\n        dest[i]=e;\n      }\n      e=next;\n    }\n  }\n}\n", "nl": "Transfer all entries from src to dest tables"}
{"code": "private void toWagonFormat(IntArrayLeafNode node,DataOutputStream out,String extension,PrintWriter pw) throws IOException {\n  StringBuilder sb=new StringBuilder();\n  int data[]=node.getIntData();\n  sb.append(\"(((\");\n  for (int i=0; i < data.length; i++) {\n    sb.append(\"(\" + data[i] + \" 0)\");\n    if (i + 1 != data.length) {\n      sb.append(\" \");\n    }\n  }\n  sb.append(\") 0))\" + extension);\n  if (out != null) {\n    writeStringToOutput(sb.toString(),out);\n  }\n else {\n  }\n  if (pw != null) {\n    pw.println(sb.toString());\n  }\n}\n", "nl": "Writes the Cart to the given DataOut in Wagon Format"}
{"code": "public int compareTo(Object o){\n  Split split=(Split)o;\n  BitSet P=getFirstPart();\n  BitSet Q=split.getFirstPart();\n  int a=P.nextSetBit(0);\n  int b=Q.nextSetBit(0);\n  while (a > -1 && b > -1) {\n    if (a < b)     return -1;\n else     if (a > b)     return 1;\n    a=P.nextSetBit(a + 1);\n    b=Q.nextSetBit(b + 1);\n  }\n  if (a < b)   return -1;\n else   if (a > b)   return 1;\n  P=getSecondPart();\n  Q=split.getSecondPart();\n  a=P.nextSetBit(0);\n  b=Q.nextSetBit(0);\n  while (a > -1 && b > -1) {\n    if (a < b)     return -1;\n else     if (a > b)     return 1;\n    a=P.nextSetBit(a + 1);\n    b=Q.nextSetBit(b + 1);\n  }\n  if (a < b)   return -1;\n else   if (a > b)   return 1;\n else   return 0;\n}\n", "nl": "compare to a split object"}
{"code": "public void writeDataFile(String filename) throws DataFileException {\n  File outFile=new File(filename);\n  FileOutputStream fos=null;\n  try {\n    fos=new FileOutputStream(outFile);\n  }\n catch (  FileNotFoundException e) {\n    throw new DataFileException(\"Could not open file \" + filename,e);\n  }\n  try {\n    writeDataFile(fos);\n  }\n  finally {\n    try {\n      if (fos != null)       fos.close();\n    }\n catch (    IOException e) {\n      throw new DataFileException(\"Could not close file \" + filename + \", may not have written correctly;\",e);\n    }\n  }\n}\n", "nl": "Writes the records in this DataFile object to a text data file"}
{"code": "private static String handleInvalidChars(String str){\n  String result=\"\";\n  final String replaceAmpresand1=\"&\";\n  final String replaceAmpresand2=\"amp;\";\n  final String replaceAmpresand=replaceAmpresand1 + replaceAmpresand2;\n  final int ampLength=replaceAmpresand2.length();\n  StringTokenizer strTokinizer=new StringTokenizer(str,String.valueOf(replaceAmpresand1),true);\n  while (strTokinizer.hasMoreTokens()) {\n    String token=strTokinizer.nextToken();\n    if (token.startsWith(replaceAmpresand2)) {\n      token=token.substring(ampLength);\n    }\n else     if (token.equals(replaceAmpresand1)) {\n      token=replaceAmpresand;\n    }\n    result+=token;\n  }\n  return result;\n}\n", "nl": "This method goes through passed string and replace each occurrence of '&' to '&amp;'"}
{"code": "public Bitmap processFilter(Bitmap inputImage){\n  Bitmap outputImage=inputImage;\n  if (outputImage != null) {\n    for (    SubFilter subFilter : subFilters) {\n      try {\n        outputImage=subFilter.process(outputImage);\n      }\n catch (      OutOfMemoryError oe) {\n        System.gc();\n        try {\n          outputImage=subFilter.process(outputImage);\n        }\n catch (        OutOfMemoryError ignored) {\n        }\n      }\n    }\n  }\n  return outputImage;\n}\n", "nl": "Give the output Bitmap by applying the defined filter"}
{"code": "private List<byte[]> readDictionaryFile(long dictionaryStartOffset,long dictionaryEndOffset) throws IOException {\n  CarbonDictionaryReaderImpl dictionaryReader=new CarbonDictionaryReaderImpl(this.carbonStorePath,this.carbonTableIdentifier,this.columnIdentifier);\n  List<byte[]> dictionaryValues=new ArrayList<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n  try {\n    if (0 == dictionaryEndOffset) {\n      dictionaryValues=dictionaryReader.read(dictionaryStartOffset);\n    }\n else {\n      Iterator<byte[]> itr=dictionaryReader.read(dictionaryStartOffset,dictionaryEndOffset);\n      while (itr.hasNext()) {\n        dictionaryValues.add(itr.next());\n      }\n    }\n  }\n  finally {\n    dictionaryReader.close();\n  }\n  return dictionaryValues;\n}\n", "nl": "This method will be used to read the dictionary file from a given offset"}
{"code": "public String[] upload_file(String group_name,String master_filename,String prefix_name,String local_filename,String file_ext_name,NameValuePair[] meta_list) throws IOException, MyException {\n  if ((group_name == null || group_name.length() == 0) || (master_filename == null || master_filename.length() == 0) || (prefix_name == null)) {\n    throw new MyException(\"invalid arguement\");\n  }\n  File f=new File(local_filename);\n  FileInputStream fis=new FileInputStream(f);\n  if (file_ext_name == null) {\n    int nPos=local_filename.lastIndexOf('.');\n    if (nPos > 0 && local_filename.length() - nPos <= ProtoCommon.FDFS_FILE_EXT_NAME_MAX_LEN + 1) {\n      file_ext_name=local_filename.substring(nPos + 1);\n    }\n  }\n  try {\n    return this.do_upload_file(ProtoCommon.STORAGE_PROTO_CMD_UPLOAD_SLAVE_FILE,group_name,master_filename,prefix_name,file_ext_name,f.length(),new UploadStream(fis,f.length()),meta_list);\n  }\n  finally {\n    fis.close();\n  }\n}\n", "nl": "upload file to storage server (by file name, slave file mode)"}
{"code": "private void buildJoinInfo(){\n  for (  QueryTableData tableData : query.getTablesData()) {\n    tableData.createJoinIndex(query.getExpTree());\n  }\n  List<LinkedList<QueryTableData>> joinedSequences=new LinkedList<LinkedList<QueryTableData>>();\n  for (int i=0; i < query.getTablesData().size(); i++) {\n    QueryTableData tableData=query.getTablesData().get(i);\n    if (!tableData.isJoined()) {\n      LinkedList<QueryTableData> seq=new LinkedList<QueryTableData>();\n      seq.add(tableData);\n      while (tableData.getJoinTable() != null) {\n        tableData=tableData.getJoinTable();\n        seq.add(tableData);\n      }\n      joinedSequences.add(seq);\n    }\n  }\n  QueryTableData lastJoined=null;\n  for (  LinkedList<QueryTableData> seq : joinedSequences) {\n    if (lastJoined != null) {\n      lastJoined.setJoinTable(seq.getFirst());\n      seq.getFirst().setJoined(true);\n    }\n    lastJoined=seq.getLast();\n  }\n}\n", "nl": "Create join related data structures and relations between tables"}
{"code": "public static <T extends Bean>T load(String collection,Bson query,Bson order,T b){\n  TimeStamp t=TimeStamp.create();\n  try {\n    MongoCollection<Document> db=MongoHelper.getCollection(collection);\n    if (db != null) {\n      FindIterable<Document> d=db.find(query);\n      if (order == null) {\n        d.sort(order);\n      }\n      if (d != null) {\n        if (log.isDebugEnabled())         log.debug(\"load - cost=\" + t.past() + \"ms, collection=\"+ collection+ \", query=\"+ query+ \", order=\"+ order);\n        Document d1=d.first();\n        if (d1 != null) {\n          b.load(d1);\n          return b;\n        }\n      }\n else {\n        if (log.isDebugEnabled())         log.debug(\"load - cost=\" + t.past() + \"ms, collection=\"+ collection+ \", query=\"+ query+ \", order=\"+ order+ \", result=\"+ null);\n      }\n    }\n  }\n catch (  Exception e) {\n    if (log.isErrorEnabled())     log.error(\"query=\" + query + \", order=\"+ order,e);\n  }\n  return null;\n}\n", "nl": "load the data by the query"}
{"code": "public static int copyDir(File src,File dest) throws IOException {\n  dest.mkdirs();\n  int count=0;\n  if (src.isFile()) {\n    count++;\n    copy(src,new File(dest.getCanonicalPath() + \"/\" + src.getName()));\n  }\n else   if (src.isDirectory()) {\n    File[] ff=src.listFiles();\n    if (ff != null && ff.length > 0) {\n      for (      File f : ff) {\n        count+=copyDir(f,new File(dest.getCanonicalPath() + \"/\" + src.getName()));\n      }\n    }\n else {\n      new File(dest.getCanonicalPath() + \"/\" + src.getName()).mkdirs();\n    }\n  }\n  return count;\n}\n", "nl": "copy files"}
{"code": "public int load(IInputReader r) throws IOException {\n  id2SumAndPos.clear();\n  try {\n    int numberOfClasses=0;\n    while (r.getPosition() < r.length()) {\n      int classId=r.readInt();\n      int count=r.readInt();\n      if (count < 0) {\n        setWeightedSum(classId,-count);\n        count=r.readInt();\n      }\n else       setWeightedSum(classId,count);\n      long pos=r.readLong();\n      setSumAndPos(classId,count,pos);\n      numberOfClasses++;\n    }\n    return numberOfClasses;\n  }\n  finally {\n    r.close();\n  }\n}\n", "nl": "read in the classification block from a file"}
{"code": "@Override public void readRep(Repository rep,ObjectId idStep,List<DatabaseMeta> databases,Map<String,Counter> counters) throws KettleException {\n  try {\n    tabelName=rep.getStepAttributeString(idStep,\"TableName\");\n    mdkeySize=rep.getStepAttributeString(idStep,\"MDKeySize\");\n    measureCount=rep.getStepAttributeString(idStep,\"Measurecount\");\n    heirAndKeySize=rep.getStepAttributeString(idStep,\"HeirAndKeySize\");\n    databaseName=rep.getStepAttributeString(idStep,\"databaseName\");\n    tableName=rep.getStepAttributeString(idStep,\"tableName\");\n    groupByEnabled=rep.getStepAttributeString(idStep,\"isGroupByEnabled\");\n    aggregatorClassString=rep.getStepAttributeString(idStep,\"aggregatorClassString\");\n    aggregatorString=rep.getStepAttributeString(idStep,\"aggregatorString\");\n    factDimLensString=rep.getStepAttributeString(idStep,\"factDimLensString\");\n    levelAnddataTypeString=rep.getStepAttributeString(idStep,\"levelAnddataTypeString\");\n    partitionID=rep.getStepAttributeString(idStep,\"partitionID\");\n    segmentId=rep.getStepAttributeString(idStep,\"segmentId\");\n    taskNo=rep.getStepAttributeString(idStep,\"taskNo\");\n  }\n catch (  Exception exception) {\n    throw new KettleException(BaseMessages.getString(PKG,\"CarbonDataWriterStepMeta.Exception.UnexpectedErrorInReadingStepInfo\"),exception);\n  }\n}\n", "nl": "Read the steps information from a Kettle repository"}
{"code": "public static String replaceString(String mainString,String oldString,String newString){\n  if (mainString == null) {\n    return null;\n  }\n  if (UtilValidate.isEmpty(oldString)) {\n    return mainString;\n  }\n  if (newString == null) {\n    newString=\"\";\n  }\n  int i=mainString.lastIndexOf(oldString);\n  if (i < 0)   return mainString;\n  StringBuilder mainSb=new StringBuilder(mainString);\n  while (i >= 0) {\n    mainSb.replace(i,i + oldString.length(),newString);\n    i=mainString.lastIndexOf(oldString,i - 1);\n  }\n  return mainSb.toString();\n}\n", "nl": "Replaces all occurrences of oldString in mainString with newString"}
{"code": "public static String decompressForGzip(byte[] compressed){\n  final int BUFFER_SIZE=compressed.length;\n  GZIPInputStream gis=null;\n  ByteArrayInputStream is=null;\n  try {\n    is=new ByteArrayInputStream(compressed);\n    gis=new GZIPInputStream(is,BUFFER_SIZE);\n    StringBuilder string=new StringBuilder();\n    byte[] data=new byte[BUFFER_SIZE];\n    int bytesRead;\n    while ((bytesRead=gis.read(data)) != -1) {\n      string.append(new String(data,0,bytesRead,\"UTF-8\"));\n    }\n    return string.toString();\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n finally {\n    okhttp3.internal.Util.closeQuietly(gis);\n    okhttp3.internal.Util.closeQuietly(is);\n  }\n  return null;\n}\n", "nl": "gzip decompress 2 string"}
{"code": "public ConstraintWidget findWidgetInSelection(float x,float y){\n  ConstraintWidget found=null;\n  ArrayList<ConstraintWidget> selection=mSelection.getWidgets();\n  for (  ConstraintWidget widget : selection) {\n    WidgetCompanion companion=(WidgetCompanion)widget.getCompanionWidget();\n    WidgetDecorator decorator=companion.getWidgetDecorator(WidgetDecorator.BLUEPRINT_STYLE);\n    if (!decorator.isVisible()) {\n      continue;\n    }\n    if (widget instanceof ConstraintWidgetContainer) {\n      ConstraintWidget f=findWidget((ConstraintWidgetContainer)widget,x,y);\n      if (f != null) {\n        found=f;\n      }\n    }\n else {\n      int l=widget.getDrawX();\n      int t=widget.getDrawY();\n      int r=l + widget.getWidth();\n      int b=t + widget.getHeight();\n      if (x >= l && x <= r && y >= t && y <= b) {\n        found=widget;\n      }\n    }\n  }\n  return found;\n}\n", "nl": "Find a widget at the coordinate (x, y) in the current selection, taking the decorator visibility in account"}
{"code": "public static TransferTagImpl createTransferTag(final TagWithAlarms tagWithAlarms,boolean aliveTag){\n  Tag tag=tagWithAlarms.getTag();\n  TransferTagImpl transferTag=null;\n  if (tag != null) {\n    transferTag=new TransferTagImpl(tag.getId(),tag.getValue(),tag.getValueDescription(),(DataTagQualityImpl)tag.getDataTagQuality(),getTagMode(tag),tag.getTimestamp(),tag instanceof DataTag ? ((DataTag)tag).getDaqTimestamp() : null,tag.getCacheTimestamp(),tag.getDescription(),tag.getName(),tag.getTopic());\n    String dataType=isKnownClass(tag.getDataType()) ? getType(tag.getDataType()).getName() : tag.getDataType();\n    transferTag.setValueClassName(dataType);\n    addAlarmValues(transferTag,tagWithAlarms.getAlarms());\n    transferTag.setSimulated(tag.isSimulated());\n    transferTag.setUnit(tag.getUnit());\n    transferTag.addEquipmentIds(tag.getEquipmentIds());\n    transferTag.addSubEquipmentIds(tag.getSubEquipmentIds());\n    transferTag.addProcessIds(tag.getProcessIds());\n    if (tag.getMetadata() != null) {\n      transferTag.setMetadata(tag.getMetadata().getMetadata());\n    }\n    if (tag instanceof RuleTag) {\n      transferTag.defineRuleExpression(((RuleTag)tag).getRuleExpression());\n    }\n else     if (tag instanceof ControlTag) {\n      transferTag.setControlTagFlag(true);\n      transferTag.setAliveTagFlag(aliveTag);\n    }\n  }\n  return transferTag;\n}\n", "nl": "Creates a <code>TransferTagImpl</code> object for the given parameters"}
{"code": "private void endList(boolean orderedList){\n  if (!mParagraphStyles.isEmpty()) {\n    AccumulatedParagraphStyle style=mParagraphStyles.peek();\n    ParagraphType type=style.getType();\n    if ((orderedList && (type.isNumbering() || type == ParagraphType.INDENTATION_OL)) || (!orderedList && (type.isBullet() || type == ParagraphType.INDENTATION_UL))) {\n      int indent=style.getRelativeIndent();\n      if (indent > 1) {\n        style.setRelativeIndent(indent - 1);\n        style.setAbsoluteIndent(style.getAbsoluteIndent() - 1);\n      }\n else {\n        mParagraphStyles.pop();\n      }\n    }\n else {\n      mParagraphStyles.pop();\n      endList(orderedList);\n    }\n  }\n}\n", "nl": "Handles OL and UL end tags"}
{"code": "public void testIndexCSVBigHTTP() throws Exception {\n  createIndex();\n  send(\"registerFields\",\"{fields: {id: {type: atom, store: true, sort: true}, id2: {type: atom, store: true, sort: true}, body: {type: text, store: true, highlight: true}}}\");\n  send(\"startIndex\");\n  StringBuilder b=new StringBuilder();\n  int size=atLeast(512);\n  for (int i=0; i < 256 * size; i++) {\n    b.append(\"wordy \");\n  }\n  b.append(\" document\");\n  String body=b.toString();\n  assertTrue(body.length() > 512 * 1024);\n  Map<String,Object> params=new HashMap<>();\n  params.put(\"indexName\",server.curIndexName);\n  JSONObject result=server.send(\"bulkCSVAddDocument2\",params,new StringReader(\"id,id2,body\\n0,1,\" + body + \"\\n\"));\n  assertEquals(1,getInt(result,\"indexedDocumentCount\"));\n  refresh();\n  assertEquals(1,getInt(send(\"search\",\"{queryText: document}\"),\"totalHits\"));\n  send(\"stopIndex\");\n  send(\"deleteIndex\");\n}\n", "nl": "Index a document via CSV that's larger than the 512 KB chunk size"}
{"code": "static public void syncClassificationBlock2Summary(int dataSetId,int totalDataSets,IClassificationBlock classificationBlock,DataTable table){\n  final Map<Integer,Integer[]> classId2count=new HashMap<>();\n  table.setClass2Counts(classificationBlock.getName(),classId2count);\n  for (  Integer classId : classificationBlock.getKeySet()) {\n    int sum=classificationBlock.getWeightedSum(classId);\n    if (sum > 0) {\n      if (classId2count.get(classId) == null)       classId2count.put(classId,new Integer[totalDataSets]);\n      Integer total=classId2count.get(classId)[dataSetId];\n      if (total != null)       classId2count.get(classId)[dataSetId]=total + sum;\n else       classId2count.get(classId)[dataSetId]=sum;\n    }\n  }\n  if (table.getAdditionalReads() > 0) {\n    if (classId2count.get(IdMapper.NOHITS_ID) == null)     classId2count.put(IdMapper.NOHITS_ID,new Integer[totalDataSets]);\n    Integer total=classId2count.get(IdMapper.NOHITS_ID)[dataSetId];\n    if (total != null)     classId2count.get(IdMapper.NOHITS_ID)[dataSetId]=total + (int)table.getAdditionalReads();\n else     classId2count.get(IdMapper.NOHITS_ID)[dataSetId]=(int)table.getAdditionalReads();\n  }\n}\n", "nl": "sync classification block to the summary"}
{"code": "public static void test(FileSystem fs,DistributedTestCLI cli,List<JSONObject> pirDataElements) throws Exception {\n  if (cli.run(\"1:J\")) {\n    DistTestSuite.testJSONInputMR(fs,pirDataElements);\n  }\n  if (cli.run(\"1:JS\")) {\n    DistTestSuite.testJSONInputSpark(fs,pirDataElements);\n  }\n  if (cli.run(\"1:SS\")) {\n    DistTestSuite.testSparkStreaming(fs,pirDataElements);\n  }\n  if (cli.run(\"1:JSS\")) {\n    DistTestSuite.testJSONInputSparkStreaming(fs,pirDataElements);\n  }\n  if (cli.run(\"1:E\") || cli.run(\"1:ES\") || cli.run(\"1:ESS\")) {\n    Inputs.createESInput();\n    if (cli.run(\"1:E\")) {\n      DistTestSuite.testESInputMR(fs,pirDataElements);\n    }\n    if (cli.run(\"1:ES\")) {\n      DistTestSuite.testESInputSpark(fs,pirDataElements);\n    }\n    if (cli.run(\"1:ESS\")) {\n      DistTestSuite.testESInputSparkStreaming(fs,pirDataElements);\n    }\n  }\n}\n", "nl": "Execute Tests"}
{"code": "public static byte[] decompressForZlib(byte[] bytesToDecompress){\n  byte[] returnValues=null;\n  Inflater inflater=new Inflater();\n  int numberOfBytesToDecompress=bytesToDecompress.length;\n  inflater.setInput(bytesToDecompress,0,numberOfBytesToDecompress);\n  int bufferSizeInBytes=numberOfBytesToDecompress;\n  int numberOfBytesDecompressedSoFar=0;\n  List<Byte> bytesDecompressedSoFar=new ArrayList<Byte>();\n  try {\n    while (inflater.needsInput() == false) {\n      byte[] bytesDecompressedBuffer=new byte[bufferSizeInBytes];\n      int numberOfBytesDecompressedThisTime=inflater.inflate(bytesDecompressedBuffer);\n      numberOfBytesDecompressedSoFar+=numberOfBytesDecompressedThisTime;\n      for (int b=0; b < numberOfBytesDecompressedThisTime; b++) {\n        bytesDecompressedSoFar.add(bytesDecompressedBuffer[b]);\n      }\n    }\n    returnValues=new byte[bytesDecompressedSoFar.size()];\n    for (int b=0; b < returnValues.length; b++) {\n      returnValues[b]=(byte)(bytesDecompressedSoFar.get(b));\n    }\n  }\n catch (  DataFormatException dfe) {\n    dfe.printStackTrace();\n  }\n  inflater.end();\n  return returnValues;\n}\n", "nl": "zlib decompress 2 byte"}
{"code": "public static StateListDrawable btnSelector(float radius,int normalColor,int pressColor,int postion){\n  StateListDrawable bg=new StateListDrawable();\n  Drawable normal=null;\n  Drawable pressed=null;\n  if (postion == 0) {\n    normal=cornerDrawable(normalColor,new float[]{0,0,0,0,0,0,radius,radius});\n    pressed=cornerDrawable(pressColor,new float[]{0,0,0,0,0,0,radius,radius});\n  }\n else   if (postion == 1) {\n    normal=cornerDrawable(normalColor,new float[]{0,0,0,0,radius,radius,0,0});\n    pressed=cornerDrawable(pressColor,new float[]{0,0,0,0,radius,radius,0,0});\n  }\n else   if (postion == -1) {\n    normal=cornerDrawable(normalColor,new float[]{0,0,0,0,radius,radius,radius,radius});\n    pressed=cornerDrawable(pressColor,new float[]{0,0,0,0,radius,radius,radius,radius});\n  }\n else   if (postion == -2) {\n    normal=cornerDrawable(normalColor,radius);\n    pressed=cornerDrawable(pressColor,radius);\n  }\n  bg.addState(new int[]{-android.R.attr.state_pressed},normal);\n  bg.addState(new int[]{android.R.attr.state_pressed},pressed);\n  return bg;\n}\n", "nl": "set btn selector with corner drawable for special position"}
{"code": "private static String parseIdentifierEscape(String stmt,int offset){\n  StringBuilder sb=new StringBuilder();\n  loop:   for (++offset; offset < stmt.length(); ++offset) {\n    char c=stmt.charAt(offset);\n    if (c == '`') {\n      if (offset + 1 < stmt.length() && stmt.charAt(offset + 1) == '`') {\n        ++offset;\n        sb.append('`');\n      }\n else {\n        break loop;\n      }\n    }\n else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}\n", "nl": "<code>AS `abc`</code>"}
{"code": "private void initCreateGameDBSchema() throws SQLException {\n  ResultSet rs;\n  rs=stmt.executeQuery(\"show tables from test like'tictactoc'\");\n  if (false == rs.next()) {\n    String sql=\"CREATE TABLE tictactoc \" + \"(id varchar(10) not NULL, \" + \" win integer(1), \"+ \" defeat integer(1), \"+ \" playtimes integer(1), \"+ \" PRIMARY KEY ( id ),\"+ \"FOREIGN KEY (id) REFERENCES userinformation (id)) Engine=Innodb default charset = utf8\";\n    stmt.executeUpdate(sql);\n  }\n  rs=stmt.executeQuery(\"show tables from test like'catchme'\");\n  if (false == rs.next()) {\n    String sql=\"CREATE TABLE catchme \" + \"(id varchar(10) not NULL, \" + \" win integer(1), \"+ \" defeat integer(1), \"+ \" playtimes integer(1), \"+ \" PRIMARY KEY ( id ),\"+ \"FOREIGN KEY (id) REFERENCES userinformation (id)) Engine=Innodb default charset = utf8\";\n    stmt.executeUpdate(sql);\n  }\n  rs=stmt.executeQuery(\"show tables from test like'meteor'\");\n  if (false == rs.next()) {\n    String sql=\"CREATE TABLE meteor \" + \"(id varchar(10) not NULL, \" + \" win integer(1), \"+ \" defeat integer(1), \"+ \" playtimes integer(1), \"+ \" PRIMARY KEY ( id ),\"+ \"FOREIGN KEY (id) REFERENCES userinformation (id)) Engine=Innodb default charset = utf8\";\n    stmt.executeUpdate(sql);\n  }\n  rs=stmt.executeQuery(\"show tables from test like'pangpang'\");\n  if (false == rs.next()) {\n    String sql=\"CREATE TABLE pangpang \" + \"(id varchar(10) not NULL, \" + \" win integer(1), \"+ \" defeat integer(1), \"+ \" playtimes integer(1), \"+ \" score integer(10), \"+ \" PRIMARY KEY ( id ),\"+ \"FOREIGN KEY (id) REFERENCES userinformation (id)) Engine=Innodb default charset = utf8\";\n    stmt.executeUpdate(sql);\n  }\n}\n", "nl": "init database system for GameDB"}
{"code": "private static void createMethods(ClassWriter cw,MethodHolder[] methods,String classInternalName){\n  for (int j=0; j < methods.length; ++j) {\n    final MethodHolder method=methods[j];\n    Class<?>[] exceptionTypes=method.getMethod().getExceptionTypes();\n    String[] exceptions=new String[exceptionTypes.length];\n    for (int i=0; i < exceptionTypes.length; ++i)     exceptions[i]=Type.getInternalName(exceptionTypes[i]);\n    MethodGenerator mv=MethodGenerator.newVarargsMethod(cw,method.getName(),method.getMethodDescriptor(),exceptions);\n    mv.start();\n    mv.loadThis();\n    mv.loadField(AbstractProxy.INTERNAL_NAME,\"_handler\",\"L\" + ProxyInvocationHandler.INTERNAL_NAME + \";\");\n    mv.loadThis();\n    mv.loadStaticField(classInternalName,\"_methods\",IMethod.ARRAY_DESCRIPTOR_NAME);\n    mv.loadConstant(j);\n    mv.loadArrayItem();\n    final Class<?>[] parameterTypes=method.getMethod().getParameterTypes();\n    mv.newArray(OBJECT_INTERNALNAME,parameterTypes.length);\n    int argPos=1;\n    for (int i=0; i < parameterTypes.length; ++i) {\n      mv.dup();\n      mv.loadConstant(i);\n      argPos+=mv.loadVariable(parameterTypes[i],argPos);\n      mv.storeArrayItem();\n    }\n    mv.invokeMethodCustom(Opcodes.INVOKEINTERFACE,ProxyInvocationHandler.INTERNAL_NAME,\"invoke\",\"(Ljava/lang/Object;\" + IMethod.DESCRIPTOR_NAME + \"[Ljava/lang/Object;)Ljava/lang/Object;\");\n    mv.returnResult(method.getMethod().getReturnType());\n  }\n}\n", "nl": "Creates method for the interfaces"}
{"code": "public void collectDeviceInfo(Context ctx){\n  try {\n    PackageManager pm=ctx.getPackageManager();\n    PackageInfo pi=pm.getPackageInfo(ctx.getPackageName(),PackageManager.GET_ACTIVITIES);\n    if (pi != null) {\n      String versionName=pi.versionName == null ? \"null\" : pi.versionName;\n      String versionCode=pi.versionCode + \"\";\n      infos.put(\"versionName\",versionName);\n      infos.put(\"versionCode\",versionCode);\n    }\n  }\n catch (  NameNotFoundException e) {\n    Log.e(TAG,\"an error occured when collect package info\",e);\n  }\n  Field[] fields=Build.class.getDeclaredFields();\n  for (  Field field : fields) {\n    try {\n      field.setAccessible(true);\n      infos.put(field.getName(),field.get(null).toString());\n      Log.d(TAG,field.getName() + \" : \" + field.get(null));\n    }\n catch (    Exception e) {\n      Log.e(TAG,\"an error occured when collect crash info\",e);\n    }\n  }\n}\n", "nl": "Collecting device parameter information"}
{"code": "static public byte[] decode(String encoded){\n  if (encoded == null)   return null;\n  int lengthData=encoded.length();\n  if (lengthData % 2 != 0)   return null;\n  char[] binaryData=encoded.toCharArray();\n  int lengthDecode=lengthData / 2;\n  byte[] decodedData=new byte[lengthDecode];\n  byte temp1, temp2;\n  char tempChar;\n  for (int i=0; i < lengthDecode; i++) {\n    tempChar=binaryData[i * 2];\n    temp1=(tempChar < BASELENGTH) ? hexNumberTable[tempChar] : -1;\n    if (temp1 == -1)     return null;\n    tempChar=binaryData[i * 2 + 1];\n    temp2=(tempChar < BASELENGTH) ? hexNumberTable[tempChar] : -1;\n    if (temp2 == -1)     return null;\n    decodedData[i]=(byte)((temp1 << 4) | temp2);\n  }\n  return decodedData;\n}\n", "nl": "Decode hex string to a byte array"}
{"code": "@deprecated public boolean skeletonsAreSimilar(String id,String skeleton){\n  if (id.equals(skeleton)) {\n    return true;\n  }\n  TreeSet<String> parser1=getSet(id);\n  TreeSet<String> parser2=getSet(skeleton);\n  if (parser1.size() != parser2.size()) {\n    return false;\n  }\n  Iterator<String> it2=parser2.iterator();\n  for (  String item : parser1) {\n    int index1=getCanonicalIndex(item,false);\n    String item2=(String)it2.next();\n    int index2=getCanonicalIndex(item2,false);\n    if (types[index1][1] != types[index2][1]) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "/*     "}
{"code": "public static String dbStringToCamelStyle2(String str){\n  if (str != null) {\n    StringBuilder sb=new StringBuilder();\n    sb.append(String.valueOf(str.charAt(0)));\n    for (int i=1; i < str.length(); i++) {\n      char c=str.charAt(i);\n      if (c != '_') {\n        sb.append(c);\n      }\n else {\n        if (i + 1 < str.length()) {\n          sb.append(String.valueOf(str.charAt(i + 1)).toUpperCase());\n          i++;\n        }\n      }\n    }\n    return sb.toString();\n  }\n  return null;\n}\n", "nl": "convert string from slash style to camel style, such as a_b_c will convert to A_B_C"}
{"code": "@deprecated public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (!(obj instanceof StringCharacterIterator)) {\n    return false;\n  }\n  StringCharacterIterator that=(StringCharacterIterator)obj;\n  if (hashCode() != that.hashCode()) {\n    return false;\n  }\n  if (!this.text.equals(that.text)) {\n    return false;\n  }\n  if ((this.pos != that.pos) || (this.begin != that.begin) || (this.end != that.end)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "/*    "}
{"code": "public static int checkSurveyResponse(Delegator delegator,String partyId,String productStoreId,String surveyId){\n  if (delegator == null || partyId == null || productStoreId == null) {\n    return -1;\n  }\n  List<GenericValue> surveyResponse=null;\n  try {\n    surveyResponse=EntityQuery.use(delegator).from(\"SurveyResponse\").where(\"surveyId\",surveyId,\"partyId\",partyId).queryList();\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,module);\n    return -1;\n  }\n  if (UtilValidate.isEmpty(surveyResponse)) {\n    return 0;\n  }\n else {\n    return surveyResponse.size();\n  }\n}\n", "nl": "Returns the number of responses for this survey by party"}
{"code": "@Deployment public void testActivityErrorEvents() throws Exception {\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"errorProcess\");\n  assertNotNull(processInstance);\n  ProcessInstance afterErrorInstance=runtimeService.createProcessInstanceQuery().processInstanceId(processInstance.getId()).singleResult();\n  assertNull(afterErrorInstance);\n  ActivitiErrorEvent errorEvent=null;\n  for (  ActivitiEvent event : listener.getEventsReceived()) {\n    if (event instanceof ActivitiErrorEvent) {\n      if (errorEvent == null) {\n        errorEvent=(ActivitiErrorEvent)event;\n      }\n else {\n        fail(\"Only one ActivityErrorEvent expected\");\n      }\n    }\n  }\n  assertNotNull(errorEvent);\n  assertEquals(ActivitiEventType.ACTIVITY_ERROR_RECEIVED,errorEvent.getType());\n  assertEquals(\"catchError\",errorEvent.getActivityId());\n  assertEquals(\"myError\",errorEvent.getErrorId());\n  assertEquals(\"123\",errorEvent.getErrorCode());\n  assertEquals(processInstance.getId(),errorEvent.getProcessInstanceId());\n  assertEquals(processInstance.getProcessDefinitionId(),errorEvent.getProcessDefinitionId());\n  assertFalse(processInstance.getId().equals(errorEvent.getExecutionId()));\n}\n", "nl": "Test events related to error-events"}
{"code": "@Override public void audit(String msg){\n  String hostName=\"\";\n  try {\n    hostName=InetAddress.getLocalHost().getHostName();\n  }\n catch (  UnknownHostException e) {\n    hostName=\"localhost\";\n  }\n  String username=\"unknown\";\n  String threadid=\"unknown\";\n  try {\n    threadid=Thread.currentThread().getId() + \"\";\n    username=UserGroupInformation.getCurrentUser().getShortUserName();\n  }\n catch (  IOException e) {\n    username=\"unknown\";\n  }\n  logger.log(AuditLevel.AUDIT,\"[\" + hostName + \"]\"+ \"[\"+ username+ \"]\"+ \"[Thread-\"+ threadid+ \"]\"+ msg);\n}\n", "nl": "log audit log"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set edgeShape=\");\n  String shapeName=np.getWordMatchesIgnoringCase(\"angular straight curved none\");\n  np.matchIgnoreCase(\";\");\n  byte shape;\n  if (shapeName.equalsIgnoreCase(\"angular\"))   shape=EdgeView.ARC_LINE_EDGE;\n else   if (shapeName.equalsIgnoreCase(\"straight\"))   shape=EdgeView.STRAIGHT_EDGE;\n else   if (shapeName.equalsIgnoreCase(\"curved\"))   shape=EdgeView.QUAD_EDGE;\n else   shape=0;\n  if (getViewer() instanceof GraphView) {\n    boolean changed=false;\n    GraphView viewer=(GraphView)getViewer();\n    for (    Edge e : viewer.getSelectedEdges()) {\n      viewer.setShape(e,shape);\n      changed=true;\n    }\n    if (changed) {\n      viewer.repaint();\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public void updateData() throws IOException {\n  ProgressListener progress=doc.getProgressListener();\n  boolean saveCancelable=false;\n  if (progress != null) {\n    saveCancelable=progress.isCancelable();\n    progress.setSubtask(\"updating viewer\");\n    progress.setCancelable(false);\n    try {\n      progress.setProgress(-1);\n    }\n catch (    CanceledException e) {\n    }\n  }\n  totalAssignedReads=0;\n  classification.getFullTree().computeId2Data(doc.getNumberOfSamples(),doc.getDataTable().getClass2Counts(getClassName()),id2NodeData);\n  for (  Integer fId : id2NodeData.keySet()) {\n    if (fId > 0) {\n      totalAssignedReads+=id2NodeData.get(fId).getCountAssigned();\n    }\n  }\n  if (progress != null)   progress.setCancelable(saveCancelable);\n  getCommandManager().updateEnableState();\n}\n", "nl": "rescan the data in the FViewer"}
{"code": "@SuppressWarnings({\"rawtypes\"}) public void fileWrite(final Component c,final String parent,final BufferedWriter bw) throws IOException {\n  if (c instanceof JTextField) {\n    if (null != c.getName()) {\n      bw.write(parent);\n      bw.write(\" : \");\n      bw.write(c.getName());\n      bw.write(\" : \");\n      bw.write(((JTextField)c).getText());\n      bw.newLine();\n    }\n  }\n  if (c instanceof JComboBox) {\n    if (null != c.getName()) {\n      bw.write(parent);\n      bw.write(\" : \");\n      bw.write(c.getName());\n      bw.write(\" : \");\n      bw.write(((JComboBox)c).getSelectedItem().toString());\n      bw.newLine();\n    }\n  }\n}\n", "nl": "Add components to save file executing component type check"}
{"code": "private static void fitToRectangle(final PhyloTreeView treeView,final Rectangle rect){\n  final PhyloTree tree=treeView.getPhyloTree();\n  double minX=Integer.MAX_VALUE;\n  double minY=Integer.MAX_VALUE;\n  double maxX=Integer.MIN_VALUE;\n  double maxY=Integer.MIN_VALUE;\n  for (Node v=tree.getFirstNode(); v != null; v=tree.getNextNode(v)) {\n    final Point2D loc=treeView.getLocation(v);\n    minX=Math.min(minX,loc.getX());\n    minY=Math.min(minY,loc.getY());\n    maxX=Math.max(maxX,loc.getX());\n    maxY=Math.max(maxY,loc.getY());\n  }\n  final double mX=((maxX - minX) != 0 ? rect.getWidth() / (maxX - minX) : 0);\n  final double mY=((maxY - minY) != 0 ? rect.getHeight() / (maxY - minY) : 0);\n  for (Node v=tree.getFirstNode(); v != null; v=tree.getNextNode(v)) {\n    final Point2D loc=treeView.getLocation(v);\n    treeView.setLocation(v,rect.getX() + mX * (loc.getX() - minX),rect.getY() + mY * (loc.getY() - minY));\n  }\n}\n", "nl": "fit coordinates into rect"}
{"code": "public static String createReceivedMessageLog(final FormattedMqttMessage message,final MessageLog messageLogOptions){\n  final StringBuffer logMessage=new StringBuffer();\n  logMessage.append(\"<MqttMessage\");\n  appendAttribute(logMessage,\"id\",String.valueOf(message.getId()));\n  appendAttribute(logMessage,\"timestamp\",String.valueOf(message.getDate().getTime()));\n  appendAttribute(logMessage,\"topic\",message.getTopic());\n  if (messageLogOptions.isLogQos()) {\n    appendAttribute(logMessage,\"qos\",String.valueOf(message.getQoS()));\n  }\n  if (messageLogOptions.isLogRetained()) {\n    appendAttribute(logMessage,\"retained\",String.valueOf(message.isRetained()));\n  }\n  if (messageLogOptions.isLogConnection()) {\n    appendAttribute(logMessage,\"connection\",message.getConnection().getMqttConnectionDetails().getName());\n  }\n  if (messageLogOptions.isLogSubscription() && message.getMatchingSubscriptionTopics() != null && message.getMatchingSubscriptionTopics().size() > 0) {\n    appendAttribute(logMessage,\"subscription\",message.getMatchingSubscriptionTopics().get(0));\n  }\n  populatePayload(logMessage,message,messageLogOptions);\n  logMessage.append(\"</MqttMessage>\");\n  return logMessage.toString();\n}\n", "nl": "Creates a single message log entry for the supplied message object"}
{"code": "public static boolean validatePin(Delegator delegator,String finAccountId,String pinNumber){\n  GenericValue finAccount=null;\n  try {\n    finAccount=EntityQuery.use(delegator).from(\"FinAccount\").where(\"finAccountId\",finAccountId).queryOne();\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,module);\n  }\n  if (finAccount != null) {\n    String dbPin=finAccount.getString(\"finAccountCode\");\n    Debug.logInfo(\"FinAccount Pin Validation: [Sent: \" + pinNumber + \"] [Actual: \"+ dbPin+ \"]\",module);\n    if (dbPin != null && dbPin.equals(pinNumber)) {\n      return true;\n    }\n  }\n else {\n    Debug.logInfo(\"FinAccount record not found (\" + finAccountId + \")\",module);\n  }\n  return false;\n}\n", "nl": "Validates a FinAccount's PIN number"}
{"code": "public void logStatisticsAsTableDriver(){\nsynchronized (lock) {\n    Iterator<Map.Entry<String,List<QueryStatistic>>> entries=queryStatisticsMap.entrySet().iterator();\n    while (entries.hasNext()) {\n      Map.Entry<String,List<QueryStatistic>> entry=entries.next();\n      String queryId=entry.getKey();\n      if (StringUtils.isEmpty(queryId)) {\n        entries.remove();\n      }\n else {\n        long interval=System.nanoTime() - Long.parseLong(queryId);\n        if (interval > QueryStatisticsConstants.CLEAR_STATISTICS_TIMEOUT) {\n          entries.remove();\n        }\n else {\n          if (entry.getValue().size() >= 2) {\n            String tableInfo=collectDriverStatistics(entry.getValue(),queryId);\n            if (null != tableInfo) {\n              LOGGER.statistic(tableInfo);\n              entries.remove();\n            }\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "Below method will be used to show statistic log as table"}
{"code": "private void sendValueWithTimeDeadbandCheck(final SourceDataTag sourceDataTag,final ValueUpdate castedUpdate,final SourceDataTagQuality newSDQuality){\n  if (sourceDataTag.getAddress().isTimeDeadbandEnabled()) {\n    this.equipmentLogger.debug(\"sendInvalidTag - passing update to time-deadband scheduler for tag \" + sourceDataTag.getId());\n    this.equipmentTimeDeadband.addToTimeDeadband(sourceDataTag,castedUpdate,newSDQuality);\n  }\n else {\n    if (this.equipmentTimeDeadband.getSdtTimeDeadbandSchedulers().containsKey(sourceDataTag.getId())) {\n      this.equipmentLogger.debug(\"sendInvalidTag - remove time-deadband scheduler for tag \" + sourceDataTag.getId());\n      this.equipmentTimeDeadband.removeFromTimeDeadband(sourceDataTag);\n    }\n    this.equipmentLogger.debug(format(\"sendInvalidTag - invalidating and sending invalid tag (%d) update to the server\",sourceDataTag.getId()));\n    SourceDataTagValue newSDValue=sourceDataTag.update(castedUpdate,newSDQuality);\n    if (newSDValue == null) {\n      this.equipmentLogger.warn(\"sendInvalidTag - method called with 0(OK) quality code for tag \" + sourceDataTag.getId() + \". This should normally not happen! sendTagFiltered() method should have been called before.\");\n    }\n else {\n      this.processMessageSender.addValue(newSDValue);\n      this.dynamicTimeDeadbandFilterer.recordTag(sourceDataTag);\n    }\n  }\n}\n", "nl": "This method checks the time deadband and according to the result it sends the updated value to the server"}
{"code": "private int[] computeHistogram(int classId,Document doc) throws IOException {\n  IConnector connector=doc.getMeganFile().getDataConnector();\n  Map<String,Integer> matched2count=new HashMap<>();\n  for (IReadBlockIterator it=connector.getReadsIterator(ClassificationType.Taxonomy.toString(),classId,doc.getMinScore(),doc.getMaxExpected(),false,true); it.hasNext(); ) {\n    IReadBlock readBlock=it.next();\n    for (int i=0; i < readBlock.getNumberOfAvailableMatchBlocks(); i++) {\n      IMatchBlock matchBlock=readBlock.getMatchBlock(i);\n      if (matchBlock.getBitScore() >= doc.getMinScore() && matchBlock.getExpected() <= doc.getMaxExpected() && matchBlock.getPercentIdentity() >= doc.getMinPercentIdentity()) {\n        String firstLine=matchBlock.getText().split(\"\\n\")[0];\n        Integer count=matched2count.get(firstLine);\n        if (count == null)         matched2count.put(firstLine,1);\n else         matched2count.put(firstLine,count + 1);\n      }\n    }\n  }\n  int[] values=new int[matched2count.size()];\n  int i=0;\n  for (  Integer count : matched2count.values()) {\n    values[i++]=count;\n  }\n  Arrays.sort(values);\n  return values;\n}\n", "nl": "compute the histogram associated with a given class"}
{"code": "public static float compareEquivalance(Bitmap bitmap1,Bitmap bitmap2){\n  if (bitmap1 == null || bitmap2 == null || bitmap1.getWidth() != bitmap2.getWidth() || bitmap1.getHeight() != bitmap2.getHeight()) {\n    return 0f;\n  }\n  ByteBuffer buffer1=ByteBuffer.allocate(bitmap1.getHeight() * bitmap1.getRowBytes());\n  bitmap1.copyPixelsToBuffer(buffer1);\n  ByteBuffer buffer2=ByteBuffer.allocate(bitmap2.getHeight() * bitmap2.getRowBytes());\n  bitmap2.copyPixelsToBuffer(buffer2);\n  byte[] array1=buffer1.array();\n  byte[] array2=buffer2.array();\n  int len=array1.length;\n  int count=0;\n  for (int i=0; i < len; i++) {\n    if (array1[i] == array2[i]) {\n      count++;\n    }\n  }\n  return ((float)(count)) / len;\n}\n", "nl": "Compares two bitmaps and gives the percentage of similarity"}
{"code": "public static String addAdditionalParty(HttpServletRequest request,HttpServletResponse response){\n  ShoppingCart cart=getCartObject(request);\n  String partyId=request.getParameter(\"additionalPartyId\");\n  String roleTypeId[]=request.getParameterValues(\"additionalRoleTypeId\");\n  List<String> eventList=new LinkedList<String>();\n  Locale locale=UtilHttp.getLocale(request);\n  int i;\n  if (UtilValidate.isEmpty(partyId) || UtilValidate.isEmpty(roleTypeId) || roleTypeId.length < 1) {\n    request.setAttribute(\"_ERROR_MESSAGE_\",UtilProperties.getMessage(resource_error,\"OrderPartyIdAndOrRoleTypeIdNotDefined\",locale));\n    return \"error\";\n  }\n  if (request.getAttribute(\"_EVENT_MESSAGE_LIST_\") != null) {\n    List<String> msg=UtilGenerics.checkList(request.getAttribute(\"_EVENT_MESSAGE_LIST_\"));\n    eventList.addAll(msg);\n  }\n  for (i=0; i < roleTypeId.length; i++) {\n    try {\n      cart.addAdditionalPartyRole(partyId,roleTypeId[i]);\n    }\n catch (    Exception e) {\n      eventList.add(e.getLocalizedMessage());\n    }\n  }\n  request.removeAttribute(\"_EVENT_MESSAGE_LIST_\");\n  request.setAttribute(\"_EVENT_MESSAGE_LIST_\",eventList);\n  return \"success\";\n}\n", "nl": "Associates a party to order"}
{"code": "public static int parseNormalizedTo(String parameterString){\n  try {\n    if (parameterString != null) {\n      NexusStreamParser np=new NexusStreamParser(new StringReader(parameterString));\n      while (np.peekNextToken() != NexusStreamParser.TT_EOF) {\n        if (np.peekMatchIgnoreCase(\"normalizedTo=\")) {\n          np.matchIgnoreCase(\"normalizedTo=\");\n          return np.getInt();\n        }\n        if (np.peekMatchIgnoreCase(\"normalized_to=\")) {\n          np.matchIgnoreCase(\"normalized_to=\");\n          return np.getInt();\n        }\n        np.getWordRespectCase();\n      }\n    }\n  }\n catch (  Exception ex) {\n  }\n  return 0;\n}\n", "nl": "Convenience method: gets the normalization number encoded in the parameter string"}
{"code": "protected void addJob(BundleContext context,Class<? extends Job> clazz,String cronExpression){\n  String jobName=clazz.getName();\n  String jobGroup=FrameworkUtil.getBundle(clazz).getSymbolicName();\n  JobDetail job=new JobDetail(jobName,jobGroup,clazz);\n  job.setDurability(false);\n  job.setVolatility(true);\n  job.setDescription(jobName);\n  try {\n    CronTrigger trigger=new CronTrigger(jobName,jobGroup,cronExpression);\n    if (scheduler == null) {\n      if (schedulerProperties == null) {\n        schedulerProperties=getDefaultSchedulerProperties();\n      }\n      scheduler=new StdSchedulerFactory(schedulerProperties).getScheduler();\n      scheduler.start();\n    }\n    Date date=scheduler.scheduleJob(job,trigger);\n    Logger.info(this,\"Scheduled job \" + jobName + \", next trigger is on \"+ date);\n  }\n catch (  ParseException e) {\n    Logger.error(this,\"Cron expression '\" + cronExpression + \"' has an exception. Throwing IllegalArgumentException\",e);\n    throw new IllegalArgumentException(e);\n  }\ncatch (  SchedulerException e) {\n    Logger.error(this,\"Unable to schedule job \" + jobName,e);\n  }\n}\n", "nl": "Adds a Job, and starts a Scheduler when none was yet started"}
{"code": "public boolean isSet(_Fields field){\n  if (field == null) {\n    throw new IllegalArgumentException();\n  }\nswitch (field) {\ncase CLIENT_APPKEY:\n    return isSetClientAppkey();\ncase TRACE_ID:\n  return isSetTraceId();\ncase SPAN_ID:\nreturn isSetSpanId();\ncase ROOT_MESSAGE_ID:\nreturn isSetRootMessageId();\ncase CURRENT_MESSAGE_ID:\nreturn isSetCurrentMessageId();\ncase SERVER_MESSAGE_ID:\nreturn isSetServerMessageId();\ncase DEBUG:\nreturn isSetDebug();\ncase SAMPLE:\nreturn isSetSample();\ncase CLIENT_IP:\nreturn isSetClientIp();\n}\nthrow new IllegalStateException();\n}\n", "nl": "Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise"}
{"code": "private boolean drawComponent(@NotNull Graphics2D gc,@NotNull NlComponent component,boolean parentHandlesPainting){\n  if (component.viewInfo != null) {\n    ViewHandler handler=component.getViewHandler();\n    boolean handlesPainting=false;\n    if (handler != null && handler instanceof ViewGroupHandler) {\n      ViewGroupHandler viewGroupHandler=(ViewGroupHandler)handler;\n      if (viewGroupHandler.handlesPainting()) {\n        viewGroupHandler.drawGroup(gc,myScreenView,component);\n        handlesPainting=true;\n      }\n    }\n    if (handler != null) {\n      handler.paintConstraints(myScreenView,gc,component);\n    }\n  }\n  boolean needsRepaint=false;\n  for (  NlComponent child : component.getChildren()) {\n    needsRepaint|=drawComponent(gc,child,parentHandlesPainting);\n  }\n  return needsRepaint;\n}\n", "nl": "Draw the given component and its children"}
{"code": "public static double computePearsonsCorrelation(Collection<Pair<Number,Number>> pairs){\n  double[] mean=new double[2];\n  for (  Pair<Number,Number> pair : pairs) {\n    mean[0]+=pair.get1().doubleValue();\n    mean[1]+=pair.get2().doubleValue();\n  }\n  mean[0]/=pairs.size();\n  mean[1]/=pairs.size();\n  double[] stddev=new double[2];\n  for (  Pair<Number,Number> pair : pairs) {\n    stddev[0]+=(pair.get1().doubleValue() - mean[0]) * (pair.get1().doubleValue() - mean[0]);\n    stddev[1]+=(pair.get2().doubleValue() - mean[1]) * (pair.get2().doubleValue() - mean[1]);\n  }\n  stddev[0]=Math.sqrt(stddev[0] / pairs.size());\n  stddev[1]=Math.sqrt(stddev[1] / pairs.size());\n  double cor=0;\n  for (  Pair<Number,Number> pair : pairs) {\n    cor+=(pair.get1().doubleValue() - mean[0]) * (pair.get2().doubleValue() - mean[1]) / (stddev[0] * stddev[1]);\n  }\n  cor/=pairs.size();\n  return cor;\n}\n", "nl": "computes the Pearson's correlation for a list of pairs"}
{"code": "public void testIndexCSVBig() throws Exception {\n  createIndex();\n  send(\"registerFields\",\"{fields: {id: {type: atom, store: true, sort: true}, id2: {type: atom, store: true, sort: true}, body: {type: text, store: true, highlight: true}}}\");\n  send(\"startIndex\");\n  StringBuilder b=new StringBuilder();\n  int size=atLeast(512);\n  for (int i=0; i < 256 * size; i++) {\n    b.append(\"wordy \");\n  }\n  b.append(\" document\");\n  String body=b.toString();\n  assertTrue(body.length() > 512 * 1024);\n  byte[] bytes=server.sendBinary(\"bulkCSVAddDocument\",toUTF8(\",\" + server.curIndexName + \"\\nid,id2,body\\n0,1,\"+ body+ \"\\n\"));\n  JSONObject result=parseJSONObject(new String(bytes,StandardCharsets.UTF_8));\n  assertEquals(1,getInt(result,\"indexedDocumentCount\"));\n  refresh();\n  assertEquals(1,getInt(send(\"search\",\"{queryText: document}\"),\"totalHits\"));\n  send(\"stopIndex\");\n  send(\"deleteIndex\");\n}\n", "nl": "Index a document via CSV that's larger than the 512 KB chunk size"}
{"code": "private void initGraph(Taxa taxa,SplitSystem splits,int[] cycle,PhyloGraph graph){\n  int[] taxon2split=new int[ntax + 1];\n  for (int s=1; s <= splits.size(); s++) {\n    BitSet part=splits.getSplit(s).getA();\n    if (part.cardinality() == ntax - 1) {\n      part=splits.getSplit(s).getB();\n    }\n    if (part.cardinality() == 1) {\n      int t=getMax(part,ntax);\n      taxon2split[t]=s;\n    }\n  }\n  Node center=graph.newNode();\n  for (int i=1; i <= ntax; i++) {\n    int t=cycle[i];\n    Node v=graph.newNode();\n    graph.setLabel(v,taxa.getLabel(t));\n    graph.setNode2Taxa(v,t);\n    graph.setTaxon2Node(t,v);\n    Edge e=graph.newEdge(center,v);\n    if (taxon2split[t] != 0) {\n      int s=taxon2split[t];\n      graph.setWeight(e,splits.getSplit(s).getWeight());\n      graph.setSplit(e,s);\n    }\n else     graph.setSplit(e,-1);\n  }\n}\n", "nl": "initializes the graph"}
{"code": "private static void checkHorizontalParentMarginSnap(ConstraintAnchor anchor,ConstraintAnchor.Type type,int margin,SnapCandidate candidate){\n  ConstraintWidget widget=anchor.getOwner();\n  if (widget.getParent() == null) {\n    return;\n  }\n  ConstraintAnchor targetParent=widget.getParent().getAnchor(type);\n  ConstraintHandle targetParentHandle=WidgetInteractionTargets.constraintHandle(targetParent);\n  ConstraintHandle anchorHandle=WidgetInteractionTargets.constraintHandle(anchor);\n  ConstraintAnchor target=new ConstraintAnchor(widget.getParent(),type);\n  int tx=targetParentHandle.getDrawX() + margin;\n  int ty=targetParentHandle.getDrawY();\n  int distance=Math.abs(anchorHandle.getDrawX() - tx);\n  if (distance <= CONNECTION_SLOPE) {\n    candidate.distance=distance;\n    candidate.target=target;\n    candidate.source=anchor;\n    candidate.x=tx;\n    candidate.y=ty;\n  }\n}\n", "nl": "Check to snap on the horizontal internal margins of a parent (used when resizing)"}
{"code": "FetchResult fetch(String url,boolean prune,boolean force,Iterable<String> refspecs) throws RepoException {\n  List<String> args=Lists.newArrayList(\"fetch\",validateUrl(url));\n  args.add(\"--verbose\");\n  if (prune) {\n    args.add(\"-p\");\n  }\n  if (force) {\n    args.add(\"-f\");\n  }\n  for (  String ref : refspecs) {\n    try {\n      Refspec.create(environment,gitDir,ref,null);\n    }\n catch (    EvalException e) {\n      throw new RepoException(\"Invalid refspec passed to fetch: \" + e);\n    }\n    args.add(ref);\n  }\n  ImmutableMap<String,GitReference> before=showRef();\n  git(getCwd(),addGitDirAndWorkTreeParams(args));\n  ImmutableMap<String,GitReference> after=showRef();\n  return new FetchResult(before,after);\n}\n", "nl": "Fetch zero or more refspecs in the local repository"}
{"code": "private void createLayouts(int widthItems,int widthLabel){\n  if (itemsLayout == null || itemsLayout.getWidth() > widthItems) {\n    itemsLayout=new StaticLayout(buildText(isScrollingPerformed),itemsPaint,widthItems,widthLabel > 0 ? Layout.Alignment.ALIGN_CENTER : Layout.Alignment.ALIGN_CENTER,1,ADDITIONAL_ITEM_HEIGHT,false);\n  }\n else {\n    itemsLayout.increaseWidthTo(widthItems);\n  }\n  if (!isScrollingPerformed && (valueLayout == null || valueLayout.getWidth() > widthItems)) {\n    String text=getAdapter() != null ? getAdapter().getItem(currentItem) : null;\n    valueLayout=new StaticLayout(text != null ? text : \"\",valuePaint,widthItems,widthLabel > 0 ? Layout.Alignment.ALIGN_CENTER : Layout.Alignment.ALIGN_CENTER,1,ADDITIONAL_ITEM_HEIGHT,false);\n  }\n else   if (isScrollingPerformed) {\n    valueLayout=null;\n  }\n else {\n    valueLayout.increaseWidthTo(widthItems);\n  }\n  if (widthLabel > 0) {\n    if (labelLayout == null || labelLayout.getWidth() > widthLabel) {\n      labelLayout=new StaticLayout(label,valuePaint,widthLabel,Layout.Alignment.ALIGN_NORMAL,1,ADDITIONAL_ITEM_HEIGHT,false);\n    }\n else {\n      labelLayout.increaseWidthTo(widthLabel);\n    }\n  }\n}\n", "nl": "Creates layouts"}
{"code": "private void drawBitmapWithStroke(Canvas canvas,Bitmap bitmap,int centerX,int centerY,float radius,Paint drawPaint){\n  drawPaint.setStyle(Paint.Style.FILL);\n  float strokeRadius=radius + mRadiusStrokeWidth;\n  drawPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));\n  canvas.drawCircle(centerX,centerY,strokeRadius,drawPaint);\n  drawPaint.setXfermode(null);\n  final int halfBitmapWidth=bitmap.getWidth() / 2;\n  final int halfBitmapHeight=bitmap.getHeight() / 2;\n  BitmapShader bitmapShader=new BitmapShader(bitmap,Shader.TileMode.REPEAT,Shader.TileMode.REPEAT);\n  Matrix shaderMatrix=new Matrix();\n  float minSize=bitmap.getWidth() > bitmap.getHeight() ? bitmap.getHeight() : bitmap.getWidth();\n  float scale=radius * 2 / minSize;\n  shaderMatrix.setScale(scale,scale);\n  shaderMatrix.postTranslate(centerX - (halfBitmapWidth * scale),centerY - (halfBitmapHeight * scale));\n  bitmapShader.setLocalMatrix(shaderMatrix);\n  drawPaint.setShader(bitmapShader);\n  canvas.drawCircle(centerX,centerY,radius,drawPaint);\n  drawPaint.setShader(null);\n}\n", "nl": "Draw single bitmap with the giving centerX, centerY and radius"}
{"code": "public void actionPerformed(ActionEvent ev){\n  File lastOpenFile=ProgramProperties.getFile(MeganProperties.TAXONOMYFILE);\n  getDir().notifyLockInput();\n  File file=ChooseFileDialog.chooseFileToOpen(getViewer().getFrame(),lastOpenFile,new TextFileFilter(\"tre\"),new TextFileFilter(\"tre\"),ev,\"Open Tree File\");\n  getDir().notifyUnlockInput();\n  if (file != null && file.exists() && file.canRead()) {\n    ProgramProperties.put(MeganProperties.TAXONOMYFILE,file.getAbsolutePath());\n    String mappingFile=Basic.replaceFileSuffix(file.getPath(),\".map\");\n    if (!(new File(mappingFile)).exists()) {\n      mappingFile=null;\n    }\n    StringBuilder buf=new StringBuilder();\n    buf.append(\"load taxonomyFile='\").append(file.getPath()).append(\"'\");\n    if (mappingFile != null)     buf.append(\" mapfile='\").append(mappingFile).append(\"';\");\n else     buf.append(\";\");\n    buf.append(\"collapse level=2;\");\n    execute(buf.toString());\n  }\n}\n", "nl": "action to be performed"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  Director.showMessageWindow();\n  final AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  final Alignment alignment=viewer.getAlignment();\n  final SelectedBlock block=viewer.getSelectedBlock();\n  for (int row=0; row < alignment.getRowCompressor().getNumberRows(); row++) {\n    if (block.isSelectedRow(row)) {\n      for (      Integer read : alignment.getRowCompressor().getCompressedRow2Reads(row)) {\n        Lane lane=alignment.getLane(read);\n        int firstJump=alignment.getGapColumnContractor().getTotalJumpBeforeLayoutColumn(block.getFirstCol());\n        if ((block.isSelectedCol(lane.getFirstNonGapPosition() - firstJump + 1))) {\n          System.out.println();\n          System.out.println(viewer.getSelectedReference());\n          System.out.println(lane.getText());\n        }\n      }\n    }\n  }\n}\n", "nl": "action to be performed"}
{"code": "@Override public void put(Collection<SinkRecord> sinkRecords) throws ConnectException {\n  for (  SinkRecord record : sinkRecords) {\n    fLog.trace(\"Put message {}\",record.value());\n    try {\n      iParser.parse(record.value().toString());\n      for (int i=0; i < iPaths.length; ++i) {\n        Element element=iParser.getElement(iPaths[i]);\n        if (element == null) {\n        }\n else {\n          String string=element.toString();\n          if (string.equals(\"null\")) {\n          }\n else {\n            if (string.charAt(0) == '\"')             iWriter.append(string.substring(1,string.length() - 1));\n else             iWriter.append(string);\n          }\n        }\n        iWriter.next();\n      }\n    }\n catch (    IOException exception) {\n      throw new ConnectException(exception);\n    }\n  }\n}\n", "nl": "Parses JSON value in each record and appends JSON elements to the table"}
{"code": "public void rescan(ProgressListener progress) throws IOException, CanceledException {\n  progress.setSubtask(\"Scanning...\");\n  lock.lock();\n  try {\n    files.clear();\n    List<File> files=Basic.getAllFilesInDirectory(rootDirectory,RMAFileFilter.getInstance(),true,progress);\n    for (    File file : files) {\n      File relative=Basic.getRelativeFile(file,rootDirectory);\n      this.files.add(relative.getPath());\n      MeganFile meganFile=new MeganFile();\n      meganFile.setFileFromExistingFile(file.getPath(),true);\n      if (meganFile.hasDataConnector()) {\n        IConnector connector=meganFile.getDataConnector();\n        DataTable dataTable=new DataTable();\n        SampleAttributeTable sampleAttributeTable=new SampleAttributeTable();\n        SyncArchiveAndDataTable.syncArchive2Summary(meganFile.getFileName(),connector,dataTable,sampleAttributeTable);\n        Object description=sampleAttributeTable.get(meganFile.getName(),\"Description\");\n        if (description == null)         description=meganFile.getName();\n        fileName2Description.put(relative.getParent(),description.toString());\n      }\n    }\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "rescan root directory and rescan contents"}
{"code": "private static DhisHttpResponse processResponse(String requestURL,String username,HttpResponse response) throws Exception {\n  DhisHttpResponse dhisHttpResponse=null;\n  String output=null;\n  int statusCode=0;\n  if (response != null) {\n    HttpEntity responseEntity=response.getEntity();\n    if (responseEntity != null && responseEntity.getContent() != null) {\n      Header contentType=response.getEntity().getContentType();\n      if (contentType != null && checkIfGzipContentType(contentType)) {\n        GzipDecompressingEntity gzipDecompressingEntity=new GzipDecompressingEntity(response.getEntity());\n        InputStream content=gzipDecompressingEntity.getContent();\n        output=IOUtils.toString(content);\n      }\n else {\n        output=EntityUtils.toString(response.getEntity());\n      }\n      statusCode=response.getStatusLine().getStatusCode();\n    }\n else {\n      throw new Exception(\"No content found in the response received from http POST call to \" + requestURL + \" with username \"+ username);\n    }\n    dhisHttpResponse=new DhisHttpResponse(response,output,statusCode);\n  }\n else {\n    throw new Exception(\"NULL response received from http POST call to \" + requestURL + \" with username \"+ username);\n  }\n  return dhisHttpResponse;\n}\n", "nl": "<pre> <b>Description : </b> Processes the HttpResponse to create a DHisHttpResponse object"}
{"code": "private void parseLayoutNode(String layoutFile,AXmlNode rootNode){\n  if (rootNode.getTag() == null || rootNode.getTag().isEmpty()) {\n    System.err.println(\"Encountered a null or empty node name \" + \"in file \" + layoutFile + \", skipping node...\");\n    return;\n  }\n  String tname=rootNode.getTag().trim();\n  if (tname.equals(\"dummy\")) {\n  }\n else   if (tname.equals(\"include\")) {\n    parseIncludeAttributes(layoutFile,rootNode);\n  }\n else   if (tname.equals(\"merge\")) {\n  }\n else   if (tname.equals(\"fragment\")) {\n    final AXmlAttribute<?> attr=rootNode.getAttribute(\"name\");\n    if (attr == null)     System.err.println(\"Fragment without class name detected\");\n else {\n      if (attr.getType() != AxmlVisitor.TYPE_STRING)       System.err.println(\"Invalid targer resource \" + attr.getValue() + \"for fragment class value\");\n      getLayoutClass(attr.getValue().toString());\n    }\n  }\n else {\n    final SootClass childClass=getLayoutClass(tname);\n    if (childClass != null && (isLayoutClass(childClass) || isViewClass(childClass)))     parseLayoutAttributes(layoutFile,childClass,rootNode);\n  }\n  for (  AXmlNode childNode : rootNode.getChildren())   parseLayoutNode(layoutFile,childNode);\n}\n", "nl": "Parses the layout file with the given root node"}
{"code": "private static void decodeHanziSegment(BitSource bits,StringBuilder result,int count) throws FormatException {\n  if (count * 13 > bits.available()) {\n    throw FormatException.getFormatInstance();\n  }\n  byte[] buffer=new byte[2 * count];\n  int offset=0;\n  while (count > 0) {\n    int twoBytes=bits.readBits(13);\n    int assembledTwoBytes=((twoBytes / 0x060) << 8) | (twoBytes % 0x060);\n    if (assembledTwoBytes < 0x003BF) {\n      assembledTwoBytes+=0x0A1A1;\n    }\n else {\n      assembledTwoBytes+=0x0A6A1;\n    }\n    buffer[offset]=(byte)((assembledTwoBytes >> 8) & 0xFF);\n    buffer[offset + 1]=(byte)(assembledTwoBytes & 0xFF);\n    offset+=2;\n    count--;\n  }\n  try {\n    result.append(new String(buffer,StringUtils.GB2312));\n  }\n catch (  UnsupportedEncodingException ignored) {\n    throw FormatException.getFormatInstance();\n  }\n}\n", "nl": "See specification GBT 18284-2000"}
{"code": "private void endList(){\n  List list=(List)getLast(List.class);\n  if (list != null) {\n    if (mResult.length() == 0 || mResult.charAt(mResult.length() - 1) != '\\n') {\n      mResult.append('\\n');\n    }\n    int start=mResult.getSpanStart(list);\n    int end=mResult.length();\n    int nrOfIndents=list.mNrOfIndents;\n    if (!list.mIsIndentation) {\n      nrOfIndents--;\n      int margin=Helper.getLeadingMarging();\n      Object span=list instanceof UL ? new BulletSpan(margin,start == end,false,false) : new NumberSpan(1,margin,start == end,false,false);\n      mResult.setSpan(span,start,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n    }\n    if (nrOfIndents > 0) {\n      int margin=nrOfIndents * Helper.getLeadingMarging();\n      IndentationSpan span=new IndentationSpan(margin,start == end,false,false);\n      mResult.setSpan(span,start,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n    }\n    mResult.removeSpan(list);\n  }\n}\n", "nl": "Handles LI tags"}
{"code": "public int size(){\n  if (fileTable != null) {\n    int size=0;\n    try {\nsynchronized (this) {\n        FastIterator<Object> iter=fileTable.keys();\n        while (iter.next() != null) {\n          size++;\n        }\n      }\n    }\n catch (    IOException e) {\n      Debug.logError(e,module);\n    }\n    return size;\n  }\n else {\n    return memoryTable.size();\n  }\n}\n", "nl": "Returns the number of elements currently in the cache"}
{"code": "@deprecated public StringTokenizer(String str,String delim,boolean returndelims,boolean coalescedelims){\n  this.m_delimiters_=EMPTY_DELIMITER_;\n  if ((delim != null) && (delim.length() > 0)) {\n    this.m_delimiters_=new UnicodeSet();\n    this.m_delimiters_.addAll(delim);\n    checkDelimiters();\n  }\n  this.m_coalesceDelimiters_=coalescedelims;\n  this.m_source_=str;\n  this.m_length_=str.length();\n  this.m_returnDelimiters_=returndelims;\n  this.m_tokenOffset_=-1;\n  this.m_tokenSize_=-1;\n  if (this.m_length_ == 0) {\n    this.m_nextOffset_=-1;\n  }\n else {\n    this.m_nextOffset_=0;\n    if (!returndelims) {\n      this.m_nextOffset_=getNextNonDelimiter(0);\n    }\n  }\n}\n", "nl": "/*    "}
{"code": "public void removeAdjustmentByType(String orderAdjustmentTypeId){\n  if (orderAdjustmentTypeId == null)   return;\n  List<List<GenericValue>> adjsLists=FastList.newInstance();\n  adjsLists.add(this.getAdjustments());\n  for (  ShoppingCartItem item : this) {\n    if (item.getAdjustments() != null) {\n      adjsLists.add(item.getAdjustments());\n    }\n  }\n  for (  List<GenericValue> adjs : adjsLists) {\n    if (adjs != null) {\n      for (int i=0; i < adjs.size(); ) {\n        GenericValue orderAdjustment=adjs.get(i);\n        if (orderAdjustmentTypeId.equals(orderAdjustment.getString(\"orderAdjustmentTypeId\"))) {\n          adjs.remove(i);\n        }\n else {\n          i++;\n        }\n      }\n    }\n  }\n}\n", "nl": "go through the order adjustments and remove all adjustments with the given type"}
{"code": "protected void writeGraphicCtrlExt() throws IOException {\n  out.write(0x21);\n  out.write(0xf9);\n  out.write(4);\n  int transp, disp;\n  if (transparent == null) {\n    transp=0;\n    disp=0;\n  }\n else {\n    transp=1;\n    disp=2;\n  }\n  if (dispose >= 0) {\n    disp=dispose & 7;\n  }\n  disp<<=2;\n  out.write(0 | disp | 0| transp);\n  writeShort(delay);\n  out.write(transIndex);\n  out.write(0);\n}\n", "nl": "Writes Graphic Control Extension"}
{"code": "private ResultPoint correctTopRight(ResultPoint bottomLeft,ResultPoint bottomRight,ResultPoint topLeft,ResultPoint topRight,int dimension){\n  float corr=distance(bottomLeft,bottomRight) / (float)dimension;\n  int norm=distance(topLeft,topRight);\n  float cos=(topRight.getX() - topLeft.getX()) / norm;\n  float sin=(topRight.getY() - topLeft.getY()) / norm;\n  ResultPoint c1=new ResultPoint(topRight.getX() + corr * cos,topRight.getY() + corr * sin);\n  corr=distance(bottomLeft,topLeft) / (float)dimension;\n  norm=distance(bottomRight,topRight);\n  cos=(topRight.getX() - bottomRight.getX()) / norm;\n  sin=(topRight.getY() - bottomRight.getY()) / norm;\n  ResultPoint c2=new ResultPoint(topRight.getX() + corr * cos,topRight.getY() + corr * sin);\n  if (!isValid(c1)) {\n    if (isValid(c2)) {\n      return c2;\n    }\n    return null;\n  }\n  if (!isValid(c2)) {\n    return c1;\n  }\n  int l1=Math.abs(transitionsBetween(topLeft,c1).getTransitions() - transitionsBetween(bottomRight,c1).getTransitions());\n  int l2=Math.abs(transitionsBetween(topLeft,c2).getTransitions() - transitionsBetween(bottomRight,c2).getTransitions());\n  return l1 <= l2 ? c1 : c2;\n}\n", "nl": "Calculates the position of the white top right module using the output of the rectangle detector for a square matrix"}
{"code": "public static void initializeProperties(String propertiesFile){\n  ProgramProperties.setPropertiesFileName(propertiesFile);\n  ProgramProperties.setProgramIcon(ResourceManager.getIcon(\"megan64.gif\"));\n  ProgramProperties.put(MEGANFILE,System.getProperty(\"user.dir\"));\n  ProgramProperties.put(SAVEFILE,System.getProperty(\"user.dir\"));\n  ProgramProperties.put(EXPORTFILE,System.getProperty(\"user.dir\"));\n  ProgramProperties.put(TAXONOMYFILE,DEFAULT_TAXONOMYFILE);\n  ProgramProperties.put(MAPPINGFILE,DEFAULT_MAPPINGFILE);\n  ProgramProperties.put(MICROBIALATTRIBUTESFILE,DEFAULT_MICROBIALATTRIBUTESFILE);\n  ProgramProperties.put(BLASTFILE,\"\");\n  ProgramProperties.put(BLASTOUTFILE,\"\");\n  ProgramProperties.put(PVALUE_COLOR,Color.YELLOW);\n  ProgramProperties.put(RECENTFILES,\"\");\n  ProgramProperties.put(MAXRECENTFILES,30);\n  ProgramProperties.put(ExportImageDialog.GRAPHICSFORMAT,\".pdf\");\n  ProgramProperties.put(ExportImageDialog.GRAPHICSDIR,System.getProperty(\"user.dir\"));\n  ProgramProperties.put(DISABLED_TAXA,new int[]{32644,37965,134367,2323,28384,61964,48510,47936,186616,12908,48479,156614,367897});\n  ProgramProperties.load(propertiesFile);\n  if (!ProgramProperties.get(\"Version\",\"\").equals(ProgramProperties.getProgramName())) {\n    ProgramProperties.put(\"Version\",ProgramProperties.getProgramName());\n    ProgramProperties.put(TAXONOMYFILE,DEFAULT_TAXONOMYFILE);\n    ProgramProperties.put(MAPPINGFILE,DEFAULT_MAPPINGFILE);\n    ProgramProperties.put(MICROBIALATTRIBUTESFILE,DEFAULT_MICROBIALATTRIBUTESFILE);\n  }\n  ProgramProperties.put(MeganProperties.DEFAULT_PROPERTIES,\"\");\n  ReadMagnitudeParser.setEnabled(ProgramProperties.get(\"allow-read-weights\",false));\n  ReadMagnitudeParser.setUnderScoreEnabled(ProgramProperties.get(\"allow-read-weights-underscore\",false));\n}\n", "nl": "sets the program properties"}
{"code": "public static void printAsNexus(String name,int ntax,String[] names,Vector<Vector<Double>> values){\n  Writer w=new StringWriter();\n  try {\n    w.write(\"#NEXUS\\n[!Computed by MEGAN using \" + name + \"]\\n\");\n    w.write(\"begin taxa;\\ndimensions ntax=\" + ntax + \";\\nend;\\n\");\n    w.write(\"begin distances;\\ndimensions ntax=\" + ntax + \";\\nformat labels no diagonal triangle=upper;\\n\");\n    w.write(\"matrix\\n\");\n    int count=0;\n    for (    Vector<Double> row : values) {\n      w.write(\"'\" + names[count++].replaceAll(\"'\",\"_\") + \"'\");\n      for (      Double value : row) {\n        w.write(\" \" + value.floatValue());\n      }\n      w.write(\"\\n\");\n    }\n    w.write(\"'\" + names[count].replaceAll(\"'\",\"_\") + \"'\\n\");\n    w.write(\";\\nend;\\n\");\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n  System.err.println(w.toString());\n}\n", "nl": "print a distance matrix in nexus format"}
{"code": "protected void processNotificationSupportedReport(SerialMessage serialMessage,int offset,int endpoint) throws ZWaveSerialMessageException {\n  v1Supported=(serialMessage.getMessagePayloadByte(offset + 1) & 0x80) == 0;\n  if (v1Supported) {\n    logger.debug(\"NODE: NOTIFICATION_SUPPORTED_REPORT reports V1 ALARM support\",getNode().getNodeId());\n  }\n  int numBytes=serialMessage.getMessagePayloadByte(offset + 1) & 0x1f;\n  for (int i=0; i < numBytes; ++i) {\n    for (int bit=0; bit < 8; ++bit) {\n      if (((serialMessage.getMessagePayloadByte(offset + i + 2)) & (1 << bit)) == 0) {\n        continue;\n      }\n      int index=(i << 3) + bit;\n      if (index >= AlarmType.values().length) {\n        continue;\n      }\n      getAlarm(index);\n    }\n  }\n  supportedInitialised=true;\n}\n", "nl": "Process NOTIFICATION_SUPPORTED_REPORT"}
{"code": "BitMatrix buildFunctionPattern(){\n  int dimension=getDimensionForVersion();\n  BitMatrix bitMatrix=new BitMatrix(dimension);\n  bitMatrix.setRegion(0,0,9,9);\n  bitMatrix.setRegion(dimension - 8,0,8,9);\n  bitMatrix.setRegion(0,dimension - 8,9,8);\n  int max=alignmentPatternCenters.length;\n  for (int x=0; x < max; x++) {\n    int i=alignmentPatternCenters[x] - 2;\n    for (int y=0; y < max; y++) {\n      if ((x == 0 && (y == 0 || y == max - 1)) || (x == max - 1 && y == 0)) {\n        continue;\n      }\n      bitMatrix.setRegion(alignmentPatternCenters[y] - 2,i,5,5);\n    }\n  }\n  bitMatrix.setRegion(6,9,1,dimension - 17);\n  bitMatrix.setRegion(9,6,dimension - 17,1);\n  if (versionNumber > 6) {\n    bitMatrix.setRegion(dimension - 11,0,3,6);\n    bitMatrix.setRegion(0,dimension - 11,6,3);\n  }\n  return bitMatrix;\n}\n", "nl": "See ISO 18004:2006 Annex E"}
{"code": "private boolean isIncludedColumn(double[] column,RealMatrix searchMatrix,double tolerance){\n  boolean found=false;\n  int i=0;\n  while (!found && i < searchMatrix.getColumnDimension()) {\n    double multiplier=1.0;\n    boolean matching=true;\n    int j=0;\n    while (matching && j < searchMatrix.getRowDimension()) {\n      double colEntry=searchMatrix.getEntry(j,i);\n      if (FastMath.abs(multiplier - 1.0) <= FastMath.ulp(1.0) && FastMath.abs(colEntry) > 1E-14 && FastMath.abs(column[j]) > 1e-14) {\n        multiplier=colEntry / column[j];\n      }\n      if (FastMath.abs(column[j] * multiplier - colEntry) > tolerance) {\n        matching=false;\n      }\n      j++;\n    }\n    found=matching;\n    i++;\n  }\n  return found;\n}\n", "nl": "Returns true iff there is a column that is a scalar multiple of column in searchMatrix (modulo tolerance)"}
{"code": "public void reduceSelection(int toRow,int toCol){\n  if (toRow > totalRows)   toRow=totalRows;\n  if (toCol > totalCols)   toCol=totalCols;\n  boolean firstRowBest=false;\n  if (Math.abs(toRow - firstRow) < Math.abs(toRow - lastRow)) {\n    firstRowBest=true;\n  }\n  int bestRowScore=Math.min(Math.abs(toRow - firstRow),Math.abs(toRow - lastRow));\n  boolean firstColBest=false;\n  if (Math.abs(toCol - firstCol) < Math.abs(toCol - lastCol)) {\n    firstColBest=true;\n  }\n  int bestColScore=Math.min(Math.abs(toCol - firstCol),Math.abs(toCol - lastCol));\n  if (toRow != -1 && (toCol == -1 || bestRowScore < bestColScore)) {\n    if (firstRowBest)     firstRow=toRow;\n else     lastRow=toRow;\n    fireSelectionChanged();\n  }\n else   if (toCol != -1) {\n    if (firstColBest)     firstCol=toCol;\n else     lastCol=toCol;\n    fireSelectionChanged();\n  }\n}\n", "nl": "reduce a selection"}
{"code": "public static String md5File(final InputStream inputStream){\n  String result=null;\n  if (inputStream != null) {\n    try {\n      MessageDigest md=MessageDigest.getInstance(\"MD5\");\n      byte[] buffer=new byte[Constant.Capacity.BYTES_PER_KB];\n      int readCount=0;\n      while ((readCount=inputStream.read(buffer,0,buffer.length)) != -1) {\n        md.update(buffer,0,readCount);\n      }\n      result=StringUtil.byteToHexString(md.digest());\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n    }\n finally {\n      try {\n        inputStream.close();\n      }\n catch (      IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n  return result;\n}\n", "nl": "md5 file"}
{"code": "private void createForLoop2(polyglot.ast.For forStmt){\n  endControlNoop.push(soot.jimple.Jimple.v().newNopStmt());\n  condControlNoop.push(soot.jimple.Jimple.v().newNopStmt());\n  Iterator initsIt=forStmt.inits().iterator();\n  while (initsIt.hasNext()) {\n    createStmt((polyglot.ast.Stmt)initsIt.next());\n  }\n  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();\n  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();\n  body.getUnits().add(noop2);\n  polyglot.ast.Expr condition=forStmt.cond();\n  if (condition != null) {\n    createBranchingExpr(condition,noop1,false);\n  }\n  createStmt(forStmt.body());\n  body.getUnits().add((condControlNoop.pop()));\n  if (labelMap != null && labelMap.containsKey(forStmt)) {\n    body.getUnits().add(labelMap.get(forStmt));\n  }\n  Iterator itersIt=forStmt.iters().iterator();\n  while (itersIt.hasNext()) {\n    createStmt((polyglot.ast.Stmt)itersIt.next());\n  }\n  soot.jimple.Stmt goto1=soot.jimple.Jimple.v().newGotoStmt(noop2);\n  body.getUnits().add(goto1);\n  body.getUnits().add(noop1);\n  body.getUnits().add((endControlNoop.pop()));\n}\n", "nl": "For Loop Stmts Creation"}
{"code": "public Boolean createSupplier(EntityManager em,String supplierId){\n  Boolean status=true;\n  Supplier supplier=null;\n  try {\n    if (!em.getTransaction().isActive()) {\n      em.getTransaction().begin();\n    }\n    supplier=new Supplier();\n    supplier.setSupplierId(supplierId);\n    supplier.setPhoneNumber(\"009180437980098\");\n    em.persist(supplier);\n    em.getTransaction().commit();\n  }\n catch (  Exception e) {\n    status=false;\n    logger.error(\"Error occured during creation of Supplier. Detailed info: \" + e);\n  }\n  return status;\n}\n", "nl": "Helper method to create Supplier"}
{"code": "public static long exportAll(BlastMode blastMode,IConnector connector,String fileName,ProgressListener progressListener) throws IOException {\n  progressListener.setTasks(\"Export\",\"Writing all matches\");\n  long countMatches=0;\n  try {\n    try (BufferedWriter w=new BufferedWriter(new FileWriter(fileName))){\n      w.write(blastMode.toString().toUpperCase() + \" file generated by MEGAN6\\n\\n\");\n      IReadBlockIterator it=connector.getAllReadsIterator(0,10000,true,true);\n      progressListener.setMaximum(it.getMaximumProgress());\n      progressListener.setProgress(0);\n      while (it.hasNext()) {\n        countMatches+=writeMatches(it.next(),w);\n        progressListener.setProgress(it.getProgress());\n      }\n    }\n   }\n catch (  CanceledException ex) {\n    System.err.println(\"USER CANCELED\");\n  }\n  return countMatches;\n}\n", "nl": "export all matches in file"}
{"code": "private void saveState(){\n  try {\n    IPath pluginStateLocation=SVNProviderPlugin.getPlugin().getStateLocation();\n    File tempFile=pluginStateLocation.append(REPOSITORIES_STATE_FILE + \".tmp\").toFile();\n    File stateFile=pluginStateLocation.append(REPOSITORIES_STATE_FILE).toFile();\n    try {\n      DataOutputStream dos=new DataOutputStream(new FileOutputStream(tempFile));\n      writeState(dos);\n      dos.close();\n      if (stateFile.exists()) {\n        stateFile.delete();\n      }\n      boolean renamed=tempFile.renameTo(stateFile);\n      if (!renamed) {\n        throw new TeamException(new Status(Status.ERROR,SVNProviderPlugin.ID,TeamException.UNABLE,Policy.bind(\"SVNProvider.rename\",tempFile.getAbsolutePath()),null));\n      }\n    }\n catch (    IOException e) {\n      throw new TeamException(new Status(Status.ERROR,SVNProviderPlugin.ID,TeamException.UNABLE,Policy.bind(\"SVNProvider.save\",stateFile.getAbsolutePath()),e));\n    }\n  }\n catch (  TeamException e) {\n    Util.logError(Policy.bind(\"SVNProvider.errorSaving\"),e);\n  }\n}\n", "nl": "Save the state of the plugin, ie the repositories locations"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set font=\");\n  String fontName=np.getWordRespectCase();\n  np.matchIgnoreCase(\";\");\n  Font font=Font.decode(fontName);\n  boolean changed=false;\n  ViewerBase viewer=(ViewerBase)getViewer();\n  Set<Node> nodes=new HashSet<>();\n  if (viewer.getSelectedNodes().size() == 0 && viewer.getSelectedEdges().size() == 0) {\n    for (Node v=viewer.getGraph().getFirstNode(); v != null; v=v.getNext())     nodes.add(v);\n  }\n else   nodes.addAll(viewer.getSelectedNodes());\n  for (  Node v : nodes) {\n    viewer.setFont(v,font);\n    changed=true;\n  }\n  for (  Edge e : viewer.getSelectedEdges()) {\n    viewer.setFont(e,font);\n    changed=true;\n  }\n  if (changed)   viewer.repaint();\n}\n", "nl": "parses the given command and executes it"}
{"code": "@deprecated protected int handleNext(){\n  CharacterIterator text=getText();\n  if ((this.cachedBreakPositions == null) || (this.positionInCache == this.cachedBreakPositions.length - 1)) {\n    int startPos=text.getIndex();\n    this.fDictionaryCharCount=0;\n    int result=super.handleNext();\n    if ((!this.usingCTDictionary) && (this.fDictionaryCharCount > 1) && (result - startPos > 1)) {\n      divideUpDictionaryRange(startPos,result);\n    }\n else {\n      this.cachedBreakPositions=null;\n      return result;\n    }\n  }\n  if (this.cachedBreakPositions != null) {\n    this.positionInCache+=1;\n    text.setIndex(this.cachedBreakPositions[this.positionInCache]);\n    return this.cachedBreakPositions[this.positionInCache];\n  }\n  Assert.assrt(false);\n  return 55537;\n}\n", "nl": "/*    "}
{"code": "protected void readChangeLogNode(XmlPullParser parser,ChangeLog changeLog) throws Exception {\n  if (parser == null || changeLog == null)   return;\n  parser.require(XmlPullParser.START_TAG,null,TAG_CHANGELOG);\n  String bulletedList=parser.getAttributeValue(null,ATTRIBUTE_BULLETEDLIST);\n  if (bulletedList == null || bulletedList.equals(\"true\")) {\n    changeLog.setBulletedList(true);\n    super.bulletedList=true;\n  }\n else {\n    changeLog.setBulletedList(false);\n    super.bulletedList=false;\n  }\n  while (parser.next() != XmlPullParser.END_TAG) {\n    if (parser.getEventType() != XmlPullParser.START_TAG) {\n      continue;\n    }\n    String tag=parser.getName();\n    if (tag.equals(TAG_CHANGELOGVERSION)) {\n      readChangeLogVersionNode(parser,changeLog);\n    }\n  }\n}\n", "nl": "Parse changelog node"}
{"code": "public void load(String fileName) throws IOException, MaryConfigurationException {\n  DataInputStream dis=null;\n  try {\n    dis=new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)));\n  }\n catch (  FileNotFoundException e) {\n    throw new RuntimeException(\"File [\" + fileName + \"] was not found.\");\n  }\n  try {\n    hdr=new MaryHeader(dis);\n    if (hdr.getType() != MaryHeader.SCOST) {\n      throw new RuntimeException(\"File [\" + fileName + \"] is not a valid Mary Units file.\");\n    }\n    numberOfUnits=dis.readInt();\n    if (numberOfUnits < 0) {\n      throw new RuntimeException(\"File [\" + fileName + \"] has a negative number of units. Aborting.\");\n    }\n    sCost=new double[numberOfUnits];\n    for (int i=0; i < numberOfUnits; i++) {\n      sCost[i]=dis.readFloat();\n    }\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"Reading the Mary header from file [\" + fileName + \"] failed.\",e);\n  }\n}\n", "nl": "Load the given unit file"}
{"code": "public static Map<String,Object> jsonStringToMap(String jsonString,DataSchema dataSchema){\n  Map<String,Object> value=new HashMap<>();\n  JSONParser jsonParser=new JSONParser();\n  try {\n    JSONObject jsonObj=(JSONObject)jsonParser.parse(jsonString);\n    for (    Object key : jsonObj.keySet()) {\n      String mapKey=key.toString();\n      if (jsonObj.get(key) != null) {\n        if (dataSchema.isArrayElement((String)key)) {\n          ArrayList<String> mapValue=StringUtils.jsonArrayStringToArrayList(jsonObj.get(key).toString());\n          value.put(mapKey,mapValue);\n        }\n else {\n          value.put(mapKey,jsonObj.get(key).toString());\n        }\n      }\n    }\n  }\n catch (  ParseException e) {\n    logger.warn(\"Could not json-decode string: \" + jsonString,e);\n  }\ncatch (  NumberFormatException e) {\n    logger.warn(\"Could not parse field into number: \" + jsonString,e);\n  }\n  return value;\n}\n", "nl": "Method to take an input json string and output a Map<String, Object> with arrays as ArrayList<String> objects and single values as String objects"}
{"code": "protected static void chooseAttack(NpcAI2 npcAI,int delay){\n  AttackIntention attackIntention=npcAI.chooseAttackIntention();\n  if (npcAI.isLogging()) {\n    AI2Logger.info(npcAI,\"AttackManager: chooseAttack \" + attackIntention + \" delay \"+ delay);\n  }\n  if (!npcAI.canThink()) {\n    return;\n  }\nswitch (attackIntention) {\ncase SIMPLE_ATTACK:\n    SimpleAttackManager.performAttack(npcAI,delay);\n  break;\ncase SKILL_ATTACK:\nSkillAttackManager.performAttack(npcAI,delay);\nbreak;\ncase FINISH_ATTACK:\nnpcAI.think();\nbreak;\ndefault :\nbreak;\n}\n}\n", "nl": "choose attack type"}
{"code": "public Matrix solve(Matrix B){\n  if (B.getRowDimension() != n) {\n    throw new IllegalArgumentException(\"Matrix row dimensions must agree.\");\n  }\n  if (!isspd) {\n    throw new RuntimeException(\"Matrix is not symmetric positive definite.\");\n  }\n  double[][] X=B.getArrayCopy();\n  int nx=B.getColumnDimension();\n  for (int k=0; k < n; k++) {\n    for (int j=0; j < nx; j++) {\n      for (int i=0; i < k; i++) {\n        X[k][j]-=X[i][j] * L[k][i];\n      }\n      X[k][j]/=L[k][k];\n    }\n  }\n  for (int k=n - 1; k >= 0; k--) {\n    for (int j=0; j < nx; j++) {\n      for (int i=k + 1; i < n; i++) {\n        X[k][j]-=X[i][j] * L[i][k];\n      }\n      X[k][j]/=L[k][k];\n    }\n  }\n  return new Matrix(X,n,nx);\n}\n", "nl": "Solve A*X = B"}
{"code": "private void updateFromHoverListener(int x,int y){\n  mHoverListener.populate();\n  mHoverListener.find(x,y);\n  ConstraintWidget widget=mHoverListener.mHitWidget;\n  ConstraintAnchor anchor=mHoverListener.getConstraintAnchor();\n  ResizeHandle handle=mHoverListener.mHitResizeHandle;\n  mMouseCursor=updateMouseCursor(handle);\n  if (mPreviousHoverWidget != null) {\n    if (!mSelection.contains(mPreviousHoverWidget)) {\n      getDecorator(mPreviousHoverWidget).setLook(ColorTheme.Look.NORMAL);\n    }\n  }\n  if (widget != null) {\n    if (!mSelection.contains(widget)) {\n      getDecorator(widget).setLook(ColorTheme.Look.HIGHLIGHTED);\n    }\n    mPreviousHoverWidget=widget;\n  }\n  mSceneDraw.setCurrentUnderneathAnchor(anchor);\n  mSceneDraw.repaint();\n}\n", "nl": "Check the hover listener for any anchor to lit"}
{"code": "@NonNull public static List<Project> create(@NonNull IntellijLintClient client,@Nullable List<VirtualFile> files,@NonNull Module... modules){\n  List<Project> projects=Lists.newArrayList();\n  Map<Project,Module> projectMap=Maps.newHashMap();\n  Map<Module,Project> moduleMap=Maps.newHashMap();\n  Map<AndroidLibrary,Project> libraryMap=Maps.newHashMap();\n  if (files != null && !files.isEmpty()) {\n    files=Lists.newArrayList(files);\n  }\n  for (  Module module : modules) {\n    addProjects(client,module,files,moduleMap,libraryMap,projectMap,projects);\n  }\n  client.setModuleMap(projectMap);\n  if (projects.size() > 1) {\n    Set<Project> roots=new HashSet<Project>(projects);\n    for (    Project project : projects) {\n      roots.removeAll(project.getAllLibraries());\n    }\n    return Lists.newArrayList(roots);\n  }\n else {\n    return projects;\n  }\n}\n", "nl": "Creates a set of projects for the given IntelliJ modules"}
{"code": "public void delayRenew(){\n  long delta=endTime - renew;\n  if (delta <= renewalRTT) {\n    return;\n  }\n else   if (delta <= renewalRTT * 3) {\n    delta=renewalRTT;\n  }\n else   if (delta <= 1000 * 60 * 60) {\n    delta/=3;\n  }\n else   if (delta <= 1000 * 60 * 60* 24) {\n    delta=1000 * 60 * 30;\n  }\n else   if (delta <= 1000 * 60 * 60* 24* 7) {\n    delta=1000 * 60 * 60* 3;\n  }\n else {\n    delta=1000 * 60 * 60* 8;\n  }\n  renew+=delta;\n}\n", "nl": "Calculate a new renew time due to an indefinite exception"}
{"code": "public Matrix solve(Matrix B){\n  if (B.getRowDimension() != n) {\n    throw new IllegalArgumentException(\"Matrix row dimensions must agree.\");\n  }\n  if (!isspd) {\n    throw new RuntimeException(\"Matrix is not symmetric positive definite.\");\n  }\n  double[][] X=B.getArrayCopy();\n  int nx=B.getColumnDimension();\n  for (int k=0; k < n; k++) {\n    for (int j=0; j < nx; j++) {\n      for (int i=0; i < k; i++) {\n        X[k][j]-=X[i][j] * L[k][i];\n      }\n      X[k][j]/=L[k][k];\n    }\n  }\n  for (int k=n - 1; k >= 0; k--) {\n    for (int j=0; j < nx; j++) {\n      for (int i=k + 1; i < n; i++) {\n        X[k][j]-=X[i][j] * L[i][k];\n      }\n      X[k][j]/=L[k][k];\n    }\n  }\n  return new Matrix(X,n,nx);\n}\n", "nl": "Solve A*X = B"}
{"code": "private long[] helperHuntingRewardMonster(long id){\n  ArrayList<Long> ids=new ArrayList<Long>();\n  ids.add(id);\n  MonsterCursor monsterCursor=mHelper.queryMonster(id);\n  monsterCursor.moveToFirst();\n  String name=monsterCursor.getMonster().getName();\n  monsterCursor.close();\n  monsterCursor=mHelper.queryMonsterTrait(name);\n  monsterCursor.moveToFirst();\n  while (!monsterCursor.isAfterLast()) {\n    ids.add(monsterCursor.getMonster().getId());\n    monsterCursor.moveToNext();\n  }\n  monsterCursor.close();\n  long[] idArray=new long[ids.size()];\n  for (int i=0; i < idArray.length; i++) {\n    idArray[i]=ids.get(i);\n  }\n  return idArray;\n}\n", "nl": "HUNTING REWARD QUERIES"}
{"code": "private static void write(IReadBlock readBlock,Writer w) throws IOException {\n  String header=readBlock.getReadHeader();\n  if (header != null) {\n    if (!header.startsWith(\">\"))     w.write(\">\");\n    w.write(header);\n    if (!header.endsWith(\"\\n\"))     w.write(\"\\n\");\n  }\n else   w.write(\">null\\n\");\n  String sequence=readBlock.getReadSequence();\n  if (sequence != null) {\n    if (sequence.endsWith(\"\\n\\n\")) {\n      w.write(sequence.substring(0,sequence.length() - 1));\n    }\n else {\n      w.write(sequence);\n      if (!sequence.endsWith(\"\\n\"))       w.write(\"\\n\");\n    }\n  }\n else   w.write(\"null\\n\");\n}\n", "nl": "write the read"}
{"code": "public Document fromXMLtoDOC(final String xml){\n  Document confXMLDoc;\n  log.trace(\"fromXMLtoDOC - trying to configure process using configuration XML\");\n  SimpleXMLParser parser=null;\n  try {\n    parser=new SimpleXMLParser();\n    confXMLDoc=parser.parse(xml);\n  }\n catch (  ParserConfigurationException e) {\n    log.error(\"fromXMLtoDOC - Error creating instance of SimpleXMLParser\");\n    return null;\n  }\ncatch (  ParserException ex) {\n    log.error(\"fromXMLtoDOC - Exception caught in DOM parsing processConfiguration XML\");\n    log.trace(\"fromXMLtoDOC - processConfiguration XML was: \" + xml);\n    return null;\n  }\n  log.trace(\"fromXMLtoDOC - Configuration XML loaded and parsed\");\n  return confXMLDoc;\n}\n", "nl": "Loads the configuration from the XML file given by the server and stored in the"}
{"code": "public static List parseConfiguration(Element element){\n  String componentName=null;\n  List configList=new ArrayList();\n  NodeList nList=element.getChildNodes();\n  for (int i=0; i < nList.getLength(); i++) {\n    Node node=nList.item(i);\n    if (node.getNodeType() == Node.ELEMENT_NODE) {\n      Element el=(Element)node;\n      if (el.getTagName().equalsIgnoreCase(\"component\")) {\n        NamedNodeMap nm=nList.item(i).getAttributes();\n        Node node1=nm.getNamedItem(\"Name\");\n        if (node1 == null)         node1=nm.getNamedItem(\"name\");\n        componentName=node1.getNodeValue();\n        if (!componentName.endsWith(\".\"))         componentName=componentName + \".\";\n        componentName=componentName.replace(' ','_');\n        Map parms=parseParameters(el);\n        for (Iterator it=parms.entrySet().iterator(); it.hasNext(); ) {\n          Map.Entry me=(Map.Entry)it.next();\n          String name=(String)me.getKey();\n          String value=(String)me.getValue();\n          configList.add(componentName + name + \"=\"+ value);\n        }\n      }\n    }\n  }\n  return (configList);\n}\n", "nl": "Parse a Configuration entry"}
{"code": "private int klattRule10(Element segment){\n  boolean hasPrecedingConsonant=false;\n  boolean hasFollowingConsonant=false;\n  if (isConsonant(segment)) {\n    Element preceding=getPreviousSegment(segment);\n    if (preceding != null && isConsonant(preceding)) {\n      hasPrecedingConsonant=true;\n    }\n    Element following=getNextSegment(segment);\n    if (following != null && isConsonant(following)) {\n      hasFollowingConsonant=true;\n    }\n    if (hasPrecedingConsonant && hasFollowingConsonant) {\n      return getPropertyAsInteger(\"rule10.surrounded\");\n    }\n else     if (hasPrecedingConsonant) {\n      return getPropertyAsInteger(\"rule10.preceded\");\n    }\n else     if (hasFollowingConsonant) {\n      return getPropertyAsInteger(\"rule10.followed\");\n    }\n  }\n  return 100;\n}\n", "nl": "Klatt Rule 10: Shortening in consonant clusters"}
{"code": "private void handlePartSelectionChanged(IWorkbenchPart part,ISelection selection){\n  if (!(selection instanceof IStructuredSelection))   return;\n  try {\n    Object first=((IStructuredSelection)selection).getFirstElement();\n    if (first instanceof IAdaptable) {\n      IAdaptable a=(IAdaptable)first;\n      Object adapter=a.getAdapter(IResource.class);\n      if (adapter instanceof IResource) {\n        IResource resource=(IResource)adapter;\n        if (!resource.isAccessible()) {\n          showSvnProperties(null);\n        }\n else {\n          ISVNLocalResource svnResource=(ISVNLocalResource)resource.getAdapter(ISVNLocalResource.class);\n          showSvnProperties(svnResource);\n        }\n      }\n    }\n  }\n catch (  SVNException e) {\n  }\n}\n", "nl": "called when the selection changed on another part "}
{"code": "private void clickImage(int position){\n  int selectedItemPosition=selectedImagePosition(images.get(position));\n  if (mode == ImagePickerActivity.MODE_MULTIPLE) {\n    if (selectedItemPosition == -1) {\n      if (selectedImages.size() < limit) {\n        imageAdapter.addSelected(images.get(position));\n      }\n else {\n        Toast.makeText(this,R.string.msg_limit_images,Toast.LENGTH_SHORT).show();\n      }\n    }\n else {\n      imageAdapter.removeSelectedPosition(selectedItemPosition,position);\n    }\n  }\n else {\n    if (selectedItemPosition != -1)     imageAdapter.removeSelectedPosition(selectedItemPosition,position);\n else {\n      if (selectedImages.size() > 0) {\n        imageAdapter.removeAllSelectedSingleClick();\n      }\n      imageAdapter.addSelected(images.get(position));\n    }\n  }\n  updateTitle();\n}\n", "nl": "Handle image selection event: add or remove selected image, change title"}
{"code": "public void loadComplete(PdfDocument pdfDocument){\n  state=State.LOADED;\n  this.documentPageCount=pdfiumCore.getPageCount(pdfDocument);\n  int firstPageIdx=0;\n  if (originalUserPages != null) {\n    firstPageIdx=originalUserPages[0];\n  }\n  this.pdfDocument=pdfDocument;\n  pdfiumCore.openPage(pdfDocument,firstPageIdx);\n  this.pageWidth=pdfiumCore.getPageWidth(pdfDocument,firstPageIdx);\n  this.pageHeight=pdfiumCore.getPageHeight(pdfDocument,firstPageIdx);\n  calculateOptimalWidthAndHeight();\n  pagesLoader=new PagesLoader(this);\n  renderingAsyncTask=new RenderingAsyncTask(this,pdfiumCore,pdfDocument);\n  renderingAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);\n  if (scrollHandle != null) {\n    scrollHandle.setupLayout(this);\n    isScrollHandleInit=true;\n  }\n  jumpTo(defaultPage,false);\n  if (onLoadCompleteListener != null) {\n    onLoadCompleteListener.loadComplete(documentPageCount);\n  }\n}\n", "nl": "Called when the PDF is loaded"}
{"code": "public void writeDiscoveryToXml(String FilePath,int pages,hipda hipda) throws Exception {\n  Writer fw=null;\n  try {\n    FileOutputStream fos=new FileOutputStream(FilePath);\n    fw=new OutputStreamWriter(fos,\"UTF-8\");\n    fw.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" + \"\\r\\n\");\n    fw.write(\"<discovery>\" + \"\\r\\n\");\n    for (int i=1; i <= pages; i++) {\n      System.out.println(\"Writting page \" + i);\n      fw.write(hipda.requestDiscoveryContent(hipda.login(),i));\n    }\n    fw.write(\"</discovery>\" + \"\\r\\n\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n finally {\n    fw.close();\n  }\n}\n", "nl": "Use this method to save data to xml file"}
{"code": "public void createPolicies(String path,boolean readFromGlobal) throws Exception {\n  try {\n    checkNotNull(path,\"path can't be null\");\n    checkArgument(path.startsWith(LOCAL_POLICIES_ROOT),\"Invalid path of local policies\");\n    LocalPolicies localPolicies=new LocalPolicies();\n    if (readFromGlobal) {\n      String globalPath=joinPath(POLICIES_ROOT,path.substring(path.indexOf(LOCAL_POLICIES_ROOT) + LOCAL_POLICIES_ROOT.length() + 1));\n      Policies glbPolicies=configurationCacheService.policiesCache().get(globalPath);\n      localPolicies.bundles=glbPolicies.bundles;\n    }\n    ZooKeeper zk=cache.getZooKeeper();\n    try {\n      ZkUtils.createFullPathOptimistic(zk,path,ObjectMapperFactory.getThreadLocal().writeValueAsBytes(localPolicies),Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);\n    }\n catch (    KeeperException.NodeExistsException e) {\n    }\n  }\n catch (  KeeperException.NoNodeException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    LOG.error(\"Failed to create policies for {} in local zookeeper: {}\",path,e.getMessage(),e);\n    throw new PulsarServerException(e);\n  }\n}\n", "nl": "Create LocalPolicies with bundle-data in LocalZookeeper by fetching it from GlobalZookeeper"}
{"code": "private static float alignmentProbability(Rectangle[] widget){\n  float[] start=new float[widget.length];\n  float[] center=new float[widget.length];\n  float[] end=new float[widget.length];\n  float widthSum=0;\n  int count=0;\n  for (int i=0; i < end.length; i++) {\n    if (widget[i] == null) {\n      start[i]=Float.NaN;\n      end[i]=Float.NaN;\n      center[i]=Float.NaN;\n      continue;\n    }\n    start[i]=widget[i].x;\n    end[i]=start[i] + widget[i].width;\n    center[i]=(start[i] + end[i]) / 2;\n    widthSum+=widget[i].width;\n    count++;\n  }\n  float startDiv=standardDeviation(start);\n  float centerDiv=standardDeviation(center);\n  float endDiv=standardDeviation(end);\n  if (count > 2) {\n    return 1 - Math.min(startDiv,Math.min(centerDiv,endDiv)) / (widthSum / count);\n  }\n  return 0;\n}\n", "nl": "Infer alignment for each column"}
{"code": "private int computeOrphan2AncestorMappingRec(Node v,Map<Integer,Integer> orphan2AncestorMapping,Set<Integer> orphans) throws CanceledException {\n  if (progress != null)   progress.incrementProgress();\n  int taxId=(Integer)v.getInfo();\n  if (taxId < 0)   return 0;\n  int below=0;\n  Set<Integer> orphansBelow=new HashSet<>();\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    Node w=e.getTarget();\n    below+=computeOrphan2AncestorMappingRec(w,orphan2AncestorMapping,orphansBelow);\n  }\n  Integer count=id2count.get(taxId);\n  if (count == null)   count=0;\n  if (below + count >= minSupport && !idMapper.isDisabled(taxId)) {\n    for (    Integer id : orphansBelow) {\n      orphan2AncestorMapping.put(id,taxId);\n    }\n  }\n else {\n    if (count > 0) {\n      orphansBelow.add(taxId);\n    }\n    orphans.addAll(orphansBelow);\n  }\n  return below + count;\n}\n", "nl": "recursively move all reads that land on taxa with too little support or on a disabled taxon to higher level nodes"}
{"code": "public QuerierCLI(String[] args){\n  cliOptions=createOptions();\n  try {\n    CommandLineParser parser=new GnuParser();\n    commandLine=parser.parse(cliOptions,args,true);\n    if (hasOption(\"h\")) {\n      printHelp();\n      System.exit(1);\n    }\n    if (!parseOptions()) {\n      logger.info(\"The provided options are not valid\");\n      printHelp();\n      System.exit(1);\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    System.exit(1);\n  }\n}\n", "nl": "Create and parse allowable options"}
{"code": "protected void drawXAxis(Graphics2D gc){\n  gc.setFont(getFont(ChartViewer.FontKeys.XAxisFont.toString()));\n  gc.setColor(getFontColor(ChartViewer.FontKeys.XAxisFont.toString(),Color.BLACK));\n  int x=5;\n  int y=getHeight() - bottomMargin + 25;\n  if (isTranspose())   gc.drawString(getChartData().getClassesLabel(),x,y);\n else {\n    String prefix=null;\n    final Document doc=getViewer().getDir().getDocument();\n    final boolean hasGroups=doc.getSampleAttributeTable().hasGroups();\n    for (    String sample : doc.getSampleAttributeTable().getSampleOrder()) {\n      String groupId=hasGroups ? doc.getSampleAttributeTable().getGroupId(sample) : \"all\";\n      if (groupId != null) {\n        int pos=groupId.indexOf('=');\n        if (pos > 0) {\n          if (prefix == null)           prefix=groupId.substring(0,pos);\n else           if (!prefix.equals(groupId.substring(0,pos))) {\n            prefix=null;\n            break;\n          }\n        }\n      }\n    }\n    gc.drawString(prefix != null ? prefix : \"Grouped\",x,y);\n  }\n}\n", "nl": "draw the x axis"}
{"code": "public static DataType fromExternalToWrapperDataType(org.apache.carbondata.format.DataType dataType){\n  if (null == dataType) {\n    return null;\n  }\nswitch (dataType) {\ncase STRING:\n    return DataType.STRING;\ncase INT:\n  return DataType.INT;\ncase LONG:\nreturn DataType.LONG;\ncase DOUBLE:\nreturn DataType.DOUBLE;\ncase DECIMAL:\nreturn DataType.DECIMAL;\ncase TIMESTAMP:\nreturn DataType.TIMESTAMP;\ncase ARRAY:\nreturn DataType.ARRAY;\ncase STRUCT:\nreturn DataType.STRUCT;\ndefault :\nreturn DataType.STRING;\n}\n}\n", "nl": "convert from external to wrapper data type"}
{"code": "private void toWagonFormat(FeatureVectorLeafNode node,DataOutputStream out,String extension,PrintWriter pw) throws IOException {\n  StringBuilder sb=new StringBuilder();\n  FeatureVector fv[]=node.getFeatureVectors();\n  sb.append(\"(((\");\n  for (int i=0; i < fv.length; i++) {\n    sb.append(\"(\" + fv[i].getUnitIndex() + \" 0)\");\n    if (i + 1 != fv.length) {\n      sb.append(\" \");\n    }\n  }\n  sb.append(\") 0))\" + extension);\n  if (out != null) {\n    writeStringToOutput(sb.toString(),out);\n  }\n else {\n  }\n  if (pw != null) {\n    pw.println(sb.toString());\n  }\n}\n", "nl": "Writes the Cart to the given DataOut in Wagon Format"}
{"code": "public static int parseMagnitude(String aLine){\n  if (aLine != null) {\n    if (underScoreEnabled) {\n      if (!warned) {\n        System.err.println(\"Using underscore parsing of magnitudes - only use with CREST\");\n        warned=true;\n      }\n      String firstWord=Basic.getFirstWord(aLine);\n      int pos=firstWord.lastIndexOf('_');\n      if (Basic.isInteger(firstWord.substring(pos + 1)))       return Math.max(1,Integer.parseInt(firstWord.substring(pos + 1)));\n    }\n    if (enabled) {\n      int pos=aLine.indexOf(MAGNITUDE_TAG);\n      int next=pos + MAGNITUDE_TAG.length();\n      if (pos == -1) {\n        pos=aLine.indexOf(WEIGHT_TAG);\n        next=pos + WEIGHT_TAG.length();\n      }\n      if (pos >= 0 && next < aLine.length() && (aLine.charAt(next) == '|' || aLine.charAt(next) == '=')) {\n        int end=next + 1;\n        while (end < aLine.length() && Character.isDigit(aLine.charAt(end)))         end++;\n        String number=aLine.substring(next + 1,end);\n        if (Basic.isInteger(number))         return Math.max(1,Basic.parseInt(number));\n      }\n    }\n  }\n  return 1;\n}\n", "nl": "attempt to parse the weight from the info line of a read"}
{"code": "public static boolean calculateMagicalCriticalRate(Creature attacker,Creature attacked,int criticalProb){\n  if (attacker instanceof Servant || attacker instanceof Homing) {\n    return false;\n  }\n  int critical=attacker.getGameStats().getMCritical().getCurrent();\n  if (attacked instanceof Player) {\n    critical=attacked.getGameStats().getPositiveReverseStat(StatEnum.MAGICAL_CRITICAL_RESIST,critical) + attacked.getGameStats().getPositiveReverseStat(StatEnum.PVP_MAGICAL_RESIST,critical);\n  }\n else {\n    critical=attacked.getGameStats().getPositiveReverseStat(StatEnum.MAGICAL_CRITICAL_RESIST,critical);\n  }\n  critical*=(float)criticalProb / 100f;\n  double criticalRate;\n  if (critical <= 440) {\n    criticalRate=critical * 0.1f;\n  }\n else   if (critical <= 600) {\n    criticalRate=(440 * 0.1f) + ((critical - 440) * 0.05f);\n  }\n else {\n    criticalRate=(440 * 0.1f) + (160 * 0.05f) + ((critical - 600) * 0.02f);\n  }\n  return Rnd.nextInt(100) < criticalRate;\n}\n", "nl": "Calculates MAGICAL CRITICAL chance"}
{"code": "private void createAndOpenProject(IProject project,IProjectDescription desc,IProgressMonitor monitor) throws SVNException {\n  try {\n    monitor.beginTask(null,5);\n    if (project.exists()) {\n      if (desc != null) {\n        project.move(desc,true,Policy.subMonitorFor(monitor,3));\n      }\n    }\n else {\n      if (desc == null) {\n        project.create(Policy.subMonitorFor(monitor,3));\n      }\n else {\n        project.create(desc,Policy.subMonitorFor(monitor,3));\n      }\n    }\n    if (!project.isOpen()) {\n      project.open(Policy.subMonitorFor(monitor,2));\n    }\n  }\n catch (  CoreException e) {\n    throw SVNException.wrapException(e);\n  }\n finally {\n    monitor.done();\n  }\n}\n", "nl": "Creates a project and open it"}
{"code": "@SuppressWarnings(\"unchecked\") public JavaRDD<MapWritable> readDataES() throws IOException, PIRException {\n  logger.info(\"Reading data \");\n  JavaRDD<MapWritable> jsonRDD;\n  Job job=Job.getInstance();\n  String jobName=\"pirSpark_ES_\" + esQuery + \"_\"+ System.currentTimeMillis();\n  job.setJobName(jobName);\n  job.getConfiguration().set(\"es.nodes\",SystemConfiguration.getProperty(\"es.nodes\"));\n  job.getConfiguration().set(\"es.port\",SystemConfiguration.getProperty(\"es.port\"));\n  job.getConfiguration().set(\"es.resource\",esResource);\n  job.getConfiguration().set(\"es.query\",esQuery);\n  jsonRDD=sc.newAPIHadoopRDD(job.getConfiguration(),EsInputFormat.class,Text.class,MapWritable.class).values().coalesce(numDataPartitions);\n  if (qSchema.getFilter() != null) {\n    return jsonRDD.filter(new FilterData(accum,bVars));\n  }\n else {\n    logger.info(\"qSchema.getFilter() is null\");\n    return jsonRDD;\n  }\n}\n", "nl": "Method to read in the data from elasticsearch, filter, and return a RDD of MapWritable data elements"}
{"code": "public String requestServiceFromThirdPartyWebApp() throws Exception {\n  String url=ConsumerWebAppURL + \"?scope=\" + OAuthUtils.encodeForOAuth(EndUserResourceURL);\n  WebTarget target=ClientBuilder.newClient().target(url);\n  Invocation.Builder builder=target.request();\n  Response response=null;\n  try {\n    response=builder.get();\n    if (302 != response.getStatus()) {\n      throw new RuntimeException(\"Service request has failed - redirection is expected\");\n    }\n    String authorizationURI=response.getStringHeaders().getFirst(\"Location\");\n    if (authorizationURI == null) {\n      throw new RuntimeException(\"Token authorization URI is missing\");\n    }\n    return authorizationURI;\n  }\n  finally {\n    response.close();\n  }\n}\n", "nl": "End user requests that a well-known 3rd party web application does something useful on its behalf"}
{"code": "private void parseAttributes(TypedArray a){\n  DisplayMetrics metrics=getContext().getResources().getDisplayMetrics();\n  barWidth=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,barWidth,metrics);\n  rimWidth=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,rimWidth,metrics);\n  circleRadius=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,circleRadius,metrics);\n  circleRadius=(int)a.getDimension(R.styleable.ProgressWheel_matProg_circleRadius,circleRadius);\n  fillRadius=a.getBoolean(R.styleable.ProgressWheel_matProg_fillRadius,false);\n  barWidth=(int)a.getDimension(R.styleable.ProgressWheel_matProg_barWidth,barWidth);\n  rimWidth=(int)a.getDimension(R.styleable.ProgressWheel_matProg_rimWidth,rimWidth);\n  float baseSpinSpeed=a.getFloat(R.styleable.ProgressWheel_matProg_spinSpeed,spinSpeed / 360.0f);\n  spinSpeed=baseSpinSpeed * 360;\n  barSpinCycleTime=a.getInt(R.styleable.ProgressWheel_matProg_barSpinCycleTime,(int)barSpinCycleTime);\n  barColor=a.getColor(R.styleable.ProgressWheel_matProg_barColor,barColor);\n  rimColor=a.getColor(R.styleable.ProgressWheel_matProg_rimColor,rimColor);\n  linearProgress=a.getBoolean(R.styleable.ProgressWheel_matProg_linearProgress,false);\n  if (a.getBoolean(R.styleable.ProgressWheel_matProg_progressIndeterminate,false)) {\n    spin();\n  }\n  a.recycle();\n}\n", "nl": "Parse the attributes passed to the view from the XML"}
{"code": "public static double[][] computeVectors(Document doc,ViewerBase graphView){\n  int numberOfDataSets=doc.getNumberOfSamples();\n  double[] total=new double[numberOfDataSets];\n  HashSet<Integer> seen=new HashSet<>();\n  LinkedList<double[]> rows=new LinkedList<>();\n  for (Node v=graphView.getGraph().getFirstNode(); v != null; v=v.getNext()) {\n    if (graphView.getSelected(v)) {\n      if (!seen.contains((Integer)v.getInfo())) {\n        seen.add((Integer)v.getInfo());\n        double[] row=new double[numberOfDataSets];\n        final int[] counts=(v.getOutDegree() == 0 ? graphView.getNodeData(v).getSummarized() : graphView.getNodeData(v).getAssigned());\n        for (int i=0; i < counts.length; i++) {\n          row[i]=counts[i];\n          total[i]+=row[i];\n        }\n        rows.add(row);\n      }\n    }\n  }\n  for (  double[] row : rows) {\n    for (int i=0; i < row.length; i++) {\n      if (total[i] > 0)       row[i]/=total[i];\n    }\n  }\n  return rows.toArray(new double[rows.size()][]);\n}\n", "nl": "compute vectors for  analysis"}
{"code": "private soot.Value reverseCondition(soot.jimple.ConditionExpr cond){\n  soot.jimple.ConditionExpr newExpr;\n  if (cond instanceof soot.jimple.EqExpr) {\n    newExpr=soot.jimple.Jimple.v().newNeExpr(cond.getOp1(),cond.getOp2());\n  }\n else   if (cond instanceof soot.jimple.NeExpr) {\n    newExpr=soot.jimple.Jimple.v().newEqExpr(cond.getOp1(),cond.getOp2());\n  }\n else   if (cond instanceof soot.jimple.GtExpr) {\n    newExpr=soot.jimple.Jimple.v().newLeExpr(cond.getOp1(),cond.getOp2());\n  }\n else   if (cond instanceof soot.jimple.GeExpr) {\n    newExpr=soot.jimple.Jimple.v().newLtExpr(cond.getOp1(),cond.getOp2());\n  }\n else   if (cond instanceof soot.jimple.LtExpr) {\n    newExpr=soot.jimple.Jimple.v().newGeExpr(cond.getOp1(),cond.getOp2());\n  }\n else   if (cond instanceof soot.jimple.LeExpr) {\n    newExpr=soot.jimple.Jimple.v().newGtExpr(cond.getOp1(),cond.getOp2());\n  }\n else {\n    throw new RuntimeException(\"Unknown Condition Expr\");\n  }\n  newExpr.getOp1Box().addAllTagsOf(cond.getOp1Box());\n  newExpr.getOp2Box().addAllTagsOf(cond.getOp2Box());\n  return newExpr;\n}\n", "nl": "in bytecode and Jimple the conditions in conditional binary  expressions are often reversed"}
{"code": "private static void resolveUnaryExpression(UnaryExpression objSubjectExpression,@Nullable Function objScope,PhpIndex objIndex,HashSet<String> objTypesSet){\n  PsiElement objOperation=objSubjectExpression.getOperation();\n  if (null == objOperation) {\n    return;\n  }\n  IElementType objType=objOperation.getNode().getElementType();\n  if (PhpTokenTypes.CAST_OPERATORS.contains(objType)) {\n    if (objType == PhpTokenTypes.opINTEGER_CAST) {\n      objTypesSet.add(Types.strInteger);\n    }\n else     if (objType == PhpTokenTypes.opARRAY_CAST) {\n      objTypesSet.add(Types.strArray);\n    }\n else     if (objType == PhpTokenTypes.opBOOLEAN_CAST) {\n      objTypesSet.add(Types.strBoolean);\n    }\n else     if (objType == PhpTokenTypes.opFLOAT_CAST) {\n      objTypesSet.add(Types.strFloat);\n    }\n else     if (objType == PhpTokenTypes.opSTRING_CAST) {\n      objTypesSet.add(Types.strString);\n    }\n    return;\n  }\n  storeAsTypeWithSignaturesImport(objSubjectExpression.getType().toString(),objScope,objIndex,objTypesSet);\n}\n", "nl": "Resolve type casting expressions"}
{"code": "public void rollback() throws GenericDataSourceException {\n  if (_connection == null) {\n    return;\n  }\n  if (Debug.verboseOn())   Debug.logVerbose(\"SQLProcessor:rollback() _manualTX=\" + _manualTX,module);\n  try {\n    if (_manualTX) {\n      _connection.rollback();\n      if (Debug.verboseOn())       Debug.logVerbose(\"SQLProcessor:rollback() : _manualTX=\" + _manualTX,module);\n    }\n else {\n      try {\n        TransactionUtil.setRollbackOnly(\"rollback called in Entity Engine SQLProcessor\",new Exception(\"Current Location Stack\"));\n        if (Debug.verboseOn())         Debug.logVerbose(\"SQLProcessor:rollback() : _manualTX=\" + _manualTX,module);\n      }\n catch (      GenericTransactionException e) {\n        Debug.logError(e,\"Error setting rollback only\",module);\n        throw new GenericDataSourceException(\"Error setting rollback only\",e);\n      }\n    }\n  }\n catch (  SQLException sqle2) {\n    Debug.logWarning(\"[SQLProcessor.rollback]: SQL Exception while rolling back insert. Error was:\" + sqle2,module);\n    Debug.logWarning(sqle2,module);\n  }\n}\n", "nl": "Rollback all modifications"}
{"code": "public void limitTransAndScale(Matrix matrix,RectF content){\n  matrix.getValues(matrixBuffer);\n  float curTransX=matrixBuffer[Matrix.MTRANS_X];\n  float curScaleX=matrixBuffer[Matrix.MSCALE_X];\n  float curTransY=matrixBuffer[Matrix.MTRANS_Y];\n  float curScaleY=matrixBuffer[Matrix.MSCALE_Y];\n  mScaleX=Math.min(Math.max(mMinScaleX,curScaleX),mMaxScaleX);\n  mScaleY=Math.min(Math.max(mMinScaleY,curScaleY),mMaxScaleY);\n  float width=0f;\n  float height=0f;\n  if (content != null) {\n    width=content.width();\n    height=content.height();\n  }\n  float maxTransX=-width * (mScaleX - 1f);\n  mTransX=Math.min(Math.max(curTransX,maxTransX - mTransOffsetX),mTransOffsetX);\n  float maxTransY=height * (mScaleY - 1f);\n  mTransY=Math.max(Math.min(curTransY,maxTransY + mTransOffsetY),-mTransOffsetY);\n  matrixBuffer[Matrix.MTRANS_X]=mTransX;\n  matrixBuffer[Matrix.MSCALE_X]=mScaleX;\n  matrixBuffer[Matrix.MTRANS_Y]=mTransY;\n  matrixBuffer[Matrix.MSCALE_Y]=mScaleY;\n  matrix.setValues(matrixBuffer);\n}\n", "nl": "limits the maximum scale and X translation of the given matrix"}
{"code": "public final void diskFull(final boolean alarmUp,final String directoryName){\n  if (alarmUp == FallbackAlarmsInterface.ACTIVATED) {\n    ArrayList recipients=new ArrayList();\n    MailDetailsBean mailDetails=new MailDetailsBean();\n    mailDetails.setSender(\"mruizgar@cern.ch\");\n    recipients.add(\"mruizgar@cern.ch\");\n    mailDetails.setToRecipients(recipients);\n    mailDetails.setSubject(\"Disk Full\");\n    mailDetails.setMessage(\"The disk \" + directoryName + \" is getting full\");\n    mailDetails.setServer(\"cernmx.cern.ch\");\n    SMTPMailSender mailSender=new SMTPMailSender();\n    try {\n      mailSender.sendMail(mailDetails);\n    }\n catch (    MailSenderException e) {\n      LOG.debug(e.getMessage());\n    }\n  }\n}\n", "nl": "Sends an email warning about the disk getting full"}
{"code": "XSParticleDecl traverseAny(Element elmNode,XSDocumentInfo schemaDoc,SchemaGrammar grammar){\n  Object[] attrValues=fAttrChecker.checkAttributes(elmNode,false,schemaDoc);\n  XSWildcardDecl wildcard=traverseWildcardDecl(elmNode,attrValues,schemaDoc,grammar);\n  XSParticleDecl particle=null;\n  if (wildcard != null) {\n    int min=((XInt)attrValues[XSAttributeChecker.ATTIDX_MINOCCURS]).intValue();\n    int max=((XInt)attrValues[XSAttributeChecker.ATTIDX_MAXOCCURS]).intValue();\n    if (max != 0) {\n      if (fSchemaHandler.fDeclPool != null) {\n        particle=fSchemaHandler.fDeclPool.getParticleDecl();\n      }\n else {\n        particle=new XSParticleDecl();\n      }\n      particle.fType=XSParticleDecl.PARTICLE_WILDCARD;\n      particle.fValue=wildcard;\n      particle.fMinOccurs=min;\n      particle.fMaxOccurs=max;\n      particle.fAnnotations=wildcard.fAnnotations;\n    }\n  }\n  fAttrChecker.returnAttrArray(attrValues,schemaDoc);\n  return particle;\n}\n", "nl": "Traverse &lt;any&gt;"}
{"code": "public boolean takeFragmentPhoto(){\n  this.thePhotoName=\"MagicalCamera\";\n  this.anotherPhotoName=\"MagicalCamera\";\n  Intent intent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE);\n  Uri FileUri=getPhotoFileUri(this.thePhotoName,this.anotherPhotoName,this.activity);\n  if (FileUri != null) {\n    intent.putExtra(MediaStore.EXTRA_OUTPUT,getPhotoFileUri(this.thePhotoName,this.anotherPhotoName,this.activity));\n    if (intent.resolveActivity(this.activity.getPackageManager()) != null) {\n      this.intentFragment=intent;\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n else {\n    return false;\n  }\n}\n", "nl": "This library call the intent to take photo"}
{"code": "private void createOrUpdateTargetSsl(CommandInput input){\n  if (input.getCredentials() == null) {\n    return;\n  }\n  if (!isSecure(input.getDockerUri())) {\n    return;\n  }\n  String clientKey=EncryptionUtils.decrypt(input.getCredentials().privateKey);\n  String clientCert=input.getCredentials().publicKey;\n  String alias=input.getDockerUri().toString().toLowerCase();\n  if (clientKey != null && !clientKey.isEmpty()) {\n    X509ExtendedKeyManager delegateKeyManager=(X509ExtendedKeyManager)CertificateUtil.getKeyManagers(alias,clientKey,clientCert)[0];\n    keyManager.putDelegate(alias,delegateKeyManager);\n  }\n  String sslTrust=(String)input.getProperties().get(SSL_TRUST_CERT_PROP_NAME);\n  if (sslTrust != null && trustManager != null) {\n    String trustAlias=(String)input.getProperties().get(SSL_TRUST_ALIAS_PROP_NAME);\n    trustManager.putDelegate(trustAlias,sslTrust);\n  }\n}\n", "nl": "Update the dynamic KeyManager and TrustManager with the client and server certs for the current request"}
{"code": "public void addSyntaxActions(Keymap map,String prefix){\n  Pattern splitter=CONFIG.getValueSeparator(prefix);\n  Configuration actionsConf=CONFIG.subConfig(prefix,\"Action.\");\n  for (  String actionName : actionsConf.stringPropertyNames()) {\n    String[] values=splitter.split(actionsConf.getProperty(actionName));\n    String actionClass=values[0];\n    SyntaxAction action=editorActions.get(actionClass);\n    if (action == null) {\n      action=createAction(actionClass);\n      action.config(CONFIG,prefix,actionName);\n    }\n    String keyStrokeString=values[1];\n    KeyStroke ks=KeyStroke.getKeyStroke(keyStrokeString);\n    if (ks == null) {\n      throw new IllegalArgumentException(\"Invalid KeyStroke: \" + keyStrokeString);\n    }\n    TextAction ta=action.getAction(actionName);\n    if (ta == null) {\n      throw new IllegalArgumentException(\"Invalid ActionName: \" + actionName);\n    }\n    map.addActionForKeyStroke(ks,ta);\n  }\n}\n", "nl": "Add keyboard actions to this control using the Configuration we have"}
{"code": "public static void assertGTest(final RealDistribution expectedDistribution,final double[] values,double alpha){\n  final int numBins=values.length / 30;\n  final double[] breaks=new double[numBins];\n  for (int b=0; b < breaks.length; b++) {\n    breaks[b]=expectedDistribution.inverseCumulativeProbability((double)b / numBins);\n  }\n  final long[] observed=new long[numBins];\n  for (  final double value : values) {\n    int b=0;\n    do {\n      b++;\n    }\n while (b < numBins && value >= breaks[b]);\n    observed[b - 1]++;\n  }\n  final double[] expected=new double[numBins];\n  Arrays.fill(expected,(double)values.length / numBins);\n  assertGTest(expected,observed,alpha);\n}\n", "nl": "Asserts the null hypothesis that the sample follows the given distribution, using a G-test"}
{"code": "private void initializeValues(){\n  passwordChanged=false;\n  if (showCredentials) {\n    loginText.setText(location.getUsername());\n    passwordText.setText(FAKE_PASSWORD);\n  }\n  String label=location.getLabel();\n  useUrlLabelButton.setSelection(label == null);\n  useCustomLabelButton.setSelection(!useUrlLabelButton.getSelection());\n  if (label == null) {\n    label=location.getLocation();\n  }\n  customLabelText.setText(label);\n  SVNUrl url=location.getUrl();\n  if (url != null) {\n    repositoryUrlText.setText(url.toString());\n  }\n else {\n    repositoryUrlText.setText(\"\");\n  }\n  SVNUrl repositoryRoot=location.getRepositoryRoot();\n  if (repositoryRoot != null) {\n    repositoryRootText.setText(repositoryRoot.toString());\n  }\n else {\n    repositoryRootText.setText(\"\");\n  }\n}\n", "nl": "Set the initial values of the widgets"}
{"code": "void sendEmailRightNow(Launch launch,Project project,ServerEmailConfig emailConfig){\n  ProjectEmailConfig projectConfig=project.getConfiguration().getEmailConfig();\n  for (  EmailSenderCase one : projectConfig.getEmailCases()) {\n    Optional<SendCase> option=SendCase.findByName(one.getSendCase());\n    boolean successRate=isSuccessRateEnough(launch,option.get());\n    boolean matchedNames=isLaunchNameMatched(launch,one);\n    boolean matchedTags=isTagsMatched(launch,one);\n    List<String> recipients=one.getRecipients();\n    if (successRate && matchedNames && matchedTags) {\n      String[] recipientsArray=findRecipients(launch.getUserRef(),recipients);\n      try {\n        String basicURL=UriComponentsBuilder.fromHttpRequest(new ServletServerHttpRequest(currentRequest.get())).replacePath(String.format(\"/#%s/launches/all/\",project.getName())).build().toUriString();\n        String resourcesURL=UriComponentsBuilder.fromHttpRequest(new ServletServerHttpRequest(currentRequest.get())).replacePath(\"/img\").build().toUriString();\n        emailService.reconfig(emailConfig);\n        emailService.setAddressFrom(project.getConfiguration().getEmailConfig().getFrom());\n        emailService.sendLaunchFinishNotification(recipientsArray,basicURL + launch.getId(),launch,resourcesURL,project.getConfiguration());\n      }\n catch (      Exception e) {\n        LOGGER.error(\"Unable to send email. Error: \\n{}\",e);\n      }\n    }\n  }\n}\n", "nl": "Try to send email when it is needed"}
{"code": "private HttpURLConnection openHttpURLConnection(URL url,HttpClientRequest httpClientRequest,String method) throws IOException {\n  logger.info(\"Open connection for api \" + url.getPath());\n  HttpURLConnection.setFollowRedirects(true);\n  HttpURLConnection conn;\n  conn=(HttpURLConnection)url.openConnection();\n  conn.setRequestMethod(method);\n  String downloadFile=httpClientRequest.getDownloadFile();\n  if (downloadFile != null) {\n    File file=new File(downloadFile);\n    if (file.exists()) {\n      conn.setRequestProperty(\"RANGE\",\"bytes=\" + file.length() + \"-\");\n    }\n  }\n  Map<String,String> headers=httpClientRequest.getHeaders();\n  if (headers != null && !headers.isEmpty()) {\n    for (    Map.Entry<String,String> entry : headers.entrySet()) {\n      conn.setRequestProperty(entry.getKey(),entry.getValue());\n    }\n  }\n  logger.info(\"Hold cookie: %s.\",cookieManager.getCookieStore().getCookies());\n  conn.setRequestProperty(\"Content-Type\",httpClientRequest.getContentType());\n  conn.setRequestProperty(\"User-Agent\",httpClientRequest.getUserAgent());\n  return conn;\n}\n", "nl": "open a  Connection"}
{"code": "public ResponderCLI(String[] args){\n  cliOptions=createOptions();\n  try {\n    CommandLineParser parser=new GnuParser();\n    commandLine=parser.parse(cliOptions,args,true);\n    if (hasOption(\"h\")) {\n      printHelp();\n      System.exit(1);\n    }\n    if (!parseOptions()) {\n      logger.info(\"The provided options are not valid\");\n      printHelp();\n      System.exit(1);\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    System.exit(1);\n  }\n}\n", "nl": "Create and parse allowable options"}
{"code": "private static float snapPercent(float percent){\n  int value=(int)(percent * 100);\n  int slope=2;\n  if (Math.abs(value - 25) <= slope) {\n    value=25;\n  }\n  if (Math.abs(value - 33) <= slope) {\n    value=33;\n  }\n  if (Math.abs(value - 50) <= slope) {\n    value=50;\n  }\n  if (Math.abs(value - 66) <= slope) {\n    value=66;\n  }\n  if (Math.abs(value - 75) <= slope) {\n    value=75;\n  }\n  return (value / 100f);\n}\n", "nl": "Snap the percent value to common values"}
{"code": "private org.apache.carbondata.format.Encoding fromWrapperToExternalEncoding(Encoding encoder){\n  if (null == encoder) {\n    return null;\n  }\nswitch (encoder) {\ncase DICTIONARY:\n    return org.apache.carbondata.format.Encoding.DICTIONARY;\ncase DELTA:\n  return org.apache.carbondata.format.Encoding.DELTA;\ncase RLE:\nreturn org.apache.carbondata.format.Encoding.RLE;\ncase INVERTED_INDEX:\nreturn org.apache.carbondata.format.Encoding.INVERTED_INDEX;\ncase BIT_PACKED:\nreturn org.apache.carbondata.format.Encoding.BIT_PACKED;\ncase DIRECT_DICTIONARY:\nreturn org.apache.carbondata.format.Encoding.DIRECT_DICTIONARY;\ndefault :\nreturn org.apache.carbondata.format.Encoding.DICTIONARY;\n}\n}\n", "nl": "converts from wrapper to external encoding"}
{"code": "public void read(IInputReader dataIndexReader) throws IOException {\n  for (  Object[] dataRecord : data) {\nswitch ((Character)dataRecord[1]) {\ncase 'i':\n      dataRecord[2]=dataIndexReader.readInt();\n    break;\ncase 'f':\n  dataRecord[2]=dataIndexReader.readFloat();\nbreak;\ncase 'l':\ndataRecord[2]=dataIndexReader.readLong();\nbreak;\ncase 'b':\ndataRecord[2]=(byte)dataIndexReader.read();\nbreak;\ncase 'B':\ndataRecord[2]=dataIndexReader.readByteByteInt();\nbreak;\ncase 'c':\ndataRecord[2]=dataIndexReader.readChar();\nbreak;\n}\n}\n}\n", "nl": "read the fixed part of the reads block"}
{"code": "public void unify(Map<String,String> unifiers){\n  if (unifiers.size() == 0)   return;\n  Map<String,String> mappings=new HashMap<>(unifiers);\n  Map<String,String> appliedMappings=new HashMap<>();\n  for (  Map.Entry<String,String> mapping : mappings.entrySet()) {\n    String varToReplace=mapping.getKey();\n    String replacementVar=mapping.getValue();\n    if (!appliedMappings.containsKey(varToReplace) || !appliedMappings.get(varToReplace).equals(replacementVar)) {\n      if (mappings.containsKey(replacementVar) && mappings.get(replacementVar).equals(varToReplace)) {\n        exchangeRelVarNames(varToReplace,replacementVar);\n        appliedMappings.put(varToReplace,replacementVar);\n        appliedMappings.put(replacementVar,varToReplace);\n      }\n    }\n  }\n  mappings.entrySet().removeIf(null);\n  Set<Atomic> toRemove=new HashSet<>();\n  Set<Atomic> toAdd=new HashSet<>();\n  atomSet.stream().filter(null).forEach(null);\n  toRemove.forEach(null);\n  toRemove.forEach(null);\n  toAdd.forEach(null);\n  toAdd.forEach(null);\n  updateSelectedVars(mappings);\n  resolveCaptures();\n}\n", "nl": "change each variable occurrence according to provided mappings (apply unifiers {[from, to]_i})"}
{"code": "public void addRow(Object[] row) throws CarbonSortKeyAndGroupByException {\n  int currentSize=entryCount;\n  if (sortBufferSize == currentSize) {\n    LOGGER.debug(\"************ Writing to temp file ********** \");\n    intermediateFileMerger.startMergingIfPossible();\n    Object[][] recordHolderListLocal=recordHolderList;\n    try {\n      semaphore.acquire();\n      dataSorterAndWriterExecutorService.submit(new DataSorterAndWriter(recordHolderListLocal));\n    }\n catch (    InterruptedException e) {\n      LOGGER.error(\"exception occurred while trying to acquire a semaphore lock: \" + e.getMessage());\n      throw new CarbonSortKeyAndGroupByException(e.getMessage());\n    }\n    this.recordHolderList=new Object[this.sortBufferSize][];\n    this.entryCount=0;\n  }\n  recordHolderList[entryCount++]=row;\n}\n", "nl": "This method will be used to add new row"}
{"code": "private boolean checkFinishedQuests(QuestStateList qsl){\n  if (finished != null && finished.size() > 0) {\n    for (    FinishedQuestCond fqc : finished) {\n      int questId=fqc.getQuestId();\n      int reward=fqc.getReward();\n      QuestState qs=qsl.getQuestState(questId);\n      if (qs == null || qs.getStatus() != QuestStatus.COMPLETE || !checkReward(questId,reward,qs.getReward())) {\n        return false;\n      }\n      QuestTemplate template=DataManager.QUEST_DATA.getQuestById(questId);\n      if (template != null && template.isRepeatable()) {\n        if (qs.getCompleteCount() != template.getMaxRepeatCount()) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n", "nl": "Check, if the player has finished listed quests"}
{"code": "@Override protected void onInit(Bundle savedInstanceState){\n  mWeeks=getResources().getStringArray(R.array.array_search_week);\n  mConstellations=getResources().getStringArray(R.array.array_search_constellation);\n  mZodiacs=getResources().getStringArray(R.array.array_search_zodiac);\n  mCalendarView=(CalendarView)findViewById(R.id.search_kit_calendar_container);\n  mLunarDate=(TextView)findViewById(R.id.search_txt_show_lunar);\n  mSunDate=(TextView)findViewById(R.id.search_txt_show_sun);\n  mDistanceNow=(TextView)findViewById(R.id.search_txt_show_distance_now);\n  mWeek=(TextView)findViewById(R.id.search_txt_show_week);\n  mConstellation=(TextView)findViewById(R.id.search_txt_show_constellation);\n  mZodiac=(TextView)findViewById(R.id.search_txt_show_zodiac);\n  mSearchLayShow=findViewById(R.id.search_lay_show);\n  mButton=(Button)findViewById(R.id.search_btn_commit);\n  View view=findViewById(R.id.lay_top);\n  view.setLayerType(View.LAYER_TYPE_SOFTWARE,null);\n  AnimJagDrawable drawable=new AnimJagDrawable();\n  drawable.setFluCount(new Rect(0,0,0,36));\n  drawable.setColor(getResources().getColor(R.color.purple_500));\n  drawable.setAlpha(164);\n  view.setBackgroundDrawable(drawable);\n  mTopBg=drawable;\n  onInitValues();\n}\n", "nl": "mWeeks 7 mConstellations 12star mZodiacs 12"}
{"code": "private boolean resizeAndSaveImage(int maxWidth,int maxHeight) throws IOException {\n  boolean saved=false;\n  String encodeURL=DiskCacheUtils.encodeURL(uri,maxWidth,maxHeight);\n  File targetFile=configuration.diskCache.get(uri);\n  if (targetFile != null && targetFile.exists()) {\n    ImageSize targetImageSize=new ImageSize(maxWidth,maxHeight);\n    DisplayImageOptions specialOptions=new DisplayImageOptions.Builder().cloneFrom(options).imageScaleType(ImageScaleType.IN_SAMPLE_INT).build();\n    ImageDecodingInfo decodingInfo=new ImageDecodingInfo(memoryCacheKey,Scheme.FILE.wrap(targetFile.getAbsolutePath()),Scheme.FILE.wrap(targetFile.getAbsolutePath()),targetImageSize,ViewScaleType.FIT_INSIDE,getDownloader(),specialOptions);\n    Bitmap bmp=decoder.decode(decodingInfo);\n    if (bmp != null && configuration.processorForDiskCache != null) {\n      L.d(LOG_PROCESS_IMAGE_BEFORE_CACHE_ON_DISK,memoryCacheKey);\n      bmp=configuration.processorForDiskCache.process(bmp);\n      if (bmp == null) {\n        L.e(ERROR_PROCESSOR_FOR_DISK_CACHE_NULL,memoryCacheKey);\n      }\n    }\n    if (bmp != null) {\n      saved=configuration.diskCache.save(encodeURL,bmp);\n      bmp.recycle();\n    }\n    if (saved) {\n      targetFile.delete();\n    }\n  }\n  return saved;\n}\n", "nl": "Decodes image file into Bitmap, resize it and save it back"}
{"code": "public void addDataToStore(Object[] row) throws CarbonDataWriterException {\n  dataRows.add(row);\n  this.entryCount++;\n  if (this.entryCount == this.blockletSize) {\n    try {\n      semaphore.acquire();\n      producerExecutorServiceTaskList.add(producerExecutorService.submit(new Producer(blockletDataHolder,dataRows,++writerTaskSequenceCounter)));\n      blockletProcessingCount.incrementAndGet();\n      processedDataCount+=entryCount;\n      LOGGER.info(\"Total Number Of records added to store: \" + processedDataCount);\n      dataRows=new ArrayList<>(this.blockletSize);\n      this.entryCount=0;\n    }\n catch (    InterruptedException e) {\n      LOGGER.error(e,e.getMessage());\n      throw new CarbonDataWriterException(e.getMessage());\n    }\n  }\n}\n", "nl": "below method will be used to add row to store"}
{"code": "public static String removeAdditionalParty(HttpServletRequest request,HttpServletResponse response){\n  ShoppingCart cart=getCartObject(request);\n  String partyId=request.getParameter(\"additionalPartyId\");\n  String roleTypeId[]=request.getParameterValues(\"additionalRoleTypeId\");\n  List<String> eventList=new LinkedList<String>();\n  Locale locale=UtilHttp.getLocale(request);\n  int i;\n  if (UtilValidate.isEmpty(partyId) || roleTypeId.length < 1) {\n    request.setAttribute(\"_ERROR_MESSAGE_\",UtilProperties.getMessage(resource_error,\"OrderPartyIdAndOrRoleTypeIdNotDefined\",locale));\n    return \"error\";\n  }\n  if (request.getAttribute(\"_EVENT_MESSAGE_LIST_\") != null) {\n    List<String> msg=UtilGenerics.checkList(request.getAttribute(\"_EVENT_MESSAGE_LIST_\"));\n    eventList.addAll(msg);\n  }\n  for (i=0; i < roleTypeId.length; i++) {\n    try {\n      cart.removeAdditionalPartyRole(partyId,roleTypeId[i]);\n    }\n catch (    Exception e) {\n      Debug.logInfo(e.getLocalizedMessage(),module);\n      eventList.add(e.getLocalizedMessage());\n    }\n  }\n  request.removeAttribute(\"_EVENT_MESSAGE_LIST_\");\n  request.setAttribute(\"_EVENT_MESSAGE_LIST_\",eventList);\n  return \"success\";\n}\n", "nl": "Removes a previously associated party to order"}
{"code": "@Override public Gradient[] calcGradient(IActorCritic iac,Stack<MiniTrans<Integer>> rewards){\n  MiniTrans<Integer> minTrans=rewards.pop();\n  int size=rewards.size();\n  int[] shape=getHistoryProcessor() == null ? mdp.getObservationSpace().getShape() : getHistoryProcessor().getConf().getShape();\n  int[] nshape=Learning.makeShape(size,shape);\n  INDArray input=Nd4j.create(nshape);\n  INDArray targets=Nd4j.create(size,1);\n  INDArray logSoftmax=Nd4j.create(size,mdp.getActionSpace().getSize());\n  double r=minTrans.getReward();\n  for (int i=0; i < size; i++) {\n    minTrans=rewards.pop();\n    r=minTrans.getReward() + conf.getGamma() * r;\n    input.putRow(i,minTrans.getObs());\n    targets.putScalar(i,r);\n    INDArray row=minTrans.getOutput()[1];\n    double prevV=row.getDouble(minTrans.getAction());\n    double expectedV=minTrans.getOutput()[0].getDouble(0);\n    double advantage=r - expectedV;\n    row=row.putScalar(minTrans.getAction(),prevV + advantage);\n    logSoftmax.putRow(i,row);\n  }\n  return iac.gradient(input,new INDArray[]{targets,logSoftmax});\n}\n", "nl": "calc the gradients based on the n-step rewards"}
{"code": "private void timeout() throws Exception {\n  int t=_timerLogical++;\n  _time+=_waitInterval;\n  Map<WatchedObject,Collection<WatchedObject>> watchedObjects=new HashMap<WatchedObject,Collection<WatchedObject>>();\n  for (Iterator<WeakReference<WatchedObject>> iter=_watchedObjects.iterator(); iter.hasNext(); ) {\n    WeakReference<WatchedObject> w=iter.next();\n    WatchedObject watched=w.get();\n    if (watched == null || !watched.isInUse()) {\n      iter.remove();\n      continue;\n    }\n    int time=watched.getTime();\n    if (time == UNWATCHED)     continue;\n    if (t - time < _timeoutLogical)     continue;\n    if (_logger.isLoggable(Level.FINE)) {\n      Level logLevel=Level.FINEST;\n      if (Group.REQUEST_GROUP.name().equals(_name) || Group.RESPONSE_GROUP.name().equals(_name)) {\n        logLevel=Level.FINE;\n      }\n else       if (Group.IDLE_GROUP.name().equals(_name)) {\n        logLevel=Level.FINEST;\n      }\n      _logger.log(logLevel,_name + \" - \" + (t - time) * _waitInterval + \" Timeout occurred, max allowed = \" + _timeout);\n    }\n    add(watchedObjects,watched);\n  }\n  if (!watchedObjects.isEmpty())   fireTimeoutOccured(watchedObjects);\n}\n", "nl": "Timeout all thread that exceeded their time to live"}
{"code": "private static int lengthOfPath(Path2D.Float path){\n  FlatteningPathIterator f=new FlatteningPathIterator(path.getPathIterator(null),1);\n  double sum=0;\n  float x1, x2, y1, y2;\n  float[] coords=new float[6];\n  f.currentSegment(coords);\n  x1=coords[0];\n  y1=coords[1];\n  f.next();\n  do {\n    f.currentSegment(coords);\n    f.next();\n    x2=coords[0];\n    y2=coords[1];\n    sum+=Math.hypot(x2 - x1,y2 - y1);\n    x1=x2;\n    y1=y2;\n  }\n while (!f.isDone());\n  return (int)sum;\n}\n", "nl": "Return the length of the given path"}
{"code": "public void load(String fileName) throws IOException, MaryConfigurationException {\n  DataInputStream dis=new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)));\n  hdr=new MaryHeader(dis);\n  if (hdr.getType() != MaryHeader.UNITS) {\n    throw new MaryConfigurationException(\"File [\" + fileName + \"] is not a valid Mary Units file.\");\n  }\n  numberOfUnits=dis.readInt();\n  if (numberOfUnits < 0) {\n    throw new MaryConfigurationException(\"File [\" + fileName + \"] has a negative number of units. Aborting.\");\n  }\n  sampleRate=dis.readInt();\n  if (sampleRate < 0) {\n    throw new MaryConfigurationException(\"File [\" + fileName + \"] has a negative number sample rate. Aborting.\");\n  }\n  units=new Unit[numberOfUnits];\n  for (int i=0; i < numberOfUnits; i++) {\n    long startTime=dis.readLong();\n    int duration=dis.readInt();\n    units[i]=new Unit(startTime,duration,i);\n  }\n}\n", "nl": "Load the given unit file"}
{"code": "public Map<String,Object> run(ServiceDispatcher dispatcher,String localName,Map<String,Object> context) throws GenericServiceException {\n  if (this.getSendMode().equals(\"all\")) {\n    return runAll(dispatcher,localName,context);\n  }\n else   if (this.getSendMode().equals(\"round-robin\")) {\n    return runIndex(dispatcher,localName,context,(++lastServiceRan % services.size()));\n  }\n else   if (this.getSendMode().equals(\"random\")) {\n    int randomIndex=(int)(Math.random() * (services.size()));\n    return runIndex(dispatcher,localName,context,randomIndex);\n  }\n else   if (this.getSendMode().equals(\"first-available\")) {\n    return runOne(dispatcher,localName,context);\n  }\n else   if (this.getSendMode().equals(\"none\")) {\n    return new HashMap<String,Object>();\n  }\n else {\n    throw new GenericServiceException(\"This mode is not currently supported\");\n  }\n}\n", "nl": "Invokes the group of services in order defined"}
{"code": "public void reorderSamples(Collection<String> newOrder) throws IOException {\n  final Integer[] order=new Integer[newOrder.size()];\n  int i=0;\n  for (  String sample : newOrder) {\n    int pid=Basic.getIndex(sample,getSampleNames());\n    if (pid == -1)     throw new IOException(\"Can't reorder: unknown sample: \" + sample);\n    order[i++]=pid;\n  }\n  final String[] datasetNames=modify(order,getSampleNames());\n  final Long[] uids=modify(order,getSampleUIds());\n  final Integer[] sizes=modify(order,getSampleSizes());\n  final BlastMode[] modes=modify(order,getBlastModes());\n  setSamples(datasetNames,uids,sizes,modes);\n  final Map<String,Map<Integer,Integer[]>> classification2Class2Counts=getClassification2Class2Counts();\n  for (  String classification : classification2Class2Counts.keySet()) {\n    final Map<Integer,Integer[]> class2Counts=classification2Class2Counts.get(classification);\n    final Set<Integer> keys=new HashSet<>();\n    keys.addAll(class2Counts.keySet());\n    for (    Integer classId : keys) {\n      Integer[] values=class2Counts.get(classId);\n      if (values != null) {\n        values=modify(order,values);\n        class2Counts.put(classId,values);\n      }\n    }\n  }\n}\n", "nl": "reorder samples"}
{"code": "public BrokerItem(Item item,int itemId,int itemUniqueId,long itemCount,String itemCreator,long price,String seller,int sellerId,BrokerRace itemBrokerRace,boolean isSold,boolean isSettled,Timestamp expireTime,Timestamp settleTime,boolean partSale){\n  this.item=item;\n  this.itemId=itemId;\n  this.itemUniqueId=itemUniqueId;\n  this.itemCount=itemCount;\n  this.itemCreator=itemCreator;\n  this.price=price;\n  this.seller=seller;\n  this.sellerId=sellerId;\n  this.itemBrokerRace=itemBrokerRace;\n  this.partSale=partSale;\n  if (item == null) {\n    this.isSold=true;\n    this.isSettled=true;\n  }\n else {\n    this.isSold=isSold;\n    this.isSettled=isSettled;\n  }\n  this.expireTime=expireTime;\n  this.settleTime=settleTime;\n  this.state=PersistentState.NOACTION;\n}\n", "nl": "Used onDBLoad"}
{"code": "public static Bitmap byteToBitmap(byte[] b,int targetWidth,int targeHeight){\n  if (b == null || b.length == 0) {\n    return null;\n  }\n  final BitmapFactory.Options options=new BitmapFactory.Options();\n  options.inJustDecodeBounds=true;\n  BitmapFactory.decodeByteArray(b,0,b.length,options);\n  int sourceWidth=options.outWidth;\n  int sourceHeight=options.outHeight;\n  options.inJustDecodeBounds=false;\n  int inSampleSize=1;\n  while (sourceWidth / inSampleSize > targetWidth) {\n    inSampleSize++;\n  }\n  while (sourceHeight / inSampleSize > targeHeight) {\n    inSampleSize++;\n  }\n  if (inSampleSize <= 0) {\n    inSampleSize=1;\n  }\n  options.inSampleSize=inSampleSize;\n  Bitmap bitmap=BitmapFactory.decodeByteArray(b,0,b.length,options);\n  return bitmap;\n}\n", "nl": "convert byte array to Bitmap"}
{"code": "public void writeSortTempFile(Object[][] records) throws CarbonSortKeyAndGroupByException {\n  DataOutputStream dataOutputStream=null;\n  ByteArrayOutputStream blockDataArray=null;\n  int totalSize=0;\n  int recordSize=0;\n  try {\n    recordSize=(measureCount * CarbonCommonConstants.DOUBLE_SIZE_IN_BYTE) + (dimensionCount * CarbonCommonConstants.INT_SIZE_IN_BYTE);\n    totalSize=records.length * recordSize;\n    blockDataArray=new ByteArrayOutputStream(totalSize);\n    dataOutputStream=new DataOutputStream(blockDataArray);\n    UnCompressedTempSortFileWriter.writeDataOutputStream(records,dataOutputStream,measureCount,dimensionCount,noDictionaryCount,complexDimensionCount);\n    stream.writeInt(records.length);\n    byte[] byteArray=SnappyByteCompression.INSTANCE.compress(blockDataArray.toByteArray());\n    stream.writeInt(byteArray.length);\n    stream.write(byteArray);\n  }\n catch (  IOException e) {\n    throw new CarbonSortKeyAndGroupByException(e);\n  }\n finally {\n    CarbonUtil.closeStreams(blockDataArray);\n    CarbonUtil.closeStreams(dataOutputStream);\n  }\n}\n", "nl": "Below method will be used to write the sort temp file"}
{"code": "public static Map<String,Object> updateTrackingNumber(DispatchContext dctx,Map<String,? extends Object> context){\n  Map<String,Object> result=new HashMap<String,Object>();\n  Delegator delegator=dctx.getDelegator();\n  String orderId=(String)context.get(\"orderId\");\n  String shipGroupSeqId=(String)context.get(\"shipGroupSeqId\");\n  String trackingNumber=(String)context.get(\"trackingNumber\");\n  try {\n    GenericValue shipGroup=EntityQuery.use(delegator).from(\"OrderItemShipGroup\").where(\"orderId\",orderId,\"shipGroupSeqId\",shipGroupSeqId).queryOne();\n    if (shipGroup == null) {\n      result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_ERROR);\n      result.put(ModelService.ERROR_MESSAGE,\"ERROR: No order shipment preference found!\");\n    }\n else {\n      shipGroup.set(\"trackingNumber\",trackingNumber);\n      shipGroup.store();\n      result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_SUCCESS);\n    }\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,module);\n    result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_ERROR);\n    result.put(ModelService.ERROR_MESSAGE,\"ERROR: Could not set tracking number (\" + e.getMessage() + \").\");\n  }\n  return result;\n}\n", "nl": "Service to update the order tracking number"}
{"code": "public static MapWritable jsonStringToMapWritableWithWritableArrayWritable(String jsonString,DataSchema dataSchema){\n  MapWritable value=new MapWritable();\n  JSONParser jsonParser=new JSONParser();\n  try {\n    JSONObject jsonObj=(JSONObject)jsonParser.parse(jsonString);\n    for (    Object key : jsonObj.keySet()) {\n      Text mapKey=new Text(key.toString());\n      if (jsonObj.get(key) != null) {\n        logger.debug(\"key = \" + key.toString());\n        if (dataSchema.isArrayElement((String)key)) {\n          WritableArrayWritable mapValue=StringUtils.jsonArrayStringToWritableArrayWritable(jsonObj.get(key).toString());\n          value.put(mapKey,mapValue);\n        }\n else {\n          Text mapValue=new Text(jsonObj.get(key).toString());\n          value.put(mapKey,mapValue);\n        }\n      }\n    }\n  }\n catch (  ParseException e) {\n    logger.warn(\"Could not json-decode string: \" + jsonString,e);\n  }\ncatch (  NumberFormatException e) {\n    logger.warn(\"Could not parse field into number: \" + jsonString,e);\n  }\n  return value;\n}\n", "nl": "Method to take an input json string and output a MapWritable with arrays as WritableArrayWritable objects"}
{"code": "@Nullable private static ResourceValue findResourceValue(ResourceType type,String name,boolean isFramework,Module module,Configuration configuration){\n  if (isFramework) {\n    ResourceRepository frameworkResources=configuration.getFrameworkResources();\n    if (frameworkResources == null) {\n      return null;\n    }\n    if (!frameworkResources.hasResourceItem(type,name)) {\n      return null;\n    }\n    ResourceItem item=frameworkResources.getResourceItem(type,name);\n    return item.getResourceValue(type,configuration.getFullConfig(),false);\n  }\n else {\n    LocalResourceRepository appResources=AppResourceRepository.getAppResources(module,true);\n    if (appResources == null) {\n      return null;\n    }\n    if (!appResources.hasResourceItem(type,name)) {\n      return null;\n    }\n    return appResources.getConfiguredValue(type,name,configuration.getFullConfig());\n  }\n}\n", "nl": "Looks up the resource item of the given type and name for the given configuration, if any"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  GroupsViewer groupsViewer=(GroupsViewer)getDir().getViewerByClass(GroupsViewer.class);\n  if (groupsViewer == null) {\n    try {\n      groupsViewer=new GroupsViewer((Director)getDir(),getViewer().getFrame());\n      getDir().addViewer(groupsViewer);\n      groupsViewer.getFrame().toFront();\n    }\n catch (    Exception e) {\n      Basic.caught(e);\n    }\n  }\n else {\n    groupsViewer.updateView(Director.ENABLE_STATE);\n    groupsViewer.getFrame().setVisible(true);\n    groupsViewer.getFrame().setState(JFrame.NORMAL);\n    groupsViewer.getFrame().toFront();\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static MapWritable jsonStringToMapWritableWithArrayWritable(String jsonString,DataSchema dataSchema){\n  MapWritable value=new MapWritable();\n  JSONParser jsonParser=new JSONParser();\n  try {\n    JSONObject jsonObj=(JSONObject)jsonParser.parse(jsonString);\n    for (    Object key : jsonObj.keySet()) {\n      Text mapKey=new Text(key.toString());\n      if (jsonObj.get(key) != null) {\n        logger.debug(\"key = \" + key.toString());\n        if (dataSchema.isArrayElement((String)key)) {\n          ArrayWritable mapValue=StringUtils.jsonArrayStringtoArrayWritable(jsonObj.get(key).toString());\n          value.put(mapKey,mapValue);\n        }\n else {\n          Text mapValue=new Text(jsonObj.get(key).toString());\n          value.put(mapKey,mapValue);\n        }\n      }\n    }\n  }\n catch (  ParseException e) {\n    logger.warn(\"Could not json-decode string: \" + jsonString,e);\n  }\ncatch (  NumberFormatException e) {\n    logger.warn(\"Could not parse field into number: \" + jsonString,e);\n  }\n  return value;\n}\n", "nl": "Method to take an input json string and output a MapWritable with arrays as WritableArrayWritable objects"}
{"code": "public static boolean isUrlUsable(String url){\n  if (CommonUtils.isEmpty(url)) {\n    return false;\n  }\n  URL urlTemp=null;\n  HttpURLConnection connt=null;\n  try {\n    urlTemp=new URL(url);\n    connt=(HttpURLConnection)urlTemp.openConnection();\n    connt.setRequestMethod(\"HEAD\");\n    int returnCode=connt.getResponseCode();\n    if (returnCode == HttpURLConnection.HTTP_OK) {\n      return true;\n    }\n  }\n catch (  Exception e) {\n    return false;\n  }\n finally {\n    connt.disconnect();\n  }\n  return false;\n}\n", "nl": "url is usable"}
{"code": "public static String sampaEnString2sampaDeString(String sEn){\n  StringBuilder result=new StringBuilder();\n  StringTokenizer st=new StringTokenizer(sEn,\"-\");\n  while (st.hasMoreTokens()) {\n    boolean stressed=false;\n    String syl=st.nextToken();\n    if (syl.startsWith(\"'\")) {\n      result.append(\"'\");\n      stressed=true;\n    }\n    Allophone[] phon=sampa(Locale.US).splitIntoAllophones(syl);\n    for (int i=0; i < phon.length; i++) {\n      String eng=phon[i].name();\n      String sDe=sampaEn2sampaDe(eng);\n      if (sDe.equals(\"6\") && stressed) {\n        sDe=\"96\";\n      }\n      result.append(sDe);\n    }\n    if (st.hasMoreTokens()) {\n      result.append(\"-\");\n    }\n  }\n  return result.toString();\n}\n", "nl": "Converts an english sampa string into a german sampa string, keeping syllable boundaries and stress markers"}
{"code": "public void paint(Graphics gc0){\n  super.paint(gc0);\n  final Graphics2D gc=(Graphics2D)gc0;\n  bottomMargin=50;\n  if (isShowXAxis()) {\n    double xAxisLabelHeight=computeXAxisLabelHeight(gc);\n    bottomMargin+=xAxisLabelHeight;\n    if (classLabelAngle > 0 && classLabelAngle < Math.PI / 2)     rightMargin=Math.max(75,(int)(0.8 * xAxisLabelHeight));\n  }\n else   bottomMargin+=20;\n  drawTitle(gc);\n  if (getChartData().getRangeX() == null || getChartData().getRangeY() == null)   return;\n  if (isLargeEnough()) {\n    if (gridStyle == GridStyle.BELOW) {\n    }\n    computeScrollBackReferenceRect();\n    drawChart(gc);\n    if (isShowXAxis())     drawXAxis(gc);\n    if (isShowYAxis())     drawYAxis(gc);\n    if (gridStyle == GridStyle.ABOVE) {\n    }\n  }\n}\n", "nl": "paints the chart"}
{"code": "public static void expandID(String numberString,WordRelation wordRelation){\n  int numberDigits=numberString.length();\n  if ((numberDigits == 4) && (numberString.charAt(2) == '0') && (numberString.charAt(3) == '0')) {\n    if (numberString.charAt(1) == '0') {\n      expandNumber(numberString,wordRelation);\n    }\n else {\n      expandNumber(numberString.substring(0,2),wordRelation);\n      wordRelation.addWord(\"hundred\");\n    }\n  }\n else   if ((numberDigits == 2) && (numberString.charAt(0) == '0')) {\n    wordRelation.addWord(\"oh\");\n    expandDigits(numberString.substring(1,2),wordRelation);\n  }\n else   if ((numberDigits == 4 && numberString.charAt(1) == '0') || numberDigits < 3) {\n    expandNumber(numberString,wordRelation);\n  }\n else   if (numberDigits % 2 == 1) {\n    String firstDigit=digit2num[numberString.charAt(0) - '0'];\n    wordRelation.addWord(firstDigit);\n    expandID(numberString.substring(1,numberDigits),wordRelation);\n  }\n else {\n    expandNumber(numberString.substring(0,2),wordRelation);\n    expandID(numberString.substring(2,numberDigits),wordRelation);\n  }\n}\n", "nl": "Expands the given number string as pairs as in years or IDs"}
{"code": "void STAR_encoding_diag2(){\n  int i, j, stripe, k;\n  char[] tmp;\n  tmp=new char[p * block_size];\n  for (stripe=0; stripe < block_nbr + 1; stripe++) {\n    for (i=0; i < data_disk_nbr; i++) {\n      for (j=0; j < block_size; j++) {\n        k=(stripe + i + p) % p;\n        if (k < block_nbr)         tmp[stripe * block_size + j]^=check_data[i][k * block_size + j];\n      }\n    }\n  }\n  for (i=0; i < block_nbr; i++) {\n    for (j=0; j < block_size; j++) {\n      tmp[i * block_size + j]^=tmp[block_nbr * block_size + j];\n    }\n  }\n  System.arraycopy(tmp,0,check_data[data_disk_nbr + 2],0,stripe_unit_size);\n}\n", "nl": "entry function for encoding diagonal line checksum, slope -1,*check_data[p+2]"}
{"code": "@Override @Transactional(rollbackFor=Exception.class,propagation=Propagation.REQUIRED) public LoginResDto login(LoginReqDto reqDto){\n  LoginResDto resDto=new LoginResDto();\n  User queryUser=new User();\n  queryUser.setUserId(reqDto.getUserId());\n  queryUser.setValid(1);\n  List<User> userList=userDao.searchUser(queryUser);\n  if (userList == null || userList.isEmpty())   throw new RuntimeException(ERR_USER_NOT_EXIST);\n  User findUser=userList.get(0);\n  if (!findUser.getUserPwd().equals(reqDto.getPassword()))   throw new RuntimeException(ERR_PWD_WRONG);\n  LoginHistory loginHistory=new LoginHistory();\n  loginHistory.setUserId(reqDto.getUserId());\n  loginHistory.setDeviceId(reqDto.getDeviceId());\n  loginHistory.setPlatform(reqDto.getPlatform());\n  loginHistoryDao.addLoginHistory(loginHistory);\n  resDto.setMenuList(buildSystemMenus(reqDto.getUserId()));\n  List<String> roleList=userRoleDao.searchRoleByUserId(reqDto.getUserId());\n  String role=StringUtils.concatStrFromList(roleList,null);\n  resDto.setUserId(findUser.getUserId());\n  resDto.setUserName(findUser.getUserName());\n  resDto.setToken(generateAccessToken(reqDto,role));\n  return resDto;\n}\n", "nl": "User Login"}
{"code": "@Override public boolean heap_sensitive_intersection(IVarAbstraction qv){\n  int i, j;\n  HeapInsNode qn;\n  SegmentNode p, q, pt[], qt[];\n  qn=(HeapInsNode)qv;\n  for (Iterator<AllocNode> it=pt_objs.keySet().iterator(); it.hasNext(); ) {\n    AllocNode an=it.next();\n    if (an instanceof ClassConstantNode)     continue;\n    if (an instanceof StringConstantNode)     continue;\n    qt=qn.find_points_to(an);\n    if (qt == null)     continue;\n    pt=find_points_to(an);\n    for (i=0; i < HeapInsIntervalManager.Divisions; ++i) {\n      p=pt[i];\n      while (p != null) {\n        for (j=0; j < HeapInsIntervalManager.Divisions; ++j) {\n          q=qt[j];\n          while (q != null) {\n            if (quick_intersecting_test(p,q))             return true;\n            q=q.next;\n          }\n        }\n        p=p.next;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Query if this pointer and qv could point to the same object under any contexts"}
{"code": "private SegmentedListIterator<T> establishPos(SegmentedListIterator<T> res){\n  int startSegment=drawSegmentNumber(false);\n  res.setStartSegment((short)startSegment);\n  for (int seg=startSegment, i=0; i < getNumSegments(); i++, seg++) {\n    if (seg == getNumSegments())     seg=0;\n    res.setCurrentSegment((short)seg);\n    Segment<T> segment=_segments[seg];\n    segment.getLock().readLock().lock();\n    try {\n      if (segment.isEmpty())       continue;\n      for (ObjectInfo<T> oi=segment.getHead().getForwardRef(); oi != null; oi=oi.getForwardRef()) {\n        if (!oi.isDeleted() && oi.getSubject() != null) {\n          res.setCurrentOI(oi);\n          res.setSubject(oi.getSubject());\n          return res;\n        }\n      }\n    }\n  finally {\n      segment.getLock().readLock().unlock();\n    }\n  }\n  return null;\n}\n", "nl": "establish a scan position- select a segment"}
{"code": "public static void assertEquals(String msg,double[] expected,double[] observed,double tolerance){\n  StringBuilder out=new StringBuilder(msg);\n  if (expected.length != observed.length) {\n    out.append(\"\\n Arrays not same length. \\n\");\n    out.append(\"expected has length \");\n    out.append(expected.length);\n    out.append(\" observed length = \");\n    out.append(observed.length);\n    Assert.fail(out.toString());\n  }\n  boolean failure=false;\n  for (int i=0; i < expected.length; i++) {\n    if (!Precision.equalsIncludingNaN(expected[i],observed[i],tolerance)) {\n      failure=true;\n      out.append(\"\\n Elements at index \");\n      out.append(i);\n      out.append(\" differ. \");\n      out.append(\" expected = \");\n      out.append(expected[i]);\n      out.append(\" observed = \");\n      out.append(observed[i]);\n    }\n  }\n  if (failure) {\n    Assert.fail(out.toString());\n  }\n}\n", "nl": "verifies that two arrays are close (sup norm)"}
{"code": "private void appendChecksum(byte[] raw,int offset,int length){\n  long chksum=0;\n  int count=length - 4;\n  long ecx;\n  int i;\n  for (i=offset; i < count; i+=4) {\n    ecx=raw[i] & 0xff;\n    ecx|=raw[i + 1] << 8 & 0xff00;\n    ecx|=raw[i + 2] << 0x10 & 0xff0000;\n    ecx|=raw[i + 3] << 0x18 & 0xff000000;\n    chksum^=ecx;\n  }\n  ecx=raw[i] & 0xff;\n  ecx|=raw[i + 1] << 8 & 0xff00;\n  ecx|=raw[i + 2] << 0x10 & 0xff0000;\n  ecx|=raw[i + 3] << 0x18 & 0xff000000;\n  raw[i]=(byte)(chksum & 0xff);\n  raw[i + 1]=(byte)(chksum >> 0x08 & 0xff);\n  raw[i + 2]=(byte)(chksum >> 0x10 & 0xff);\n  raw[i + 3]=(byte)(chksum >> 0x18 & 0xff);\n}\n", "nl": "add checksum to the end of the packet"}
{"code": "private void askToSaveCurrent() throws CanceledException {\n  if (ProgramProperties.isUseGUI()) {\n    if (!doc.getMeganFile().hasDataConnector() && doc.getNumberOfSamples() > 0 && doc.isDirty()) {\n      getFrame().toFront();\n      getFrame().setAlwaysOnTop(true);\n      try {\n        int result=JOptionPane.showConfirmDialog(getFrame(),\"Document has been modified, save before \" + (ProjectManager.isQuitting() ? \"quitting?\" : \"closing?\"),ProgramProperties.getProgramName() + \" - Save Changes?\",JOptionPane.YES_NO_CANCEL_OPTION);\n        if (result == JOptionPane.YES_OPTION) {\n          Boolean[] canceled=new Boolean[]{false};\n          getCommandManager().getCommand(SaveCommand.NAME).actionPerformed(new ActionEvent(canceled,0,\"askToSave\"));\n          if (canceled[0])           throw new CanceledException();\n          doc.setDirty(false);\n        }\n else         if (result == JOptionPane.NO_OPTION)         doc.setDirty(false);\n else         if (result == JOptionPane.CANCEL_OPTION) {\n          throw new CanceledException();\n        }\n      }\n  finally {\n        getFrame().setAlwaysOnTop(false);\n      }\n    }\n  }\n}\n", "nl": "determine whether current data needs saving and allows the user to do so, if necessary"}
{"code": "public int send(OutputStream out) throws IOException {\n  long remainBytes=fileSize;\n  byte[] buff=new byte[256 * 1024];\n  int bytes;\n  while (remainBytes > 0) {\n    try {\n      if ((bytes=inputStream.read(buff,0,remainBytes > buff.length ? buff.length : (int)remainBytes)) < 0) {\n        return -1;\n      }\n    }\n catch (    IOException ex) {\n      ex.printStackTrace();\n      return -1;\n    }\n    out.write(buff,0,bytes);\n    remainBytes-=bytes;\n  }\n  return 0;\n}\n", "nl": "send file content callback function, be called only once when the file uploaded"}
{"code": "public void print(TorrentSessionState sessionState){\n  if (shutdown) {\n    return;\n  }\n  try {\n    long downloaded=sessionState.getDownloaded();\n    long uploaded=sessionState.getUploaded();\n    graphics.putString(0,2,getDurations(downloaded - this.downloaded,sessionState.getPiecesRemaining(),sessionState.getPiecesTotal()));\n    graphics.putString(0,3,getSessionInfo(sessionState.getConnectedPeers(),downloaded - this.downloaded,uploaded - this.uploaded));\n    graphics.putString(0,4,getProgressBar(sessionState.getPiecesTotal(),sessionState.getPiecesRemaining()));\n    if (sessionState.getPiecesRemaining() == 0) {\n      graphics.putString(0,5,\"Download is complete. Press Ctrl-C to stop seeding and exit.\");\n    }\n    screen.refresh(Screen.RefreshType.DELTA);\n    this.downloaded=downloaded;\n    this.uploaded=uploaded;\n  }\n catch (  Throwable e) {\n    LOGGER.error(\"Unexpected error when printing session state\",e);\n    shutdown();\n  }\n}\n", "nl": "call me once per second"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set labelFillColor=\");\n  Color color=null;\n  if (np.peekMatchIgnoreCase(\"null\"))   np.matchIgnoreCase(\"null\");\n else   color=np.getColor();\n  np.matchIgnoreCase(\";\");\n  if (getViewer() instanceof GraphView) {\n    boolean changed=false;\n    GraphView viewer=(GraphView)getViewer();\n    for (    Node v : viewer.getSelectedNodes()) {\n      if (viewer.isLabelVisible(v)) {\n        viewer.setLabelBackgroundColor(v,color);\n        changed=true;\n      }\n    }\n    for (    Edge edge : viewer.getSelectedEdges()) {\n      if (viewer.isLabelVisible(edge)) {\n        viewer.setLabelBackgroundColor(edge,color);\n        changed=true;\n      }\n    }\n    if (changed) {\n      viewer.repaint();\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private void checkFloat(float expected,String string,int delta){\n  int expectedBits=Float.floatToRawIntBits(expected);\n  BytesRef bytes=getBytes(string);\n  final float v;\n  try {\n    v=MathUtil.parseFloat(bytes.bytes,bytes.offset,bytes.length);\n  }\n catch (  Throwable t) {\n    throw new AssertionError(string + \" didn't parse to \" + expected+ \", instead hit \"+ t,t);\n  }\n  try {\n    int actualBits=Float.floatToRawIntBits(v);\n    int actualDelta=Math.abs(expectedBits - actualBits);\n    if (actualDelta > delta) {\n      throw new AssertionError(\"expected: <\" + expectedBits + \"> but was:<\"+ actualBits+ \">\");\n    }\n  }\n catch (  Throwable t) {\n    throw new AssertionError(string + \" didn't parse to \" + expected+ \", instead: \"+ v,t);\n  }\n}\n", "nl": "Checks float parse"}
{"code": "public static boolean FlymeSetStatusBarLightMode(Window window,boolean dark){\n  boolean result=false;\n  if (window != null) {\n    try {\n      WindowManager.LayoutParams lp=window.getAttributes();\n      Field darkFlag=WindowManager.LayoutParams.class.getDeclaredField(\"MEIZU_FLAG_DARK_STATUS_BAR_ICON\");\n      Field meizuFlags=WindowManager.LayoutParams.class.getDeclaredField(\"meizuFlags\");\n      darkFlag.setAccessible(true);\n      meizuFlags.setAccessible(true);\n      int bit=darkFlag.getInt(null);\n      int value=meizuFlags.getInt(lp);\n      if (dark) {\n        value|=bit;\n      }\n else {\n        value&=~bit;\n      }\n      meizuFlags.setInt(lp,value);\n      window.setAttributes(lp);\n      result=true;\n    }\n catch (    Exception e) {\n    }\n  }\n  return result;\n}\n", "nl": "meizu Flyme set status bar light mode"}
{"code": "protected void spawnHelpers(int npcId,float x,float y,float z,byte h,int count,int action){\n  if (isHome.equals(true) || isAlreadyDead()) {\n    return;\n  }\n  for (int i=0; i < count; i++) {\n    SpawnTemplate summon=SpawnEngine.addNewSingleTimeSpawn(getPosition().getMapId(),npcId,x,y,z,h);\n    VisibleObject npc=SpawnEngine.spawnObject(summon,getPosition().getInstanceId());\n    PacketSendUtility.broadcastPacket(getOwner(),new SM_NPC_INFO((Npc)npc,\"\"));\n    addHelpersSpawn(npc.getObjectId());\nswitch (action) {\ncase 1:\n      moveToForward((Npc)npc,633.7391f,455.4411f,135.82466f,false);\n    break;\ncase 2:\n  moveToForward((Npc)npc,639.51807f,455.4411f,135.82466f,false);\nbreak;\ncase 3:\nmoveToForward((Npc)npc,636.39575f,455.4411f,135.82466f,false);\nbreak;\n}\n}\n}\n", "nl": "Spawn Anuratis Helpers <p/> movement must be better adapted"}
{"code": "private String[] diff_halfMatchI(String longtext,String shorttext,int i){\n  String seed=longtext.substring(i,i + longtext.length() / 4);\n  int j=-1;\n  String best_common=\"\";\n  String best_longtext_a=\"\", best_longtext_b=\"\";\n  String best_shorttext_a=\"\", best_shorttext_b=\"\";\n  while ((j=shorttext.indexOf(seed,j + 1)) != -1) {\n    int prefixLength=diff_commonPrefix(longtext.substring(i),shorttext.substring(j));\n    int suffixLength=diff_commonSuffix(longtext.substring(0,i),shorttext.substring(0,j));\n    if (best_common.length() < suffixLength + prefixLength) {\n      best_common=shorttext.substring(j - suffixLength,j) + shorttext.substring(j,j + prefixLength);\n      best_longtext_a=longtext.substring(0,i - suffixLength);\n      best_longtext_b=longtext.substring(i + prefixLength);\n      best_shorttext_a=shorttext.substring(0,j - suffixLength);\n      best_shorttext_b=shorttext.substring(j + prefixLength);\n    }\n  }\n  if (best_common.length() * 2 >= longtext.length()) {\n    return new String[]{best_longtext_a,best_longtext_b,best_shorttext_a,best_shorttext_b,best_common};\n  }\n else {\n    return null;\n  }\n}\n", "nl": "Does a substring of shorttext exist within longtext such that the substring is at least half the length of longtext?"}
{"code": "public void addPages(){\n  ISVNRepositorySourceProvider[] repositorySourceProviders=null;\n  try {\n    repositorySourceProviders=SVNUIPlugin.getRepositorySourceProviders();\n  }\n catch (  Exception e) {\n  }\n  if (repositorySourceProviders != null && repositorySourceProviders.length > 0) {\n    repositorySourceProviderPage=new ConfigurationWizardRepositorySourceProviderPage(\"source\",Policy.bind(\"NewLocationWizard.heading\"),SVNUIPlugin.getPlugin().getImageDescriptor(ISVNUIConstants.IMG_WIZBAN_NEW_LOCATION),repositorySourceProviders);\n    repositorySourceProviderPage.setDescription(Policy.bind(\"NewLocationWizard.0\"));\n    addPage(repositorySourceProviderPage);\n    for (    ISVNRepositorySourceProvider repositorySourceProvider : repositorySourceProviders) {\n      SVNRepositoryProviderWizardPage wizardPage=repositorySourceProvider.getWizardPage();\n      addPage(wizardPage);\n      wizardPageMap.put(repositorySourceProvider,wizardPage);\n    }\n  }\n  mainPage=new ConfigurationWizardMainPage(\"main\",Policy.bind(\"NewLocationWizard.heading\"),SVNUIPlugin.getPlugin().getImageDescriptor(ISVNUIConstants.IMG_WIZBAN_NEW_LOCATION));\n  if (properties != null) {\n    mainPage.setProperties(properties);\n  }\n  mainPage.setDescription(Policy.bind(\"NewLocationWizard.description\"));\n  mainPage.setDialogSettings(getDialogSettings());\n  addPage(mainPage);\n}\n", "nl": "Creates the wizard pages"}
{"code": "public static String removeOrderTerm(HttpServletRequest request,HttpServletResponse response){\n  ShoppingCart cart=getCartObject(request);\n  String termIndexStr=request.getParameter(\"termIndex\");\n  if (UtilValidate.isNotEmpty(termIndexStr)) {\n    try {\n      Integer termIndex=Integer.parseInt(termIndexStr);\n      if (termIndex >= 0) {\n        List<GenericValue> orderTerms=cart.getOrderTerms();\n        if (orderTerms != null && orderTerms.size() > termIndex) {\n          cart.removeOrderTerm(termIndex);\n        }\n      }\n    }\n catch (    NumberFormatException e) {\n      Debug.logWarning(e,\"Error parsing termIndex: \" + termIndexStr,module);\n    }\n  }\n  return \"success\";\n}\n", "nl": "Remove an order term"}
{"code": "@Override public void load(String fileName,InputStream dummy,String dummy2,float dummy3) throws IOException, MaryConfigurationException {\n  DataInputStream dis=new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)));\n  hdr=new MaryHeader(dis);\n  if (hdr.getType() != MaryHeader.PRECOMPUTED_JOINCOSTS) {\n    throw new MaryConfigurationException(\"File [\" + fileName + \"] is not a valid Mary precompiled join costs file.\");\n  }\n  int numberOfLeftUnits=dis.readInt();\n  if (numberOfLeftUnits < 0) {\n    throw new MaryConfigurationException(\"File [\" + fileName + \"] has a negative number of units. Aborting.\");\n  }\n  left=new HashMap();\n  for (int i=0; i < numberOfLeftUnits; i++) {\n    int leftIndex=dis.readInt();\n    int numberOfRightUnits=dis.readInt();\n    Map right=new HashMap();\n    left.put(new Integer(leftIndex),right);\n    for (int j=0; j < numberOfRightUnits; j++) {\n      int rightIndex=dis.readInt();\n      float cost=dis.readFloat();\n      right.put(new Integer(rightIndex),new Float(cost));\n    }\n  }\n}\n", "nl": "Load the given precompiled join cost file"}
{"code": "private void testBasicLockUnlock(long timeout) throws Exception {\n  String lockPath=\"/test-basic-lock-unlock-\" + timeout + System.currentTimeMillis();\n  String clientId=\"test-basic-lock-unlock\";\n  createLockPath(zkc.get(),lockPath);\n  ZKSessionLock lock=new ZKSessionLock(zkc,lockPath,clientId,lockStateExecutor);\n  lock.tryLock(timeout,TimeUnit.MILLISECONDS);\n  assertEquals(State.CLAIMED,lock.getLockState());\n  List<String> children=getLockWaiters(zkc,lockPath);\n  assertEquals(1,children.size());\n  assertEquals(lock.getLockId(),Await.result(asyncParseClientID(zkc.get(),lockPath,children.get(0))));\n  try {\n    lock.tryLock(timeout,TimeUnit.MILLISECONDS);\n    fail(\"Should fail on locking a failure lock.\");\n  }\n catch (  LockStateChangedException lsce) {\n  }\n  assertEquals(State.CLAIMED,lock.getLockState());\n  children=getLockWaiters(zkc,lockPath);\n  assertEquals(1,children.size());\n  assertEquals(lock.getLockId(),Await.result(asyncParseClientID(zkc.get(),lockPath,children.get(0))));\n  lock.unlock();\n  assertEquals(State.CLOSED,lock.getLockState());\n  assertEquals(0,getLockWaiters(zkc,lockPath).size());\n}\n", "nl": "Test Basic Lock and Unlock - lock should succeed if there is no lock held - lock should fail on a success lock - unlock should release the held lock"}
{"code": "@Deployment public void testNonInterruptingSignalWithSubProcess(){\n  ProcessInstance pi=runtimeService.startProcessInstanceByKey(\"nonInterruptingSignalWithSubProcess\");\n  List<Task> tasks=taskService.createTaskQuery().processInstanceId(pi.getProcessInstanceId()).list();\n  assertEquals(1,tasks.size());\n  Task currentTask=tasks.get(0);\n  assertEquals(\"Approve\",currentTask.getName());\n  runtimeService.signalEventReceived(\"alert\");\n  tasks=taskService.createTaskQuery().processInstanceId(pi.getProcessInstanceId()).list();\n  assertEquals(2,tasks.size());\n  for (  Task task : tasks) {\n    if (!task.getName().equals(\"Approve\") && !task.getName().equals(\"Review\")) {\n      fail(\"Expected: <Approve> or <Review> but was <\" + task.getName() + \">.\");\n    }\n  }\n  taskService.complete(taskService.createTaskQuery().taskName(\"Approve\").singleResult().getId());\n  tasks=taskService.createTaskQuery().processInstanceId(pi.getProcessInstanceId()).list();\n  assertEquals(1,tasks.size());\n  currentTask=tasks.get(0);\n  assertEquals(\"Review\",currentTask.getName());\n  taskService.complete(taskService.createTaskQuery().taskName(\"Review\").singleResult().getId());\n  tasks=taskService.createTaskQuery().processInstanceId(pi.getProcessInstanceId()).list();\n  assertEquals(1,tasks.size());\n}\n", "nl": "TestCase to reproduce Issue ACT-1344"}
{"code": "public LoadMetadataDetails[] readLoadMetadata(String tableFolderPath){\n  Gson gsonObjectToRead=new Gson();\n  DataInputStream dataInputStream=null;\n  BufferedReader buffReader=null;\n  InputStreamReader inStream=null;\n  String metadataFileName=tableFolderPath + CarbonCommonConstants.FILE_SEPARATOR + CarbonCommonConstants.LOADMETADATA_FILENAME;\n  LoadMetadataDetails[] listOfLoadFolderDetailsArray;\n  AtomicFileOperations fileOperation=new AtomicFileOperationsImpl(metadataFileName,FileFactory.getFileType(metadataFileName));\n  try {\n    if (!FileFactory.isFileExist(metadataFileName,FileFactory.getFileType(metadataFileName))) {\n      return new LoadMetadataDetails[0];\n    }\n    dataInputStream=fileOperation.openForRead();\n    inStream=new InputStreamReader(dataInputStream,Charset.forName(CarbonCommonConstants.DEFAULT_CHARSET));\n    buffReader=new BufferedReader(inStream);\n    listOfLoadFolderDetailsArray=gsonObjectToRead.fromJson(buffReader,LoadMetadataDetails[].class);\n  }\n catch (  IOException e) {\n    return new LoadMetadataDetails[0];\n  }\n finally {\n    closeStreams(buffReader,inStream,dataInputStream);\n  }\n  return listOfLoadFolderDetailsArray;\n}\n", "nl": "This method reads the load metadata file"}
{"code": "public Range intersection(SegmentRange range){\n  if (!hasFunctionCallDescription(this) && !hasFunctionCallDescription(range)) {\n    return handleSegmentWithSegment(range);\n  }\n else   if (!twoBuiltInFunctions(this,range)) {\n    return new CompositeRange(this,range);\n  }\n else   if (hasFunctionOnlyOnOneSide(this,range)) {\n    return new CompositeRange(this,range);\n  }\n else   if (hasFunctionCallDescription(this) && hasFunctionCallDescription(range)) {\n    if (hasSameFunction(range)) {\n      return handleSegmentWithSegment(range);\n    }\n else {\n      return new CompositeRange(this,range);\n    }\n  }\n  return new CompositeRange(this,range);\n}\n", "nl": "Calculates the intersection between this range and the given range"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  final megan.remote.RemoteServiceBrowser remoteServiceBrowser=(megan.remote.RemoteServiceBrowser)getViewer();\n  if (remoteServiceBrowser != null) {\n    String url=remoteServiceBrowser.getURL();\n    String user=remoteServiceBrowser.getUser();\n    String password=remoteServiceBrowser.getPasswd();\n    String command=\"openServer url='\" + url + \"'\";\n    if (user.length() > 0)     command+=\" user='\" + user + \"'\";\n    if (password.length() > 0) {\nsynchronized (syncObject) {\n        OpenRemoteServerCommand.hiddenPassword=password;\n      }\n      command+=\" password='\" + HIDDEN_PASSWORD + \"'\";\n    }\n    command+=\";\";\n    if (url.length() > 0) {\n      execute(command);\n    }\n  }\n}\n", "nl": "action to be performed"}
{"code": "@SuppressWarnings(\"unchecked\") public boolean isInRange(final SourceDataTag sdt,final Object value){\n  this.equipmentLogger.trace(\"isInRange - entering isInRange()..\");\n  boolean isInRange=true;\n  Comparable convertedValue;\n  setDataTypeOfRangeValue(sdt);\n  if (sdt.getMinValue() != null) {\n    convertedValue=(Comparable)TypeConverter.cast(value,sdt.getDataType());\n    if (compare(sdt.getMinValue(),convertedValue) > 0) {\n      this.equipmentLogger.trace(\"\\tisInRange - out of range : \" + convertedValue + \" is less than the authorized minimum value \"+ sdt.getMinValue());\n      isInRange=false;\n    }\n  }\n  if (isInRange) {\n    if (sdt.getMaxValue() != null) {\n      convertedValue=(Comparable)TypeConverter.cast(value,sdt.getDataType());\n      if (compare(sdt.getMaxValue(),convertedValue) < 0) {\n        this.equipmentLogger.trace(\"\\tisInRange - out of range : \" + convertedValue + \" is greater than the authorized maximum value \"+ sdt.getMaxValue());\n        isInRange=false;\n      }\n    }\n  }\n  this.equipmentLogger.trace(\"isInRange - leaving isInRange(). Is value in range?: \" + isInRange);\n  return isInRange;\n}\n", "nl": "This method is responsible for checking if new value received from data source fits in a proper range"}
{"code": "public void runScript(Reader reader) throws IOException, SQLException {\n  try {\n    boolean originalAutoCommit=connection.getAutoCommit();\n    try {\n      if (originalAutoCommit != this.autoCommit) {\n        connection.setAutoCommit(this.autoCommit);\n      }\n      runScript(connection,reader);\n    }\n  finally {\n      connection.setAutoCommit(originalAutoCommit);\n    }\n  }\n catch (  IOException|SQLException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new RuntimeException(\"Error running script.  Cause: \" + e,e);\n  }\n}\n", "nl": "Runs an SQL script (read in using the Reader parameter)"}
{"code": "public List<Sweet> extractSweetsForFeatureWithOpenCV(Mat img,Mat feature,int i){\n  STEP=10;\n  DIFFERENCE_LIMIT=60;\n  Imgproc.pyrDown(feature,feature,new Size(feature.cols() / 2,feature.rows() / 2));\n  Mat result=createResultMat(img,feature);\n  result=matchFeature(img,feature,result);\n  if (i != 5) {\n    THRESHOLD=0.96;\n  }\n else {\n    THRESHOLD=0.85;\n  }\n  Core.MinMaxLocResult mmr=Core.minMaxLoc(result);\n  Point matchLoc=mmr.maxLoc;\n  int refX=(int)matchLoc.x + feature.cols() / 2;\n  int refY=(int)matchLoc.y + feature.rows() / 2;\n  if (!isFeatureAbsent(img,feature,refX,refY)) {\n    Imgproc.threshold(result,result,THRESHOLD,255,Imgproc.THRESH_BINARY);\n    return extractSweetsForFeatureWithOpenCV(result,i);\n  }\n  return Collections.emptyList();\n}\n", "nl": "OpenCV Version"}
{"code": "@Override public boolean onMenuItemClick(MenuItem item){\nswitch (item.getItemId()) {\ncase R.id.action_notice:\n    if (getUserConstant().isLogin()) {\n      openActivity(UserMessageActivity.class);\n    }\n else {\n      showShortToast(getString(R.string.toast_no_login));\n    }\n  break;\ncase R.id.action_about:\nOpenWebViewUtils.aboutMe(this);\nbreak;\ncase R.id.action_search:\nshowShortToast(getString(R.string.toast_adorn));\nbreak;\ncase R.id.action_settings:\nopenActivity(SettingActivity.class);\nbreak;\n}\nreturn true;\n}\n", "nl": "toolbar menu click callback"}
{"code": "public int stringLength(){\n  String sqlTypeUpperCase=sqlType.toUpperCase();\n  if (sqlTypeUpperCase.indexOf(\"VARCHAR\") >= 0) {\n    if (sqlTypeUpperCase.indexOf(\"(\") > 0 && sqlTypeUpperCase.indexOf(\")\") > 0) {\n      String length=sqlTypeUpperCase.substring(sqlTypeUpperCase.indexOf(\"(\") + 1,sqlTypeUpperCase.indexOf(\")\"));\n      return Integer.parseInt(length);\n    }\n else {\n      return 255;\n    }\n  }\n else   if (sqlTypeUpperCase.indexOf(\"CHAR\") >= 0) {\n    if (sqlTypeUpperCase.indexOf(\"(\") > 0 && sqlTypeUpperCase.indexOf(\")\") > 0) {\n      String length=sqlTypeUpperCase.substring(sqlTypeUpperCase.indexOf(\"(\") + 1,sqlTypeUpperCase.indexOf(\")\"));\n      return Integer.parseInt(length);\n    }\n else {\n      return 255;\n    }\n  }\n else   if (sqlTypeUpperCase.indexOf(\"TEXT\") >= 0 || sqlTypeUpperCase.indexOf(\"LONG\") >= 0 || sqlTypeUpperCase.indexOf(\"CLOB\") >= 0) {\n    return 5000;\n  }\n  return 20;\n}\n", "nl": "A simple function to derive the max length of a String created from the field value, based on the sql-type"}
{"code": "public void loadMeganFile() throws IOException, CanceledException {\n  clearReads();\n  getProgressListener().setTasks(\"Loading MEGAN File\",getMeganFile().getName());\n  if (getMeganFile().hasDataConnector()) {\n    IConnector connector=getMeganFile().getDataConnector();\n    SyncArchiveAndDataTable.syncArchive2Summary(meganFile.getFileName(),connector,dataTable,sampleAttributeTable);\n    if (dataTable.getTotalReads() == 0 && connector.getNumberOfReads() > 0) {\n      SyncArchiveAndDataTable.syncRecomputedArchive2Summary(getMeganFile().getName(),\"merge\",dataTable.getBlastMode(),\"\",connector,dataTable,0);\n    }\n    setNumberReads(getDataTable().getTotalReads());\n    setAdditionalReads(getDataTable().getAdditionalReads());\n    getActiveViewers().clear();\n    getActiveViewers().addAll(Arrays.asList(connector.getAllClassificationNames()));\n    String parameters=getDataTable().getParameters();\n    if (parameters != null) {\n      parseParameterString(parameters);\n    }\n    getSampleAttributeTable().addAttribute(SampleAttributeTable.HiddenAttribute.Source.toString(),getMeganFile().getFileName(),true);\n  }\n else   if (getMeganFile().isMeganSummaryFile()) {\n    loadMeganSummaryFile();\n  }\n else   throw new IOException(\"File format not (or no longer) supported\");\n  loadColorTableFromDataTable();\n  lastRecomputeTime=System.currentTimeMillis();\n  colorsArray=new Color[getNumberOfSamples()];\n}\n", "nl": "load data from the set file"}
{"code": "@Override public void selectionChanged(@NotNull SelectionModel model,@NotNull List<NlComponent> selection){\n  if (selection.isEmpty()) {\n    return;\n  }\n  boolean different=selection.size() != mySelection.size();\n  if (!different) {\n    for (    NlComponent component : model.getSelection()) {\n      if (!mySelection.contains(myWidgetsScene.getWidget(component))) {\n        different=true;\n        break;\n      }\n    }\n  }\n  if (!different) {\n    return;\n  }\n  mySelection.silentClear();\n  for (  NlComponent component : model.getSelection()) {\n    ConstraintWidget widget=myWidgetsScene.getWidget(component);\n    if (widget != null && !widget.isRoot() && !widget.isRootContainer()) {\n      mySelection.silentAdd(widget);\n    }\n  }\n}\n", "nl": "Something has changed on the selection of NlModel"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  ClusterViewer viewer=getViewer();\n  np.matchIgnoreCase(\"rotate axis=\");\n  String axis=np.getWordMatchesIgnoringCase(\"x y z\");\n  np.matchIgnoreCase(\"angle=\");\n  double angle=np.getDouble();\n  Matrix3D matrix=viewer.getPcoaTab().getTransformation3D();\n  if (axis.equalsIgnoreCase(\"x\")) {\n    matrix.rotateX(angle);\n  }\n else   if (axis.equalsIgnoreCase(\"y\")) {\n    matrix.rotateY(angle);\n  }\n else   if (axis.equalsIgnoreCase(\"z\")) {\n    matrix.rotateZ(angle);\n  }\n  viewer.getPcoaTab().updateTransform(true);\n  if (viewer.getPcoaTab().isShowGroupsAsConvexHulls())   viewer.getPcoaTab().computeConvexHullsAndEllipsesForGroups(viewer.getGroup2Nodes());\n  np.matchIgnoreCase(\";\");\n}\n", "nl": "parses the given command and executes it"}
{"code": "public int calculateCount(String desktopstate,int concurrentvms,int vmsperhost,double vcenterhamultiplier){\n  int i=0;\n  Float f=null;\n  if (desktopstate.equalsIgnoreCase(\"on\")) {\n    f=((float)concurrentvms / (float)vmsperhost);\n  }\n else   if (desktopstate.equalsIgnoreCase(\"off\")) {\n    f=((float)concurrentvms / (float)vmsperhost);\n  }\n else   if (desktopstate.equalsIgnoreCase(\"suspend\")) {\n    f=((float)concurrentvms / (float)vmsperhost);\n  }\n else {\n    f=((float)concurrentvms / (float)vmsperhost);\n  }\n  f=(float)Math.ceil(f * 2) / 2;\n  f=(float)Math.round(f);\n  f=(float)(f * vcenterhamultiplier);\n  f=(float)Math.ceil(f * 2) / 2;\n  final Float ftemp=(float)0.5;\n  if (ftemp == (f % 1)) {\n    f+=ftemp;\n  }\n  i=f.intValue();\n  return i;\n}\n", "nl": "Calculate host number"}
{"code": "@deprecated protected void handleComputeFields(int julianDay){\n  int[] fields=new int[3];\n  jdToCE(julianDay,getJDEpochOffset(),fields);\n  int year;\n  int era;\n  int year;\n  if (isAmeteAlemEra()) {\n    int era=0;\n    year=fields[0] + 5500;\n  }\n else {\n    int year;\n    if (fields[0] > 0) {\n      int era=1;\n      year=fields[0];\n    }\n else {\n      era=0;\n      year=fields[0] + 5500;\n    }\n  }\n  internalSet(19,fields[0]);\n  internalSet(0,era);\n  internalSet(1,year);\n  internalSet(2,fields[1]);\n  internalSet(5,fields[2]);\n  internalSet(6,30 * fields[1] + fields[2]);\n}\n", "nl": "/*    "}
{"code": "public void handleBtnKeyEvent(KeyEvent e){\nswitch (e.getCode()) {\ncase ENTER:\n    processCommand();\n  break;\ncase BACK_SPACE:\nbreak;\ncase UP:\nif (nCommandIndicatorPoisition != nCommandsContainerIndicator && nCommandIndicatorPoisition > Settings.ERRORCODE) setServerCommandTextEdit();\nif (nCommandIndicatorPoisition != nCommandsContainerIndicator) nCommandIndicatorPoisition--;\nif (nCommandIndicatorPoisition < 0 && sCommandsContainer[Settings.nMaximumSizeOfCommandsContainer - 1] != null) nCommandIndicatorPoisition=Settings.nMaximumSizeOfCommandsContainer - 1;\nbreak;\ncase DOWN:\nif (nCommandIndicatorPoisition != _firstPoistion) nCommandIndicatorPoisition++;\nif (nCommandIndicatorPoisition >= Settings.nMaximumSizeOfCommandsContainer && sCommandsContainer[Settings.ZEROINIT] != null) nCommandIndicatorPoisition=Settings.ZEROINIT;\nif (nCommandIndicatorPoisition != nCommandsContainerIndicator && nCommandIndicatorPoisition > Settings.ERRORCODE) setServerCommandTextEdit();\nbreak;\ncase LEFT:\nbreak;\ncase RIGHT:\nbreak;\ndefault :\ne.consume();\nbreak;\n}\n}\n", "nl": "handle shell btn event"}
{"code": "private void onWeatherChange(int mapId,Player player){\n  WeatherEntry[] weatherEntries=getWeatherEntries(mapId);\n  if (weatherEntries == null) {\n    return;\n  }\n  if (player == null) {\n    for (Iterator<Player> playerIterator=World.getInstance().getPlayersIterator(); playerIterator.hasNext(); ) {\n      Player currentPlayer=playerIterator.next();\n      if (!currentPlayer.isSpawned()) {\n        continue;\n      }\n      if (currentPlayer.getWorldId() == mapId) {\n        PacketSendUtility.sendPacket(currentPlayer,new SM_WEATHER(weatherEntries));\n      }\n    }\n  }\n else {\n    PacketSendUtility.sendPacket(player,new SM_WEATHER(weatherEntries));\n  }\n}\n", "nl": "triggers the update of weather to all players"}
{"code": "private void copyDatabase() throws Exception {\n  try {\n    InputStream input=mContext.getAssets().open(DB_NAME);\n    String outFileName=DB_PATH + DB_NAME;\n    OutputStream output=new FileOutputStream(outFileName);\n    byte[] buffer=new byte[1024];\n    int length;\n    while (((length=input.read(buffer)) > 0)) {\n      output.write(buffer,0,length);\n    }\n    output.flush();\n    input.close();\n    output.close();\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n    Log.e(\"DB_ERROR\",\"copyDatabase(): Could not copy DB\");\n  }\n}\n", "nl": "copy to database in device which copy assets folder database"}
{"code": "public static String clearEvent(HttpServletRequest request,HttpServletResponse response){\n  String errMsg=\"\";\n  Locale locale=UtilHttp.getLocale(request);\n  Security security=(Security)request.getAttribute(\"security\");\n  if (!security.hasPermission(\"UTIL_CACHE_EDIT\",request.getSession())) {\n    errMsg=UtilProperties.getMessage(UtilCacheEvents.err_resource,\"utilCacheEvents.permissionEdit\",locale) + \".\";\n    request.setAttribute(\"_ERROR_MESSAGE_\",errMsg);\n    return \"error\";\n  }\n  String name=request.getParameter(\"UTIL_CACHE_NAME\");\n  if (name == null) {\n    errMsg=UtilProperties.getMessage(UtilCacheEvents.err_resource,\"utilCache.couldNotClearCache\",locale) + \".\";\n    request.setAttribute(\"_ERROR_MESSAGE_\",errMsg);\n    return \"error\";\n  }\n  UtilCache<?,?> utilCache=UtilCache.findCache(name);\n  if (utilCache != null) {\n    utilCache.clear();\n    errMsg=UtilProperties.getMessage(UtilCacheEvents.err_resource,\"utilCache.clearCache\",UtilMisc.toMap(\"name\",name),locale) + \".\";\n    request.setAttribute(\"_EVENT_MESSAGE_\",errMsg);\n  }\n else {\n    errMsg=UtilProperties.getMessage(UtilCacheEvents.err_resource,\"utilCache.couldNotClearCacheNotFoundName\",UtilMisc.toMap(\"name\",name),locale) + \".\";\n    request.setAttribute(\"_ERROR_MESSAGE_\",errMsg);\n    return \"error\";\n  }\n  return \"success\";\n}\n", "nl": "An HTTP WebEvent handler that clears the named cache"}
{"code": "public static void forkResourceFile(@NotNull DesignSurface surface,@Nullable String newFolder,boolean open){\n  Configuration configuration=surface.getConfiguration();\n  if (configuration == null) {\n    assert false;\n    return;\n  }\n  final VirtualFile file=configuration.getFile();\n  if (file == null) {\n    assert false;\n    return;\n  }\n  Module module=configuration.getModule();\n  if (module == null) {\n    assert false;\n    return;\n  }\n  XmlFile xmlFile=(XmlFile)configuration.getPsiFile();\n  ResourceFolderType folderType=ResourceHelper.getFolderType(xmlFile);\n  if (folderType == null) {\n    folderType=ResourceFolderType.LAYOUT;\n  }\n  forkResourceFile(module.getProject(),folderType,file,xmlFile,newFolder,configuration,open);\n}\n", "nl": "Create a variation (copy) of a given resource file"}
{"code": "private void doOperation(Account account,String remotePath){\n  mCurrentSyncOperation=mPendingOperations.get(account.name,remotePath);\n  if (mCurrentSyncOperation != null) {\n    RemoteOperationResult result=null;\n    try {\n      if (mCurrentAccount == null || !mCurrentAccount.equals(account)) {\n        mCurrentAccount=account;\n        mStorageManager=new FileDataStorageManager(account,mService.getContentResolver());\n      }\n      OwnCloudAccount ocAccount=new OwnCloudAccount(account,mService);\n      mOwnCloudClient=OwnCloudClientManagerFactory.getDefaultSingleton().getClientFor(ocAccount,mService);\n      result=mCurrentSyncOperation.execute(mOwnCloudClient,mStorageManager);\n    }\n catch (    AccountsException e) {\n      Log_OC.e(TAG,\"Error while trying to get authorization\",e);\n    }\ncatch (    IOException e) {\n      Log_OC.e(TAG,\"Error while trying to get authorization\",e);\n    }\n finally {\n      mPendingOperations.removePayload(account.name,remotePath);\n      mService.dispatchResultToOperationListeners(mCurrentSyncOperation,result);\n      sendBroadcastFinishedSyncFolder(account,remotePath,result.isSuccess());\n    }\n  }\n}\n", "nl": "Performs the next operation in the queue"}
{"code": "public List<GenericValue> makeAllAdjustments(){\n  List<GenericValue> allAdjs=FastList.newInstance();\n  for (  GenericValue orderAdjustment : this.getAdjustments()) {\n    allAdjs.add(orderAdjustment);\n    if (\"SHIPPING_CHARGES\".equals(orderAdjustment.get(\"orderAdjustmentTypeId\"))) {\n      Iterator<GenericValue> fsppas=this.freeShippingProductPromoActions.iterator();\n      while (fsppas.hasNext()) {\n      }\n    }\n  }\n  for (  ShoppingCartItem item : cartLines) {\n    Collection<GenericValue> adjs=item.getAdjustments();\n    if (adjs != null) {\n      for (      GenericValue orderAdjustment : adjs) {\n        orderAdjustment.set(\"orderItemSeqId\",item.getOrderItemSeqId());\n        allAdjs.add(orderAdjustment);\n        if (\"SHIPPING_CHARGES\".equals(orderAdjustment.get(\"orderAdjustmentTypeId\"))) {\n          Iterator<GenericValue> fsppas=this.freeShippingProductPromoActions.iterator();\n          while (fsppas.hasNext()) {\n          }\n        }\n      }\n    }\n  }\n  return allAdjs;\n}\n", "nl": "make a list of all adjustments including order adjustments, order line adjustments, and special adjustments (shipping and tax if applicable)"}
{"code": "private static void extract(String s,int start,ExtractFloatResult result){\n  int currentIndex=start;\n  boolean foundSeparator=false;\n  result.mEndWithNegSign=false;\n  for (; currentIndex < s.length(); currentIndex++) {\n    char currentChar=s.charAt(currentIndex);\nswitch (currentChar) {\ncase ' ':\ncase ',':\n      foundSeparator=true;\n    break;\ncase '-':\n  if (currentIndex != start) {\n    foundSeparator=true;\n    result.mEndWithNegSign=true;\n  }\nbreak;\n}\nif (foundSeparator) {\nbreak;\n}\n}\nresult.mEndPosition=currentIndex;\n}\n", "nl": "Calculate the position of the next comma or space or negative sign"}
{"code": "public EnumActionResult onItemUse(ItemStack stack,EntityPlayer playerIn,World worldIn,BlockPos pos,EnumHand hand,EnumFacing facing,float hitX,float hitY,float hitZ){\n  if (facing != EnumFacing.UP) {\n    return EnumActionResult.FAIL;\n  }\n else {\n    IBlockState iblockstate=worldIn.getBlockState(pos);\n    Block block=iblockstate.getBlock();\n    if (!block.isReplaceable(worldIn,pos)) {\n      pos=pos.offset(facing);\n    }\n    if (playerIn.canPlayerEdit(pos,facing,stack) && this.block.canPlaceBlockAt(worldIn,pos)) {\n      EnumFacing enumfacing=EnumFacing.fromAngle((double)playerIn.rotationYaw);\n      int i=enumfacing.getFrontOffsetX();\n      int j=enumfacing.getFrontOffsetZ();\n      placeDoor(worldIn,pos,enumfacing,this.block);\n      SoundType soundtype=this.block.getSoundType();\n      worldIn.playSound(playerIn,pos,soundtype.getPlaceSound(),SoundCategory.BLOCKS,(soundtype.getVolume() + 1.0F) / 2.0F,soundtype.getPitch() * 0.8F);\n      --stack.stackSize;\n      return EnumActionResult.SUCCESS;\n    }\n else {\n      return EnumActionResult.FAIL;\n    }\n  }\n}\n", "nl": "Called when a Block is right-clicked with this Item"}
{"code": "private void registerCallbackMethodsForView(SootClass callbackClass,LayoutControl lc){\n  if (callbackClass.getName().startsWith(\"android.\"))   return;\n  if (lc.getViewClass().getName().startsWith(\"android.\"))   return;\n{\n    SootClass sc=lc.getViewClass();\n    boolean isView=false;\n    while (sc.hasSuperclass()) {\n      if (sc.getName().equals(\"android.view.View\")) {\n        isView=true;\n        break;\n      }\n      sc=sc.getSuperclass();\n    }\n    if (!isView)     return;\n  }\n  SootClass sc=lc.getViewClass();\n  Set<String> systemMethods=new HashSet<String>(10000);\n  for (  SootClass parentClass : Scene.v().getActiveHierarchy().getSuperclassesOf(sc)) {\n    if (parentClass.getName().startsWith(\"android.\"))     for (    SootMethod sm : parentClass.getMethods())     if (!sm.isConstructor())     systemMethods.add(sm.getSubSignature());\n  }\n  for (  SootMethod sm : sc.getMethods())   if (!sm.isConstructor())   if (systemMethods.contains(sm.getSubSignature()))   addCallbackMethod(callbackClass.getName(),new AndroidMethod(sm));\n}\n", "nl": "Registers the callback methods in the given layout control so that they are included in the dummy main method"}
{"code": "public static String[] split(String str,char escapeChar,char separator){\n  if (str == null) {\n    return null;\n  }\n  List<String> strList=new ArrayList<>();\n  StringBuilder split=new StringBuilder();\n  int index=0;\n  while ((index=findNext(str,separator,escapeChar,index,split)) >= 0) {\n    ++index;\n    strList.add(split.toString());\n    split.setLength(0);\n  }\n  strList.add(split.toString());\n  int last=strList.size();\n  while (--last >= 0 && \"\".equals(strList.get(last))) {\n    strList.remove(last);\n  }\n  return strList.toArray(new String[strList.size()]);\n}\n", "nl": "Split a string using the given separator"}
{"code": "public static boolean[] identifyDimensionType(List<CarbonDimension> tableDimensionList){\n  List<Boolean> isDictionaryDimensions=new ArrayList<Boolean>();\n  Set<Integer> processedColumnGroup=new HashSet<Integer>();\n  for (  CarbonDimension carbonDimension : tableDimensionList) {\n    List<CarbonDimension> childs=carbonDimension.getListOfChildDimensions();\n    if (null != childs && childs.size() > 0) {\n      break;\n    }\n    if (carbonDimension.isColumnar() && hasEncoding(carbonDimension.getEncoder(),Encoding.DICTIONARY)) {\n      isDictionaryDimensions.add(true);\n    }\n else     if (!carbonDimension.isColumnar()) {\n      if (processedColumnGroup.add(carbonDimension.columnGroupId())) {\n        isDictionaryDimensions.add(true);\n      }\n    }\n else {\n      isDictionaryDimensions.add(false);\n    }\n  }\n  boolean[] primitive=ArrayUtils.toPrimitive(isDictionaryDimensions.toArray(new Boolean[isDictionaryDimensions.size()]));\n  return primitive;\n}\n", "nl": "Below method will be used to get the dimension"}
{"code": "public static boolean FlymeSetStatusBarLightMode(Window window,boolean dark){\n  boolean result=false;\n  if (window != null) {\n    try {\n      WindowManager.LayoutParams lp=window.getAttributes();\n      Field darkFlag=WindowManager.LayoutParams.class.getDeclaredField(\"MEIZU_FLAG_DARK_STATUS_BAR_ICON\");\n      Field meizuFlags=WindowManager.LayoutParams.class.getDeclaredField(\"meizuFlags\");\n      darkFlag.setAccessible(true);\n      meizuFlags.setAccessible(true);\n      int bit=darkFlag.getInt(null);\n      int value=meizuFlags.getInt(lp);\n      if (dark) {\n        value|=bit;\n      }\n else {\n        value&=~bit;\n      }\n      meizuFlags.setInt(lp,value);\n      window.setAttributes(lp);\n      result=true;\n    }\n catch (    Exception e) {\n    }\n  }\n  return result;\n}\n", "nl": "meizu Flyme set status bar light mode"}
{"code": "public static Boolean checkPartyType(Delegator delegator,String partyId,String checkedPartyType){\n  GenericValue party=null;\n  GenericValue partyType=null;\n  GenericValue checkedTypeOfParty=null;\n  try {\n    party=EntityQuery.use(delegator).from(\"Party\").where(\"partyId\",partyId).queryOne();\n    if (UtilValidate.isNotEmpty(party)) {\n      partyType=party.getRelatedOne(\"PartyType\",true);\n      checkedTypeOfParty=EntityQuery.use(delegator).from(\"PartyType\").where(\"partyTypeId\",checkedPartyType).cache().queryOne();\n    }\n else {\n      return false;\n    }\n  }\n catch (  GenericEntityException e) {\n    Debug.logWarning(e,module);\n  }\n  return EntityTypeUtil.isType(partyType,checkedTypeOfParty);\n}\n", "nl": "Check if a related party is of the right party type (PERSON or PARTY_GROUP)"}
{"code": "public Builder cloneFrom(DisplayImageOptions options){\n  imageResOnLoading=options.imageResOnLoading;\n  imageResForEmptyUri=options.imageResForEmptyUri;\n  imageResOnFail=options.imageResOnFail;\n  imageOnLoading=options.imageOnLoading;\n  imageForEmptyUri=options.imageForEmptyUri;\n  imageOnFail=options.imageOnFail;\n  resetViewBeforeLoading=options.resetViewBeforeLoading;\n  cacheInMemory=options.cacheInMemory;\n  cacheOnDisc=options.cacheOnDisc;\n  imageScaleType=options.imageScaleType;\n  decodingOptions=options.decodingOptions;\n  delayBeforeLoading=options.delayBeforeLoading;\n  considerExifParams=options.considerExifParams;\n  extraForDownloader=options.extraForDownloader;\n  preProcessor=options.preProcessor;\n  postProcessor=options.postProcessor;\n  displayer=options.displayer;\n  handler=options.handler;\n  isSyncLoading=options.isSyncLoading;\n  return this;\n}\n", "nl": "Sets all options equal to incoming options"}
{"code": "private void siftDown(final Item item){\n  while (true) {\n    Item j=null;\n    Item right=getRight(item);\n    if (right != null && right.position.compareTo(item.position) < 0) {\n      Item left=getLeft(item);\n      if (left.position.compareTo(right.position) < 0) {\n        j=left;\n      }\n else {\n        j=right;\n      }\n    }\n else {\n      Item left=getLeft(item);\n      if (left != null && left.position.compareTo(item.position) < 0) {\n        j=left;\n      }\n    }\n    if (j != null) {\n      swap(item,j);\n    }\n else {\n      break;\n    }\n  }\n}\n", "nl": "Push the item down towards the bottom of the tree (highest reading position)"}
{"code": "public static CommandTagCacheObject createTestCommandTag(){\n  CommandTagCacheObject commandTag=new CommandTagCacheObject(Long.valueOf(2000),\"Test command tag\",\"Test command tag desc\",\"Float\",DataTagConstants.MODE_OPERATIONAL);\n  commandTag.setEquipmentId(Long.valueOf(100));\n  commandTag.setMaximum(Float.valueOf(5));\n  commandTag.setMinimum(Float.valueOf(1));\n  RbacAuthorizationDetails details=new RbacAuthorizationDetails();\n  details.setRbacClass(\"class\");\n  details.setRbacDevice(\"device\");\n  details.setRbacProperty(\"property\");\n  commandTag.setAuthorizationDetails(details);\n  commandTag.setClientTimeout(10000);\n  try {\n    commandTag.setHardwareAddress(new OPCHardwareAddressImpl(\"test\"));\n  }\n catch (  ConfigurationException e) {\n    e.printStackTrace();\n  }\n  commandTag.setSourceTimeout(10000);\n  commandTag.setSourceRetries(4);\n  commandTag.setExecTimeout(10000);\n  commandTag.setProcessId(Long.valueOf(90));\n  CommandExecutionDetails<Long> commandExecutionDetails=new CommandExecutionDetails<Long>();\n  commandExecutionDetails.setExecutionStartTime(new Timestamp(System.currentTimeMillis() - 1000));\n  commandExecutionDetails.setExecutionEndTime(new Timestamp(System.currentTimeMillis()));\n  commandExecutionDetails.setValue(10L);\n  commandTag.setCommandExecutionDetails(commandExecutionDetails);\n  return commandTag;\n}\n", "nl": "Creates a test CommandTag"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"show webpage taxon=\");\n  String taxon=np.getWordRespectCase();\n  np.matchIgnoreCase(\";\");\n  AttributesWindow viewer=(AttributesWindow)getViewer();\n  if (viewer != null) {\n    boolean ok=false;\n    int taxId;\n    if (Basic.isInteger(taxon))     taxId=Integer.parseInt(taxon);\n else     taxId=TaxonomyData.getName2IdMap().get(taxon);\n    if (taxId > 0) {\n      try {\n        final URL url=new URL(\"http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?mode=Info&id=\" + taxId);\n        Basic.openWebPage(url);\n        ok=true;\n      }\n catch (      Exception e1) {\n        Basic.caught(e1);\n      }\n    }\n    if (!ok)     NotificationsInSwing.showError(viewer.getFrame(),\"Failed to open NCBI website for taxon: \" + taxon);\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private void saveCrashToLocal(Throwable ex){\n  LogUtil.d(\"saveCrashToLocal\");\n  if (config.isSaveToLocal()) {\n    String localFolderPath=config.getLocalFolderPath();\n    if (null != localFolderPath && localFolderPath.length() > 2) {\n      File file=new File(localFolderPath);\n      file.mkdirs();\n      if (file.exists() && file.isDirectory()) {\n        AECHFileWriter.getInstance(mContext).writeEx2File(ex,localFolderPath);\n      }\n else {\n        AECHFileWriter.getInstance(mContext).writeEx2File(ex);\n      }\n    }\n else {\n      AECHFileWriter.getInstance(mContext).writeEx2File(ex);\n    }\n  }\n}\n", "nl": "save crash to local"}
{"code": "public PathController(JList l,JLabel label,DefaultListModel model,JButton add,JFileChooser chooser,JButton remove,JButton up,JButton down,ListDataListener lstnr){\n  this.l=l;\n  this.label=label;\n  this.model=model;\n  this.add=add;\n  this.remove=remove;\n  this.up=up;\n  this.down=down;\n  this.chooser=chooser;\n  this.lstnr=lstnr;\n  l.setModel(model);\n  if (model != null) {\n    model.addListDataListener(this);\n  }\n  add.setActionCommand(\"add\");\n  remove.setActionCommand(\"remove\");\n  up.setActionCommand(\"up\");\n  down.setActionCommand(\"down\");\n  add.addActionListener(this);\n  remove.addActionListener(this);\n  up.addActionListener(this);\n  down.addActionListener(this);\n  l.addListSelectionListener(this);\n  remove.setEnabled(false);\n  up.setEnabled(false);\n  down.setEnabled(false);\n}\n", "nl": "Creates a new instance of PathController"}
{"code": "public List<String> updateDeletionStatus(List<String> loadIds,LoadMetadataDetails[] listOfLoadFolderDetailsArray,List<String> invalidLoadIds){\n  for (  String loadId : loadIds) {\n    boolean loadFound=false;\n    for (    LoadMetadataDetails loadMetadata : listOfLoadFolderDetailsArray) {\n      if (loadId.equalsIgnoreCase(loadMetadata.getLoadName())) {\n        if (CarbonCommonConstants.SEGMENT_COMPACTED.equalsIgnoreCase(loadMetadata.getLoadStatus())) {\n          LOG.error(\"Cannot delete the Segment which is compacted. Segment is \" + loadId);\n          invalidLoadIds.add(loadId);\n          return invalidLoadIds;\n        }\n        if (!CarbonCommonConstants.MARKED_FOR_DELETE.equals(loadMetadata.getLoadStatus())) {\n          loadFound=true;\n          loadMetadata.setLoadStatus(CarbonCommonConstants.MARKED_FOR_DELETE);\n          loadMetadata.setModificationOrdeletionTimesStamp(readCurrentTime());\n          LOG.info(\"Segment ID \" + loadId + \" Marked for Delete\");\n        }\n        break;\n      }\n    }\n    if (!loadFound) {\n      LOG.audit(\"Delete segment by ID is failed. No matching segment id found :\" + loadId);\n      invalidLoadIds.add(loadId);\n      return invalidLoadIds;\n    }\n  }\n  return invalidLoadIds;\n}\n", "nl": "updates deletion status details for each load and returns invalidLoadIds"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  ChartViewer viewer=(ChartViewer)getViewer();\n  ChartColorManager chartColors=viewer.getChartColorManager();\n  np.matchIgnoreCase(\"set color=\");\n  Color color=np.getColor();\n  String series=null;\n  if (np.peekMatchIgnoreCase(\"series\")) {\n    np.matchIgnoreCase(\"series=\");\n    series=np.getLabelRespectCase();\n  }\n  String className=null;\n  if (np.peekMatchIgnoreCase(\"class\")) {\n    np.matchIgnoreCase(\"class=\");\n    className=np.getLabelRespectCase();\n  }\n  np.matchIgnoreCase(\";\");\n  if (series != null)   chartColors.setSampleColor(series,color);\n  if (className != null)   chartColors.setClassColor(className,color);\n}\n", "nl": "parses the given command and executes it"}
{"code": "private int computeOrphan2AncestorMappingRec(Node v,Map<Integer,Integer> orphan2AncestorMapping,Set<Integer> orphans) throws CanceledException {\n  progressListener.incrementProgress();\n  int taxId=(Integer)v.getInfo();\n  if (taxId < 0)   return 0;\n  int below=0;\n  Set<Integer> orphansBelow=new HashSet<>();\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    Node w=e.getTarget();\n    below+=computeOrphan2AncestorMappingRec(w,orphan2AncestorMapping,orphansBelow);\n  }\n  Integer count=taxId2count.get(taxId);\n  if (count == null)   count=0;\n  if (below + count >= minSupport) {\n    for (    Integer id : orphansBelow) {\n      orphan2AncestorMapping.put(id,taxId);\n    }\n  }\n else {\n    if (count > 0) {\n      orphansBelow.add(taxId);\n    }\n    orphans.addAll(orphansBelow);\n  }\n  return below + count;\n}\n", "nl": "recursively move all reads that land on taxa with too little support to higher level nodes"}
{"code": "public static double[] interpolateNonZeroValues(double[] contour){\n  for (int i=0; i < contour.length; i++) {\n    if (contour[i] == 0) {\n      int index=findNextIndexNonZero(contour,i);\n      if (index == -1) {\n        for (int j=(i == 0 ? 1 : i); j < contour.length; j++) {\n          contour[j]=contour[j - 1];\n        }\n        break;\n      }\n else {\n        for (int j=i; j < index; j++) {\n          if (i == 0) {\n            contour[j]=contour[index];\n          }\n else {\n            contour[j]=contour[j - 1] + ((contour[index] - contour[i - 1]) / (index - i));\n          }\n        }\n        i=index - 1;\n      }\n    }\n  }\n  return contour;\n}\n", "nl": "To interpolate Zero values with respect to NonZero values"}
{"code": "public List<LogFile> searchRemoteLogs(String search){\n  List<LogFile> logs=new FastList<LogFile>();\n  if (!isConnected()) {\n    PacketSamurai.getUserInterface().log(\"You have to be connected to use the Remote Log Repository\");\n    return null;\n  }\n  PostMethod post=new PostMethod(_repoLocation + \"/rpc.php\");\n  post.addParameter(\"user\",getUserName());\n  post.addParameter(\"pass\",getPassword());\n  CompoundXmlRequest req=new CompoundXmlRequest();\n  Request listReq=req.createRequest(\"list\");\n  listReq.addPart(new RequestPart(\"matchQuery\",search));\n  post.addParameter(\"req\",req.toXml());\n  try {\n    int response=_httpClient.executeMethod(post);\n    if (response != HttpStatus.SC_OK) {\n    }\n    post.getResponseHeaders();\n    post.getResponseBodyAsStream();\n  }\n catch (  HttpException e) {\n    e.printStackTrace();\n  }\ncatch (  IOException e) {\n    e.printStackTrace();\n  }\n  return logs;\n}\n", "nl": "We could have made some extensive xml format for those searches, but i'm lazy :p"}
{"code": "public void loadAndParseRClassSilently(){\n  final String rClassName=getRClassName(myModule);\n  try {\n    if (rClassName == null) {\n      LOG.info(String.format(\"loadAndParseRClass: failed to find manifest package for project %1$s\",myModule.getProject().getName()));\n      return;\n    }\n    myLogger.setResourceClass(rClassName);\n    loadAndParseRClass(rClassName);\n  }\n catch (  ClassNotFoundException e) {\n    myLogger.setMissingResourceClass(true);\n  }\ncatch (  NoClassDefFoundError e) {\n    myLogger.setMissingResourceClass(true);\n  }\ncatch (  InconvertibleClassError e) {\n    assert rClassName != null;\n    myLogger.addIncorrectFormatClass(rClassName,e);\n  }\n}\n", "nl": "Load and parse the R class such that resource references in the layout rendering can refer to local resources properly"}
{"code": "public static SparseMatrix loadSparseMatrix(File file) throws IOException, IllegalFormatException {\n  String str;\n  TextFileReader reader=new TextFileReader(file);\n  str=reader.readLine();\n  String[] parts=str.split(\"\\\\s+\");\n  if (parts.length != 2)   throw new IllegalFormatException();\n  int rows=Integer.parseInt(parts[0]);\n  int cols=Integer.parseInt(parts[1]);\n  SparseMatrix matrix=new SparseMatrix(rows,cols);\n  while ((str=reader.readLine()) != null) {\n    parts=str.split(\"\\\\s+\");\n    if (parts.length != 3)     throw new IllegalFormatException();\n    int row=Integer.parseInt(parts[0]);\n    int col=Integer.parseInt(parts[1]);\n    double value=Double.parseDouble(parts[2]);\n    matrix.add(row,col,value);\n  }\n  reader.close();\n  return matrix;\n}\n", "nl": "The first line of the input file should be \"rows cols\", and the following line should be \"rowIndex colIndex value\""}
{"code": "public static boolean isUrlUsable(String url){\n  if (AppUtils.isEmpty(url)) {\n    return false;\n  }\n  URL urlTemp=null;\n  HttpURLConnection connt=null;\n  try {\n    urlTemp=new URL(url);\n    connt=(HttpURLConnection)urlTemp.openConnection();\n    connt.setRequestMethod(\"HEAD\");\n    int returnCode=connt.getResponseCode();\n    if (returnCode == HttpURLConnection.HTTP_OK) {\n      return true;\n    }\n  }\n catch (  Exception e) {\n    return false;\n  }\n finally {\n    connt.disconnect();\n  }\n  return false;\n}\n", "nl": "url is usable"}
{"code": "public static double[] genPulseFromFourierMag(double[] mag,double f0){\n  int numHarm=mag.length;\n  int currentF0=(int)Math.round(f0);\n  int T;\n  if (currentF0 < 512)   T=512;\n else   T=1024;\n  int T2=2 * T;\n  double[] pulse=new double[T];\n  double[] real=new double[T2];\n  double[] imag=new double[T2];\n  real[0]=real[T]=0.0;\n  for (int i=1; i <= numHarm; i++) {\n    real[i]=real[T - i]=real[T + i]=real[T2 - i]=mag[i - 1];\n    imag[i]=imag[T - i]=imag[T + i]=imag[T2 - i]=0.0;\n  }\n  for (int i=(numHarm + 1); i < (T - numHarm); i++) {\n    real[i]=real[T - i]=real[T + i]=real[T2 - i]=1.0;\n    imag[i]=imag[T - i]=imag[T + i]=imag[T2 - i]=0.0;\n  }\n  FFT.transform(real,imag,true);\n  double sqrt_f0=Math.sqrt(currentF0);\n  for (int i=0; i < T; i++)   pulse[i]=real[(i - numHarm) % T] * sqrt_f0;\n  return pulse;\n}\n", "nl": "Generate one pitch period from Fourier magnitudes"}
{"code": "private String md5(String str){\n  if (str == null) {\n    return null;\n  }\n  MessageDigest messageDigest=null;\n  try {\n    messageDigest=MessageDigest.getInstance(QuickPayConf.signType);\n    messageDigest.reset();\n    messageDigest.update(str.getBytes(QuickPayConf.charset));\n  }\n catch (  NoSuchAlgorithmException e) {\n    return str;\n  }\ncatch (  UnsupportedEncodingException e) {\n    return str;\n  }\n  byte[] byteArray=messageDigest.digest();\n  StringBuffer md5StrBuff=new StringBuffer();\n  for (int i=0; i < byteArray.length; i++) {\n    if (Integer.toHexString(0xFF & byteArray[i]).length() == 1)     md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i]));\n else     md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n  }\n  return md5StrBuff.toString();\n}\n", "nl": "get the md5 hash of a string"}
{"code": "public static String determineOriginalFile(Context context,Uri uri) throws IllegalArgumentException {\n  String originalFile=null;\n  if (uri != null) {\n    if (uri.getScheme().startsWith(\"content\")) {\n      originalFile=getPathFromUri(context,uri);\n    }\n    if (uri.toString().matches(\"https?://\\\\w+\\\\.googleusercontent\\\\.com/.+\")) {\n      originalFile=uri.toString();\n    }\n    if (uri.getScheme().startsWith(\"file\")) {\n      originalFile=uri.toString().substring(7);\n    }\n    if (isNullOrEmpty(originalFile)) {\n      throw new IllegalArgumentException(\"File path was null\");\n    }\n  }\n else {\n    throw new IllegalArgumentException(\"Image Uri was null!\");\n  }\n  return originalFile;\n}\n", "nl": "Retrieve local file path for an arbitrary Uri"}
{"code": "Client(Socket socket,String name,String clientIpAddress,Date accessTime){\n  this.dAccessTime=accessTime;\n  this.ticTacToc=new ClientGameInformation(Settings.sGameStringStyleTicTacToc);\n  this.catchMe=new ClientGameInformation(Settings.sGameStringStyleCatchMe);\n  this.meteor=new ClientGameInformation(Settings.sGameStringStyleMeteorGame);\n  this.pangPang=new ClientGameInformation(Settings.sGameStringStylePangPang);\n  this.sEnteredRoom=null;\n  this.clientName=name;\n  this.socket=socket;\n  this.nDestoryMeteor=Settings.ZEROINIT;\n  this.clientIpAddress=clientIpAddress;\n  this.queryDataSet=FXCollections.observableArrayList();\n  this.setGameStartSet(false);\n  this.setPlayToken(false);\n  this.setRename(false);\n  this.clientGameTag=Settings.ERRORCODE;\n  this.rnd=new Random();\n  this.nCatchmePlayCount=Settings.nCatchMeMAXClickCount;\n  executorServiceSending=Executors.newSingleThreadExecutor();\n  receive();\n  checkTheTime();\n}\n", "nl": "client's construct"}
{"code": "public void printCenterTable(ScoutWidget[] list){\n  System.out.println(\"----------------- BASE TABLE --------------------\");\n  final int SIZE=10;\n  String padd=new String(new char[SIZE]).replace('\\0',' ');\n  System.out.print(\"  \");\n  for (int i=0; i < len; i++) {\n    String dbg=\"[\" + i + \"] \"+ list[i]+ \"-------------------------\";\n    dbg=dbg.substring(0,20);\n    System.out.print(dbg + ((i == len - 1) ? \"\\n\" : \"\"));\n  }\n  String str=\"[\";\n  for (int con=0; con < len * 2; con++) {\n    int opposite=con & 0x1;\n    str+=(con / 2 + ((opposite == 0) ? \"->\" : \"<-\") + \"           \").substring(0,10);\n  }\n  System.out.println(\"  \" + str);\n  for (int i=1; i < len; i++) {\n    for (int dir=0; dir < mBinaryProbability[i].length; dir++) {\n      String tab=\"\";\n      for (int k=0; k < mBinaryProbability[i][dir].length; k++) {\n        tab+=Utils.toS(mBinaryProbability[i][dir][k]) + \"\\n  \";\n      }\n      System.out.println(Direction.toString(dir) + \" \" + tab);\n    }\n  }\n}\n", "nl": "Print the tables involved int centering the widgets"}
{"code": "public Boolean createProduct(EntityManager em,String productId){\n  Boolean status=true;\n  Product product=new Product();\n  try {\n    em.getTransaction().begin();\n    product.setProductId(productId);\n    product.setCategory(\"SMARTPHONE\");\n    product.setQuantityUnit(\"EA\");\n    product.setWeightUnit(\"KG\");\n    product.setPrice(BigDecimal.valueOf(Double.parseDouble(\"500\")));\n    em.persist(product);\n    em.getTransaction().commit();\n  }\n catch (  Exception e) {\n    status=false;\n    logger.error(\"Error occured during creation of product. Detailed info: \" + e);\n  }\n  return status;\n}\n", "nl": "Helper method to create Product"}
{"code": "public static void cleanupTemporaryWorlds(String currentWorld){\n  List<SaveFormatComparator> saveList;\n  ISaveFormat isaveformat=Minecraft.getMinecraft().getSaveLoader();\n  isaveformat.flushCache();\n  try {\n    saveList=isaveformat.getSaveList();\n  }\n catch (  AnvilConverterException e) {\n    e.printStackTrace();\n    return;\n  }\n  String searchString=tempMark + AddressHelper.getMissionControlPort() + \"_\";\n  for (  SaveFormatComparator s : saveList) {\n    String folderName=s.getFileName();\n    if (folderName.startsWith(searchString) && !folderName.equals(currentWorld)) {\n      isaveformat.deleteWorldDirectory(folderName);\n    }\n  }\n}\n", "nl": "Attempts to delete all Minecraft Worlds with \"TEMP_\" in front of the name"}
{"code": "public MainFrame(){\n  initComponents();\n  saveAsItem.setEnabled(itemIsEnable);\n  forceLayoutItem.setEnabled(itemIsEnable);\n  CircleLayoutItem.setEnabled(itemIsEnable);\n  randomLayoutItem.setEnabled(itemIsEnable);\n  gridLayoutItem.setEnabled(itemIsEnable);\n  fruchtermanLayoutItem.setEnabled(itemIsEnable);\n  radialTreeLayout.setEnabled(itemIsEnable);\n  nodeLinkTreeLayoutItem.setEnabled(itemIsEnable);\n  noTextItem.setEnabled(itemIsEnable);\n  textOnlyItem.setEnabled(itemIsEnable);\n  textAndImageItem.setEnabled(itemIsEnable);\n  rectangleItem.setEnabled(itemIsEnable);\n  roundItem.setEnabled(itemIsEnable);\n  roundRectangleItem.setEnabled(itemIsEnable);\n  curveItem.setEnabled(itemIsEnable);\n  straightItem.setEnabled(itemIsEnable);\n  zoomToFitItem.setEnabled(itemIsEnable);\n  switchButton.setEnabled(itemIsEnable);\n  backgroundButton.setEnabled(itemIsEnable);\n}\n", "nl": "Creates new form MainFrame"}
{"code": "boolean importExistingProject(IProgressMonitor monitor) throws TeamException {\n  if (directory == null) {\n    return false;\n  }\n  try {\n    monitor.beginTask(\"Importing\",3 * 1000);\n    createExistingProject(new SubProgressMonitor(monitor,1000));\n    monitor.subTask(\"Refreshing \" + project.getName());\n    RepositoryProvider.map(project,SVNProviderPlugin.getTypeId());\n    monitor.worked(1000);\n    SVNWorkspaceRoot.setSharing(project,new SubProgressMonitor(monitor,1000));\n    return true;\n  }\n catch (  CoreException ce) {\n    throw new SVNException(\"Failed to import External SVN Project\" + ce,ce);\n  }\n finally {\n    monitor.done();\n  }\n}\n", "nl": "Imports a existing SVN Project to the workbench"}
{"code": "@SuppressWarnings(\"deprecation\") public static Range toRange(String colName,FunctionCallDescription functionCallDescription,Object value,short matchCode){\nswitch (matchCode) {\ncase TemplateMatchCodes.IS_NULL:\n    return new IsNullRange(colName,functionCallDescription);\ncase TemplateMatchCodes.NOT_NULL:\n  return new NotNullRange(colName,functionCallDescription);\ncase TemplateMatchCodes.EQ:\nreturn new EqualValueRange(colName,functionCallDescription,value);\ncase TemplateMatchCodes.NE:\nreturn new NotEqualValueRange(colName,functionCallDescription,value);\ncase TemplateMatchCodes.GT:\nreturn new SegmentRange(colName,functionCallDescription,castToComparable(value),false,null,false);\ncase TemplateMatchCodes.GE:\nreturn new SegmentRange(colName,functionCallDescription,castToComparable(value),true,null,false);\ncase TemplateMatchCodes.LE:\nreturn new SegmentRange(colName,functionCallDescription,null,false,castToComparable(value),true);\ncase TemplateMatchCodes.LT:\nreturn new SegmentRange(colName,functionCallDescription,null,false,castToComparable(value),false);\ncase TemplateMatchCodes.REGEX:\nreturn new RegexRange(colName,functionCallDescription,(String)value);\ncase TemplateMatchCodes.NOT_REGEX:\nreturn new NotRegexRange(colName,functionCallDescription,(String)value);\ncase TemplateMatchCodes.IN:\nreturn new InRange(colName,functionCallDescription,(Set)value);\n}\nreturn Range.EMPTY_RANGE;\n}\n", "nl": "Converts single external entry expression to a range"}
{"code": "public Builder cloneFrom(DisplayImageOptions options){\n  imageResOnLoading=options.imageResOnLoading;\n  imageResForEmptyUri=options.imageResForEmptyUri;\n  imageResOnFail=options.imageResOnFail;\n  imageOnLoading=options.imageOnLoading;\n  imageForEmptyUri=options.imageForEmptyUri;\n  imageOnFail=options.imageOnFail;\n  resetViewBeforeLoading=options.resetViewBeforeLoading;\n  cacheInMemory=options.cacheInMemory;\n  cacheOnDisc=options.cacheOnDisc;\n  imageScaleType=options.imageScaleType;\n  decodingOptions=options.decodingOptions;\n  delayBeforeLoading=options.delayBeforeLoading;\n  considerExifParams=options.considerExifParams;\n  extraForDownloader=options.extraForDownloader;\n  preProcessor=options.preProcessor;\n  postProcessor=options.postProcessor;\n  displayer=options.displayer;\n  handler=options.handler;\n  isSyncLoading=options.isSyncLoading;\n  return this;\n}\n", "nl": "Sets all options equal to incoming options"}
{"code": "public Boolean createCustomerReview(EntityManager em,String customerReviewId){\n  Boolean status=true;\n  Date date=null;\n  CustomerReview customerReview=new CustomerReview();\n  Calendar cal=Calendar.getInstance();\n  DateFormat formatter=new SimpleDateFormat(\"yyyymmdd\");\n  try {\n    date=formatter.parse(\"19770707\");\n    cal.setTime(date);\n    em.getTransaction().begin();\n    customerReview.setCustomerReviewId(customerReviewId);\n    customerReview.setComment(\"This product is really great. I like especially the design, speed and performance\");\n    customerReview.setRating(5);\n    customerReview.setFirstName(\"John\");\n    customerReview.setLastName(\"Smith\");\n    customerReview.setProductId(\"HT-2001\");\n    customerReview.setCreationDate(cal);\n    em.persist(customerReview);\n    em.getTransaction().commit();\n  }\n catch (  Exception e) {\n    status=false;\n    logger.error(\"Error occured during creation of customer review. Detailed info: \" + e);\n  }\n  return status;\n}\n", "nl": "Helper method to create CustomerReview"}
{"code": "private static void addHorizontalSmallSpring(Path2D.Float path,int y0,int x1,int x2){\n  int springHeight=2;\n  int springWidth=2;\n  int distance=Math.abs(x2 - x1);\n  int numSprings=(distance / (springHeight));\n  int leftOver=(distance - (numSprings * springHeight)) / 2;\n  path.lineTo(x1,y0);\n  path.lineTo(x1 - leftOver,y0 - leftOver);\n  int count=0;\n  if (x1 > x2) {\n    for (int x=x1 - leftOver; x > x2 + leftOver; x-=springHeight) {\n      int y=(count % 2 == 0) ? y0 - springWidth : y0 + springWidth;\n      path.lineTo(x,y);\n      count++;\n    }\n  }\n else {\n    for (int x=x1 + leftOver; x < x2 - leftOver; x+=springHeight) {\n      int y=(count % 2 == 0) ? y0 - springWidth : y0 + springWidth;\n      path.lineTo(x,y);\n      count++;\n    }\n  }\n  path.lineTo(x2 + leftOver,y0);\n  path.lineTo(x2,y0);\n}\n", "nl": "Add an horizontal spring between (x1, y0) and (x2, y0) to the given path object"}
{"code": "private boolean promptForAddOfIgnored(){\n  IResource[] resources=getSelectedResources();\n  boolean prompt=false;\n  for (int i=0; i < resources.length; i++) {\n    ISVNLocalResource resource=SVNWorkspaceRoot.getSVNResourceFor(resources[i]);\n    try {\n      if (resource.isIgnored()) {\n        prompt=true;\n        break;\n      }\n    }\n catch (    SVNException e) {\n      handle(e);\n    }\n  }\n  if (prompt) {\n    return MessageDialog.openQuestion(getShell(),Policy.bind(\"AddAction.addIgnoredTitle\"),Policy.bind(\"AddAction.addIgnoredQuestion\"));\n  }\n  return true;\n}\n", "nl": "asks the user if he wants to add the resources if some of them are ignored"}
{"code": "public static boolean isFileExist(String filePath,FileType fileType,boolean performFileCheck) throws IOException {\n  filePath=filePath.replace(\"\\\\\",\"/\");\nswitch (fileType) {\ncase HDFS:\ncase VIEWFS:\n    Path path=new Path(filePath);\n  FileSystem fs=path.getFileSystem(configuration);\nif (performFileCheck) {\n  return fs.exists(path) && fs.isFile(path);\n}\n else {\n  return fs.exists(path);\n}\ncase LOCAL:\ndefault :\nFile defaultFile=new File(filePath);\nif (performFileCheck) {\nreturn defaultFile.exists() && defaultFile.isFile();\n}\n else {\nreturn defaultFile.exists();\n}\n}\n}\n", "nl": "This method checks the given path exists or not and also is it file or not if the performFileCheck is true"}
{"code": "public static String loadCartFromShoppingList(HttpServletRequest request,HttpServletResponse response){\n  LocalDispatcher dispatcher=(LocalDispatcher)request.getAttribute(\"dispatcher\");\n  HttpSession session=request.getSession();\n  GenericValue userLogin=(GenericValue)session.getAttribute(\"userLogin\");\n  String shoppingListId=request.getParameter(\"shoppingListId\");\n  ShoppingCart cart=null;\n  try {\n    Map<String,Object> outMap=dispatcher.runSync(\"loadCartFromShoppingList\",UtilMisc.<String,Object>toMap(\"shoppingListId\",shoppingListId,\"userLogin\",userLogin));\n    cart=(ShoppingCart)outMap.get(\"shoppingCart\");\n  }\n catch (  GenericServiceException exc) {\n    request.setAttribute(\"_ERROR_MESSAGE_\",exc.getMessage());\n    return \"error\";\n  }\n  session.setAttribute(\"shoppingCart\",cart);\n  session.setAttribute(\"productStoreId\",cart.getProductStoreId());\n  session.setAttribute(\"orderMode\",cart.getOrderType());\n  session.setAttribute(\"orderPartyId\",cart.getOrderPartyId());\n  return \"success\";\n}\n", "nl": "Initialize order entry from a shopping list"}
{"code": "public static String join(CharSequence delimiter,Iterable tokens){\n  StringBuilder sb=new StringBuilder();\n  boolean firstTime=true;\n  for (  Object token : tokens) {\n    if (token == null || isEmpty(token.toString())) {\n      continue;\n    }\n    if (firstTime) {\n      firstTime=false;\n    }\n else {\n      sb.append(delimiter);\n    }\n    sb.append(token.toString());\n  }\n  if (firstTime) {\n    return null;\n  }\n  return sb.toString();\n}\n", "nl": "Returns a string containing the tokens joined by delimiters, taking in considerations if the token of the iterable is null"}
{"code": "static IBlockState applyFacing(IBlockState state,Facing facing){\n  for (  IProperty prop : (java.util.Set<IProperty>)state.getProperties().keySet()) {\n    if (prop.getName().equals(\"facing\")) {\n      if (prop.getValueClass() == EnumFacing.class) {\n        EnumFacing current=(EnumFacing)state.getValue(prop);\n        if (!current.getName().equalsIgnoreCase(facing.name())) {\n          return state.withProperty(prop,EnumFacing.valueOf(facing.name()));\n        }\n      }\n else       if (prop.getValueClass() == EnumOrientation.class) {\n        EnumOrientation current=(EnumOrientation)state.getValue(prop);\n        if (!current.getName().equalsIgnoreCase(facing.name())) {\n          return state.withProperty(prop,EnumOrientation.valueOf(facing.name()));\n        }\n      }\n    }\n  }\n  return state;\n}\n", "nl": "Change the facing attribute of the Minecraft block"}
{"code": "public void removeTableBlocks(List<String> segmentsToBeRemoved,AbsoluteTableIdentifier absoluteTableIdentifier){\n  Object lockObject=tableLockMap.get(absoluteTableIdentifier);\n  if (null == lockObject) {\n    return;\n  }\n  Map<BlockInfo,AbstractIndex> map=tableBlocksMap.get(absoluteTableIdentifier);\n  if (null == map || map.isEmpty()) {\n    return;\n  }\n  Map<String,List<BlockInfo>> segmentIdToBlockInfoMap=segmentIdToBlockListMap.get(absoluteTableIdentifier);\n  if (null == segmentIdToBlockInfoMap || segmentIdToBlockInfoMap.isEmpty()) {\n    return;\n  }\nsynchronized (lockObject) {\n    for (    String segmentId : segmentsToBeRemoved) {\n      List<BlockInfo> tableBlockInfoList=segmentIdToBlockInfoMap.remove(segmentId);\n      if (null == tableBlockInfoList) {\n        continue;\n      }\n      Iterator<BlockInfo> tableBlockInfoIterator=tableBlockInfoList.iterator();\n      while (tableBlockInfoIterator.hasNext()) {\n        BlockInfo info=tableBlockInfoIterator.next();\n        map.remove(info);\n      }\n    }\n  }\n}\n", "nl": "This will be used to remove a particular blocks useful in case of deletion of some of the blocks in case of retention or may be some other scenario"}
{"code": "public static void assertGTest(final double[] expected,long[] observed,double alpha){\n  if (gTest(expected,observed) < alpha) {\n    StringBuilder msgBuffer=new StringBuilder();\n    DecimalFormat df=new DecimalFormat(\"#.##\");\n    msgBuffer.append(\"G test failed\");\n    msgBuffer.append(\" p-value = \");\n    msgBuffer.append(gTest(expected,observed));\n    msgBuffer.append(\". \\n\");\n    msgBuffer.append(\"value\\texpected\\tobserved\\n\");\n    for (int i=0; i < expected.length; i++) {\n      msgBuffer.append(df.format(expected[i]));\n      msgBuffer.append(\"\\t\\t\");\n      msgBuffer.append(observed[i]);\n      msgBuffer.append(\"\\n\");\n    }\n    msgBuffer.append(\"This test can fail randomly due to sampling error with probability \");\n    msgBuffer.append(alpha);\n    msgBuffer.append(\".\");\n    Assert.fail(msgBuffer.toString());\n  }\n}\n", "nl": "Asserts the null hypothesis that the observed counts follow the given distribution implied by expected, using a G-test"}
{"code": "protected void addJob(BundleContext context,Class<? extends Job> clazz,String cronExpression){\n  String jobName=clazz.getName();\n  String jobGroup=FrameworkUtil.getBundle(clazz).getSymbolicName();\n  JobDetail job=new JobDetail(jobName,jobGroup,clazz);\n  job.setDurability(false);\n  job.setVolatility(true);\n  job.setDescription(jobName);\n  try {\n    CronTrigger trigger=new CronTrigger(jobName,jobGroup,cronExpression);\n    if (scheduler == null) {\n      if (schedulerProperties == null) {\n        schedulerProperties=getDefaultSchedulerProperties();\n      }\n      scheduler=new StdSchedulerFactory(schedulerProperties).getScheduler();\n      scheduler.start();\n    }\n    Date date=scheduler.scheduleJob(job,trigger);\n    Logger.info(this,\"Scheduled job \" + jobName + \", next trigger is on \"+ date);\n  }\n catch (  ParseException e) {\n    Logger.error(this,\"Cron expression '\" + cronExpression + \"' has an exception. Throwing IllegalArgumentException\",e);\n    throw new IllegalArgumentException(e);\n  }\ncatch (  SchedulerException e) {\n    Logger.error(this,\"Unable to schedule job \" + jobName,e);\n  }\n}\n", "nl": "Adds a Job, and starts a Scheduler when none was yet started"}
{"code": "public void calculateExpLoss(){\n  long expLost=XPLossEnum.getExpLoss(this.level,this.getExpNeed());\n  int unrecoverable=(int)(expLost * 0.33333333);\n  int recoverable=(int)expLost - unrecoverable;\n  long allExpLost=recoverable + this.expRecoverable;\n  if (this.getExpShown() > unrecoverable) {\n    this.exp=this.exp - unrecoverable;\n  }\n else {\n    this.exp=this.exp - this.getExpShown();\n  }\n  if (this.getExpShown() > recoverable) {\n    this.expRecoverable=allExpLost;\n    this.exp=this.exp - recoverable;\n  }\n else {\n    this.expRecoverable=this.expRecoverable + this.getExpShown();\n    this.exp=this.exp - this.getExpShown();\n  }\n  if (this.expRecoverable > getExpNeed() * 0.25) {\n    this.expRecoverable=Math.round(getExpNeed() * 0.25);\n  }\n  if (this.getPlayer() != null) {\n    PacketSendUtility.sendPacket(getPlayer(),new SM_STATUPDATE_EXP(getExpShown(),getExpRecoverable(),getExpNeed(),this.getCurrentReposteEnergy(),this.getMaxReposteEnergy(),this.getCurrentEventExp()));\n  }\n}\n", "nl": "calculate the lost experience must be called before setexp"}
{"code": "public int[] calculateAspectRatio(int origWidth,int origHeight){\n  int newWidth=this.targetWidth;\n  int newHeight=this.targetHeight;\n  if (newWidth <= 0 && newHeight <= 0) {\n    newWidth=origWidth;\n    newHeight=origHeight;\n  }\n else   if (newWidth > 0 && newHeight <= 0) {\n    newHeight=(newWidth * origHeight) / origWidth;\n  }\n else   if (newWidth <= 0 && newHeight > 0) {\n    newWidth=(newHeight * origWidth) / origHeight;\n  }\n else {\n    double newRatio=newWidth / (double)newHeight;\n    double origRatio=origWidth / (double)origHeight;\n    if (origRatio > newRatio) {\n      newHeight=(newWidth * origHeight) / origWidth;\n    }\n else     if (origRatio < newRatio) {\n      newWidth=(newHeight * origWidth) / origHeight;\n    }\n  }\n  int[] retval=new int[2];\n  retval[0]=newWidth;\n  retval[1]=newHeight;\n  return retval;\n}\n", "nl": "Maintain the aspect ratio so the resulting image does not look smooshed"}
{"code": "public void actionPerformed(ActionEvent ev){\n  File lastOpenFile=ProgramProperties.getFile(MeganProperties.MEGANFILE);\n  MeganAndRMAFileFilter meganAndRMAFileFilter=new MeganAndRMAFileFilter();\n  meganAndRMAFileFilter.setAllowGZipped(true);\n  meganAndRMAFileFilter.setAllowZipped(true);\n  meganAndRMAFileFilter.add(MeganizedDAAFileFilter.getInstance());\n  getDir().notifyLockInput();\n  CompareWindow viewer=(CompareWindow)getParent();\n  Collection<File> files;\n  try {\n    files=ChooseFileDialog.chooseFilesToOpen(viewer,lastOpenFile,meganAndRMAFileFilter,meganAndRMAFileFilter,ev,\"Add MEGAN file\");\n  }\n  finally {\n    getDir().notifyUnlockInput();\n  }\n  if (files != null && files.size() > 0) {\n    StringBuilder buf=new StringBuilder();\n    for (    File file : files) {\n      if (file != null && file.exists() && file.canRead()) {\n        ProgramProperties.put(MeganProperties.MEGANFILE,file.getAbsolutePath());\n        buf.append(\"add file='\").append(file.getPath()).append(\"';\");\n      }\n    }\n    execute(buf.toString());\n  }\n}\n", "nl": "action to be performed"}
{"code": "private void loadList(String listPath,String className) throws IOException {\n  BufferedReader in=new BufferedReader(new InputStreamReader(FileTools.openResourceFileAsStream(listPath.toString()),StandardCharsets.UTF_8));\n  Set<String> items=new HashSet<String>();\n  String line;\n  while ((line=in.readLine()) != null) {\n    line=line.trim();\n    if (line.startsWith(\"#\") || (line.length() == 0)) {\n      continue;\n    }\n    int end=line.indexOf('#');\n    if (-1 != end) {\n      line=line.substring(0,end).trim();\n      if (line.length() == 0) {\n        continue;\n      }\n    }\n    items.add(line);\n    items.add(line.toUpperCase());\n    char firstChar=line.charAt(0);\n    if (Character.isLowerCase(firstChar)) {\n      firstChar=Character.toUpperCase(firstChar);\n      items.add(firstChar + line.substring(1));\n    }\n  }\n  in.close();\n  this.getClassMembersMap().put(className,items);\n}\n", "nl": "Loads the abbreviations list from the given path and stores its items under the given class name"}
{"code": "private static void generateGraph(IDataProcessStatus dataProcessTaskStatus,SchemaInfo info,String tableName,String partitionID,CarbonDataLoadSchema schema,String factStoreLocation,List<LoadMetadataDetails> loadMetadataDetails) throws GraphGeneratorException {\n  DataLoadModel model=new DataLoadModel();\n  model.setCsvLoad(null != dataProcessTaskStatus.getCsvFilePath() || null != dataProcessTaskStatus.getFilesToProcess());\n  model.setSchemaInfo(info);\n  model.setTableName(dataProcessTaskStatus.getTableName());\n  model.setTaskNo(\"1\");\n  model.setBlocksID(dataProcessTaskStatus.getBlocksID());\n  model.setFactTimeStamp(readCurrentTime());\n  model.setEscapeCharacter(dataProcessTaskStatus.getEscapeCharacter());\n  model.setQuoteCharacter(dataProcessTaskStatus.getQuoteCharacter());\n  model.setCommentCharacter(dataProcessTaskStatus.getCommentCharacter());\n  if (null != loadMetadataDetails && !loadMetadataDetails.isEmpty()) {\n    model.setLoadNames(CarbonDataProcessorUtil.getLoadNameFromLoadMetaDataDetails(loadMetadataDetails));\n    model.setModificationOrDeletionTime(CarbonDataProcessorUtil.getModificationOrDeletionTimesFromLoadMetadataDetails(loadMetadataDetails));\n  }\n  boolean hdfsReadMode=dataProcessTaskStatus.getCsvFilePath() != null && dataProcessTaskStatus.getCsvFilePath().startsWith(\"hdfs:\");\n  int allocate=null != dataProcessTaskStatus.getCsvFilePath() ? 1 : dataProcessTaskStatus.getFilesToProcess().size();\n  String outputLocation=CarbonProperties.getInstance().getProperty(\"store_output_location\",\"../carbon-store/system/carbon/etl\");\n  GraphGenerator generator=new GraphGenerator(model,hdfsReadMode,partitionID,factStoreLocation,allocate,schema,\"0\",outputLocation);\n  generator.generateGraph();\n}\n", "nl": "generate graph"}
{"code": "public static boolean writeFile(String filePath,List<String> contentList,boolean append){\n  if (ListUtil.isEmpty(contentList)) {\n    return false;\n  }\n  FileWriter fileWriter=null;\n  try {\n    makeDirs(filePath);\n    fileWriter=new FileWriter(filePath,append);\n    int i=0;\n    for (    String line : contentList) {\n      if (i++ > 0) {\n        fileWriter.write(\"\\r\\n\");\n      }\n      fileWriter.write(line);\n    }\n    return true;\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"IOException occurred. \",e);\n  }\n finally {\n    IOUtil.close(fileWriter);\n  }\n}\n", "nl": "write file"}
{"code": "public static void drawRoundRectText(Graphics2D g,Font font,Color textColor,String text,int x,int y){\n  Graphics2D g2=(Graphics2D)g.create();\n  g2.setFont(font);\n  FontMetrics fm=g2.getFontMetrics();\n  int padding=2;\n  Rectangle2D bounds=fm.getStringBounds(text,g2);\n  double th=bounds.getHeight() + padding * 2;\n  double tw=bounds.getWidth() + padding * 2;\n  int radius=(int)(Math.min(th,tw) / 3);\n  g2.fillRoundRect((int)(x - tw / 2),(int)(y - th / 2),(int)tw,(int)th,radius,radius);\n  g2.setColor(textColor);\n  g2.drawString(text,(int)(x - tw / 2 + padding),(int)(y - th / 2 + fm.getAscent()));\n  if (DEBUG) {\n    g2.setColor(Color.RED);\n    g2.drawLine(x - 50,y,x + 50,y);\n    g2.drawLine(x,y - 50,x,y + 50);\n  }\n  g2.dispose();\n}\n", "nl": "Utility function to draw a circle text centered at coordinates (x, y)"}
{"code": "public void updated(int flags){\n  myNotifyDirty|=flags;\n  myFolderConfigDirty|=flags;\n  myModificationCount++;\n  if (myManager.getStateVersion() != myProjectStateVersion) {\n    myNotifyDirty|=MASK_PROJECT_STATE;\n    myFolderConfigDirty|=MASK_PROJECT_STATE;\n    myDevice=null;\n    myState=null;\n  }\n  if (myBulkEditingCount == 0) {\n    int changed=myNotifyDirty;\n    if (myListeners != null) {\n      for (      ConfigurationListener listener : myListeners) {\n        listener.changed(changed);\n      }\n    }\n    myNotifyDirty=0;\n  }\n}\n", "nl": "Called when one or more attributes of the configuration has changed"}
{"code": "public static List<Writable> rowToWritables(Schema schema,Row row){\n  List<Writable> ret=new ArrayList<>();\n  for (int i=0; i < row.size(); i++) {\nswitch (schema.getType(i)) {\ncase Double:\n      ret.add(new DoubleWritable(row.getDouble(i)));\n    break;\ncase Float:\n  ret.add(new FloatWritable(row.getFloat(i)));\nbreak;\ncase Integer:\nret.add(new IntWritable(row.getInt(i)));\nbreak;\ncase Long:\nret.add(new LongWritable(row.getLong(i)));\nbreak;\ncase String:\nret.add(new Text(row.getString(i)));\nbreak;\ndefault :\nthrow new IllegalStateException(\"Illegal type\");\n}\n}\nreturn ret;\n}\n", "nl": "Convert a given Row to a list of writables, given the specified Schema"}
{"code": "private void forceResize(int width,int height){\n  boolean devEnv=(Boolean)Launch.blackboard.get(\"fml.deobfuscatedEnvironment\");\n  String resizeMethodName=devEnv ? \"resize\" : \"func_71370_a\";\n  Class[] cArgs=new Class[2];\n  cArgs[0]=int.class;\n  cArgs[1]=int.class;\n  Method resize;\n  try {\n    resize=Minecraft.class.getDeclaredMethod(resizeMethodName,cArgs);\n    resize.setAccessible(true);\n    resize.invoke(Minecraft.getMinecraft(),width,height);\n  }\n catch (  NoSuchMethodException e) {\n    e.printStackTrace();\n  }\ncatch (  SecurityException e) {\n    e.printStackTrace();\n  }\ncatch (  IllegalAccessException e) {\n    e.printStackTrace();\n  }\ncatch (  IllegalArgumentException e) {\n    e.printStackTrace();\n  }\ncatch (  InvocationTargetException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Force Minecraft to resize its GUI"}
{"code": "@deprecated protected void handleComputeFields(int julianDay){\n  int[] fields=new int[3];\n  jdToCE(julianDay,getJDEpochOffset(),fields);\n  int year;\n  int era;\n  int year;\n  if (fields[0] <= 0) {\n    int era=0;\n    year=1 - fields[0];\n  }\n else {\n    era=1;\n    year=fields[0];\n  }\n  internalSet(19,fields[0]);\n  internalSet(0,era);\n  internalSet(1,year);\n  internalSet(2,fields[1]);\n  internalSet(5,fields[2]);\n  internalSet(6,30 * fields[1] + fields[2]);\n}\n", "nl": "/*    "}
{"code": "public static boolean MIUISetStatusBarLightMode(Window window,boolean dark){\n  boolean result=false;\n  if (window != null) {\n    Class clazz=window.getClass();\n    try {\n      int darkModeFlag=0;\n      Class layoutParams=Class.forName(\"android.view.MiuiWindowManager$LayoutParams\");\n      Field field=layoutParams.getField(\"EXTRA_FLAG_STATUS_BAR_DARK_MODE\");\n      darkModeFlag=field.getInt(layoutParams);\n      Method extraFlagField=clazz.getMethod(\"setExtraFlags\",int.class,int.class);\n      if (dark) {\n        extraFlagField.invoke(window,darkModeFlag,darkModeFlag);\n      }\n else {\n        extraFlagField.invoke(window,0,darkModeFlag);\n      }\n      result=true;\n    }\n catch (    Exception e) {\n    }\n  }\n  return result;\n}\n", "nl": "xiaomi MIUI set status bar light mode"}
{"code": "public void createFieldsInHosts(){\n  if (!fieldsExistsInHost()) {\n    Logger.info(this,\"********************START CREATE FIELDS FOR TWITTER PLUGIN*********************\");\n    Logger.info(this,\"*The required fields for the Twitter plugin didn't exits in the Host structure*\");\n    Structure hostStructure=StructureFactory.getStructureByVelocityVarName(\"Host\");\n    addFieldToHostStructure(hostStructure,Configuration.HOSTFIELDNAME_TWITTERLINEDIVIDER,Field.FieldType.LINE_DIVIDER,Field.DataType.SECTION_DIVIDER,95);\n    addFieldToHostStructure(hostStructure,Configuration.HOSTFIELDNAME_TWITTERCONSUMERKEY,Field.FieldType.TEXT,Field.DataType.TEXT,96);\n    addFieldToHostStructure(hostStructure,Configuration.HOSTFIELDNAME_TWITTERSECRETCONSUMERKEY,Field.FieldType.TEXT,Field.DataType.TEXT,97);\n    addFieldToHostStructure(hostStructure,Configuration.HOSTFIELDNAME_TWITTERACCESSTOKEN,Field.FieldType.TEXT,Field.DataType.TEXT,98);\n    addFieldToHostStructure(hostStructure,Configuration.HOSTFIELDNAME_TWITTERSECRETACCESSTOKEN,Field.FieldType.TEXT,Field.DataType.TEXT,99);\n    FieldsCache.removeFields(hostStructure);\n    ContentTypeCacheImpl contentTypeCache=new ContentTypeCacheImpl();\n    contentTypeCache.remove(hostStructure);\n    try {\n      StructureFactory.saveStructure(hostStructure);\n    }\n catch (    DotHibernateException e) {\n      throw new RuntimeException(e.toString(),e);\n    }\n    FieldsCache.addFields(hostStructure,hostStructure.getFieldsBySortOrder());\n    Logger.info(this,\"*All the missing fields for the Twitter plugin are added to the Host structure*\");\n    Logger.info(this,\"*********************END CREATE FIELDS FOR TWITTER PLUGIN**********************\");\n  }\n}\n", "nl": "Add all the configuration fields that are required for the Twitter plugin"}
{"code": "public boolean loadBitmap(final String type,final Long resourceId,final ImageView imageView,final String path){\n  final String imageKey=String.valueOf(resourceId);\n  BitmapDrawable bitmap=mCacheManager.getBitmapFromMemCache(imageKey);\n  if (bitmap != null) {\n    imageView.setImageDrawable(bitmap);\n    return true;\n  }\n  if (GalleryLoader.cancelPotentialWork(resourceId,imageView)) {\n    GalleryLoader galleryLoader=new GalleryLoader(mContext,imageView,type,mCacheManager,path);\n    GalleryLoader.AsyncDrawable asyncDrawable=new GalleryLoader.AsyncDrawable(mContext.getResources(),mPlaceHolderBitmap,galleryLoader);\n    imageView.setImageDrawable(asyncDrawable);\n    try {\n      galleryLoader.execute(resourceId);\n    }\n catch (    RejectedExecutionException exception) {\n      exception.printStackTrace();\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Load bitmaps from the cache if it is available in cache otherwise process the bitmap and save it in cache"}
{"code": "private void triggerProblem(BinaryExpression objExpression){\n  PsiElement objLeftOperand=objExpression.getLeftOperand();\n  PsiElement objRightOperand=objExpression.getRightOperand();\n  if (objRightOperand instanceof StringLiteralExpression || objLeftOperand instanceof StringLiteralExpression) {\n    PsiElement objNonStringOperand;\n    String strLiteralValue;\n    if (objRightOperand instanceof StringLiteralExpression) {\n      strLiteralValue=((StringLiteralExpression)objRightOperand).getContents();\n      objNonStringOperand=objLeftOperand;\n    }\n else {\n      strLiteralValue=((StringLiteralExpression)objLeftOperand).getContents();\n      objNonStringOperand=objRightOperand;\n    }\n    objNonStringOperand=ExpressionSemanticUtil.getExpressionTroughParenthesis(objNonStringOperand);\n    if (null != objNonStringOperand && ClassInStringContextStrategy.apply(objNonStringOperand,holder,objExpression,strProblemDescriptionMissingToStringMethod)) {\n      return;\n    }\n    if (strLiteralValue.length() > 0 && !strLiteralValue.matches(\"^[0-9\\\\+\\\\-]+$\")) {\n      holder.registerProblem(objExpression,strProblemDescriptionSafeToReplace,ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n      return;\n    }\n  }\n  holder.registerProblem(objExpression,strProblemDescription,ProblemHighlightType.WEAK_WARNING);\n}\n", "nl": "generates more specific warnings for given expression"}
{"code": "private void assignCoordinatesToNodesRec(Node v,BitSet splitsInPath,NodeSet nodesVisited,boolean useWeights,PhyloTreeView view) throws NotOwnerException {\n  PhyloTree graph=(PhyloTree)view.getGraph();\n  if (!nodesVisited.contains(v)) {\n    nodesVisited.add(v);\n    Iterator it=graph.getAdjacentEdges(v);\n    while (it.hasNext()) {\n      Edge e=(Edge)it.next();\n      int s=graph.getSplit(e);\n      if (!splitsInPath.get(s)) {\n        Node w=graph.getOpposite(v,e);\n        Point2D p=Geometry.translateByAngle(view.getLocation(v),graph.getAngle(e),useWeights ? graph.getWeight(e) : 1);\n        view.setLocation(w,p);\n        splitsInPath.set(s,true);\n        assignCoordinatesToNodesRec(w,splitsInPath,nodesVisited,useWeights,view);\n        splitsInPath.set(s,false);\n      }\n    }\n  }\n}\n", "nl": "recursively assigns coordinates to all nodes"}
{"code": "private boolean isLookupSwitch(polyglot.ast.Switch switchStmt){\n  int lowest=0;\n  int highest=0;\n  int counter=0;\n  Iterator it=switchStmt.elements().iterator();\n  while (it.hasNext()) {\n    Object next=it.next();\n    if (next instanceof polyglot.ast.Case) {\n      polyglot.ast.Case caseStmt=(polyglot.ast.Case)next;\n      if (caseStmt.isDefault())       continue;\n      int caseValue=(int)caseStmt.value();\n      if (caseValue <= lowest || counter == 0) {\n        lowest=caseValue;\n      }\n      if (caseValue >= highest || counter == 0) {\n        highest=caseValue;\n      }\n      counter++;\n    }\n  }\n  if ((counter - 1) == (highest - lowest))   return false;\n  return true;\n}\n", "nl": "Determine if switch should be lookup or table - this doesn't always get the same result as javac  lookup: non-table table: sequential (no gaps)"}
{"code": "public int calculateNumberOfEffects(int dispelLevel){\n  int number=0;\n  for (  Effect effect : abnormalEffectMap.values()) {\n    DispelCategoryType dispelCat=effect.getDispelCategory();\n    SkillTargetSlot tragetSlot=effect.getSkillTemplate().getTargetSlot();\n    if (effect.getDuration() >= 86400000 && !removebleEffect(effect)) {\n      continue;\n    }\n    if (effect.isSanctuaryEffect()) {\n      continue;\n    }\n    if (tragetSlot != SkillTargetSlot.BUFF && (tragetSlot != SkillTargetSlot.DEBUFF && dispelCat != DispelCategoryType.ALL) || effect.getTargetSlotLevel() >= 2) {\n      continue;\n    }\nswitch (dispelCat) {\ncase ALL:\ncase BUFF:\n      if (effect.getReqDispelLevel() <= dispelLevel) {\n        number++;\n      }\n    break;\ndefault :\n  break;\n}\n}\nreturn number;\n}\n", "nl": "Method used to calculate number of effects of given dispelcategory, targetslot and dispelLevel used only in DispelBuffCounterAtk, therefore rest of cases are skipped"}
{"code": "public List<ShoppingCartItem> findAllCartItemsInCategory(String productCategoryId,String groupNumber){\n  if (productCategoryId == null)   return this.items();\n  Delegator delegator=this.getDelegator();\n  List<ShoppingCartItem> itemsToReturn=FastList.newInstance();\n  try {\n    for (    ShoppingCartItem cartItem : cartLines) {\n      if (UtilValidate.isNotEmpty(groupNumber) && !cartItem.isInItemGroup(groupNumber)) {\n        continue;\n      }\n      if (CategoryWorker.isProductInCategory(delegator,cartItem.getProductId(),productCategoryId)) {\n        itemsToReturn.add(cartItem);\n      }\n else {\n      }\n    }\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,\"Error getting cart items that are in a category: \" + e.toString(),module);\n  }\n  return itemsToReturn;\n}\n", "nl": "Get all ShoppingCartItems from the cart object with the given productCategoryId and optional groupNumber to limit it to a specific item group"}
{"code": "public void login(String authCode) throws LoginFailedException, RemoteServerException {\n  HttpUrl url=HttpUrl.parse(OAUTH_TOKEN_ENDPOINT).newBuilder().addQueryParameter(\"code\",authCode).addQueryParameter(\"client_id\",CLIENT_ID).addQueryParameter(\"client_secret\",SECRET).addQueryParameter(\"grant_type\",\"authorization_code\").addQueryParameter(\"scope\",\"openid email https://www.googleapis.com/auth/userinfo.email\").addQueryParameter(\"redirect_uri\",\"urn:ietf:wg:oauth:2.0:oob\").build();\n  RequestBody reqBody=RequestBody.create(null,new byte[0]);\n  Request request=new Request.Builder().url(url).method(\"POST\",reqBody).build();\n  Response response=null;\n  try {\n    response=client.newCall(request).execute();\n  }\n catch (  IOException e) {\n    throw new RemoteServerException(\"Network Request failed to fetch tokenId\",e);\n  }\n  Moshi moshi=new Moshi.Builder().build();\n  GoogleAuthTokenJson googleAuth=null;\n  try {\n    googleAuth=moshi.adapter(GoogleAuthTokenJson.class).fromJson(response.body().string());\n    Log.d(TAG,\"\" + googleAuth.getExpiresIn());\n  }\n catch (  IOException e) {\n    throw new RemoteServerException(\"Failed to unmarshell the Json response to fetch tokenId\",e);\n  }\n  Log.d(TAG,\"Got token: \" + googleAuth.getAccessToken());\n  expiresTimestamp=time.currentTimeMillis() + (googleAuth.getExpiresIn() * 1000 - REFRESH_TOKEN_BUFFER_TIME);\n  tokenId=googleAuth.getIdToken();\n  refreshToken=googleAuth.getRefreshToken();\n  authbuilder=AuthInfo.newBuilder();\n}\n", "nl": "Uses an access code to login and get tokens"}
{"code": "protected SegmentationProfile mergeHeaderWithProfile(SegmentationProfile segmentationProfile,HttpHeaders headers){\n  if (segmentationProfile != null && segmentationProfile.getProfile() != null && headers != null) {\n    for (    String headerKey : headers.getRequestHeaders().keySet()) {\n      if (!segmentationProfile.hasAttribute(headerKey)) {\n        segmentationProfile.addAttribute(headerKey,headers.getRequestHeader(headerKey).get(0));\n      }\n    }\n  }\n else   if ((segmentationProfile == null || segmentationProfile.getProfile() == null) && headers != null) {\n    Map profileMap=new HashMap();\n    segmentationProfile=new SegmentationProfile.Builder(profileMap).build();\n    for (    String headerKey : headers.getRequestHeaders().keySet()) {\n      if (!segmentationProfile.hasAttribute(headerKey)) {\n        segmentationProfile.addAttribute(headerKey,headers.getRequestHeader(headerKey).get(0));\n      }\n    }\n  }\n  return segmentationProfile;\n}\n", "nl": "Adds http header attributes to profile (does not override existing profile attributes) We only use the first attribute if multiple attributes with same key are provided in header"}
{"code": "private boolean removeLegionMember(String charName,boolean kick,String playerName){\n  LegionMemberEx legionMember=getLegionMemberEx(charName);\n  if (legionMember == null) {\n    log.error(\"Char name does not exist in legion member table: \" + charName);\n    return false;\n  }\n  deleteLegionMemberFromDB(legionMember);\n  Player player=world.findPlayer(charName);\n  if (player != null) {\n    PacketSendUtility.broadcastPacket(player,new SM_LEGION_UPDATE_TITLE(player.getObjectId(),0,\"\",2),true);\n  }\n  if (kick) {\n    PacketSendUtility.broadcastPacketToLegion(legionMember.getLegion(),new SM_LEGION_LEAVE_MEMBER(1300247,legionMember.getObjectId(),playerName,legionMember.getName()));\n  }\n else {\n    PacketSendUtility.broadcastPacketToLegion(legionMember.getLegion(),new SM_LEGION_LEAVE_MEMBER(900699,legionMember.getObjectId(),charName));\n  }\n  return true;\n}\n", "nl": "This method will remove a legion member"}
{"code": "private boolean processRowToNextStep() throws KettleException {\n  if (null == this.sortDataRows) {\n    LOGGER.info(\"Record Processed For table: \" + meta.getTabelName());\n    LOGGER.info(\"Number of Records was Zero\");\n    String logMessage=\"Summary: Carbon Sort Key Step: Read: \" + 0 + \": Write: \"+ 0;\n    LOGGER.info(logMessage);\n    putRow(data.getOutputRowMeta(),new Object[0]);\n    setOutputDone();\n    return false;\n  }\n  try {\n    this.sortDataRows.startSorting();\n    this.intermediateFileMerger.finish();\n    LOGGER.info(\"Record Processed For table: \" + meta.getTabelName());\n    String logMessage=\"Summary: Carbon Sort Key Step: Read: \" + readCounter + \": Write: \"+ writeCounter;\n    LOGGER.info(logMessage);\n    putRow(data.getOutputRowMeta(),new Object[0]);\n    setOutputDone();\n    CarbonTimeStatisticsFactory.getLoadStatisticsInstance().recordSortRowsStepTotalTime(meta.getPartitionID(),System.currentTimeMillis());\n    CarbonTimeStatisticsFactory.getLoadStatisticsInstance().recordDictionaryValuesTotalTime(meta.getPartitionID(),System.currentTimeMillis());\n    return false;\n  }\n catch (  CarbonSortKeyAndGroupByException e) {\n    throw new KettleException(e);\n  }\n}\n", "nl": "Below method will be used to process data to next step"}
{"code": "private static Map<String,List<ChartObject>> databaseDataConverter(Map<String,ComplexValue> dbData,int launches,Launch last){\n  DecimalFormat formatter=new DecimalFormat(\"###.##\");\n  Map<String,List<ChartObject>> result=new LinkedHashMap<>();\n  if (dbData.keySet().isEmpty())   return result;\n  for (  Entry<String,ComplexValue> pair : dbData.entrySet()) {\n    ChartObject object=new ChartObject();\n    Map<String,String> values=new HashMap<>();\n    values.put(ALL_RUNS,String.valueOf(pair.getValue().getTotal()));\n    values.put(FAILED,String.valueOf(pair.getValue().getCount()));\n    double value=(double)pair.getValue().getCount() / pair.getValue().getTotal() * 100;\n    values.put(AFFECTED_BY,String.valueOf(formatter.format(value)));\n    values.put(LAST_FAIL_CAPTION,String.valueOf(pair.getValue().getStartTime()));\n    object.setValues(values);\n    result.put(pair.getKey(),Lists.newArrayList(object));\n  }\n  ChartObject lastLaunch=new ChartObject();\n  lastLaunch.setName(last.getName());\n  lastLaunch.setNumber(last.getNumber().toString());\n  lastLaunch.setId(last.getId());\n  result.put(LAST_FOUND_LAUNCH,Lists.newArrayList(lastLaunch));\n  return result;\n}\n", "nl": "Returned data from database converter in UI style charts"}
{"code": "public static final void release(final Summon summon,final UnsummonType unsummonType,final boolean isAttacked){\n  if (summon.getMode() == SummonMode.RELEASE) {\n    return;\n  }\n  summon.getController().cancelCurrentSkill();\n  summon.setMode(SummonMode.RELEASE);\n  final Player master=summon.getMaster();\nswitch (unsummonType) {\ncase COMMAND:\n    PacketSendUtility.sendPacket(master,SM_SYSTEM_MESSAGE.STR_SKILL_SUMMON_UNSUMMON_FOLLOWER(summon.getNameId()));\n  PacketSendUtility.sendPacket(master,new SM_SUMMON_UPDATE(summon));\nbreak;\ncase DISTANCE:\nPacketSendUtility.sendPacket(master,SM_SYSTEM_MESSAGE.STR_SKILL_SUMMON_UNSUMMON_BY_TOO_DISTANCE);\nPacketSendUtility.sendPacket(master,new SM_SUMMON_UPDATE(summon));\nbreak;\ncase LOGOUT:\ncase UNSPECIFIED:\nbreak;\n}\nsummon.getObserveController().notifySummonReleaseObservers();\nsummon.setReleaseTask(ThreadPoolManager.getInstance().schedule(new ReleaseSummonTask(summon,unsummonType,isAttacked),5000));\n}\n", "nl": "Release summon"}
{"code": "public void initialize() throws IOException {\n  CsvParserSettings parserSettings=new CsvParserSettings();\n  parserSettings.getFormat().setDelimiter(csvParserVo.getDelimiter().charAt(0));\n  parserSettings.getFormat().setComment(csvParserVo.getCommentCharacter().charAt(0));\n  parserSettings.setLineSeparatorDetectionEnabled(true);\n  parserSettings.setMaxColumns(getMaxColumnsForParsing(csvParserVo.getNumberOfColumns(),csvParserVo.getMaxColumns()));\n  parserSettings.setNullValue(\"\");\n  parserSettings.setIgnoreLeadingWhitespaces(false);\n  parserSettings.setIgnoreTrailingWhitespaces(false);\n  parserSettings.setSkipEmptyLines(false);\n  parserSettings.getFormat().setQuote(null == csvParserVo.getQuoteCharacter() ? '\\\"' : csvParserVo.getQuoteCharacter().charAt(0));\n  parserSettings.getFormat().setQuoteEscape(null == csvParserVo.getEscapeCharacter() ? '\\\\' : csvParserVo.getEscapeCharacter().charAt(0));\n  blockCounter++;\n  initializeReader();\n  if (csvParserVo.getBlockDetailsList().get(blockCounter).getBlockOffset() == 0) {\n    parserSettings.setHeaderExtractionEnabled(csvParserVo.isHeaderPresent());\n  }\n  parser=new CsvParser(parserSettings);\n  parser.beginParsing(inputStreamReader);\n}\n", "nl": "Below method will be used to initialize the the parser"}
{"code": "public void test(String sql){\n  ParseResult result=new ParseResult();\n  ExecutePlan plan=new ExecutePlan();\n  parser.init(sql,null);\n  parser.parse(result);\n  plan.setExecuteType(ExecuteType.PARTITION);\n  SQLSelectStatement stmt=(SQLSelectStatement)parser.statement;\n  parser.parseMysqlQueary(result,plan,(MySqlSelectQueryBlock)stmt.getSelect().getQuery());\n  StringBuilder out=new StringBuilder();\n  MySqlOutputVisitor outPutVisitor=new MySqlOutputVisitor(out);\n  stmt.accept(outPutVisitor);\n  System.out.println();\n  System.out.println(\"/***********************agg*************************/\");\n  System.out.println(plan.getMergeColumns());\n  System.out.println(\"setHasAllColumnExpr:\" + result.isHasAllColumnExpr());\n  System.out.println(out.toString());\n  PrintUtil.printFildAlisMap(result.getAliaColumns());\n  System.out.println(\"/*********************group by**********************/\");\n  System.out.println(plan.getGroupbyColumns());\n  System.out.println(\"/*********************order by**********************/\");\n  System.out.println(plan.getOrderbyColumns());\n}\n", "nl": "//agg getMergeColumns getAliaColumns //group by setGroupbyColumns"}
{"code": "public void saveGraph(DirectedGraph graph,String destFile) throws IOException {\n  if (graph == null)   throw new NullPointerException(\"Cannot dump null graph\");\n  if (destFile == null)   throw new NullPointerException(\"No destination file\");\n  Log.d(Mary.LOG,\"Dumping directed graph in Mary format to \" + destFile + \" ...\");\n  DataOutputStream out=new DataOutputStream(new BufferedOutputStream(new FileOutputStream(destFile)));\n  MaryHeader hdr=new MaryHeader(MaryHeader.DIRECTED_GRAPH);\n  hdr.writeTo(out);\n  Properties props=graph.getProperties();\n  if (props == null) {\n    out.writeShort(0);\n  }\n else {\n    ByteArrayOutputStream baos=new ByteArrayOutputStream();\n    props.store(baos,null);\n    byte[] propData=baos.toByteArray();\n    out.writeShort(propData.length);\n    out.write(propData);\n  }\n  graph.getFeatureDefinition().writeBinaryTo(out);\n  dumpBinary(graph,out);\n  out.close();\n  Log.d(Mary.LOG,\" ... done\\n\");\n}\n", "nl": "Dump the graph in Mary format"}
{"code": "@Override public void createOrUpdateMetadata(byte[] metadata) throws IOException {\n  checkClosedOrInError(\"createOrUpdateMetadata\");\n  String zkPath=getZKPath();\n  LOG.debug(\"Setting application specific metadata on {}\",zkPath);\n  try {\n    Stat currentStat=writerZKC.get().exists(zkPath,false);\n    if (currentStat == null) {\n      if (metadata.length > 0) {\n        Utils.zkCreateFullPathOptimistic(writerZKC,zkPath,metadata,writerZKC.getDefaultACL(),CreateMode.PERSISTENT);\n      }\n    }\n else {\n      writerZKC.get().setData(zkPath,metadata,currentStat.getVersion());\n    }\n  }\n catch (  InterruptedException ie) {\n    throw new DLInterruptedException(\"Interrupted on creating or updating container metadata\",ie);\n  }\ncatch (  Exception exc) {\n    throw new IOException(\"Exception creating or updating container metadata\",exc);\n  }\n}\n", "nl": "Creates or update the metadata stored at the node associated with the name and URI"}
{"code": "@Override public void onCancel(String callerTag){\n  ComponentsGetter cg=(ComponentsGetter)getActivity();\n  ArrayList<OCFile> list=new ArrayList<>();\n  list.add(mTargetFile);\n  cg.getFileOperationsHelper().removeFiles(list,true);\n  FileDataStorageManager storageManager=cg.getStorageManager();\n  boolean containsFavorite=false;\n  if (mTargetFile.isFolder()) {\n    Vector<OCFile> files=storageManager.getFolderContent(mTargetFile,false);\n    for (    OCFile file : files) {\n      containsFavorite=file.isFavorite() || containsFavorite;\n      if (containsFavorite)       break;\n    }\n  }\n  if (mTargetFile.isFavorite() || containsFavorite) {\n    OCFile folder=null;\n    if (mTargetFile.isFolder()) {\n      folder=mTargetFile;\n    }\n else {\n      folder=storageManager.getFileById(mTargetFile.getParentId());\n    }\n    folder.setEtag(\"\");\n    storageManager.saveFile(folder);\n  }\n}\n", "nl": "Performs the removal of the local copy of the target file"}
{"code": "@SuppressWarnings(\"unchecked\") private void restoreChangedIconsAndTexts(){\n  Bundle restoredBundle=savedInstanceState;\n  if (restoredBundle != null) {\n    if (restoredBundle.containsKey(CHANGED_ICON_AND_TEXT_BUNDLE_KEY)) {\n      changedItemAndIconHashMap=(HashMap<Integer,SpaceItem>)restoredBundle.getSerializable(CHANGED_ICON_AND_TEXT_BUNDLE_KEY);\n      if (changedItemAndIconHashMap != null) {\n        SpaceItem spaceItem;\n        for (int i=0; i < changedItemAndIconHashMap.size(); i++) {\n          spaceItem=changedItemAndIconHashMap.get(i);\n          spaceItems.get(i).setItemIcon(spaceItem.getItemIcon());\n          spaceItems.get(i).setItemName(spaceItem.getItemName());\n        }\n      }\n    }\n    if (restoredBundle.containsKey(CENTRE_BUTTON_ICON_KEY)) {\n      centreButtonIcon=restoredBundle.getInt(CENTRE_BUTTON_ICON_KEY);\n      fab.setImageResource(centreButtonIcon);\n    }\n    if (restoredBundle.containsKey(SPACE_BACKGROUND_COLOR_KEY)) {\n      int backgroundColor=restoredBundle.getInt(SPACE_BACKGROUND_COLOR_KEY);\n      changeSpaceBackgroundColor(backgroundColor);\n    }\n  }\n}\n", "nl": "Restore changed icons,colors and texts from saveInstance"}
{"code": "private void trace(VarNode node,PrintStream ps,HashSet<Node> visitedNodes,int level){\n  if (level < 1)   return;\n  ps.println(\"\\t\" + translateLabel(node));\n  Node[] succs=pag.simpleInvLookup(node);\n  for (int i=0; i < succs.length; i++) {\n    if (visitedNodes.contains(succs[i]))     continue;\n    ps.println(\"\\t\" + translateLabel(succs[i]));\n    ps.println(\"\\t\" + translateEdge(node,succs[i],\"assign\"));\n    visitedNodes.add(succs[i]);\n    trace((VarNode)succs[i],ps,visitedNodes,level - 1);\n  }\n  succs=pag.allocInvLookup(node);\n  for (int i=0; i < succs.length; i++) {\n    if (visitedNodes.contains(succs[i]))     continue;\n    ps.println(\"\\t\" + translateLabel(succs[i]));\n    ps.println(\"\\t\" + translateEdge(node,succs[i],\"new\"));\n  }\n  succs=vmatches.get(node);\n  if (succs != null) {\n    for (int i=0; i < succs.length; i++) {\n      if (visitedNodes.contains(succs[i]))       continue;\n      ps.println(\"\\t\" + translateLabel(succs[i]));\n      ps.println(\"\\t\" + translateEdge(node,succs[i],\"vmatch\"));\n      trace((VarNode)succs[i],ps,visitedNodes,level - 1);\n    }\n  }\n}\n", "nl": "Do a DFS traversal"}
{"code": "public static String camelCaseToUnderlines(String string){\n  if (string.isEmpty()) {\n    return string;\n  }\n  StringBuilder sb=new StringBuilder(2 * string.length());\n  int n=string.length();\n  boolean lastWasUpperCase=Character.isUpperCase(string.charAt(0));\n  for (int i=0; i < n; i++) {\n    char c=string.charAt(i);\n    boolean isUpperCase=Character.isUpperCase(c);\n    if (isUpperCase && !lastWasUpperCase) {\n      sb.append('_');\n    }\n    lastWasUpperCase=isUpperCase;\n    c=Character.toLowerCase(c);\n    sb.append(c);\n  }\n  return sb.toString();\n}\n", "nl": "Converts a CamelCase word into an underlined_word"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  ChartViewer viewer=(ChartViewer)getViewer();\n  np.matchIgnoreCase(\"show what=\");\n  String what=np.getWordMatchesIgnoringCase(\"all none selected\");\n  final LabelsJList list;\n  if (np.peekMatchIgnoreCase(\"target=\")) {\n    np.matchIgnoreCase(\"target=\");\n    list=viewer.getLabelsJList(np.getWordMatchesIgnoringCase(\"series classes attributes\"));\n  }\n else {\n    list=viewer.getActiveLabelsJList();\n  }\n  np.matchIgnoreCase(\";\");\n  if (what.equalsIgnoreCase(\"none\")) {\n    list.disableLabels(list.getAllLabels());\n  }\n else   if (what.equalsIgnoreCase(\"selected\")) {\n    list.enableLabels(list.getSelectedLabels());\n  }\n else {\n    list.enableLabels(list.getAllLabels());\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "@Deprecated private static void makeJSForInlineSubmit(Appendable writer,Map<String,Object> context,ModelForm modelForm,String hiddenFormName) throws IOException {\n  List<ModelFormField> rowSubmitFields=modelForm.getMultiSubmitFields();\n  if (rowSubmitFields != null) {\n    writer.append(\"<script type=\\\"text/javascript\\\">\\r\\n\");\n    writer.append(\"jQuery(document).ready(function() {\\r\\n\");\n    writer.append(\"\\tvar submitForm = $(\\\"form[name=\" + hiddenFormName + \"]\\\");\\r\\n\");\n    writer.append(\"\\tif (submitForm) {\\r\\n\");\n    for (    ModelFormField rowSubmitField : rowSubmitFields) {\n      writer.append(\"\\t\\tvar id = $(\\\"[id^=\" + rowSubmitField.getCurrentContainerId(context) + \"]\\\");\\r\\n\");\n      writer.append(\"\\t\\t$(id).click(function(e) {\\r\\n\");\n      writer.append(\"\\t\\te.preventDefault();\\r\\n\");\n      makeHiddenFieldsForHiddenForm(writer);\n      writer.append(\"\\t\\t\\tsubmitForm.submit();\\r\\n\");\n      writer.append(\"\\t\\t});\\r\\n\");\n    }\n    writer.append(\"\\t} else {\\r\\n\");\n    writer.append(\"\\t\\treturn false;\\r\\n\");\n    writer.append(\"\\t}\\r\\n\");\n    writer.append(\"});\\r\\n\");\n    writer.append(\"</script>\\r\\n\");\n  }\n}\n", "nl": "SCIPIO: Creates JS script to populate the target hidden form with the corresponding fields of the row that triggered the submission (only when use-submit-row is false)"}
{"code": "private ResultPoint correctTopRightRectangular(ResultPoint bottomLeft,ResultPoint bottomRight,ResultPoint topLeft,ResultPoint topRight,int dimensionTop,int dimensionRight){\n  float corr=distance(bottomLeft,bottomRight) / (float)dimensionTop;\n  int norm=distance(topLeft,topRight);\n  float cos=(topRight.getX() - topLeft.getX()) / norm;\n  float sin=(topRight.getY() - topLeft.getY()) / norm;\n  ResultPoint c1=new ResultPoint(topRight.getX() + corr * cos,topRight.getY() + corr * sin);\n  corr=distance(bottomLeft,topLeft) / (float)dimensionRight;\n  norm=distance(bottomRight,topRight);\n  cos=(topRight.getX() - bottomRight.getX()) / norm;\n  sin=(topRight.getY() - bottomRight.getY()) / norm;\n  ResultPoint c2=new ResultPoint(topRight.getX() + corr * cos,topRight.getY() + corr * sin);\n  if (!isValid(c1)) {\n    if (isValid(c2)) {\n      return c2;\n    }\n    return null;\n  }\n  if (!isValid(c2)) {\n    return c1;\n  }\n  int l1=Math.abs(dimensionTop - transitionsBetween(topLeft,c1).getTransitions()) + Math.abs(dimensionRight - transitionsBetween(bottomRight,c1).getTransitions());\n  int l2=Math.abs(dimensionTop - transitionsBetween(topLeft,c2).getTransitions()) + Math.abs(dimensionRight - transitionsBetween(bottomRight,c2).getTransitions());\n  if (l1 <= l2) {\n    return c1;\n  }\n  return c2;\n}\n", "nl": "Calculates the position of the white top right module using the output of the rectangle detector for a rectangular matrix"}
{"code": "public void closeHandler() throws CarbonDataWriterException {\n  if (null != this.dataWriter) {\n    while (blockletProcessingCount.get() > 0) {\n      try {\n        Thread.sleep(50);\n      }\n catch (      InterruptedException e) {\n        throw new CarbonDataWriterException(e.getMessage());\n      }\n    }\n    consumerExecutorService.shutdownNow();\n    processWriteTaskSubmitList(consumerExecutorServiceTaskList);\n    this.dataWriter.writeBlockletInfoToFile();\n    LOGGER.info(\"All blocklets have been finished writing\");\n    this.dataWriter.closeWriter();\n  }\n  this.dataWriter=null;\n  this.keyBlockHolder=null;\n}\n", "nl": "below method will be used to close the handler"}
{"code": "protected void drawHole(Canvas c){\n  if (mChart.isDrawHoleEnabled() && mBitmapCanvas != null) {\n    float radius=mChart.getRadius();\n    float holeRadius=radius * (mChart.getHoleRadius() / 100);\n    MPPointF center=mChart.getCenterCircleBox();\n    if (Color.alpha(mHolePaint.getColor()) > 0) {\n      mBitmapCanvas.drawCircle(center.x,center.y,holeRadius,mHolePaint);\n    }\n    if (Color.alpha(mTransparentCirclePaint.getColor()) > 0 && mChart.getTransparentCircleRadius() > mChart.getHoleRadius()) {\n      int alpha=mTransparentCirclePaint.getAlpha();\n      float secondHoleRadius=radius * (mChart.getTransparentCircleRadius() / 100);\n      mTransparentCirclePaint.setAlpha((int)((float)alpha * mAnimator.getPhaseX() * mAnimator.getPhaseY()));\n      mHoleCirclePath.reset();\n      mHoleCirclePath.addCircle(center.x,center.y,secondHoleRadius,Path.Direction.CW);\n      mHoleCirclePath.addCircle(center.x,center.y,holeRadius,Path.Direction.CCW);\n      mBitmapCanvas.drawPath(mHoleCirclePath,mTransparentCirclePaint);\n      mTransparentCirclePaint.setAlpha(alpha);\n    }\n    MPPointF.recycleInstance(center);\n  }\n}\n", "nl": "draws the hole in the center of the chart and the transparent circle / hole"}
{"code": "public int readString(byte[] tmp,byte[] target) throws IOException {\n  int size=readInt();\n  if (size > 0) {\n    if (size > target.length)     throw new IOException(\"Unreasonable string length: \" + size);\n    return in.read(target,0,size);\n  }\n else {\n    size=-size;\n    if (size > tmp.length)     throw new IOException(\"Unreasonable string length: \" + size);\n    int got=in.read(tmp,0,size);\n    if (got != size)     throw new IOException(\"Bytes read: \" + got + \", expected: \"+ size);\n    try {\n      return compressor.inflateByteArray(size,tmp,target);\n    }\n catch (    DataFormatException e) {\n      throw new IOException(e.getMessage());\n    }\n  }\n}\n", "nl": "reads an archived string"}
{"code": "private CarbonDictionarySortModel[] prepareDictionarySortModels(List<String> distinctValues,Dictionary dictionary,DataType dataType){\n  CarbonDictionarySortModel[] dictionarySortModels=null;\n  int surrogate=1;\n  if (null != dictionary) {\n    DictionaryChunksWrapper dictionaryChunksWrapper=dictionary.getDictionaryChunks();\n    dictionarySortModels=new CarbonDictionarySortModel[dictionaryChunksWrapper.getSize() + distinctValues.size()];\n    while (dictionaryChunksWrapper.hasNext()) {\n      dictionarySortModels[surrogate - 1]=createDictionarySortModel(surrogate,dataType,dictionaryChunksWrapper.next());\n      surrogate++;\n    }\n  }\n else {\n    dictionarySortModels=new CarbonDictionarySortModel[distinctValues.size()];\n  }\n  Iterator<String> distinctValue=distinctValues.iterator();\n  while (distinctValue.hasNext()) {\n    dictionarySortModels[surrogate - 1]=createDictionarySortModel(surrogate,dataType,distinctValue.next().getBytes());\n    surrogate++;\n  }\n  return dictionarySortModels;\n}\n", "nl": "The method returns the array of CarbonDictionarySortModel"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  final ParametersDialog parametersDialog=(ParametersDialog)getParent();\n  final Director dir=(Director)getDir();\n  parametersDialog.setVisible(false);\n  if (dir.getDocument().getMeganFile().hasDataConnector()) {\n    ReadMagnitudeParser.setEnabled(parametersDialog.isUseMagnitudes());\n    int numberOfMatches=0;\n    try {\n      final IConnector connector=dir.getDocument().getMeganFile().getDataConnector();\n      numberOfMatches=connector.getNumberOfMatches();\n    }\n catch (    IOException e) {\n      Basic.caught(e);\n    }\n    if (numberOfMatches > 10000000) {\n      int result=JOptionPane.showConfirmDialog(MainViewer.getLastActiveFrame(),String.format(\"This sample contains %,d matches, processing may take a long time, proceed?\",numberOfMatches),\"Very large dataset, proceed?\",JOptionPane.YES_NO_OPTION);\n      if (result != JOptionPane.YES_OPTION)       return;\n    }\n  }\n  parametersDialog.setCanceled(false);\n}\n", "nl": "action to be performed"}
{"code": "@RequestMapping(method=RequestMethod.POST,produces=\"application/json\") public JsonNode handleFileUpload(HttpServletRequest request,@RequestParam(\"file\") MultipartFile file){\n  if (!file.isEmpty()) {\n    try {\n      ServerConfig serverConfig=retrieveServerConfig();\n      String fileName=file.getOriginalFilename();\n      if (fileName != null && (fileName.endsWith(\".bpmn\") || fileName.endsWith(\".bpmn20.xml\") || fileName.endsWith(\".zip\")|| fileName.endsWith(\".bar\"))) {\n        return clientService.uploadDeployment(serverConfig,fileName,file.getInputStream());\n      }\n else {\n        throw new BadRequestException(\"Invalid file name\");\n      }\n    }\n catch (    IOException e) {\n      throw new InternalServerErrorException(\"Could not deploy file: \" + e.getMessage());\n    }\n  }\n else {\n    throw new BadRequestException(\"No file found in POST body\");\n  }\n}\n", "nl": "POST /rest/activiti/deployments: upload a deployment"}
{"code": "@Override public void delete() throws IOException {\n  BKLogWriteHandler ledgerHandler=createWriteHandler(true);\n  try {\n    ledgerHandler.deleteLog();\n  }\n  finally {\n    Utils.closeQuietly(ledgerHandler);\n  }\n  String zkPath=getZKPath();\n  if (zkPath.toLowerCase().contains(\"distributedlog\")) {\n    try {\n      LOG.info(\"Delete the path associated with the log {}, ZK Path {}\",name,zkPath);\n      ZKUtil.deleteRecursive(writerZKC.get(),zkPath);\n    }\n catch (    InterruptedException ie) {\n      LOG.error(\"Interrupted while accessing ZK\",ie);\n      throw new DLInterruptedException(\"Error initializing zk\",ie);\n    }\ncatch (    KeeperException ke) {\n      LOG.error(\"Error accessing entry in zookeeper\",ke);\n      throw new IOException(\"Error initializing zk\",ke);\n    }\n  }\n else {\n    LOG.warn(\"Skip deletion of unrecognized ZK Path {}\",zkPath);\n  }\n}\n", "nl": "Delete all the partitions of the specified log"}
{"code": "public static String decodeUnicodeStr(String s){\n  StringBuilder sb=new StringBuilder(s.length());\n  char[] chars=s.toCharArray();\n  for (int i=0; i < chars.length; i++) {\n    char c=chars[i];\n    if (c == '\\\\' && chars[i + 1] == 'u') {\n      char cc=0;\n      for (int j=0; j < 4; j++) {\n        char ch=Character.toLowerCase(chars[i + 2 + j]);\n        if ('0' <= ch && ch <= '9' || 'a' <= ch && ch <= 'f') {\n          cc|=(Character.digit(ch,16) << (3 - j) * 4);\n        }\n else {\n          cc=0;\n          break;\n        }\n      }\n      if (cc > 0) {\n        i+=5;\n        sb.append(cc);\n        continue;\n      }\n    }\n    sb.append(c);\n  }\n  return sb.toString();\n}\n", "nl": "decode Unicode string"}
{"code": "public static double[] arrayResize(double[] source,int targetSize){\n  if (source.length == targetSize) {\n    return source;\n  }\n  int sourceSize=source.length;\n  double fraction=(double)source.length / (double)targetSize;\n  double[] newSignal=new double[targetSize];\n  for (int i=0; i < targetSize; i++) {\n    double posIdx=fraction * i;\n    int nVal=(int)Math.floor(posIdx);\n    double diffVal=posIdx - nVal;\n    if (nVal >= sourceSize - 1) {\n      newSignal[i]=source[sourceSize - 1];\n      continue;\n    }\n    double fVal=(diffVal * source[nVal + 1]) + ((1 - diffVal) * source[nVal]);\n    newSignal[i]=fVal;\n  }\n  return newSignal;\n}\n", "nl": "array resize to target size using linear interpolation"}
{"code": "private void createMessage(MailDetailsBean mDetails) throws MailSenderException {\n  message=new MimeMessage(session);\n  try {\n    message.setFrom(new InternetAddress(mDetails.getSender()));\n    message.setSubject(mDetails.getSubject());\n    message.setText(mDetails.getMessage());\n    for (int i=0; i < mDetails.getToRecipients().size(); i++) {\n      message.addRecipient(Message.RecipientType.TO,new InternetAddress((String)mDetails.getToRecipients().get(i)));\n    }\n    for (int i=0; i < mDetails.getCcRecipients().size(); i++) {\n      message.addRecipient(Message.RecipientType.CC,new InternetAddress((String)mDetails.getCcRecipients().get(i)));\n    }\n    for (int i=0; i < mDetails.getBccRecipients().size(); i++) {\n      message.addRecipient(Message.RecipientType.BCC,new InternetAddress((String)mDetails.getBccRecipients().get(i)));\n    }\n    LOG.debug(\"createMessage() - The email \" + mDetails.getSubject() + \" has being successfully composed \");\n  }\n catch (  AddressException e) {\n    throw new MailSenderException(\"One of the emails adrresses was not correctly formatted \");\n  }\ncatch (  MessagingException e) {\n    throw new MailSenderException(\"An error ocurred while preparing the message to be sent \");\n  }\n}\n", "nl": "Creates the message that would be sent within the email with the information specified by the parameter"}
{"code": "private String placeBracketsAroundInsertionsInReadSequence(boolean dna2ProteinMode,String refSequence,String readSequence){\n  StringBuilder buf=new StringBuilder();\n  int readPos=0;\n  boolean inInsertion=false;\n  for (int i=0; i < refSequence.length() && readPos < readSequence.length(); i++) {\n    final boolean isInsertion=(refSequence.charAt(i) == '-' && readSequence.charAt(readPos) != '-');\n    if (!inInsertion && isInsertion) {\n      buf.append(\"[\");\n      inInsertion=true;\n    }\n    if (inInsertion && !isInsertion) {\n      buf.append(\"]\");\n      inInsertion=false;\n    }\n    if (dna2ProteinMode) {\n      buf.append(readSequence.charAt(readPos++));\n      buf.append(readSequence.charAt(readPos++));\n      buf.append(readSequence.charAt(readPos++));\n    }\n else     buf.append(readSequence.charAt(readPos++));\n  }\n  if (inInsertion) {\n    buf.append(\"]\");\n  }\n  return buf.toString();\n}\n", "nl": "put brackets around all inserts in the read sequence"}
{"code": "public boolean computeEmbedding(PhyloTreeView treeView,PhyloTree tree){\n  treeView.removeAllInternalPoints();\n  if (tree.getNumberOfNodes() == 0)   return true;\n  treeView.removeAllInternalPoints();\n  Node root=tree.getFirstNode();\n  NodeSet leaves=new NodeSet(tree);\n  for (Node v=tree.getFirstNode(); v != null; v=tree.getNextNode(v)) {\n    if (tree.getDegree(v) == 1)     leaves.add(v);\n    if (tree.getDegree(v) > tree.getDegree(root))     root=v;\n  }\n  EdgeDoubleArray angle=new EdgeDoubleArray(tree);\n  Random rand=new Random();\n  rand.setSeed(1);\n  int seen=setAnglesRec(tree,0,root,null,leaves,angle,rand);\n  if (seen != leaves.size())   System.err.println(\"Warning: Number of nodes seen: \" + seen + \" != Number of leaves: \"+ leaves.size());\n  setCoordsRec(treeView,tree,root,null,angle);\n  treeView.trans.setCoordinateRect(treeView.getBBox());\n  treeView.resetViews();\n  treeView.fitGraphToWindow();\n  return true;\n}\n", "nl": "compute an embedding of the graph"}
{"code": "public List<GenericValue> makeAllOrderPaymentInfos(LocalDispatcher dispatcher){\n  Delegator delegator=this.getDelegator();\n  List<GenericValue> allOpPrefs=new LinkedList<GenericValue>();\n  BigDecimal remainingAmount=this.getGrandTotal().subtract(this.getPaymentTotal());\n  remainingAmount=remainingAmount.setScale(2,BigDecimal.ROUND_HALF_UP);\n  if (getBillingAccountId() != null && this.billingAccountAmt.compareTo(BigDecimal.ZERO) <= 0) {\n    BigDecimal billingAccountAvailableAmount=CheckOutHelper.availableAccountBalance(getBillingAccountId(),dispatcher);\n    if (this.billingAccountAmt.compareTo(BigDecimal.ZERO) == 0 && billingAccountAvailableAmount.compareTo(BigDecimal.ZERO) > 0) {\n      this.billingAccountAmt=billingAccountAvailableAmount;\n    }\n    if (remainingAmount.compareTo(getBillingAccountAmount()) < 0) {\n      this.billingAccountAmt=remainingAmount;\n    }\n    if (billingAccountAvailableAmount.compareTo(getBillingAccountAmount()) < 0) {\n      this.billingAccountAmt=billingAccountAvailableAmount;\n    }\n  }\n  for (  CartPaymentInfo inf : paymentInfo) {\n    if (inf.amount == null) {\n      inf.amount=remainingAmount;\n      remainingAmount=BigDecimal.ZERO;\n    }\n    allOpPrefs.addAll(inf.makeOrderPaymentInfos(delegator,this));\n  }\n  return allOpPrefs;\n}\n", "nl": "make a list of all OrderPaymentPreferences and Billing info including all payment methods and types"}
{"code": "public boolean executeImmediately(final String command,CommandManager commandManager){\n  System.err.println(\"Executing: \" + command);\n  try {\n    if (doc.getProgressListener() == null) {\n      ProgressListener progressListener=new ProgressPercentage();\n      doc.setProgressListener(progressListener);\n    }\n    if (commandManager != null)     commandManager.execute(command);\n else     throw new Exception(\"Internal error: commandManager==null\");\n    if (viewer == null || !viewer.isLocked()) {\n      notifyUpdateViewer(Director.ENABLE_STATE);\n      WaitUntilAllViewersAreUptoDate();\n      notifyUnlockInput();\n    }\n    return true;\n  }\n catch (  CanceledException ex) {\n    System.err.println(\"USER CANCELED EXECUTE\");\n    NotificationsInSwing.showInformation(\"USER CANCELED EXECUTE\");\n    return false;\n  }\ncatch (  Exception ex) {\n    NotificationsInSwing.showError(\"Command failed: \" + ex.getMessage());\n    return false;\n  }\n}\n", "nl": "execute a command within the swing thread"}
{"code": "public static void main(String[] args) throws Exception {\n  if (args.length == 0 && System.getProperty(\"user.name\").equals(\"huson\")) {\n    args=new String[]{\"-ref\",\"/Users/huson/data/michael/test/dna/references-aligned.fasta\",\"-rea\",\"/Users/huson/data/michael/test/dna/reads-aligned.fasta\"};\n    args=new String[]{\"-ref\",\"/Users/huson/data/michael/test/references-aligned-sg.fasta\",\"-rea\",\"/Users/huson/data/michael/test/reads-aligned-sg.fasta\",\"-d2p\",\"-f\",\"BlastNText\"};\n    args=new String[]{\"-ref\",\"/Users/huson/data/michael/adam/try-alignments/880_rpoB_sequences_min_1000_AAs.mafft\",\"-rea\",\"/Users/huson/data/michael/adam/try-alignments/use\",\"-d2p\",\"-o\",\"/Users/huson/data/michael/adam/try-alignments/out.blastn\",\"-f\",\"BlastNText\",\"-n\",\"880_rpoB_sequences_min_1000_AAs|kegg|3043\"};\n    args=new String[]{\"-ref\",\"/Users/huson/data/michael/test/references-aligned.fasta\",\"-rea\",\"/Users/huson/data/michael/test/reads-aligned.fasta\",\"-d2p\",\"-f\",\"BlastNText\"};\n    args=new String[]{\"-ref\",\"/Users/huson/data/michael/adam/try-alignments/references-aligned.fasta\",\"-rea\",\"/Users/huson/data/michael/adam/try-alignments/use\",\"-d2p\",\"-o\",\"/Users/huson/data/michael/adam/try-alignments/SRR172902-rpoB.blastn\",\"-f\",\"BlastNText\",\"-n\",\"880_rpoB_sequences_min_1000_AAs|kegg|3043\",\"-r\",\"/Users/huson/data/michael/adam/try-alignments/SRR172902-rpoB.fasta\"};\n    args=new String[]{\"-ref\",\"/Users/huson/data/michael/adam/try-alignments/references-top-aligned.fasta\",\"-rea\",\"/Users/huson/data/michael/adam/try-alignments/use\",\"-d2p\",\"-o\",\"/Users/huson/data/michael/adam/try-alignments/SRR172902-rpoB.blastn\",\"-f\",\"BlastNText\",\"-n\",\"references-top|kegg|3043\",\"-r\",\"/Users/huson/data/michael/adam/try-alignments/SRR172902-rpoB.fasta\"};\n    args=new String[]{\"-ref\",\"/Users/huson/data/michael/adam/try-alignments/one-aligned.fasta\",\"-rea\",\"/Users/huson/data/michael/adam/try-alignments/two-reads-aligned.fasta\",\"-d2p\",\"-o\",\"/Users/huson/data/michael/adam/try-alignments/two.blastn\",\"-f\",\"BlastNText\",\"-n\",\"references-top|kegg|3043\"};\n    args=new String[]{\"-ref\",\"/Users/huson/data/michael/adam/try-alignments/references-82-aligned.fasta\",\"-rea\",\"/Users/huson/data/michael/adam/try-alignments/use82\",\"-d2p\",\"-o\",\"/Users/huson/data/michael/adam/try-alignments/SRR172902-rpoB-82.blastn\",\"-f\",\"BlastNText\",\"-n\",\"references-top|kegg|3043\",\"-r\",\"/Users/huson/data/michael/adam/try-alignments/SRR172902-rpoB.fasta\"};\n  }\n  try {\n    long start=System.currentTimeMillis();\n    (new MergeAlignments()).run(args);\n    System.err.println(\"Time: \" + ((System.currentTimeMillis() - start) / 1000) + \"s\");\n    System.exit(0);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n    System.exit(1);\n  }\n}\n", "nl": "converts the file"}
{"code": "private void writeSourceSinkDomPair(SourceSinkDomPair pair,Document document,Element rootElement){\n  final Element pairElement;\n  final Element sourceSinkElement;\nswitch (pair.getType()) {\ncase SourceDomPair:\n    pairElement=document.createElement(\"sourcedompair\");\n  sourceSinkElement=document.createElement(\"source\");\nbreak;\ncase SinkDomPair:\npairElement=document.createElement(\"sinkdompair\");\nsourceSinkElement=document.createElement(\"sink\");\nbreak;\ndefault :\nthrow new RuntimeException(\"Invalid source/sink domain pair type\");\n}\nrootElement.appendChild(pairElement);\npairElement.appendChild(sourceSinkElement);\nwriteSourceSinkSpec(pair.getSourceOrSink(),document,sourceSinkElement);\nwriteDomainSpec(pair.getDomain(),document,pairElement);\n}\n", "nl": "Writes out a source or sink domain pair"}
{"code": "public static void markText(JTextComponent pane,int start,int end,SimpleMarker marker){\n  try {\n    Highlighter hiliter=pane.getHighlighter();\n    int selStart=pane.getSelectionStart();\n    int selEnd=pane.getSelectionEnd();\n    if (selStart == selEnd || end < selStart || start > selStart) {\n      hiliter.addHighlight(start,end,marker);\n      return;\n    }\n    if (selStart > start && selStart < end) {\n      hiliter.addHighlight(start,selStart,marker);\n    }\n    if (selEnd > start && selEnd < end) {\n      hiliter.addHighlight(selEnd,end,marker);\n    }\n  }\n catch (  BadLocationException ex) {\n    LOG.log(Level.SEVERE,null,ex);\n  }\n}\n", "nl": "add highlights for the given region on the given pane"}
{"code": "private void flushAndRelease(){\n  final int flushResult=LameUtil.flush(mp3Buffer);\n  if (flushResult > 0) {\n    try {\n      mFileOutputStream.write(mp3Buffer,0,flushResult);\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n finally {\n      if (mFileOutputStream != null) {\n        try {\n          mFileOutputStream.close();\n        }\n catch (        IOException e) {\n          e.printStackTrace();\n        }\n      }\n      LameUtil.close();\n    }\n  }\n}\n", "nl": "Flush all data left in lame buffer to file"}
{"code": "public static void sendWarehouseInfo(Player player,boolean sendAccountWh){\n  List<Item> items=player.getStorage(StorageType.REGULAR_WAREHOUSE.getId()).getItems();\n  int whSize=player.getWarehouseSize();\n  int itemsSize=items.size();\n  boolean firstPacket=true;\n  if (itemsSize != 0) {\n    int index=0;\n    while (index + 10 < itemsSize) {\n      PacketSendUtility.sendPacket(player,new SM_WAREHOUSE_INFO(items.subList(index,index + 10),StorageType.REGULAR_WAREHOUSE.getId(),whSize,firstPacket,player));\n      index+=10;\n      firstPacket=false;\n    }\n    PacketSendUtility.sendPacket(player,new SM_WAREHOUSE_INFO(items.subList(index,itemsSize),StorageType.REGULAR_WAREHOUSE.getId(),whSize,firstPacket,player));\n  }\n  PacketSendUtility.sendPacket(player,new SM_WAREHOUSE_INFO(null,StorageType.REGULAR_WAREHOUSE.getId(),whSize,false,player));\n  if (sendAccountWh) {\n    PacketSendUtility.sendPacket(player,new SM_WAREHOUSE_INFO(player.getStorage(StorageType.ACCOUNT_WAREHOUSE.getId()).getItemsWithKinah(),StorageType.ACCOUNT_WAREHOUSE.getId(),0,true,player));\n  }\n  PacketSendUtility.sendPacket(player,new SM_WAREHOUSE_INFO(null,StorageType.ACCOUNT_WAREHOUSE.getId(),0,false,player));\n}\n", "nl": "Sends correctly warehouse packets"}
{"code": "public static List<Target> createTargetsWithPauses(List<Element> segmentsAndBoundaries,String silenceSymbol){\n  List<Target> targets=new ArrayList<Target>();\n  if (segmentsAndBoundaries.size() == 0)   return targets;\n  Element last=segmentsAndBoundaries.get(segmentsAndBoundaries.size() - 1);\n  if (!last.getTagName().equals(MaryXML.BOUNDARY)) {\n    Element finalPause=MaryXML.createElement(last.getOwnerDocument(),MaryXML.BOUNDARY);\n    Element token=(Element)DomUtils.getAncestor(last,MaryXML.TOKEN);\n    Element parent=(Element)token.getParentNode();\n    parent.appendChild(finalPause);\n    segmentsAndBoundaries.add(finalPause);\n  }\n  for (  Element sOrB : segmentsAndBoundaries) {\n    String phone=UnitSelector.getPhoneSymbol(sOrB);\n    Target t=(Target)sOrB.getUserData(\"target\");\n    if (t == null) {\n      t=new Target(phone,sOrB);\n      sOrB.setUserData(\"target\",t,Target.targetFeatureCloner);\n    }\n    targets.add(t);\n  }\n  return targets;\n}\n", "nl": "Create the list of targets from the segments to be synthesized Prepend and append pauses if necessary"}
{"code": "public void loadStreamConf(Optional<DistributedLogConfiguration> streamConfiguration){\n  if (!streamConfiguration.isPresent()) {\n    return;\n  }\n  ArrayList<Object> ignoredSettings=new ArrayList<Object>();\n  Iterator iterator=streamConfiguration.get().getKeys();\n  while (iterator.hasNext()) {\n    Object setting=iterator.next();\n    if (setting instanceof String && streamSettings.contains(setting)) {\n      String settingStr=(String)setting;\n      setProperty(settingStr,streamConfiguration.get().getProperty(settingStr));\n    }\n else {\n      ignoredSettings.add(setting);\n    }\n  }\n  if (LOG.isWarnEnabled() && !ignoredSettings.isEmpty()) {\n    LOG.warn(\"invalid stream configuration override(s): {}\",StringUtils.join(ignoredSettings,\";\"));\n  }\n}\n", "nl": "Load whitelisted stream configuration from another configuration object"}
{"code": "public void readRow() throws CarbonSortKeyAndGroupByException {\n  if (prefetch) {\n    fillDataForPrefetch();\n  }\n else   if (isSortTempFileCompressionEnabled) {\n    if (bufferRowCounter >= bufferSize) {\n      try {\n        new DataFetcher(false).call();\n        bufferRowCounter=0;\n      }\n catch (      Exception e) {\n        LOGGER.error(e);\n        throw new CarbonSortKeyAndGroupByException(tempFile + \" Problem while reading\",e);\n      }\n    }\n    prefetchRecordsProceesed++;\n    returnRow=currentBuffer[bufferRowCounter++];\n  }\n else {\n    Object[] outRow=getRowFromStream();\n    this.returnRow=outRow;\n  }\n}\n", "nl": "This method will be used to read new row from file"}
{"code": "private int klattRule7(Element segment){\n  Element token=getToken(segment);\n  Element syllable=getSyllable(segment);\n  int stress=getStress(syllable);\n  if (stress == 2 || stress == 0) {\n    if (isInOnset(segment)) {\n      if (isLiquid(segment) || isGlide(segment)) {\n        return (getPropertyAsInteger(\"rule7.onset.liquids\"));\n      }\n else {\n        return (getPropertyAsInteger(\"rule7.others\"));\n      }\n    }\n else     if (isInNucleus(segment)) {\n      if (isWordMedial(syllable)) {\n        return (getPropertyAsInteger(\"rule7.nucleus.medial\"));\n      }\n else {\n        return (getPropertyAsInteger(\"rule7.nucleus.others\"));\n      }\n    }\n else {\n      return (getPropertyAsInteger(\"rule7.others\"));\n    }\n  }\n  return 100;\n}\n", "nl": "Klatt Rule 7: Unstressed shortening"}
{"code": "private String makeSAM(String queryName,String refName,float bitScore,float expect,float percentIdentity,int queryStart,int referenceStart,int referenceEnd,String line) throws IOException {\n  final StringBuilder buffer=new StringBuilder();\n  buffer.append(queryName).append(\"\\t\");\n  boolean reverseComplemented=(referenceStart > referenceEnd);\n  if (reverseComplemented) {\n    buffer.append(0x10);\n  }\n else   buffer.append(0);\n  buffer.append(\"\\t\");\n  buffer.append(refName).append(\"\\t\");\n  if (reverseComplemented)   buffer.append(referenceEnd).append(\"\\t\");\n else   buffer.append(referenceStart).append(\"\\t\");\n  buffer.append(\"255\\t\");\n  buffer.append(\"*\\t\");\n  buffer.append(\"*\\t\");\n  buffer.append(\"0\\t\");\n  buffer.append(\"0\\t\");\n  buffer.append(\"*\\t\");\n  buffer.append(\"*\\t\");\n  buffer.append(String.format(\"AS:i:%d\\t\",(int)Math.round(bitScore)));\n  buffer.append(String.format(\"ZE:f:%g\\t\",expect));\n  buffer.append(String.format(\"ZI:i:%d\\t\",(int)Math.round(percentIdentity)));\n  buffer.append(String.format(\"ZS:i:%s\\t\",queryStart));\n  buffer.append(String.format(\"AL:Z:%s\\t\",Basic.replaceSpaces(line,' ')));\n  return buffer.toString();\n}\n", "nl": "make a SAM line"}
{"code": "private void toWagonFormat(IntAndFloatArrayLeafNode node,DataOutputStream out,String extension,PrintWriter pw) throws IOException {\n  StringBuilder sb=new StringBuilder();\n  int data[]=node.getIntData();\n  float floats[]=node.getFloatData();\n  sb.append(\"(((\");\n  for (int i=0; i < data.length; i++) {\n    sb.append(\"(\" + data[i] + \" \"+ floats[i]+ \")\");\n    if (i + 1 != data.length) {\n      sb.append(\" \");\n    }\n  }\n  sb.append(\") 0))\" + extension);\n  if (out != null) {\n    writeStringToOutput(sb.toString(),out);\n  }\n else {\n  }\n  if (pw != null) {\n    pw.println(sb.toString());\n  }\n}\n", "nl": "Writes the Cart to the given DataOut in Wagon Format"}
{"code": "public boolean checkIfScanIsNotPresentForUser(final String userId,final String scanId) throws UnsupportedEncodingException, ParserConfigurationException, IOException, SAXException, DASTProxyException, XPathExpressionException {\n  LOGGER.debug(\"Inside checkIfScanIsNotPresentForUser...1\");\n  boolean retValue=true;\n  try {\n    final XPathFactory factory=XPathFactory.newInstance();\n    final XPath xpath=factory.newXPath();\n    LOGGER.debug(\"Inside checkIfScanIsNotPresentForUser...2\");\n    xpath.setNamespaceContext(_nsContext);\n    Document response=sendRESTRequestToASE(AppScanConstants.APPSCAN_BASE_URL + \"folders/\" + userId+ \"/folderitems\",\"\");\n    LOGGER.debug(\"Inside checkIfScanIsNotPresentForUser...3...response...=\" + response);\n    LOGGER.debug(\"Check if scan exists in the system. \");\n    checkForError(response,null);\n    final XPathExpression expr=xpath.compile(\"//ase:folder-items/ase:content-scan-job[contains(ase:id,'\" + scanId + \"')]/ase:id/text()\");\n    LOGGER.debug(\"Inside checkIfScanIsNotPresentForUser...4....expr=\" + expr);\n    final String id=(String)expr.evaluate(response,XPathConstants.STRING);\n    LOGGER.debug(\"Inside checkIfScanIsNotPresentForUser...5....id=\" + id);\n    if (id != null && !id.isEmpty()) {\n      LOGGER.debug(\"Inside checkIfScanIsNotPresentForUser...6\");\n      retValue=false;\n    }\n  }\n catch (  ConnectException ce) {\n    LOGGER.error(\"Failed in checking if the scan is present for user...userId=\" + userId + \" scanId=\"+ scanId);\n    LOGGER.error(ce);\n  }\n  return retValue;\n}\n", "nl": "Check if the scan is not present in the user folder"}
{"code": "@Override public void addDictionaryChunk(List<byte[]> newDictionaryChunk){\n  if (dictionaryChunks.size() > 0) {\n    List<byte[]> lastDictionaryChunk=dictionaryChunks.get(dictionaryChunks.size() - 1);\n    int dictionaryOneChunkSize=CarbonUtil.getDictionaryChunkSize();\n    int differenceInLastDictionaryAndOneChunkSize=dictionaryOneChunkSize - lastDictionaryChunk.size();\n    if (differenceInLastDictionaryAndOneChunkSize > 0) {\n      if (differenceInLastDictionaryAndOneChunkSize >= newDictionaryChunk.size()) {\n        lastDictionaryChunk.addAll(newDictionaryChunk);\n      }\n else {\n        List<byte[]> subListOfNewDictionaryChunk=newDictionaryChunk.subList(0,differenceInLastDictionaryAndOneChunkSize);\n        lastDictionaryChunk.addAll(subListOfNewDictionaryChunk);\n        List<byte[]> remainingNewDictionaryChunk=newDictionaryChunk.subList(differenceInLastDictionaryAndOneChunkSize,newDictionaryChunk.size());\n        dictionaryChunks.add(remainingNewDictionaryChunk);\n      }\n    }\n else {\n      dictionaryChunks.add(newDictionaryChunk);\n    }\n  }\n else {\n    dictionaryChunks.add(newDictionaryChunk);\n  }\n}\n", "nl": "This method will add a new dictionary chunk to existing list of dictionary chunks"}
{"code": "public void cancelCurrentSkill(){\n  if (getOwner().getCastingSkill() == null) {\n    return;\n  }\n  Creature creature=getOwner();\n  Skill castingSkill=creature.getCastingSkill();\n  castingSkill.cancelCast();\n  creature.removeSkillCoolDown(castingSkill.getSkillTemplate().getCooldownId());\n  creature.setCasting(null);\n  PacketSendUtility.broadcastPacketAndReceive(creature,new SM_SKILL_CANCEL(creature,castingSkill.getSkillTemplate().getSkillId()));\n  if (getOwner().getAi2() instanceof NpcAI2) {\n    NpcAI2 npcAI=(NpcAI2)getOwner().getAi2();\n    npcAI.setSubStateIfNot(AISubState.NONE);\n    npcAI.onGeneralEvent(AIEventType.ATTACK_COMPLETE);\n    if (creature.getSkillNumber() > 0) {\n      creature.setSkillNumber(creature.getSkillNumber() - 1);\n    }\n  }\n}\n", "nl": "Cancel current skill and remove cooldown"}
{"code": "private boolean canCreateLegion(Player activePlayer,String legionName){\n  if (!isValidName(legionName)) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_CREATE_INVALID_GUILD_NAME);\n    return false;\n  }\n else   if (!isFreeName(legionName)) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_CREATE_SAME_GUILD_EXIST);\n    return false;\n  }\n else   if (activePlayer.isLegionMember()) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_CREATE_ALREADY_BELONGS_TO_GUILD);\n    return false;\n  }\n else   if (activePlayer.getInventory().getKinah() < LegionConfig.LEGION_CREATE_REQUIRED_KINAH) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_CREATE_NOT_ENOUGH_MONEY);\n    return false;\n  }\n  return true;\n}\n", "nl": "This method checks all restrictions for legion creation"}
{"code": "@SuppressWarnings(\"unchecked\") @EdmFunctionImport(name=\"CancelSalesOrder\",entitySet=\"SalesOrderHeaders\",returnType=@ReturnType(type=Type.ENTITY,isCollection=true)) public List<SalesOrderHeader> cancelSalesOrder(@EdmFunctionImportParameter(name=\"SalesOrderId\") String salesOrderId) throws ODataException {\n  EntityManagerFactory emf=Utility.getEntityManagerFactory();\n  EntityManager em=emf.createEntityManager();\n  try {\n    Query query=em.createQuery(\"SELECT s FROM SalesOrderHeader s WHERE s.salesOrderId =\" + salesOrderId);\n    try {\n      SalesOrderHeader so=(SalesOrderHeader)query.getSingleResult();\n      em.getTransaction().begin();\n      so.setLifeCycleStatus(\"X\");\n      so.setLifeCycleStatusName(\"Cancelled\");\n      em.persist(so);\n      em.getTransaction().commit();\n      List<SalesOrderHeader> salesOrderList=null;\n      query=em.createQuery(\"SELECT s FROM SalesOrderHeader s WHERE s.salesOrderId ='\" + salesOrderId + \"'\");\n      salesOrderList=query.getResultList();\n      return salesOrderList;\n    }\n catch (    NoResultException e) {\n      throw new ODataApplicationException(\"No Sales Order with Sales Order Id:\" + salesOrderId,Locale.ENGLISH,HttpStatusCodes.BAD_REQUEST);\n    }\n  }\n  finally {\n    em.close();\n  }\n}\n", "nl": "Function Import implementation for cancelling a sales order"}
{"code": "private boolean processRowToNextStep(SortDataRows sortDataRows) throws CarbonDataLoadingException {\n  if (null == sortDataRows) {\n    LOGGER.info(\"Record Processed For table: \" + parameters.getTableName());\n    LOGGER.info(\"Number of Records was Zero\");\n    String logMessage=\"Summary: Carbon Sort Key Step: Read: \" + 0 + \": Write: \"+ 0;\n    LOGGER.info(logMessage);\n    return false;\n  }\n  try {\n    sortDataRows.startSorting();\n    LOGGER.info(\"Record Processed For table: \" + parameters.getTableName());\n    CarbonTimeStatisticsFactory.getLoadStatisticsInstance().recordSortRowsStepTotalTime(parameters.getPartitionID(),System.currentTimeMillis());\n    CarbonTimeStatisticsFactory.getLoadStatisticsInstance().recordDictionaryValuesTotalTime(parameters.getPartitionID(),System.currentTimeMillis());\n    return false;\n  }\n catch (  CarbonSortKeyAndGroupByException e) {\n    throw new CarbonDataLoadingException(e);\n  }\n}\n", "nl": "Below method will be used to process data to next step"}
{"code": "public void load(String treeFile,String mapFile,ProgressListener progress){\n  progress.setCancelable(false);\n  try {\n    progress.setSubtask(\"Loading \" + mapFile);\n    progress.setMaximum(2);\n    progress.setProgress(0);\n    Document.loadVersionInfo(cName + \" tree\",Basic.replaceFileSuffix(treeFile,\".info\"));\n    name2IdMap.loadFromFile(mapFile);\n    progress.setProgress(1);\n    progress.setSubtask(\"Loading \" + treeFile);\n    if (cName.equals(Classification.Taxonomy)) {\n      if (name2IdMap.get(3554) != null && name2IdMap.get(3554).equals(\"Beta\"))       name2IdMap.put(\"Beta <vulgaris>\",3554);\n    }\n    fullTree.loadFromFile(treeFile);\n    progress.setProgress(2);\n  }\n catch (  Exception e) {\n    Basic.caught(e);\n    NotificationsInSwing.showError(MainViewer.getLastActiveFrame(),\"Failed to open files: \" + treeFile + \" and \"+ mapFile+ \": \"+ e.getMessage());\n  }\n finally {\n    progress.setCancelable(true);\n  }\n}\n", "nl": "load the data"}
{"code": "private static void createCollection(HttpSolrClient solrClient){\n  final CollectionAdminRequest.Create createCollectionRequest=new CollectionAdminRequest.Create();\n  createCollectionRequest.setCollectionName(Constants.COLLECTION_NAME);\n  createCollectionRequest.setConfigName(Constants.CONFIGURATION_NAME);\n  logger.info(Messages.getString(\"SetupThread.CREATING_COLLECTION\"));\n  CollectionAdminResponse response=null;\n  try {\n    response=createCollectionRequest.process(solrClient);\n  }\n catch (  SolrServerException e) {\n    logger.error(e.getMessage());\n  }\ncatch (  IOException e) {\n    logger.error(e.getMessage());\n  }\n  if (!response.isSuccess()) {\n    logger.error(Messages.getString(\"SetupThread.CREATING_COLLECTION_FAILED\") + response.getErrorMessages().toString());\n  }\n  logger.info(Messages.getString(\"SetupThread.COLLECTION_CREATED\"));\n}\n", "nl": "Creates a SOLR collection in which documents can later be ingested"}
{"code": "@Override public void addChild(WXComponent child,int index){\n  if (child == null || index < -1) {\n    return;\n  }\n  checkRefreshOrLoading(child);\n  if (child instanceof WXBaseRefresh) {\n    return;\n  }\n  if (mChildren == null) {\n    mChildren=new ArrayList<>();\n  }\n  int count=mChildren.size();\n  index=index >= count ? -1 : index;\n  if (index == -1) {\n    mChildren.add(child);\n  }\n else {\n    mChildren.add(index,child);\n  }\n}\n", "nl": "Intercept refresh view and loading view"}
{"code": "public static java.util.Date toDate(String date,String time){\n  if (date == null || time == null)   return null;\n  String month;\n  String day;\n  String year;\n  String hour;\n  String minute;\n  String second;\n  int dateSlash1=date.indexOf(\"/\");\n  int dateSlash2=date.lastIndexOf(\"/\");\n  if (dateSlash1 <= 0 || dateSlash1 == dateSlash2)   return null;\n  int timeColon1=time.indexOf(\":\");\n  int timeColon2=time.lastIndexOf(\":\");\n  if (timeColon1 <= 0)   return null;\n  month=date.substring(0,dateSlash1);\n  day=date.substring(dateSlash1 + 1,dateSlash2);\n  year=date.substring(dateSlash2 + 1);\n  hour=time.substring(0,timeColon1);\n  if (timeColon1 == timeColon2) {\n    minute=time.substring(timeColon1 + 1);\n    second=\"0\";\n  }\n else {\n    minute=time.substring(timeColon1 + 1,timeColon2);\n    second=time.substring(timeColon2 + 1);\n  }\n  return toDate(month,day,year,hour,minute,second);\n}\n", "nl": "Converts a date String and a time String into a Date"}
{"code": "public static Map<String,Object> findProductById(DispatchContext ctx,Map<String,Object> context){\n  Delegator delegator=ctx.getDelegator();\n  String idToFind=(String)context.get(\"idToFind\");\n  String goodIdentificationTypeId=(String)context.get(\"goodIdentificationTypeId\");\n  String searchProductFirstContext=(String)context.get(\"searchProductFirst\");\n  String searchAllIdContext=(String)context.get(\"searchAllId\");\n  boolean searchProductFirst=UtilValidate.isNotEmpty(searchProductFirstContext) && \"N\".equals(searchProductFirstContext) ? false : true;\n  boolean searchAllId=UtilValidate.isNotEmpty(searchAllIdContext) && \"Y\".equals(searchAllIdContext) ? true : false;\n  GenericValue product=null;\n  List<GenericValue> productsFound=null;\n  try {\n    productsFound=ProductWorker.findProductsById(delegator,idToFind,goodIdentificationTypeId,searchProductFirst,searchAllId);\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,module);\n    return ServiceUtil.returnError(e.getMessage());\n  }\n  if (UtilValidate.isNotEmpty(productsFound)) {\n    product=EntityUtil.getFirst(productsFound);\n    productsFound.remove(0);\n  }\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  result.put(\"product\",product);\n  result.put(\"productsList\",productsFound);\n  return result;\n}\n", "nl": "Finds productId(s) corresponding to a product reference, productId or a GoodIdentification idValue"}
{"code": "private boolean takeScreenShot(Activity activity){\n  Date now=new Date();\n  android.text.format.DateFormat.format(fileFormat,now);\n  View v1=activity.getWindow().getDecorView().getRootView();\n  v1.setDrawingCacheEnabled(true);\n  Bitmap bitmap=Bitmap.createBitmap(v1.getDrawingCache());\n  v1.setDrawingCacheEnabled(false);\n  File imageFile=new File(path,now + \".jpg\");\n  try {\n    FileOutputStream outputStream=new FileOutputStream(imageFile);\n    bitmap.compress(Bitmap.CompressFormat.JPEG,quality,outputStream);\n    outputStream.flush();\n    outputStream.close();\n  }\n catch (  IOException ex) {\n    return false;\n  }\n  return true;\n}\n", "nl": "This method is responsible for taking the screenshot and creating a file"}
{"code": "protected void wrapContent(){\n  mWidget.setMinWidth(100);\n  mWidget.setMinHeight(30);\n  int tw=mWidget.getMinWidth();\n  int th=mWidget.getMinHeight();\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setWidth(tw);\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setHeight(th);\n  }\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getWidth() <= mWidget.getMinWidth()) {\n      mWidget.setHorizontalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getHeight() <= mWidget.getMinHeight()) {\n      mWidget.setVerticalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  mWidget.setBaselineDistance(0);\n}\n", "nl": "Utility method computing the size of the widget if dimensions are set to wrap_content, using the default font"}
{"code": "public static String normalizeColumnValueForItsDataType(String value,CarbonDimension dimension){\n  try {\n    Object parsedValue=null;\nswitch (dimension.getDataType()) {\ncase DECIMAL:\n      return parseStringToBigDecimal(value,dimension);\ncase INT:\ncase LONG:\n    parsedValue=normalizeIntAndLongValues(value,dimension.getDataType());\n  break;\ncase DOUBLE:\nparsedValue=Double.parseDouble(value);\nbreak;\ndefault :\nreturn value;\n}\nif (null != parsedValue) {\nreturn value;\n}\nreturn null;\n}\n catch (Exception e) {\nreturn null;\n}\n}\n", "nl": "This method will parse a given string value corresponding to its data type"}
{"code": "private void checkDouble(double expected,String string,int delta){\n  long expectedBits=Double.doubleToRawLongBits(expected);\n  BytesRef bytes=getBytes(string);\n  final double v;\n  try {\n    v=MathUtil.parseDouble(bytes.bytes,bytes.offset,bytes.length);\n  }\n catch (  Throwable t) {\n    throw new AssertionError(string + \" didn't parse to \" + expected+ \", instead hit \"+ t,t);\n  }\n  try {\n    long actualBits=Double.doubleToRawLongBits(v);\n    long actualDelta=Math.abs(expectedBits - actualBits);\n    if (actualDelta > delta) {\n      throw new AssertionError(\"expected: <\" + expectedBits + \"> but was:<\"+ actualBits+ \">\");\n    }\n  }\n catch (  Throwable t) {\n    throw new AssertionError(string + \" didn't parse to \" + expected+ \", instead: \"+ v,t);\n  }\n}\n", "nl": "Checks double parse"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  final RemoteServiceBrowser remoteServiceBrowser=(RemoteServiceBrowser)getViewer();\n  final ServicePanel servicePanel=remoteServiceBrowser.getServicePanel();\n  if (servicePanel != null) {\n    final Collection<String> selectedFiles=remoteServiceBrowser.getServicePanel().getSelectedFiles();\n    final StringBuilder buf=new StringBuilder();\n    int count=0;\n    Set<String> openFiles=servicePanel.getCurrentlyOpenRemoteFiles();\n    for (    String fileName : selectedFiles) {\n      if (openFiles.contains(fileName)) {\n        buf.append(\"toFront file='\").append(fileName).append(\"';\");\n      }\n else {\n        buf.append(\"open file='\").append(fileName).append(\"' readOnly=true;\");\n        count++;\n      }\n    }\n    if (count > 10) {\n      if (JOptionPane.showConfirmDialog(remoteServiceBrowser.getFrame(),\"Do you really want to open \" + count + \" new files?\",\"Confirm\",JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION)       return;\n    }\n    execute(buf.toString());\n  }\n}\n", "nl": "action to be performed"}
{"code": "public void dumpMaryCART(CART cart,String destFile) throws IOException {\n  if (cart == null)   throw new NullPointerException(\"Cannot dump null CART\");\n  if (destFile == null)   throw new NullPointerException(\"No destination file\");\n  Log.d(Mary.LOG,\"Dumping CART in MaryCART format to \" + destFile + \" ...\");\n  DataOutputStream out=new DataOutputStream(new BufferedOutputStream(new FileOutputStream(destFile)));\n  MaryHeader hdr=new MaryHeader(MaryHeader.CARTS);\n  hdr.writeTo(out);\n  Properties props=cart.getProperties();\n  if (props == null) {\n    out.writeShort(0);\n  }\n else {\n    ByteArrayOutputStream baos=new ByteArrayOutputStream();\n    props.store(baos,null);\n    byte[] propData=baos.toByteArray();\n    out.writeShort(propData.length);\n    out.write(propData);\n  }\n  cart.getFeatureDefinition().writeBinaryTo(out);\n  dumpBinary(cart.getRootNode(),out);\n  out.close();\n  Log.d(Mary.LOG,\" ... done\\n\");\n}\n", "nl": "Dump the CARTs in MaryCART format"}
{"code": "private boolean resizeAndSaveImage(File targetFile,int maxWidth,int maxHeight) throws IOException {\n  boolean saved=false;\n  ImageSize targetImageSize=new ImageSize(maxWidth,maxHeight);\n  DisplayImageOptions specialOptions=new DisplayImageOptions.Builder().cloneFrom(options).imageScaleType(ImageScaleType.IN_SAMPLE_INT).build();\n  ImageDecodingInfo decodingInfo=new ImageDecodingInfo(memoryCacheKey,ImageDownloader.Scheme.FILE.wrap(targetFile.getAbsolutePath()),targetImageSize,ViewScaleType.FIT_INSIDE,getDownloader(),specialOptions);\n  Bitmap bmp=decoder.decode(decodingInfo);\n  if (bmp != null && configuration.processorForDiscCache != null) {\n    log(LOG_PROCESS_IMAGE_BEFORE_CACHE_ON_DISC);\n    bmp=configuration.processorForDiscCache.process(bmp);\n    if (bmp == null) {\n      L.e(ERROR_PROCESSOR_FOR_DISC_CACHE_NULL,memoryCacheKey);\n    }\n  }\n  if (bmp != null) {\n    OutputStream os=new BufferedOutputStream(new FileOutputStream(targetFile),BUFFER_SIZE);\n    try {\n      bmp.compress(configuration.imageCompressFormatForDiscCache,configuration.imageQualityForDiscCache,os);\n    }\n  finally {\n      IoUtils.closeSilently(os);\n    }\n    bmp.recycle();\n  }\n  return true;\n}\n", "nl": "Decodes image file into Bitmap, resize it and save it back"}
{"code": "@SuppressLint(\"NewApi\") public final void makeFullScreenAfterKitKat(boolean enable){\n  try {\n    View decorView=getWindow().getDecorView();\n    if (enable) {\n      int uiOptionsEnable=View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN| View.SYSTEM_UI_FLAG_HIDE_NAVIGATION| View.SYSTEM_UI_FLAG_FULLSCREEN| View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;\n      decorView.setSystemUiVisibility(uiOptionsEnable);\n    }\n else {\n      int uiOptionsDisable=View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN| View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;\n      decorView.setSystemUiVisibility(uiOptionsDisable);\n    }\n  }\n catch (  Exception e) {\n    WindowManager.LayoutParams lp=getWindow().getAttributes();\n    if (enable) {\n      lp.flags|=WindowManager.LayoutParams.FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;\n    }\n else {\n      lp.flags&=(~WindowManager.LayoutParams.FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);\n    }\n    getWindow().setAttributes(lp);\n  }\n}\n", "nl": "If the Android version is higher than KitKat(API>=19) <br> use this call to show & hide"}
{"code": "@Override public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (obj == null) {\n    return false;\n  }\n  if (getClass() != obj.getClass()) {\n    return false;\n  }\n  Diff other=(Diff)obj;\n  if (operation != other.operation) {\n    return false;\n  }\n  if (text == null) {\n    if (other.text != null) {\n      return false;\n    }\n  }\n else   if (!text.equals(other.text)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Is this Diff equivalent to another Diff?"}
{"code": "public int compare(IEntryPacket e1,IEntryPacket e2){\n  if (e1 == null) {\n    if (e2 == null)     return 0;\n    return -1;\n  }\n  if (e2 == null)   return 1;\n  int rc=0;\n  JoinedEntry j1=(JoinedEntry)e1;\n  JoinedEntry j2=(JoinedEntry)e2;\n  for (int i=0; i < groupColumns.size(); i++) {\n    SelectColumn groupCol=groupColumns.get(i);\n    e1=j1.getEntry(groupCol.getColumnTableData().getTableIndex());\n    e2=j2.getEntry(groupCol.getColumnTableData().getTableIndex());\n    Object obj1=(Comparable)groupCol.getFieldValue(e1);\n    Object obj2=(Comparable)groupCol.getFieldValue(e2);\n    if (obj1 == null && obj2 == null)     rc=0;\n else     if (obj1 == null && obj2 != null)     rc=-1;\n else     if (obj1 != null && obj2 == null)     rc=1;\n else     rc=((Comparable)obj1).compareTo(obj2);\n    if (rc != 0)     return rc;\n  }\n  return rc;\n}\n", "nl": "Compare two arrays of values - only the group by columns are compared"}
{"code": "static public String formatMillis(long millis){\n  boolean isMinutes=false;\n  double instTime=millis;\n  String suffix=\"milliseconds\";\n  if (instTime > (60 * 1000)) {\n    suffix=\"minutes\";\n    instTime=instTime / (60 * 1000);\n    isMinutes=true;\n  }\n else   if (instTime > 1000) {\n    suffix=\"seconds\";\n    instTime=instTime / 1000;\n  }\n  if (!isMinutes) {\n    NumberFormat nf=NumberFormat.getInstance();\n    nf.setMaximumFractionDigits(2);\n    return nf.format(instTime) + \" \" + suffix;\n  }\n  int minutes=(int)instTime;\n  double seconds=(instTime - minutes) * 60;\n  NumberFormat nf=NumberFormat.getInstance();\n  nf.setMaximumFractionDigits(2);\n  nf.setMinimumIntegerDigits(2);\n  return minutes + \":\" + nf.format(seconds)+ \" \"+ suffix;\n}\n", "nl": "Format ms interval to min/sec/ms"}
{"code": "public static void writeToBinFile(File dmpFile,File binFile) throws IOException {\n  System.err.println(\"Converting \" + dmpFile.getName() + \" to \"+ binFile.getName()+ \"...\");\n  long totalOut=0;\n  try (final FileInputIterator it=new FileInputIterator(dmpFile,true);OutputWriter outs=new OutputWriter(binFile)){\n    System.err.println(\"Writing file: \" + binFile);\n    outs.writeInt(MAGIC_NUMBER);\n    long lastGi=0;\n    int lineNo=0;\n    while (it.hasNext()) {\n      String aLine=it.next();\n      lineNo++;\n      final int pos=aLine.indexOf('\\t');\n      final String giString=aLine.substring(0,pos);\n      final int dotPos=giString.indexOf('.');\n      final long gi=Long.parseLong(dotPos > 0 ? giString.substring(0,dotPos) : giString);\n      if (gi >= 0) {\n        final int taxId=Integer.parseInt(aLine.substring(pos + 1));\n        if (gi >= 0 && gi <= lastGi)         throw new IOException(\"Error, line: \" + lineNo + \": GIs out of order: \"+ gi+ \" after \"+ lastGi);\n        final int missing=(int)(gi - 1 - lastGi);\n        for (int i=0; i < missing; i++)         outs.writeInt(0);\n        outs.writeInt(taxId);\n        totalOut++;\n        lastGi=gi;\n      }\n    }\n  }\n   System.err.println(\"done (\" + totalOut + \" entries)\");\n}\n", "nl": "converts the named dmp file to a bin file"}
{"code": "protected void init(){\n  InputStream in=null;\n  props=new Properties();\n  try {\n    URI uri=getClass().getClassLoader().getResource(PROPERTY_FILE_NAME).toURI();\n    File file=new File(uri);\n    in=new FileInputStream(file);\n    props.load(in);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  URISyntaxException e) {\n    e.printStackTrace();\n  }\n finally {\n    CarbonUtil.closeStreams(in);\n  }\n}\n", "nl": "this method will read the property file for required details like dbName, tableName, etc"}
{"code": "private void parseSection(){\n  PsiBuilder.Marker marker=builder.mark();\n  if (matches(ProjectViewTokenType.LIST_KEYWORD)) {\n    expect(ProjectViewTokenType.COLON);\n    skipPastNewline();\n    parseListItems();\n    marker.done(ProjectViewElementTypes.LIST_SECTION);\n    return;\n  }\n  if (currentToken() == ProjectViewTokenType.SCALAR_KEYWORD) {\n    ScalarSectionParser parser=ProjectViewKeywords.SCALAR_KEYWORD_MAP.get(builder.getTokenText());\n    if (parser != null) {\n      parseScalarSection(parser);\n      marker.done(ProjectViewElementTypes.SCALAR_SECTION);\n      return;\n    }\n  }\n  if (matches(ProjectViewTokenType.INDENT)) {\n    skipBlockAndError(marker,\"Invalid indentation. Indented lines must be preceded by a list keyword\");\n    return;\n  }\n  if (matches(ProjectViewTokenType.COLON)) {\n    skipBlockAndError(marker,\"Invalid section: lines cannot begin with a colon.\");\n    return;\n  }\n  skipBlockAndError(marker,\"Unrecognized keyword: \" + builder.getTokenText());\n}\n", "nl": "A block is one of: - scalar section - list section"}
{"code": "public void visitPhpAssignmentExpression(AssignmentExpression assignmentExpression){\n  PhpPsiElement variable=assignmentExpression.getVariable();\n  if (null != variable && assignmentExpression.getValue() instanceof BinaryExpression) {\n    BinaryExpression value=(BinaryExpression)assignmentExpression.getValue();\n    PsiElement leftOperand=value.getLeftOperand();\n    PsiElement rightOperand=value.getRightOperand();\n    if (null == leftOperand || null == rightOperand) {\n      return;\n    }\n    IElementType operation=value.getOperationType();\n    if (operation == PhpTokenTypes.opPLUS) {\n      if ((leftOperand.getText().equals(\"1\") && PsiEquivalenceUtil.areElementsEquivalent(rightOperand,variable)) || (rightOperand.getText().equals(\"1\") && PsiEquivalenceUtil.areElementsEquivalent(leftOperand,variable))) {\n        if (!isArrayAccessOrString(assignmentExpression.getVariable())) {\n          String strMessage=strProblemDescriptionIncrement.replace(\"%s%\",variable.getText());\n          holder.registerProblem(assignmentExpression,strMessage,ProblemHighlightType.WEAK_WARNING);\n        }\n      }\n      return;\n    }\n    if (operation == PhpTokenTypes.opMINUS) {\n      if (rightOperand.getText().equals(\"1\") && PsiEquivalenceUtil.areElementsEquivalent(leftOperand,variable) && !isArrayAccessOrString(assignmentExpression.getVariable())) {\n        String strMessage=strProblemDescriptionDecrement.replace(\"%s%\",variable.getText());\n        holder.registerProblem(assignmentExpression,strMessage,ProblemHighlightType.WEAK_WARNING);\n      }\n    }\n  }\n}\n", "nl": "assignments expressions inspection"}
{"code": "public void actionPerformed(ActionEvent ev){\n  Document doc=getDoc();\n  if ((doc.getMeganFile().isRMA2File() || doc.getMeganFile().isRMA3File()) && !doc.getMeganFile().isReadOnly()) {\n    Object object=doc.getSampleAttributeTable().get(doc.getSampleNames().get(0),SampleAttributeTable.DescriptionAttribute);\n    if (object == null)     object=\"\";\n    String description=JOptionPane.showInputDialog(getViewer().getFrame(),\"A short description:\",object);\n    if (description != null) {\n      description=description.replaceAll(\"^ +| +$|( )+\",\"$1\");\n      execute(\"set description='\" + description + \"';\");\n    }\n  }\n else {\n    StringBuilder buf=new StringBuilder();\n    for (    String name : doc.getSampleNames()) {\n      Object object=doc.getSampleAttributeTable().get(name,SampleAttributeTable.DescriptionAttribute);\n      if (object != null) {\n        buf.append(name).append(\": \").append(object).append(\"\\n\");\n      }\n    }\n    if (buf.length() > 0) {\n      NotificationsInSwing.showInformation(getViewer().getFrame(),\"Description:\\n\" + buf.toString());\n    }\n  }\n}\n", "nl": "action to be performed"}
{"code": "private AudioInputStream synthesizeSelectedVocalization(int backchannelNumber,AudioFileFormat aft,Element domElement) throws SynthesisException {\n  int numberOfBackChannels=unitFileReader.getNumberOfUnits();\n  if (backchannelNumber >= numberOfBackChannels) {\n    throw new IllegalArgumentException(\"This voice has \" + numberOfBackChannels + \" backchannels only. so it doesn't support unit number \"+ backchannelNumber);\n  }\n  VocalizationUnit bUnit=unitFileReader.getUnit(backchannelNumber);\n  Unit[] units=bUnit.getUnits();\n  String[] unitNames=bUnit.getUnitNames();\n  long endTime=0l;\n  for (int i=0; i < units.length; i++) {\n    int unitDuration=units[i].duration * 1000 / unitFileReader.getSampleRate();\n    endTime+=unitDuration;\n    Element element=MaryXML.createElement(domElement.getOwnerDocument(),MaryXML.PHONE);\n    element.setAttribute(\"d\",Integer.toString(unitDuration));\n    element.setAttribute(\"end\",Long.toString(endTime));\n    element.setAttribute(\"p\",unitNames[i]);\n    domElement.appendChild(element);\n  }\n  return this.vSynthesizer.synthesize(backchannelNumber,aft);\n}\n", "nl": "Synthesize a selected vocalization"}
{"code": "public int compare(IEntryPacket e1,IEntryPacket e2){\n  if (e1 == null) {\n    if (e2 == null)     return 0;\n    return -1;\n  }\n  if (e2 == null)   return 1;\n  int rc=0;\n  for (int i=0; i < groupColumns.size(); i++) {\n    SelectColumn groupCol=groupColumns.get(i);\n    Object obj1=_queryResult.getFieldValue(groupCol,e1);\n    Object obj2=_queryResult.getFieldValue(groupCol,e2);\n    if (obj1 == null && obj2 == null)     rc=0;\n else     if (obj1 == null && obj2 != null)     rc=-1;\n else     if (obj1 != null && obj2 == null)     rc=1;\n else     rc=((Comparable)obj1).compareTo(obj2);\n    if (rc != 0)     return rc;\n  }\n  return rc;\n}\n", "nl": "Compare two arrays of values - only the group by columns are compared"}
{"code": "public synchronized AbstractEntryReplicaData produceNextData(ISynchronizationCallback syncCallback){\n  if (isForcedClose()) {\n    throw new RuntimeException(\"space=\" + _engine.getFullSpaceName() + \" replica forced closing\");\n  }\n  if (_isClosed)   return null;\n  try {\n    while (true) {\n      if (isForcedClose()) {\n        this.notifyAll();\n        throw new RuntimeException(\"space=\" + _engine.getFullSpaceName() + \" replica forced closing\");\n      }\n      IEntryHolder entry=_entriesIterSA.next();\n      AbstractEntryReplicaData replicaData=produceDataFromEntry(syncCallback,entry);\n      if (replicaData == null && !_isClosed) {\n        continue;\n      }\n      if (replicaData == null && _isClosed) {\n        return null;\n      }\n      return replicaData;\n    }\n  }\n catch (  Exception ex) {\n    throw new ReplicationInternalSpaceException(\"Failure in .\",ex);\n  }\n}\n", "nl": "Creates the next entry that will be copied to the source space"}
{"code": "public Matrix times(Matrix B){\n  if (B.m != n) {\n    throw new IllegalArgumentException(\"Matrix inner dimensions must agree.\");\n  }\n  Matrix X=new Matrix(m,B.n);\n  double[][] C=X.getArray();\n  double[] Bcolj=new double[n];\n  for (int j=0; j < B.n; j++) {\n    for (int k=0; k < n; k++) {\n      Bcolj[k]=B.A[k][j];\n    }\n    for (int i=0; i < m; i++) {\n      double[] Arowi=A[i];\n      double s=0;\n      for (int k=0; k < n; k++) {\n        s+=Arowi[k] * Bcolj[k];\n      }\n      C[i][j]=s;\n    }\n  }\n  return X;\n}\n", "nl": "Linear algebraic matrix multiplication, A * B"}
{"code": "@SuppressWarnings(\"unchecked\") @EdmFunctionImport(name=\"ConfirmSalesOrder\",entitySet=\"SalesOrderHeaders\",returnType=@ReturnType(type=Type.ENTITY,isCollection=true)) public List<SalesOrderHeader> confirmSalesOrder(@EdmFunctionImportParameter(name=\"SalesOrderId\") String salesOrderId) throws ODataException {\n  EntityManagerFactory emf=Utility.getEntityManagerFactory();\n  EntityManager em=emf.createEntityManager();\n  try {\n    Query query=em.createQuery(\"SELECT s FROM SalesOrderHeader s WHERE s.salesOrderId =\" + salesOrderId);\n    try {\n      SalesOrderHeader so=(SalesOrderHeader)query.getSingleResult();\n      em.getTransaction().begin();\n      so.setLifeCycleStatus(\"P\");\n      so.setLifeCycleStatusName(\"In Process\");\n      em.persist(so);\n      em.getTransaction().commit();\n      List<SalesOrderHeader> salesorderlist=null;\n      query=em.createQuery(\"SELECT s FROM SalesOrderHeader s WHERE s.salesOrderId ='\" + salesOrderId + \"'\");\n      salesorderlist=query.getResultList();\n      return salesorderlist;\n    }\n catch (    NoResultException e) {\n      throw new ODataApplicationException(\"No Sales Order with Sales Order Id:\" + salesOrderId,Locale.ENGLISH,HttpStatusCodes.BAD_REQUEST);\n    }\n  }\n  finally {\n    em.close();\n  }\n}\n", "nl": "Function Import implementation for confirming a sales order"}
{"code": "public Map<String,Object> send(String url,Map<String,Object> request) throws HttpClientException {\n  if (debug) {\n    Debug.logInfo(\"Request : \" + url + \" / \"+ request,module);\n  }\n  String timeoutString=(String)props.get(\"payment.valuelink.timeout\");\n  int timeout=34;\n  try {\n    timeout=Integer.parseInt(timeoutString);\n  }\n catch (  NumberFormatException e) {\n    Debug.logError(e,\"Unable to set timeout to \" + timeoutString + \" using default \"+ timeout);\n  }\n  HttpClient client=new HttpClient(url,request);\n  client.setTimeout(timeout * 1000);\n  client.setDebug(debug);\n  client.setClientCertificateAlias((String)props.get(\"payment.valuelink.certificateAlias\"));\n  String response=client.post();\n  return this.parseResponse(response);\n}\n", "nl": "Transmit a request to ValueLink"}
{"code": "@Override public void run(Timeout timeout) throws Exception {\n  if (timeout.isCancelled()) {\n    return;\n  }\n  long timeToWaitMs;\nsynchronized (this) {\n    OpSendMsg firstMsg=pendingMessages.peek();\n    if (firstMsg == null) {\n      timeToWaitMs=conf.getSendTimeoutMs();\n    }\n else {\n      long diff=(firstMsg.createdAt + conf.getSendTimeoutMs()) - System.currentTimeMillis();\n      if (diff <= 0) {\n        log.info(\"[{}] [{}] Message send timed out. Failing {} messages\",topic,producerName,pendingMessages.size());\n        PulsarClientException te=new PulsarClientException.TimeoutException(\"Could not send message to broker within given timeout\");\n        failPendingMessages(cnx(),te);\n        stats.incrementSendFailed(pendingMessages.size());\n        timeToWaitMs=conf.getSendTimeoutMs();\n      }\n else {\n        timeToWaitMs=diff;\n      }\n    }\n  }\n  sendTimeout=client.timer().newTimeout(this,timeToWaitMs,TimeUnit.MILLISECONDS);\n}\n", "nl": "Process sendTimeout events"}
{"code": "public Pair<Integer,Integer> writeOverlapGraph(Writer w) throws IOException, CanceledException {\n  final NodeArray<String> names=new NodeArray<>(overlapGraph);\n  final NodeArray<String> sequences=new NodeArray<>(overlapGraph);\n  for (Node v=overlapGraph.getFirstNode(); v != null; v=v.getNext()) {\n    ReadData readData=readId2ReadData[(Integer)v.getInfo()];\n    sequences.set(v,readData.getSegment());\n    names.set(v,readData.getName());\n  }\n  final Map<String,NodeArray<?>> label2nodes=new TreeMap<>();\n  label2nodes.put(\"label\",names);\n  label2nodes.put(\"sequence\",sequences);\n  final EdgeArray<Integer> overlap=new EdgeArray<>(overlapGraph);\n  for (Edge e=overlapGraph.getFirstEdge(); e != null; e=e.getNext()) {\n    overlap.set(e,(Integer)e.getInfo());\n  }\n  final Map<String,EdgeArray<?>> label2edges=new TreeMap<>();\n  label2edges.put(\"label\",null);\n  label2edges.put(\"overlap\",overlap);\n  overlapGraph.writeGML(w,\"Overlap graph generated by MEGAN6\",true,label,1,label2nodes,label2edges);\n  return new Pair<>(this.overlapGraph.getNumberOfNodes(),this.overlapGraph.getNumberOfEdges());\n}\n", "nl": "write the overlap graph"}
{"code": "private String makeSAM(String queryName,String refName,int referenceLength,float bitScore,float expect,int rawScore,float percentIdentity,int frame,int queryStart,int queryEnd,int referenceStart,int referenceEnd,String alignedQuery,String alignedReference){\n  final StringBuilder buffer=new StringBuilder();\n  buffer.append(queryName).append(\"\\t\");\n  buffer.append(0);\n  buffer.append(\"\\t\");\n  buffer.append(refName).append(\"\\t\");\n  buffer.append(referenceStart).append(\"\\t\");\n  buffer.append(\"255\\t\");\n  Utilities.appendCigar(alignedQuery,alignedReference,buffer);\n  buffer.append(\"\\t\");\n  buffer.append(\"*\\t\");\n  buffer.append(\"0\\t\");\n  buffer.append(\"0\\t\");\n  buffer.append(alignedQuery.replaceAll(\"-\",\"\")).append(\"\\t\");\n  buffer.append(\"*\\t\");\n  buffer.append(String.format(\"AS:i:%d\\t\",(int)Math.round(bitScore)));\n  buffer.append(String.format(\"NM:i:%d\\t\",Utilities.computeEditDistance(alignedQuery,alignedReference)));\n  buffer.append(String.format(\"ZL:i:%d\\t\",referenceLength));\n  buffer.append(String.format(\"ZR:i:%d\\t\",rawScore));\n  buffer.append(String.format(\"ZE:f:%g\\t\",expect));\n  buffer.append(String.format(\"ZI:i:%d\\t\",(int)Math.round(percentIdentity)));\n  if (frame != 0)   buffer.append(String.format(\"ZF:i:%d\\t\",frame));\n  buffer.append(String.format(\"ZS:i:%s\\t\",queryStart));\n  Utilities.appendMDString(alignedQuery,alignedReference,buffer);\n  return buffer.toString();\n}\n", "nl": "make a SAM line"}
{"code": "public void loadReferences(boolean loadOnDemand) throws IOException {\n  if (references == null) {\n    try (InputReaderLittleEndian ins=new InputReaderLittleEndian(new FileInputStreamAdapter(fileName))){\n      ins.skip(getLocationOfBlockInFile(getRefNamesBlockIndex()));\n      initializeReferences((int)getDbSeqsUsed(),loadOnDemand);\n      if (loadOnDemand) {\n        for (int r=0; r < getDbSeqsUsed(); r++) {\n          if ((r & (referenceLocationChunkSize - 1)) == 0) {\n            referenceLocations[r >>> referenceLocationChunkBits]=ins.getPosition();\n          }\n          ins.skipNullTerminatedBytes();\n        }\n      }\n else {\n        for (int r=0; r < getDbSeqsUsed(); r++) {\n          setReference(r,ins.readNullTerminatedBytes().getBytes());\n        }\n      }\n      initializeRefLengths((int)getDbSeqsUsed());\n      for (int i=0; i < getDbSeqsUsed(); i++) {\n        setRefLength(i,ins.readInt());\n      }\n    }\n   }\n}\n", "nl": "load all references from file (if not already loaded)"}
{"code": "protected final void removeNode(PurityNode n){\n  Iterator it=edges.get(n).iterator();\n  while (it.hasNext()) {\n    PurityEdge e=(PurityEdge)it.next();\n    backEdges.remove(e.getTarget(),e);\n  }\n  it=backEdges.get(n).iterator();\n  while (it.hasNext()) {\n    PurityEdge e=(PurityEdge)it.next();\n    edges.remove(e.getSource(),e);\n  }\n  it=backLocals.get(n).iterator();\n  while (it.hasNext()) {\n    Local l=(Local)it.next();\n    locals.remove(l,n);\n  }\n  ret.remove(n);\n  edges.remove(n);\n  backEdges.remove(n);\n  backLocals.remove(n);\n  nodes.remove(n);\n  paramNodes.remove(n);\n  globEscape.remove(n);\n  mutated.remove(n);\n}\n", "nl": "Utility function to remove a node & all adjacent edges"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  final AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  final Alignment alignment=viewer.getAlignment();\n  final SelectedBlock block=viewer.getSelectedBlock();\n  StringBuilder buf=new StringBuilder();\n  int count=0;\n  for (int row=0; row < alignment.getRowCompressor().getNumberRows(); row++) {\n    if (block.isSelectedRow(row)) {\n      for (      Integer read : alignment.getRowCompressor().getCompressedRow2Reads(row)) {\n        Lane lane=alignment.getLane(read);\n        int firstJump=alignment.getGapColumnContractor().getTotalJumpBeforeLayoutColumn(block.getFirstCol());\n        if ((block.isSelectedCol(lane.getFirstNonGapPosition() - firstJump + 1))) {\n          if (count++ > 0)           buf.append(\"\\n\");\n          buf.append(Basic.getFirstWord(lane.getName()));\n        }\n      }\n    }\n  }\n  if (count > 1)   buf.append(\"\\n\");\n  if (count > 0) {\n    StringSelection selection=new StringSelection(buf.toString());\n    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection,null);\n  }\n}\n", "nl": "action to be performed"}
{"code": "private void init(AttributeSet attrs,int defStyle){\n  TypedArray a=getContext().obtainStyledAttributes(attrs,R.styleable.FlowLayout);\n  try {\n    mConnectivityAware=a.getBoolean(R.styleable.FlowLayout_isConnectivityAware,mConnectivityAware);\n    mConnectedText=a.getResourceId(R.styleable.FlowLayout_connectedText,mConnectedText);\n    mConnectedTextColor=a.getResourceId(R.styleable.FlowLayout_connectedTextColor,mConnectedTextColor);\n    mConnectedBackground=a.getResourceId(R.styleable.FlowLayout_connectedBackground,mConnectedBackground);\n    mConnectedLayout=a.getResourceId(R.styleable.FlowLayout_connectedlayout,mConnectedLayout);\n    mDisconnectedText=a.getResourceId(R.styleable.FlowLayout_disconnectedText,mDisconnectedText);\n    mDisconnectedTextColor=a.getResourceId(R.styleable.FlowLayout_disconnectedTextColor,mDisconnectedTextColor);\n    mDisconnectedBackground=a.getResourceId(R.styleable.FlowLayout_disconnectedBackground,mDisconnectedBackground);\n    mDisconnectedLayout=a.getResourceId(R.styleable.FlowLayout_disconnectedlayout,mDisconnectedLayout);\n    mErrorText=a.getResourceId(R.styleable.FlowLayout_errorText,mErrorText);\n    mEmptyLayout=a.getResourceId(R.styleable.FlowLayout_emptyLayout,mEmptyLayout);\n    mEmptyText=a.getResourceId(R.styleable.FlowLayout_emptyText,mEmptyText);\n    mEmptyTextColor=a.getResourceId(R.styleable.FlowLayout_emptyTextColor,mEmptyTextColor);\n    mProgressLayout=a.getResourceId(R.styleable.FlowLayout_progressLayout,mProgressLayout);\n  }\n  finally {\n    a.recycle();\n  }\n  postInit();\n}\n", "nl": "Init view"}
{"code": "public void saveCommentHistory() throws TeamException {\n  IPath pluginStateLocation=SVNUIPlugin.getPlugin().getStateLocation();\n  File tempFile=pluginStateLocation.append(COMMENT_HIST_FILE + \".tmp\").toFile();\n  File histFile=pluginStateLocation.append(COMMENT_HIST_FILE).toFile();\n  try {\n    XMLWriter writer=new XMLWriter(new BufferedOutputStream(new FileOutputStream(tempFile)));\n    try {\n      writer.startTag(ELEMENT_COMMIT_HISTORY,null,false);\n      for (int i=0; i < previousComments.length && i < maxComments; i++)       writer.printSimpleTag(ELEMENT_COMMIT_COMMENT,previousComments[i]);\n      writer.endTag(ELEMENT_COMMIT_HISTORY);\n    }\n  finally {\n      writer.close();\n    }\n    if (histFile.exists()) {\n      histFile.delete();\n    }\n    boolean renamed=tempFile.renameTo(histFile);\n    if (!renamed) {\n      throw new TeamException(new Status(IStatus.ERROR,SVNUIPlugin.ID,TeamException.UNABLE,Policy.bind(\"RepositoryManager.rename\",tempFile.getAbsolutePath()),null));\n    }\n  }\n catch (  IOException e) {\n    throw new TeamException(new Status(IStatus.ERROR,SVNUIPlugin.ID,TeamException.UNABLE,Policy.bind(\"RepositoryManager.save\",histFile.getAbsolutePath()),e));\n  }\n}\n", "nl": "save the comments history"}
{"code": "@Override public boolean heap_sensitive_intersection(IVarAbstraction qv){\n  int i, j;\n  PtInsNode qn;\n  SegmentNode p, q, pt[], qt[];\n  qn=(PtInsNode)qv;\n  for (Iterator<AllocNode> it=pt_objs.keySet().iterator(); it.hasNext(); ) {\n    AllocNode an=it.next();\n    if (an instanceof StringConstantNode)     continue;\n    qt=qn.find_points_to(an);\n    if (qt == null)     continue;\n    pt=find_points_to(an);\n    for (i=0; i < PtInsIntervalManager.Divisions; ++i) {\n      p=pt[i];\n      while (p != null) {\n        for (j=0; j < PtInsIntervalManager.Divisions; ++j) {\n          q=qt[j];\n          while (q != null) {\n            if (quick_intersecting_test(p,q))             return true;\n            q=q.next;\n          }\n        }\n        p=p.next;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Query if this pointer and qv could point to the same object under any contexts"}
{"code": "private int readCounter() throws DataFallbackException {\n  final int counter;\n  openCounterDataInputStream();\n  try {\n    String line;\n    line=dInput.readLine();\n    if (line != null) {\n      counter=new Integer(line).intValue();\n      goToLine(counter);\n      if (LOG.isDebugEnabled())       LOG.debug(\"The counter file \" + counterFile.getName() + \" has been read\");\n    }\n else {\n      throw new DataFallbackException(\"readCounter() - The counter could not be read, the counter file is empty\");\n    }\n  }\n catch (  IOException e) {\n    LOG.error(\"Exception is: \" + e.getMessage());\n    throw new DataFallbackException(\"readCounter() - The counter could not be read \" + e.getMessage());\n  }\n finally {\n    closeCounterDataInputStream();\n  }\n  return counter;\n}\n", "nl": "Reads the number that is stored in the counter file and which represents the already committed data"}
{"code": "@ApiMethod(path=\"{type}/\",verb=ApiVerb.DELETE,description=\"Gets and deletes entries from space that matches the query.\",produces={MediaType.APPLICATION_JSON_VALUE}) @RequestMapping(value=\"/{type}\",method=RequestMethod.DELETE,produces={MediaType.APPLICATION_JSON_VALUE}) public @ResponseBody Map<String,Object> deleteByQuery(@ApiPathParam(name=\"type\",description=TYPE_DESCRIPTION) @PathVariable String type,@ApiQueryParam(name=\"query\") @RequestParam(value=QUERY_PARAM) String query,@ApiQueryParam(name=\"max\",description=\"The maximum number of entries to return. Default is Integer.MAX_VALUE\") @RequestParam(value=MAX_PARAM,required=false) Integer max){\n  if (logger.isLoggable(Level.FINE))   logger.fine(\"creating take query with type: \" + type + \" and query: \"+ query);\n  GigaSpace gigaSpace=ControllerUtils.xapCache.get();\n  SQLQuery<Object> sqlQuery=new SQLQuery<Object>(type,query);\n  int maxSize=(max == null ? maxReturnValues : max.intValue());\n  Object[] docs;\n  try {\n    docs=gigaSpace.takeMultiple(sqlQuery,maxSize);\n  }\n catch (  DataAccessException e) {\n    throw translateDataAccessException(gigaSpace,e,type);\n  }\n  if (docs == null) {\n    docs=new Object[]{};\n  }\n  try {\n    Map<String,Object> result=new HashMap<String,Object>();\n    result.put(\"status\",\"success\");\n    result.put(\"data\",ControllerUtils.mapper.readValue(ControllerUtils.mapper.writeValueAsString(docs),ArrayList.class));\n    return result;\n  }\n catch (  IOException e) {\n    throw new RestException(e.getMessage());\n  }\n}\n", "nl": "REST DELETE by query request handler"}
{"code": "public boolean hasNext(){\n  if (enable) {\n    if (done)     return false;\n    if (next != null)     return true;\n    try {\n      next=queue.take();\n    }\n catch (    InterruptedException e) {\n      done=true;\n      next=null;\n      return false;\n    }\n    if (next == sentinel) {\n      done=true;\n      next=null;\n      return false;\n    }\n else     return true;\n  }\n else   return iterator.hasNext();\n}\n", "nl": "has next? Prefetches the next item"}
{"code": "private boolean resizeAndSaveImage(File targetFile,int maxWidth,int maxHeight) throws IOException {\n  boolean saved=false;\n  ImageSize targetImageSize=new ImageSize(maxWidth,maxHeight);\n  DisplayImageOptions specialOptions=new DisplayImageOptions.Builder().cloneFrom(options).imageScaleType(ImageScaleType.IN_SAMPLE_INT).build();\n  ImageDecodingInfo decodingInfo=new ImageDecodingInfo(memoryCacheKey,ImageDownloader.Scheme.FILE.wrap(targetFile.getAbsolutePath()),targetImageSize,ViewScaleType.FIT_INSIDE,getDownloader(),specialOptions);\n  Bitmap bmp=decoder.decode(decodingInfo);\n  if (bmp != null && configuration.processorForDiscCache != null) {\n    log(LOG_PROCESS_IMAGE_BEFORE_CACHE_ON_DISC);\n    bmp=configuration.processorForDiscCache.process(bmp);\n    if (bmp == null) {\n      L.e(ERROR_PROCESSOR_FOR_DISC_CACHE_NULL,memoryCacheKey);\n    }\n  }\n  if (bmp != null) {\n    OutputStream os=new BufferedOutputStream(new FileOutputStream(targetFile),BUFFER_SIZE);\n    try {\n      bmp.compress(configuration.imageCompressFormatForDiscCache,configuration.imageQualityForDiscCache,os);\n    }\n  finally {\n      IoUtils.closeSilently(os);\n    }\n    bmp.recycle();\n  }\n  return true;\n}\n", "nl": "Decodes image file into Bitmap, resize it and save it back"}
{"code": "@SuppressWarnings(\"rawtypes\") public static void main(String args[]){\n  if (args.length < 1) {\n    System.out.println(\"Error: Must have 1 parameter: config filename\");\n    return;\n  }\n  System.out.println(\"java.version=\" + System.getProperty(\"java.version\"));\n  try {\n    ClientGlobal.init(args[0]);\n    System.out.println(\"network_timeout=\" + ClientGlobal.g_network_timeout + \"ms\");\n    System.out.println(\"charset=\" + ClientGlobal.g_charset);\n    file_ids=new java.util.concurrent.ConcurrentLinkedQueue();\n    for (int i=0; i < 10; i++) {\n      (new UploadThread(i)).start();\n    }\n    for (int i=0; i < 20; i++) {\n      (new DownloadThread(i)).start();\n    }\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n  }\n}\n", "nl": "entry point"}
{"code": "private void winningBidActions(Player player,int npcId,long highestValue){\n  DropNpc dropNpc=DropRegistrationService.getInstance().getDropRegistrationMap().get(npcId);\n  if (highestValue > 0) {\n    if (!player.getInventory().tryDecreaseKinah(highestValue)) {\n      return;\n    }\n    PacketSendUtility.sendPacket(player,SM_SYSTEM_MESSAGE.STR_MSG_PAY_ACCOUNT_ME(highestValue));\n  }\n  if (player.isInGroup2() || player.isInAlliance2()) {\n    for (    Player member : dropNpc.getInRangePlayers()) {\n      if (member != null && !player.equals(member) && member.isOnline()) {\n        PacketSendUtility.sendPacket(member,SM_SYSTEM_MESSAGE.STR_MSG_PAY_ACCOUNT_OTHER(player.getName(),highestValue));\n        long distributeKinah=highestValue / (dropNpc.getGroupSize() - 1);\n        member.getInventory().increaseKinah(distributeKinah);\n        PacketSendUtility.sendPacket(member,SM_SYSTEM_MESSAGE.STR_MSG_PAY_DISTRIBUTE(highestValue,dropNpc.getGroupSize() - 1,distributeKinah));\n      }\n    }\n  }\n}\n", "nl": "messages/removes and shares kinah when item gained via BID"}
{"code": "public static void restartActivity(@NotNull Project project,@NotNull InstantRunContext instantRunContext){\n  for (  IDevice device : findDevices(project)) {\n    InstantRunClient instantRunClient=InstantRunManager.getInstantRunClient(instantRunContext);\n    if (instantRunClient == null) {\n      Logger.getInstance(RestartActivityAction.class).warn(\"Unable to connect to to app running on device, not restarting.\");\n      return;\n    }\n    try {\n      if (instantRunClient.getAppState(device) == AppState.FOREGROUND) {\n        instantRunClient.restartActivity(device);\n        if (InstantRunSettings.isShowToastEnabled()) {\n          showToast(device,instantRunContext,\"Activity Restarted\");\n        }\n      }\n    }\n catch (    IOException e) {\n      Messages.showErrorDialog(project,\"Unable to restart activity: \" + e,\"Instant Run\");\n      InstantRunManager.LOG.warn(\"Unable to restart activity\",e);\n    }\n  }\n}\n", "nl": "Restarts the activity associated with the given module"}
{"code": "public void sync() throws CanceledException {\n  if (!inSync) {\n    inSync=true;\n    IChartData chartData=(IChartData)getChartData();\n    chartData.clear();\n    Document doc=((Director)dir).getDocument();\n    setChartTitle(cName + \" profile for \" + doc.getTitle());\n    int numberOfDatasets=doc.getNumberOfSamples();\n    if (numberOfDatasets > 0) {\n      chartData.setAllSeries(doc.getSampleNames());\n      String[] sampleNames=doc.getSampleNames().toArray(new String[doc.getSampleNames().size()]);\n      java.util.Collection<Integer> ids=parentViewer.getSelectedIds();\n      LinkedList<String> classNames=new LinkedList<>();\n      for (      Integer id : ids) {\n        String className=parentViewer.getClassification().getName2IdMap().get(id);\n        classNames.add(className);\n        int[] summarized=parentViewer.getSummarized(id);\n        for (int i=0; i < sampleNames.length; i++) {\n          chartData.putValue(sampleNames[i],className,summarized[i]);\n        }\n      }\n      chartData.setClassNames(classNames);\n    }\n    chartData.setTree(parentViewer.getInducedTree(((Name2IdMap)parentViewer.getClassification().getName2IdMap()).getId2Name(),parentViewer.getSelectedNodes()));\n    super.sync();\n    inSync=false;\n  }\n}\n", "nl": "synchronize chart to reflect latest user selection in taxon chart"}
{"code": "public void actionPerformed(ActionEvent e){\n  if (e.getSource() instanceof JButton) {\n    JButton button=(JButton)e.getSource();\n    if (button == refreshButton) {\n      refreshAttributes();\n      return;\n    }\n    if (button == clearButton) {\n      clearCurrentNotifications();\n      return;\n    }\n    if (button == subscribeButton) {\n      registerListener();\n      return;\n    }\n    if (button == unsubscribeButton) {\n      unregisterListener();\n      return;\n    }\n  }\n}\n", "nl": "Action listener: handles actions in panel buttons"}
{"code": "public void trim(int leftTrimNumberOfSample,int rightTrimNumberOfSample){\n  long chunkSize=waveHeader.getChunkSize();\n  long subChunk2Size=waveHeader.getSubChunk2Size();\n  long totalTrimmed=leftTrimNumberOfSample + rightTrimNumberOfSample;\n  if (totalTrimmed > subChunk2Size) {\n    leftTrimNumberOfSample=(int)subChunk2Size;\n  }\n  chunkSize-=totalTrimmed;\n  subChunk2Size-=totalTrimmed;\n  if (chunkSize >= 0 && subChunk2Size >= 0) {\n    waveHeader.setChunkSize(chunkSize);\n    waveHeader.setSubChunk2Size(subChunk2Size);\n    byte[] trimmedData=new byte[(int)subChunk2Size];\n    System.arraycopy(data,(int)leftTrimNumberOfSample,trimmedData,0,(int)subChunk2Size);\n    data=trimmedData;\n  }\n else {\n    System.err.println(\"Trim error: Negative length\");\n  }\n}\n", "nl": "Trim the wave data"}
{"code": "private static void generateGraph(IDataProcessStatus dataProcessTaskStatus,SchemaInfo info,String tableName,String partitionID,CarbonDataLoadSchema schema,String factStoreLocation,List<LoadMetadataDetails> loadMetadataDetails) throws GraphGeneratorException {\n  DataLoadModel model=new DataLoadModel();\n  model.setCsvLoad(null != dataProcessTaskStatus.getCsvFilePath() || null != dataProcessTaskStatus.getFilesToProcess());\n  model.setSchemaInfo(info);\n  model.setTableName(dataProcessTaskStatus.getTableName());\n  model.setTaskNo(\"1\");\n  model.setBlocksID(dataProcessTaskStatus.getBlocksID());\n  model.setFactTimeStamp(readCurrentTime());\n  model.setEscapeCharacter(dataProcessTaskStatus.getEscapeCharacter());\n  model.setQuoteCharacter(dataProcessTaskStatus.getQuoteCharacter());\n  model.setCommentCharacter(dataProcessTaskStatus.getCommentCharacter());\n  if (null != loadMetadataDetails && !loadMetadataDetails.isEmpty()) {\n    model.setLoadNames(CarbonDataProcessorUtil.getLoadNameFromLoadMetaDataDetails(loadMetadataDetails));\n    model.setModificationOrDeletionTime(CarbonDataProcessorUtil.getModificationOrDeletionTimesFromLoadMetadataDetails(loadMetadataDetails));\n  }\n  boolean hdfsReadMode=dataProcessTaskStatus.getCsvFilePath() != null && dataProcessTaskStatus.getCsvFilePath().startsWith(\"hdfs:\");\n  int allocate=null != dataProcessTaskStatus.getCsvFilePath() ? 1 : dataProcessTaskStatus.getFilesToProcess().size();\n  String outputLocation=CarbonProperties.getInstance().getProperty(\"store_output_location\",\"../carbon-store/system/carbon/etl\");\n  GraphGenerator generator=new GraphGenerator(model,hdfsReadMode,partitionID,factStoreLocation,allocate,schema,\"0\",outputLocation);\n  generator.generateGraph();\n}\n", "nl": "generate graph"}
{"code": "private void justify(){\n  if (adapter == null) {\n    return;\n  }\n  lastScrollY=0;\n  int offset=scrollingOffset;\n  int itemHeight=getItemHeight();\n  boolean needToIncrease=offset > 0 ? currentItem < adapter.getItemsCount() : currentItem > 0;\n  if ((isCyclic || needToIncrease) && Math.abs((float)offset) > (float)itemHeight / 2) {\n    if (offset < 0)     offset+=itemHeight + MIN_DELTA_FOR_SCROLLING;\n else     offset-=itemHeight + MIN_DELTA_FOR_SCROLLING;\n  }\n  if (Math.abs(offset) > MIN_DELTA_FOR_SCROLLING) {\n    scroller.startScroll(0,0,0,offset,SCROLLING_DURATION);\n    setNextMessage(MESSAGE_JUSTIFY);\n  }\n else {\n    finishScrolling();\n  }\n}\n", "nl": "Justifies wheel"}
{"code": "@Override public void onBindViewHolder(final RecyclerView.ViewHolder holder,int positions){\n  super.onBindViewHolder(holder,positions);\n  int viewType=holder.getItemViewType();\n  if (mItemTouchHelper != null && itemDragEnabled && viewType != LOADING_VIEW && viewType != HEADER_VIEW && viewType != EMPTY_VIEW && viewType != FOOTER_VIEW) {\n    if (mToggleViewId != NO_TOGGLE_VIEW) {\n      View toggleView=((BaseViewHolder)holder).getView(mToggleViewId);\n      if (toggleView != null) {\n        toggleView.setTag(R.id.BaseQuickAdapter_viewholder_support,holder);\n        if (mDragOnLongPress) {\n          toggleView.setOnLongClickListener(mOnToggleViewLongClickListener);\n        }\n else {\n          toggleView.setOnTouchListener(mOnToggleViewTouchListener);\n        }\n      }\n    }\n else {\n      holder.itemView.setTag(R.id.BaseQuickAdapter_viewholder_support,holder);\n      holder.itemView.setOnLongClickListener(mOnToggleViewLongClickListener);\n    }\n  }\n}\n", "nl": "To bind different types of holder and solve different the bind events"}
{"code": "private void hideView(String type){\nswitch (type) {\ncase HEADERVIEW:\n    if (mHeaderView.getLayoutParams().height < mHeaderViewHeight) {\n      startAnimator(mHeaderView,mHeaderView.getLayoutParams().height,0);\n    }\n else {\n      startAnimator(mHeaderView,mHeaderView.getLayoutParams().height,mHeaderViewHeight);\n    }\n  isLoadingMoreData=false;\nbreak;\ncase FOOTERVIEW:\nif (mFooterView.getLayoutParams().height < mFooterViewHeight) {\nstartAnimator(mFooterView,mFooterView.getLayoutParams().height,0);\n}\n else {\nstartAnimator(mFooterView,mFooterView.getLayoutParams().height,mFooterViewHeight);\n}\nisLoadingData=false;\nbreak;\n}\n}\n", "nl": "hide the headerview use the animator"}
{"code": "public void testDeployIntermediateVersionWithoutMessageStartEvent(){\n  String deploymentId1=deployStartMessageTestProcess();\n  assertEquals(1,getAllEventSubscriptions().size());\n  assertEquals(0,runtimeService.createProcessInstanceQuery().count());\n  runtimeService.startProcessInstanceByMessage(\"myStartMessage\");\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  assertEventSubscriptionsCount(1);\n  String deploymentId2=deployProcessWithoutEvents();\n  assertEquals(0,getAllEventSubscriptions().size());\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  try {\n    runtimeService.startProcessInstanceByMessage(\"myStartMessage\");\n    fail();\n  }\n catch (  Exception e) {\n  }\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  assertEventSubscriptionsCount(0);\n  String deploymentId3=deployStartMessageTestProcess();\n  assertEquals(1,getAllEventSubscriptions().size());\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  runtimeService.startProcessInstanceByMessage(\"myStartMessage\");\n  assertEquals(2,runtimeService.createProcessInstanceQuery().count());\n  assertEventSubscriptionsCount(1);\n  List<EventSubscriptionEntity> eventSubscriptions=getAllEventSubscriptions();\n  assertEquals(repositoryService.createProcessDefinitionQuery().deploymentId(deploymentId3).singleResult().getId(),eventSubscriptions.get(0).getProcessDefinitionId());\n  cleanup(deploymentId1,deploymentId2,deploymentId3);\n}\n", "nl": "v1 -> has start message event v2 -> has no start message event v3 -> has start message event"}
{"code": "protected void wrapContent(){\n  mWidget.setMinWidth(100);\n  mWidget.setMinHeight(30);\n  int tw=mWidget.getMinWidth();\n  int th=mWidget.getMinHeight();\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setWidth(tw);\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setHeight(th);\n  }\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getWidth() <= mWidget.getMinWidth()) {\n      mWidget.setHorizontalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getHeight() <= mWidget.getMinHeight()) {\n      mWidget.setVerticalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  mWidget.setBaselineDistance(0);\n}\n", "nl": "Utility method computing the size of the widget if dimensions are set to wrap_content, using the default font"}
{"code": "private WriteEntriesResult writeEntryPackets(IEntryPacket[] entryPackets,WriteEntriesResult values,Context context,ServerTransaction transaction,long lease,long[] leases,int modifiers,SpaceContext sc,boolean reInsertedEntry,boolean fromWriteMultiple) throws RemoteException, TransactionException {\n  for (int i=0; i < entryPackets.length; ++i) {\n    if (values.isError(i))     continue;\n    try {\n      final long entryLease=leases != null ? leases[i] : lease;\n      WriteEntryResult writeResult=write(context,entryPackets[i],transaction,entryLease,modifiers,false,true,sc,false,true);\n      values.setResult(i,writeResult);\n    }\n catch (    UnusableEntryException e) {\n      values.setError(i,e);\n    }\ncatch (    UnknownTypeException e) {\n      values.setError(i,e);\n    }\ncatch (    EntryAlreadyInSpaceException e) {\n      values.setError(i,e);\n    }\ncatch (    ProtectiveModeException e) {\n      values.setError(i,e);\n    }\ncatch (    DuplicateIndexValueException e) {\n      values.setError(i,e);\n    }\n  }\n  return values;\n}\n", "nl": "call write for each EP in value, update value with the result"}
{"code": "public static boolean create(String sid,long expired,int w,int h,File outputFile,int len) throws IOException {\n  if (outputFile == null) {\n    return false;\n  }\n  File dir=outputFile.getParentFile();\n  if (!dir.exists()) {\n    dir.mkdirs();\n  }\n  try {\n    String code=UID.random(len,VERIFY_CODES).toLowerCase();\n    outputFile.createNewFile();\n    FileOutputStream fos=new FileOutputStream(outputFile);\n    outputImage(w,h,fos,code.toUpperCase());\n    fos.close();\n    Cache.set(\"//captcha/\" + sid,Code.create(code,expired));\n    return true;\n  }\n catch (  IOException e) {\n    throw e;\n  }\n}\n", "nl": "output the \"code image\" to the file"}
{"code": "protected void addJob(BundleContext context,Class<? extends Job> clazz,String cronExpression){\n  String jobName=clazz.getName();\n  String jobGroup=FrameworkUtil.getBundle(clazz).getSymbolicName();\n  JobDetail job=new JobDetail(jobName,jobGroup,clazz);\n  job.setDurability(false);\n  job.setVolatility(true);\n  job.setDescription(jobName);\n  try {\n    CronTrigger trigger=new CronTrigger(jobName,jobGroup,cronExpression);\n    if (scheduler == null) {\n      if (schedulerProperties == null) {\n        schedulerProperties=getDefaultSchedulerProperties();\n      }\n      scheduler=new StdSchedulerFactory(schedulerProperties).getScheduler();\n      scheduler.start();\n    }\n    Date date=scheduler.scheduleJob(job,trigger);\n    Logger.info(this,\"Scheduled job \" + jobName + \", next trigger is on \"+ date);\n  }\n catch (  ParseException e) {\n    Logger.error(this,\"Cron expression '\" + cronExpression + \"' has an exception. Throwing IllegalArgumentException\",e);\n    throw new IllegalArgumentException(e);\n  }\ncatch (  SchedulerException e) {\n    Logger.error(this,\"Unable to schedule job \" + jobName,e);\n  }\n}\n", "nl": "Adds a Job, and starts a Scheduler when none was yet started"}
{"code": "public void removeACL(Collection<String> listIPs,int from,int to){\n  AmazonEC2 client=null;\n  try {\n    client=getEc2Client();\n    List<IpPermission> ipPermissions=new ArrayList<IpPermission>();\n    ipPermissions.add(new IpPermission().withFromPort(from).withIpProtocol(\"tcp\").withIpRanges(listIPs).withToPort(to));\n    if (this.insEnvIdentity.isClassic()) {\n      client.revokeSecurityGroupIngress(new RevokeSecurityGroupIngressRequest(config.getACLGroupName(),ipPermissions));\n      logger.info(\"Done removing from ACL within classic env for running instance: \" + StringUtils.join(listIPs,\",\"));\n    }\n else {\n      RevokeSecurityGroupIngressRequest req=new RevokeSecurityGroupIngressRequest();\n      req.withGroupId(getVpcGroupId());\n      client.revokeSecurityGroupIngress(req.withIpPermissions(ipPermissions));\n      logger.info(\"Done removing from ACL within vpc env for running instance: \" + StringUtils.join(listIPs,\",\"));\n    }\n  }\n  finally {\n    if (client != null)     client.shutdown();\n  }\n}\n", "nl": "removes a iplist from the SG"}
{"code": "public Element makeXmlElement(Document document,String prefix){\n  Element element=null;\n  if (prefix == null)   prefix=\"\";\n  if (document != null)   element=document.createElement(prefix + this.getEntityName());\n  if (element == null)   return null;\n  Iterator<ModelField> modelFields=this.getModelEntity().getFieldsIterator();\n  while (modelFields.hasNext()) {\n    ModelField modelField=modelFields.next();\n    String name=modelField.getName();\n    String value=this.getString(name);\n    if (value != null) {\n      if (value.indexOf('\\n') >= 0 || value.indexOf('\\r') >= 0) {\n        UtilXml.addChildElementCDATAValue(element,name,value,document);\n      }\n else {\n        element.setAttribute(name,value);\n      }\n    }\n  }\n  return element;\n}\n", "nl": "Makes an XML Element object with an attribute for each field of the entity"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set colorTable=\");\n  String name=np.getWordMatchesRespectingCase(ColorTableManager.getNames());\n  boolean isHeatMap;\n  if (np.peekMatchIgnoreCase(\"heatMap\")) {\n    np.matchIgnoreCase(\"heatMap=\");\n    isHeatMap=np.getBoolean();\n  }\n else   isHeatMap=false;\n  np.matchIgnoreCase(\";\");\n  if (isHeatMap) {\n    getDir().getDocument().getChartColorManager().setHeatMapTable(name);\n    ColorTableManager.setDefaultColorTableHeatMap(name);\n  }\n else {\n    getDir().getDocument().getChartColorManager().setColorTable(name);\n    ColorTableManager.setDefaultColorTable(name);\n  }\n  getDir().getDocument().setDirty(true);\n}\n", "nl": "parses the given command and executes it"}
{"code": "protected void handleAndroidResourceFiles(String apk,Set<String> fileNameFilter,IResourceHandler handler){\n  File apkF=new File(apk);\n  if (!apkF.exists())   throw new RuntimeException(\"file '\" + apk + \"' does not exist!\");\n  try {\n    ZipFile archive=null;\n    try {\n      archive=new ZipFile(apkF);\n      Enumeration<?> entries=archive.entries();\n      while (entries.hasMoreElements()) {\n        ZipEntry entry=(ZipEntry)entries.nextElement();\n        String entryName=entry.getName();\n        handler.handleResourceFile(entryName,fileNameFilter,archive.getInputStream(entry));\n      }\n    }\n  finally {\n      if (archive != null)       archive.close();\n    }\n  }\n catch (  Exception e) {\n    System.err.println(\"Error when looking for XML resource files in apk \" + apk + \": \"+ e);\n    e.printStackTrace();\n    if (e instanceof RuntimeException)     throw (RuntimeException)e;\n else     throw new RuntimeException(e);\n  }\n}\n", "nl": "Opens the given apk file and provides the given handler with a stream for accessing the contained resource manifest files"}
{"code": "@NotNull public String computePreferredTheme(@NotNull Configuration configuration){\n  MergedManifest manifest=MergedManifest.get(myModule);\n  String activity=configuration.getActivity();\n  if (activity != null) {\n    String activityFqcn=activity;\n    if (activity.startsWith(\".\")) {\n      String pkg=StringUtil.notNullize(manifest.getPackage());\n      activityFqcn=pkg + activity;\n    }\n    ActivityAttributes attributes=manifest.getActivityAttributes(activityFqcn);\n    if (attributes != null) {\n      String theme=attributes.getTheme();\n      if (theme != null && theme.startsWith(SdkConstants.PREFIX_RESOURCE_REF)) {\n        return theme;\n      }\n    }\n    attributes=manifest.getActivityAttributes(activity);\n    if (attributes != null) {\n      String theme=attributes.getTheme();\n      if (theme != null && theme.startsWith(SdkConstants.PREFIX_RESOURCE_REF)) {\n        return theme;\n      }\n    }\n  }\n  return manifest.getDefaultTheme(configuration.getTarget(),configuration.getScreenSize(),configuration.getDevice());\n}\n", "nl": "Returns the preferred theme"}
{"code": "public void cipher(byte[] data,int offset,int length){\n  int blockNumber=length >> 3;\n  int p;\n  for (int k=0; k < blockNumber; k++) {\n    p=offset + (k << 3);\n    int xl=byteArrayToInteger(data,p);\n    int xr=byteArrayToInteger(data,p + 4);\n    int tmp;\n    for (int i=0; i < 16; i++) {\n      xl=xl ^ pArray[i];\n      xr=F(xl) ^ xr;\n      tmp=xl;\n      xl=xr;\n      xr=tmp;\n    }\n    tmp=xl;\n    xl=xr;\n    xr=tmp;\n    xr^=pArray[16];\n    xl^=pArray[17];\n    integerToByteArray(xl,data,p);\n    integerToByteArray(xr,data,p + 4);\n  }\n}\n", "nl": "Cipher the given byte-array with Blowfish cipher"}
{"code": "private OCFile(Parcel source){\n  mId=source.readLong();\n  mParentId=source.readLong();\n  mLength=source.readLong();\n  mCreationTimestamp=source.readLong();\n  mModifiedTimestamp=source.readLong();\n  mModifiedTimestampAtLastSyncForData=source.readLong();\n  mRemotePath=source.readString();\n  mLocalPath=source.readString();\n  mMimeType=source.readString();\n  mNeedsUpdating=source.readInt() == 0;\n  mFavorite=source.readInt() == 1;\n  mLastSyncDateForProperties=source.readLong();\n  mLastSyncDateForData=source.readLong();\n  mEtag=source.readString();\n  mShareByLink=source.readInt() == 1;\n  mPublicLink=source.readString();\n  mPermissions=source.readString();\n  mRemoteId=source.readString();\n  mNeedsUpdateThumbnail=source.readInt() == 1;\n  mIsDownloading=source.readInt() == 1;\n  mEtagInConflict=source.readString();\n  mShareWithSharee=source.readInt() == 1;\n}\n", "nl": "Reconstruct from parcel"}
{"code": "public final void dbUnavailable(final boolean alarmUp,final String exceptionMsg,final String dbInfo){\n  if (alarmUp == FallbackAlarmsInterface.ACTIVATED) {\n    ArrayList recipients=new ArrayList();\n    MailDetailsBean mailDetails=new MailDetailsBean();\n    mailDetails.setSender(\"mruizgar@cern.ch\");\n    recipients.add(\"mruizgar@cern.ch\");\n    mailDetails.setToRecipients(recipients);\n    mailDetails.setSubject(\"DB Unavailable\");\n    mailDetails.setMessage(\"The DB connection to \" + dbInfo + \"could not be established due to: \"+ exceptionMsg);\n    mailDetails.setServer(\"cernmx.cern.ch\");\n    SMTPMailSender mailSender=new SMTPMailSender();\n    try {\n      mailSender.sendMail(mailDetails);\n    }\n catch (    MailSenderException e) {\n      LOG.debug(e.getMessage());\n    }\n  }\n}\n", "nl": "Sends an email warning about the DB problems"}
{"code": "protected void drawLabels(Canvas c,float pos,PointF anchor){\n  final float labelRotationAngleDegrees=mXAxis.getLabelRotationAngle();\n  float[] position=new float[]{0f,0f};\n  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {\n    position[0]=i;\n    mTrans.pointValuesToPixel(position);\n    if (mViewPortHandler.isInBoundsX(position[0])) {\n      String label=mXAxis.getValues().get(i);\n      if (mXAxis.isAvoidFirstLastClippingEnabled()) {\n        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {\n          float width=Utils.calcTextWidth(mAxisLabelPaint,label);\n          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;\n        }\n else         if (i == 0) {\n          float width=Utils.calcTextWidth(mAxisLabelPaint,label);\n          position[0]+=width / 2;\n        }\n      }\n      drawLabel(c,label,i,position[0],pos,anchor,labelRotationAngleDegrees);\n    }\n  }\n}\n", "nl": "draws the x-labels on the specified y-position"}
{"code": "private void initializeCounterFile(){\n  try {\n    openCounterDataOutputStream();\n    dOutput.write(\"0\");\n    dOutput.newLine();\n    dOutput.flush();\n    if (LOG.isDebugEnabled())     LOG.debug(\"initializeCounterFile() - The counter file has been updated with zero\");\n  }\n catch (  IOException e) {\n    LOG.error(\"initializeCounterFile() - Error while trying to write in the counter file\");\n  }\ncatch (  DataFallbackException e) {\n    LOG.error(\"initializeCounterFile() - The counter file could not be opened\");\n  }\n finally {\n    try {\n      closeCounterDataOutputStream();\n    }\n catch (    DataFallbackException ex) {\n      LOG.error(\"initializeCounterFile() - The counter file could not be closed\");\n    }\n  }\n}\n", "nl": "It sets the file counter to zero"}
{"code": "@Override public void process(WatchedEvent event){\n  if (Event.EventType.None == event.getType() && Event.KeeperState.Expired == event.getState()) {\n    Set<String> keySet=new HashSet<String>(listeners.keySet());\n    for (    String logSegmentsPath : keySet) {\n      scheduleTask(logSegmentsPath,new ReadLogSegmentsTask(logSegmentsPath,this),0L);\n    }\n    return;\n  }\n  String path=event.getPath();\n  if (null == path) {\n    return;\n  }\nswitch (event.getType()) {\ncase NodeDeleted:\n    listeners.remove(path);\n  break;\ncase NodeChildrenChanged:\nnew ReadLogSegmentsTask(path,this).run();\nbreak;\ndefault :\nbreak;\n}\n}\n", "nl": "Process the watched events for registered listeners"}
{"code": "public static Map<String,Object> testRandomAuthorize(DispatchContext dctx,Map<String,? extends Object> context){\n  Locale locale=(Locale)context.get(\"locale\");\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  String refNum=UtilDateTime.nowAsString();\n  Random r=new Random();\n  int i=r.nextInt(9);\n  if (i < 5 || i % 2 == 0) {\n    result.put(\"authResult\",Boolean.TRUE);\n    result.put(\"authFlag\",\"A\");\n  }\n else {\n    result.put(\"authResult\",Boolean.FALSE);\n    result.put(\"authFlag\",\"D\");\n  }\n  result.put(\"processAmount\",context.get(\"processAmount\"));\n  result.put(\"authRefNum\",refNum);\n  result.put(\"authAltRefNum\",refNum);\n  result.put(\"authCode\",\"100\");\n  result.put(\"authMessage\",UtilProperties.getMessage(resource,\"AccountingPaymentTestCapture\",locale));\n  return result;\n}\n", "nl": "Test authorize - does random declines"}
{"code": "private static void addVerticalSmallSpring(Path2D.Float path,int x0,int y1,int y2){\n  int springHeight=2;\n  int springWidth=2;\n  int distance=Math.abs(y2 - y1);\n  int numSprings=(distance / (springHeight));\n  int leftOver=(distance - (numSprings * springHeight)) / 2;\n  path.lineTo(x0,y1);\n  path.lineTo(x0,y1 - leftOver);\n  int count=0;\n  if (y1 > y2) {\n    for (int y=y1 - leftOver; y > y2 + leftOver; y-=springHeight) {\n      int x=(count % 2 == 0) ? x0 - springWidth : x0 + springWidth;\n      path.lineTo(x,y);\n      count++;\n    }\n  }\n else {\n    for (int y=y1 + leftOver; y < y2 - leftOver; y+=springHeight) {\n      int x=(count % 2 == 0) ? x0 - springWidth : x0 + springWidth;\n      path.lineTo(x,y);\n      count++;\n    }\n  }\n  path.lineTo(x0,y2 + leftOver);\n  path.lineTo(x0,y2);\n}\n", "nl": "Add an vertical spring between (x0, y1) and (x0, y1) to the given path object"}
{"code": "protected Control createDialogArea(Composite parent){\n  GridData gd;\n  Composite dialogComp=(Composite)super.createDialogArea(parent);\n  Composite topComp=new Composite(dialogComp,SWT.NONE);\n  gd=new GridData(GridData.FILL_BOTH);\n  topComp.setLayoutData(gd);\n  GridLayout topLayout=new GridLayout();\n  topLayout.numColumns=2;\n  topComp.setLayout(topLayout);\n  setTitle(Messages.getString(\"SootConfigManagerDialog.Soot_Configurations_Manager\"));\n  setMessage(\"\");\n  Composite selection=createSelectionArea(topComp);\n  gd=new GridData(GridData.FILL_BOTH);\n  gd.horizontalSpan=1;\n  selection.setLayoutData(gd);\n  Control specialButtons=createSpecialButtonBar(topComp);\n  gd=new GridData(GridData.FILL_BOTH);\n  specialButtons.setLayoutData(gd);\n  Label separator=new Label(topComp,SWT.HORIZONTAL | SWT.SEPARATOR);\n  gd=new GridData(GridData.FILL_HORIZONTAL);\n  gd.horizontalSpan=2;\n  separator.setLayoutData(gd);\n  dialogComp.layout(true);\n  return dialogComp;\n}\n", "nl": "creates a sash form - one side for a selection tree  and the other for the options"}
{"code": "static void calculate(){\n  for (  byte levelByte : itemLevels) {\n    short level=(short)(levelByte & 0xFF);\n    if (level < 10) {\n      continue;\n    }\n    int countIndex=0;\n    for (    short countByte : fullCounts) {\n      short count=(short)(countByte & 0xFF);\n      int finalLevel=level;\n      if (finalLevel % 5 == 0) {\n        finalLevel--;\n      }\n      int pointLevel=(int)itemLevels[(finalLevel / 5)];\n      int feedPoints=Math.max(0,pointLevel - 5) / 5 * 8;\n      pointValues[finalLevel / 5][countIndex++]=getPoints(feedPoints,count);\n    }\n  }\n}\n", "nl": "Calculate point values for each item levels and each max feed count"}
{"code": "public short[] interpolate(int oldSampleRate,int newSampleRate,short[] samples){\n  if (oldSampleRate == newSampleRate) {\n    return samples;\n  }\n  int newLength=Math.round(((float)samples.length / oldSampleRate * newSampleRate));\n  float lengthMultiplier=(float)newLength / samples.length;\n  short[] interpolatedSamples=new short[newLength];\n  for (int i=0; i < newLength; i++) {\n    float currentPosition=i / lengthMultiplier;\n    int nearestLeftPosition=(int)currentPosition;\n    int nearestRightPosition=nearestLeftPosition + 1;\n    if (nearestRightPosition >= samples.length) {\n      nearestRightPosition=samples.length - 1;\n    }\n    float slope=samples[nearestRightPosition] - samples[nearestLeftPosition];\n    float positionFromLeft=currentPosition - nearestLeftPosition;\n    interpolatedSamples[i]=(short)(slope * positionFromLeft + samples[nearestLeftPosition]);\n  }\n  return interpolatedSamples;\n}\n", "nl": "Do interpolation on the samples according to the original and destinated sample rates"}
{"code": "public static StyledLayerDescriptor readSLDFile(File file){\n  StyledLayerDescriptor sld=null;\n  if (file != null) {\n    StyleFactory styleFactory=CommonFactoryFinder.getStyleFactory();\n    try {\n      URL url=file.toURI().toURL();\n      SLDParser styleReader=new SLDParser(styleFactory,url);\n      setResourcelocator(styleReader,file.toURI().toURL());\n      sld=styleReader.parseSLD();\n    }\n catch (    MalformedURLException e) {\n      ConsoleManager.getInstance().exception(SLDUtils.class,e);\n    }\ncatch (    IOException e) {\n      ConsoleManager.getInstance().exception(SLDUtils.class,e);\n    }\n  }\n  return sld;\n}\n", "nl": "Creates a StyledLayerDescriptor object containing a SLD by  reading the contents of a file"}
{"code": "public static SparklerConfiguration newDefaultConfig(){\n  Yaml yaml=new Yaml();\n  InputStream input=null;\n  SparklerConfiguration sparklerConf=null;\n  try {\n    input=Constants.class.getClassLoader().getResourceAsStream(file.SPARKLER_DEFAULT);\n    Map<String,Object> yamlMap=(Map<String,Object>)yaml.load(input);\n    sparklerConf=new SparklerConfiguration(yamlMap);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n finally {\n    IOUtils.closeQuietly(input);\n  }\n  if (sparklerConf != null) {\n    sparklerConf.put(key.UUID_KEY,UUID.randomUUID().toString());\n  }\n  return sparklerConf;\n}\n", "nl": "Create configuration instance for Sparkler"}
{"code": "public static final Optional<ArrayList<SteamVRApp>> parseManifest(final File manifest){\n  try (Scanner scanner=new Scanner(manifest)){\n    final JSONParser parser=new JSONParser();\n    final ArrayList<SteamVRApp> toReturn=new ArrayList<>();\n    final StringBuilder builder=new StringBuilder();\n    while (scanner.hasNextLine())     builder.append(scanner.nextLine() + \"\\n\");\n    scanner.close();\n    final JSONObject object=(JSONObject)parser.parse(builder.toString());\n    final JSONArray applications=(JSONArray)object.get(\"applications\");\n    final Iterator<?> iterator=applications.iterator();\n    while (iterator.hasNext()) {\n      final JSONObject currentApplication=(JSONObject)iterator.next();\n      final String appKey=(String)currentApplication.get(\"app_key\");\n      final String launchType=(String)currentApplication.get(\"launch_type\");\n      final JSONObject strings=(JSONObject)currentApplication.get(\"strings\");\n      JSONObject english=(JSONObject)strings.get(\"en_us\");\n      final String name=(String)english.get(\"name\");\n      final String imagePath=(String)currentApplication.get(\"image_path\");\n      final String launchURL=(String)currentApplication.get(\"url\");\n      toReturn.add(new SteamVRApp(-1,appKey,launchType,name,imagePath,launchURL));\n    }\n    if (toReturn.size() > 0)     return Optional.of(toReturn);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  return Optional.empty();\n}\n", "nl": "TODO make this not language specific"}
{"code": "private void initLabels(){\n  CompareConfiguration cc=getCompareConfiguration();\n  cc.setLeftEditable(!readOnly);\n  cc.setRightEditable(false);\n  String title;\n  String leftLabel;\n  String rightLabel;\n  if (resources.length > 1) {\n    title=Policy.bind(\"SVNLocalBaseCompareInput.0\") + remoteRevision;\n    leftLabel=Policy.bind(\"SVNLocalBaseCompareInput.1\");\n    rightLabel=remoteRevision.toString();\n  }\n else {\n    title=Policy.bind(\"SVNCompareRevisionsInput.compareResourceAndVersions\",new Object[]{resources[0].getName()});\n    leftLabel=Policy.bind(\"SVNCompareRevisionsInput.workspace\",new Object[]{resources[0].getName()});\n    rightLabel=Policy.bind(\"SVNCompareRevisionsInput.repository\",new Object[]{resources[0].getName()});\n  }\n  setTitle(title);\n  cc.setLeftLabel(leftLabel);\n  cc.setRightLabel(rightLabel);\n}\n", "nl": "initialize the labels : the title, the lft label and the right one"}
{"code": "@Deployment public void testNonInterruptingSignal(){\n  ProcessInstance pi=runtimeService.startProcessInstanceByKey(\"nonInterruptingSignalEvent\");\n  List<Task> tasks=taskService.createTaskQuery().processInstanceId(pi.getProcessInstanceId()).list();\n  assertEquals(1,tasks.size());\n  Task currentTask=tasks.get(0);\n  assertEquals(\"My User Task\",currentTask.getName());\n  runtimeService.signalEventReceived(\"alert\");\n  tasks=taskService.createTaskQuery().processInstanceId(pi.getProcessInstanceId()).list();\n  assertEquals(2,tasks.size());\n  for (  Task task : tasks) {\n    if (!task.getName().equals(\"My User Task\") && !task.getName().equals(\"My Second User Task\")) {\n      fail(\"Expected: <My User Task> or <My Second User Task> but was <\" + task.getName() + \">.\");\n    }\n  }\n  taskService.complete(taskService.createTaskQuery().taskName(\"My User Task\").singleResult().getId());\n  tasks=taskService.createTaskQuery().processInstanceId(pi.getProcessInstanceId()).list();\n  assertEquals(1,tasks.size());\n  currentTask=tasks.get(0);\n  assertEquals(\"My Second User Task\",currentTask.getName());\n}\n", "nl": "TestCase to reproduce Issue ACT-1344"}
{"code": "public static Map<String,Object> testService(DispatchContext dctx,Map<String,?> context){\n  Map<String,Object> response=ServiceUtil.returnSuccess();\n  if (context.size() > 0) {\n    for (    Map.Entry<String,?> entry : context.entrySet()) {\n      Object cKey=entry.getKey();\n      Object value=entry.getValue();\n      System.out.println(\"---- SVC-CONTEXT: \" + cKey + \" => \"+ value);\n    }\n  }\n  if (!context.containsKey(\"message\")) {\n    response.put(\"resp\",\"no message found\");\n  }\n else {\n    System.out.println(\"-----SERVICE TEST----- : \" + (String)context.get(\"message\"));\n    response.put(\"resp\",\"service done\");\n  }\n  System.out.println(\"----- SVC: \" + dctx.getName() + \" -----\");\n  return response;\n}\n", "nl": "Generic Test Service"}
{"code": "public double calculateReplicaUsableCapacity(int vmthinsizeparentvm,int poolsnapshotcount,int desktoppoolcount,int datastorecount,int storageoverhead,String storagetiering){\n  boolean b=false;\n  if (storagetiering.equalsIgnoreCase(\"On\")) {\n    b=true;\n  }\n else {\n    b=false;\n  }\n  double d=0;\n  if (b) {\n    d=(vmthinsizeparentvm * desktoppoolcount * poolsnapshotcount) / 1048576.0;\n  }\n else {\n    d=(vmthinsizeparentvm * poolsnapshotcount * desktoppoolcount* datastorecount) / 1048576.0;\n  }\n  d*=(1.0 + (storageoverhead / 100.0));\n  d=(double)Math.round(d * 100) / 100;\n  return d;\n}\n", "nl": "Calculate amount of storage capacity to be used by replicas"}
{"code": "public static boolean calculatePhysicalDodgeRate(Creature attacker,Creature attacked,int accMod){\n  if (attacker.getObserveController().checkAttackerStatus(AttackStatus.DODGE)) {\n    return true;\n  }\n  if (attacked.getObserveController().checkAttackStatus(AttackStatus.DODGE)) {\n    return true;\n  }\n  float accuracy=attacker.getGameStats().getMainHandPAccuracy().getCurrent() + accMod;\n  float dodge=0;\n  if (attacked instanceof Player) {\n    dodge=attacked.getGameStats().getEvasion().getBonus() + getMovementModifier(attacked,StatEnum.EVASION,attacked.getGameStats().getEvasion().getBase()) + attacked.getGameStats().getStat(StatEnum.PVP_DODGE,0).getCurrent();\n  }\n else {\n    dodge=attacked.getGameStats().getEvasion().getBonus() + getMovementModifier(attacked,StatEnum.EVASION,attacked.getGameStats().getEvasion().getBase());\n  }\n  float dodgeRate=dodge - accuracy;\n  if (attacked instanceof Npc) {\n    int levelDiff=attacked.getLevel() - attacker.getLevel();\n    dodgeRate*=1 + getNpcLevelDiffMod(levelDiff,0);\n    if (((Npc)attacked).hasStatic()) {\n      return false;\n    }\n  }\n  return calculatePhysicalEvasion(dodgeRate,300);\n}\n", "nl": "Calculates DODGE chance"}
{"code": "@Override public void json(String json){\n  if (TextUtils.isEmpty(json)) {\n    d(\"Empty/Null json content\");\n    return;\n  }\n  try {\n    json=json.trim();\n    if (json.startsWith(\"{\")) {\n      JSONObject jsonObject=new JSONObject(json);\n      String message=jsonObject.toString(JSON_INDENT);\n      d(message);\n      return;\n    }\n    if (json.startsWith(\"[\")) {\n      JSONArray jsonArray=new JSONArray(json);\n      String message=jsonArray.toString(JSON_INDENT);\n      d(message);\n    }\n  }\n catch (  JSONException e) {\n    e(e.getCause().getMessage() + \"\\n\" + json);\n  }\n}\n", "nl": "Formats the json content and print it"}
{"code": "private static int snapVertical(Collection<ConstraintWidget> widgets,ConstraintWidget widget,ConstraintAnchor anchor,int position,ArrayList<SnapCandidate> snapCandidates){\n  SnapCandidate candidate=new SnapCandidate();\n  ConstraintHandle handle=WidgetInteractionTargets.constraintHandle(anchor);\n  if (handle == null) {\n    return position;\n  }\n  handle.setDrawY(position);\n  SnapPlacement.snapAnchor(widgets,widget,anchor,candidate);\n  if (candidate.target != null) {\n    ConstraintHandle targetHandle=WidgetInteractionTargets.constraintHandle(candidate.target);\n    int ty=candidate.y;\n    if (targetHandle != null) {\n      ty=targetHandle.getDrawY();\n    }\n    position=ty + candidate.margin;\n    snapCandidates.add(candidate);\n  }\n  return position;\n}\n", "nl": "Utility function to gather snap candidates on the vertical axis"}
{"code": "public static void writeCustomAttributes(Collection<List<ExtensionAttribute>> attributes,XMLStreamWriter xtw,Map<String,String> namespaceMap,List<ExtensionAttribute>... blackLists) throws XMLStreamException {\n  for (  List<ExtensionAttribute> attributeList : attributes) {\n    if (attributeList != null && !attributeList.isEmpty()) {\n      for (      ExtensionAttribute attribute : attributeList) {\n        if (!isBlacklisted(attribute,blackLists)) {\n          if (attribute.getNamespacePrefix() == null) {\n            if (attribute.getNamespace() == null)             xtw.writeAttribute(attribute.getName(),attribute.getValue());\n else {\n              xtw.writeAttribute(attribute.getNamespace(),attribute.getName(),attribute.getValue());\n            }\n          }\n else {\n            if (!namespaceMap.containsKey(attribute.getNamespacePrefix())) {\n              namespaceMap.put(attribute.getNamespacePrefix(),attribute.getNamespace());\n              xtw.writeNamespace(attribute.getNamespacePrefix(),attribute.getNamespace());\n            }\n            xtw.writeAttribute(attribute.getNamespacePrefix(),attribute.getNamespace(),attribute.getName(),attribute.getValue());\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "write attributes to xtw (except blacklisted)"}
{"code": "private String parseAlignedSequence(String aLine){\n  String[] tokens=aLine.split(\"\\\\s+\");\nswitch (tokens.length) {\ncase 3:\n{\n      final StringBuilder buf=new StringBuilder();\n      int gaps=Integer.parseInt(tokens[0]);\n      while (--gaps >= 0)       buf.append(\"-\");\n      buf.append(tokens[1]);\n      gaps=Integer.parseInt(tokens[2]);\n      while (--gaps >= 0)       buf.append(\"-\");\n      return buf.toString();\n    }\ncase 2:\n{\n    final StringBuilder buf=new StringBuilder();\n    int gaps=Integer.parseInt(tokens[0]);\n    while (--gaps >= 0)     buf.append(\"-\");\n    buf.append(tokens[1]);\n    return buf.toString();\n  }\ncase 1:\nreturn tokens[0];\ndefault :\nreturn aLine.replaceAll(\"\\\\s+\",\"\");\n}\n}\n", "nl": "get the algined sequence in the line Possible formats: XXXXX 5 XXXX  (5 leading gaps) 5 XXXX 3 (3 trailing gaps)"}
{"code": "public void loadNamespaceDestinations(ServiceUnitId suName) throws Exception {\n  LOG.info(\"Loading all topics on service unit: {}\",suName);\n  NamespaceName nsName=suName.getNamespaceObject();\n  List<CompletableFuture<Topic>> persistentTopics=Lists.newArrayList();\n  long topicLoadStart=System.nanoTime();\n  for (  String topic : getNamespaceService().getListOfDestinations(nsName.getProperty(),nsName.getCluster(),nsName.getLocalName())) {\n    try {\n      DestinationName dn=DestinationName.get(topic);\n      if (suName.includes(dn)) {\n        CompletableFuture<Topic> future=brokerService.getTopic(topic);\n        if (future != null) {\n          persistentTopics.add(future);\n        }\n      }\n    }\n catch (    Throwable t) {\n      LOG.warn(\"Failed to preload topic {}\",topic,t);\n    }\n  }\n  if (!persistentTopics.isEmpty()) {\n    FutureUtil.waitForAll(persistentTopics).thenRun(null);\n  }\n}\n", "nl": "Load all the destination contained in a namespace"}
{"code": "@deprecated public static void permute(String source,boolean skipZeros,Set<String> output){\n  if ((source.length() <= 2) && (UTF16.countCodePoint(source) <= 1)) {\n    output.add(source);\n    return;\n  }\n  Set<String> subpermute=new HashSet();\n  int cp;\n  String chStr;\n  for (int i=0; i < source.length(); i+=UTF16.getCharCount(cp)) {\n    cp=UTF16.charAt(source,i);\n    if ((!skipZeros) || (i == 0) || (UCharacter.getCombiningClass(cp) != 0)) {\n      subpermute.clear();\n      permute(source.substring(0,i) + source.substring(i + UTF16.getCharCount(cp)),skipZeros,subpermute);\n      chStr=UTF16.valueOf(source,i);\n      for (      String s : subpermute) {\n        String piece=chStr + s;\n        output.add(piece);\n      }\n    }\n  }\n}\n", "nl": "/*    "}
{"code": "public static void moveToBindLocation(Player player,boolean useTeleport){\n  float x, y, z;\n  int worldId;\n  byte h=0;\n  if (player.getBindPoint() != null) {\n    BindPointPosition bplist=player.getBindPoint();\n    worldId=bplist.getMapId();\n    x=bplist.getX();\n    y=bplist.getY();\n    z=bplist.getZ();\n    h=bplist.getHeading();\n  }\n else {\n    PlayerInitialData.LocationData locationData=DataManager.PLAYER_INITIAL_DATA.getSpawnLocation(player.getRace());\n    worldId=locationData.getMapId();\n    x=locationData.getX();\n    y=locationData.getY();\n    z=locationData.getZ();\n  }\n  InstanceService.onLeaveInstance(player);\n  if (useTeleport) {\n    teleportTo(player,worldId,x,y,z,h);\n  }\n else {\n    World.getInstance().setPosition(player,worldId,1,x,y,z,h);\n  }\n}\n", "nl": "This method will move a player to their bind location"}
{"code": "public static void snapAnchor(Collection<ConstraintWidget> widgets,ConstraintWidget widget,ConstraintAnchor anchor,SnapCandidate candidate){\n  if (widget.getParent() != null) {\n    if (!anchor.isVerticalAnchor()) {\n      checkHorizontalParentMarginSnap(anchor,ConstraintAnchor.Type.RIGHT,-DEFAULT_MARGIN,candidate);\n      checkHorizontalParentMarginSnap(anchor,ConstraintAnchor.Type.LEFT,DEFAULT_MARGIN,candidate);\n    }\n else {\n      checkVerticalParentMarginSnap(anchor,ConstraintAnchor.Type.BOTTOM,-DEFAULT_MARGIN,candidate);\n      checkVerticalParentMarginSnap(anchor,ConstraintAnchor.Type.TOP,DEFAULT_MARGIN,candidate);\n    }\n  }\n  for (  ConstraintWidget w : widgets) {\n    if (w == widget) {\n      continue;\n    }\n    ArrayList<ConstraintAnchor> anchorsTarget=w.getAnchors();\n    for (    ConstraintAnchor at : anchorsTarget) {\n      snapCheck(anchor,at,candidate,CONNECTION_SLOPE);\n    }\n  }\n}\n", "nl": "Try to find snapping candidates for the given anchor"}
{"code": "private static BitMatrix bitMatrixFromEncoder(PDF417 encoder,String contents,int errorCorrectionLevel,int width,int height,int margin) throws WriterException {\n  encoder.generateBarcodeLogic(contents,errorCorrectionLevel);\n  int aspectRatio=4;\n  byte[][] originalScale=encoder.getBarcodeMatrix().getScaledMatrix(1,aspectRatio);\n  boolean rotated=false;\n  if ((height > width) ^ (originalScale[0].length < originalScale.length)) {\n    originalScale=rotateArray(originalScale);\n    rotated=true;\n  }\n  int scaleX=width / originalScale[0].length;\n  int scaleY=height / originalScale.length;\n  int scale;\n  if (scaleX < scaleY) {\n    scale=scaleX;\n  }\n else {\n    scale=scaleY;\n  }\n  if (scale > 1) {\n    byte[][] scaledMatrix=encoder.getBarcodeMatrix().getScaledMatrix(scale,scale * aspectRatio);\n    if (rotated) {\n      scaledMatrix=rotateArray(scaledMatrix);\n    }\n    return bitMatrixFrombitArray(scaledMatrix,margin);\n  }\n  return bitMatrixFrombitArray(originalScale,margin);\n}\n", "nl": "Takes encoder, accounts for width/height, and retrieves bit matrix"}
{"code": "public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {\n  try {\n    JsonReader jsonReader=new JsonReader(json);\n    JsonElement element=parse(jsonReader);\n    if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {\n      throw new JsonSyntaxException(\"Did not consume the entire document.\");\n    }\n    return element;\n  }\n catch (  MalformedJsonException e) {\n    throw new JsonSyntaxException(e);\n  }\ncatch (  IOException e) {\n    throw new JsonIOException(e);\n  }\ncatch (  NumberFormatException e) {\n    throw new JsonSyntaxException(e);\n  }\n}\n", "nl": "Parses the specified JSON string into a parse tree"}
{"code": "private void endList(boolean orderedList){\n  if (!mParagraphStyles.isEmpty()) {\n    AccumulatedParagraphStyle style=mParagraphStyles.peek();\n    ParagraphType type=style.getType();\n    if ((orderedList && (type.isNumbering() || type == ParagraphType.INDENTATION_OL)) || (!orderedList && (type.isBullet() || type == ParagraphType.INDENTATION_UL))) {\n      int indent=style.getRelativeIndent();\n      if (indent > 1) {\n        style.setRelativeIndent(indent - 1);\n        style.setAbsoluteIndent(style.getAbsoluteIndent() - 1);\n      }\n else {\n        mParagraphStyles.pop();\n      }\n    }\n else {\n      mParagraphStyles.pop();\n      endList(orderedList);\n    }\n  }\n}\n", "nl": "Handles OL and UL end tags"}
{"code": "private void readState(DataInputStream dis) throws IOException, SVNException {\n  int version=dis.readInt();\n  if ((version < REPOSITORIES_STATE_FILE_VERSION_1) || (version > REPOSITORIES_STATE_FILE_VERSION_3)) {\n    Util.logError(Policy.bind(\"SVNProviderPlugin.unknownStateFileVersion\",new Integer(version).toString()),null);\n    return;\n  }\n  int count=dis.readInt();\n  for (int i=0; i < count; i++) {\n    ISVNRepositoryLocation root=SVNRepositoryLocation.fromString(dis.readUTF());\n    addToRepositoriesCache(root);\n    if (version >= REPOSITORIES_STATE_FILE_VERSION_2) {\n      String label=dis.readUTF();\n      if (!label.equals(\"\")) {\n        root.setLabel(label);\n      }\n    }\n    if (version >= REPOSITORIES_STATE_FILE_VERSION_3) {\n      String repositoryRoot=dis.readUTF();\n      if (!repositoryRoot.equals(\"\")) {\n        root.setRepositoryRoot(new SVNUrl(repositoryRoot));\n      }\n    }\n  }\n}\n", "nl": "read the state of the plugin, ie the repositories locations"}
{"code": "private Object castValue(Object value){\n  ResourceType.DataType<D> parentDataType=dataType();\n  if (parentDataType.equals(ResourceType.DataType.DOUBLE)) {\n    return ((Number)value).doubleValue();\n  }\n else   if (parentDataType.equals(ResourceType.DataType.LONG)) {\n    if (value instanceof Double) {\n      throw new ClassCastException();\n    }\n    return ((Number)value).longValue();\n  }\n else {\n    try {\n      return Class.forName(parentDataType.getName()).cast(value);\n    }\n catch (    ClassNotFoundException e) {\n      throw new RuntimeException(ErrorMessage.INVALID_RESOURCE_CAST.getMessage(value,parentDataType.getName()));\n    }\n  }\n}\n", "nl": "This is to handle casting longs and doubles when the type allows for the data type to be a number"}
{"code": "public void forceClose(ServerInfo server){\n  if (server == null || server.sock == null) {\n    return;\n  }\n  try {\n    if (this.keep_alive) {\n      try {\n        ProtoCommon.quit(server.sock);\n      }\n catch (      IOException ex) {\n        System.err.println(\"quit error: \" + ex.getMessage());\n      }\n    }\n    server.sock.close();\n    server.sock=null;\n  }\n catch (  IOException ex) {\n    System.err.println(\"close socket error: \" + ex.getMessage());\n  }\n}\n", "nl": "force close server"}
{"code": "static double slowexp(final double x,final double result[]){\n  final double xs[]=new double[2];\n  final double ys[]=new double[2];\n  final double facts[]=new double[2];\n  final double as[]=new double[2];\n  split(x,xs);\n  ys[0]=ys[1]=0.0;\n  for (int i=FACT.length - 1; i >= 0; i--) {\n    splitMult(xs,ys,as);\n    ys[0]=as[0];\n    ys[1]=as[1];\n    split(FACT[i],as);\n    splitReciprocal(as,facts);\n    splitAdd(ys,facts,as);\n    ys[0]=as[0];\n    ys[1]=as[1];\n  }\n  if (result != null) {\n    result[0]=ys[0];\n    result[1]=ys[1];\n  }\n  return ys[0] + ys[1];\n}\n", "nl": "For x between 0 and 1, returns exp(x), uses extended precision"}
{"code": "public static ResourcesPoet create(File file){\n  init();\n  try {\n    Document document=sDocumentBuilder.parse(file);\n    Element resources;\n    NodeList list=document.getElementsByTagName(ELEMENT_RESOURCES);\n    if (list == null || list.getLength() == 0) {\n      resources=document.createElement(ELEMENT_RESOURCES);\n      document.appendChild(resources);\n    }\n else {\n      resources=(Element)list.item(0);\n    }\n    return create(document,resources);\n  }\n catch (  IOException|SAXException e) {\n    throw new IllegalStateException(\"Unable to parse the resource file you passed. Make sure it is properly formatted\",e);\n  }\n}\n", "nl": "Creates a builder on top of the current resources XML file"}
{"code": "public static RuleTagCacheObject createTestRuleTag(){\n  RuleTagCacheObject cacheObject=new RuleTagCacheObject(new Long(130),\"Junit_test_tag\",\"Integer\",DataTagConstants.MODE_TEST,\"(#100000 = true)&(#100001 = true)[2],true[3]\");\n  cacheObject.setId(new Long(130));\n  cacheObject.setName(\"Junit_test_rule_tag\");\n  cacheObject.setDescription(\"test rule description\");\n  cacheObject.setMode(DataTagConstants.MODE_TEST);\n  cacheObject.setDataType(\"Integer\");\n  cacheObject.setLogged(false);\n  cacheObject.setUnit(\"test unit m/sec\");\n  cacheObject.setDipAddress(\"testDIPaddress\");\n  cacheObject.setJapcAddress(\"testJAPCaddress\");\n  cacheObject.setValue(new Integer(1000));\n  cacheObject.setValueDescription(\"test value description\");\n  cacheObject.setSimulated(false);\n  cacheObject.setValueDictionary(new DataTagValueDictionary());\n  cacheObject.setDataTagQuality(createValidQuality());\n  cacheObject.setCacheTimestamp(new Timestamp(System.currentTimeMillis()));\n  cacheObject.setRuleIdsString(\"\");\n  return cacheObject;\n}\n", "nl": "Returns a test rule tag object"}
{"code": "public static void updateContext(LRMIInvocationTrace invocationTrace,ProxyWriteType proxyWriteType,InvocationStage stage,PlatformLogicalVersion sourceLogicalVersion,PlatformLogicalVersion targetLogicalVersion,boolean createSnapshot,Boolean useStubCache,InetSocketAddress clientEndPointAddress){\n  LRMIInvocationContextHolder holder=invocationContexts.get();\n  LRMIInvocationContext invocationContext=holder.getContext();\n  LRMIInvocationContext actualContext=createSnapshot ? invocationContext.snapshot() : invocationContext;\n  if (invocationTrace != null || createSnapshot)   actualContext.setTrace(invocationTrace);\n  if (proxyWriteType != null || createSnapshot)   actualContext.setProxyWriteType(proxyWriteType);\n  if (stage != null || createSnapshot)   actualContext.setInvocationStage(stage);\n  if (sourceLogicalVersion != null || createSnapshot)   actualContext.setSourceLogicalVersion(sourceLogicalVersion);\n  if (targetLogicalVersion != null || createSnapshot)   actualContext.setTargetLogicalVersion(targetLogicalVersion);\n  if (useStubCache != null)   actualContext.setUseStubCache(useStubCache.booleanValue());\n  if (clientEndPointAddress != null || createSnapshot) {\n    actualContext.setClientEndPointAddress(clientEndPointAddress);\n  }\n  if (createSnapshot) {\n    if (invocationContext._livenessPriorityEnabledInNextInvocation)     actualContext.setLivenessPriorityEnabled(true);\n    if (invocationContext._customPriorityEnabledInNextInvocation)     actualContext.setCustomPriorityEnabled(true);\n    if (invocationContext._callbackMethodInNextInvocation)     actualContext.setCallbackMethod(true);\n  }\n  holder.setContext(actualContext);\n}\n", "nl": "Updates this thread lrmi invocation context"}
{"code": "public static boolean deletefile(String delpath){\n  File file=new File(delpath);\n  if (!file.isDirectory()) {\n    file.delete();\n  }\n else   if (file.isDirectory()) {\n    String[] filelist=file.list();\n    for (int i=0; i < filelist.length; i++) {\n      File delfile=new File(delpath + filelist[i]);\n      if (!delfile.isDirectory()) {\n        delfile.delete();\n      }\n else       if (delfile.isDirectory()) {\n        deletefile(delpath + filelist[i]);\n      }\n    }\n    file.delete();\n  }\n  return true;\n}\n", "nl": "Delete all files in a folder under the folder and files"}
{"code": "private void updateFinder(){\n  int flag=0;\n  if (!jChkRegex.isSelected()) {\n    flag|=Pattern.LITERAL;\n  }\n  flag|=(jChkIgnoreCase.isSelected()) ? Pattern.CASE_INSENSITIVE : 0;\n  if (jChkIgnoreCase.isSelected()) {\n    flag|=Pattern.CASE_INSENSITIVE;\n  }\n  String regex=(String)jCmbFind.getSelectedItem();\n  if (regex != null && regex.length() > 0) {\n    Pattern pattern=Pattern.compile(regex,flag);\n    finder.setWrap(jChkWrap.isSelected());\n    finder.setPattern(pattern);\n    ActionUtils.insertIntoCombo(jCmbFind,regex);\n  }\n else {\n    finder.setPattern(null);\n  }\n}\n", "nl": "update the finder object with data from our UI"}
{"code": "protected void handleSendMessage(){\n  setMessageSendCallback();\nswitch (message.status()) {\ncase SUCCESS:\n    progressBar.setVisibility(View.INVISIBLE);\n  if (percentageView != null)   percentageView.setVisibility(View.INVISIBLE);\nstatusView.setVisibility(View.INVISIBLE);\nbreak;\ncase FAIL:\nprogressBar.setVisibility(View.INVISIBLE);\nif (percentageView != null) percentageView.setVisibility(View.INVISIBLE);\nstatusView.setVisibility(View.VISIBLE);\nbreak;\ncase INPROGRESS:\nprogressBar.setVisibility(View.VISIBLE);\nif (percentageView != null) {\npercentageView.setVisibility(View.VISIBLE);\npercentageView.setText(message.progress() + \"%\");\n}\nstatusView.setVisibility(View.INVISIBLE);\nbreak;\ndefault :\nprogressBar.setVisibility(View.INVISIBLE);\nif (percentageView != null) percentageView.setVisibility(View.INVISIBLE);\nstatusView.setVisibility(View.VISIBLE);\nbreak;\n}\n}\n", "nl": "handle sending message"}
{"code": "public void addAp(int additionalAp){\n  dailyAP+=additionalAp;\n  if (dailyAP < 0) {\n    dailyAP=0;\n  }\n  weeklyAP+=additionalAp;\n  if (weeklyAP < 0) {\n    weeklyAP=0;\n  }\n  int cappedCount=0;\n  if (CustomConfig.ENABLE_AP_CAP) {\n    cappedCount=(long)(currentAp + additionalAp) > CustomConfig.AP_CAP_VALUE ? (int)(CustomConfig.AP_CAP_VALUE - currentAp) : additionalAp;\n  }\n else {\n    cappedCount=additionalAp;\n  }\n  currentAp+=cappedCount;\n  if (currentAp < 0) {\n    currentAp=0;\n  }\n  AbyssRankEnum newRank=AbyssRankEnum.getRankForAp(currentAp);\n  if (newRank.getId() <= 9) {\n    setRank(newRank);\n  }\n  setPersistentState(PersistentState.UPDATE_REQUIRED);\n}\n", "nl": "Add AP to a player (current player AP + added AP)"}
{"code": "public boolean isNewQualityStatus(final SourceDataTagQuality newSDQuality){\n  if (this.lastSourceDataTag != null) {\n    SourceDataTagValue lastSentSDTagValue=this.lastSourceDataTag.getCurrentValue();\n    if ((lastSentSDTagValue.getValue() != null) && (lastSentSDTagValue.getQuality().getQualityCode() != newSDQuality.getQualityCode())) {\n      if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug(\"\\tscheduler[\" + this.sourceDataTag.getId() + \"] : New Quality status. Last Sent Quality [ \"+ lastSentSDTagValue.getQuality()+ \"] vs New Quality [\"+ newSDQuality+ \"]\");\n      }\n      return true;\n    }\n  }\n else   if (isScheduledForSending()) {\n    SourceDataTagValue scheduledValue=sourceDataTag.getCurrentValue();\n    if ((scheduledValue != null) && (scheduledValue.getQuality().getQualityCode() != newSDQuality.getQualityCode())) {\n      if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug(\"\\tscheduler[\" + this.sourceDataTag.getId() + \"] : New Quality status. Scheduled Quality [\"+ scheduledValue.getQuality()+ \"] vs New Quality [\"+ newSDQuality+ \"]\");\n      }\n      return true;\n    }\n  }\n  if (LOGGER.isDebugEnabled()) {\n    LOGGER.debug(\"\\tscheduler[\" + this.sourceDataTag.getId() + \"] : No new Quality status \");\n  }\n  return false;\n}\n", "nl": "If the quality has changed it means the data tag is swapping from valid to invalid or the other way round"}
{"code": "private double[] interpolateNonZeroValues(double[] contour){\n  for (int i=0; i < contour.length; i++) {\n    if (contour[i] == 0) {\n      int index=findNextIndexNonZero(contour,i);\n      if (index == -1) {\n        for (int j=i; j < contour.length; j++) {\n          contour[j]=contour[j - 1];\n        }\n        break;\n      }\n else {\n        for (int j=i; j < index; j++) {\n          if (i == 0) {\n            contour[j]=contour[index];\n          }\n else {\n            contour[j]=contour[j - 1] + ((contour[index] - contour[i - 1]) / (index - i));\n          }\n        }\n        i=index - 1;\n      }\n    }\n  }\n  return contour;\n}\n", "nl": "To interpolate Zero values with respect to NonZero values"}
{"code": "private static void addAndroidLibrary(@NotNull AndroidLibrary library,@NotNull DependencySet dependencies,@NotNull DependencyScope scope,@NotNull Set<File> unique,boolean supportsDependencyGraph){\n  File folder=library.getFolder();\n  if (unique.contains(folder)) {\n    return;\n  }\n  unique.add(folder);\n  ModuleDependency mainDependency=null;\n  String gradleProjectPath=library.getProject();\n  if (isNotEmpty(gradleProjectPath)) {\n    mainDependency=addAndroidModule(library,gradleProjectPath,dependencies,scope,unique,supportsDependencyGraph);\n  }\n  if (mainDependency == null) {\n    dependencies.add(createLibraryDependency(library,scope));\n    addTransitiveDependencies(library,dependencies,scope,unique,supportsDependencyGraph);\n  }\n else {\n    LibraryDependency backup=createLibraryDependency(library,scope);\n    mainDependency.setBackupDependency(backup);\n  }\n}\n", "nl": "Add an Android library, along with any recursive library dependencies"}
{"code": "public ClassPath(@Nonnull Iterable<DexFile> classPath,boolean checkPackagePrivateAccess){\n  Iterable<DexFile> dexFiles=Iterables.concat(classPath,Lists.newArrayList(getBasicClasses()));\n  unknownClass=new UnknownClassProto(this);\n  loadedClasses.put(unknownClass.getType(),unknownClass);\n  this.checkPackagePrivateAccess=checkPackagePrivateAccess;\n  loadPrimitiveType(\"Z\");\n  loadPrimitiveType(\"B\");\n  loadPrimitiveType(\"S\");\n  loadPrimitiveType(\"C\");\n  loadPrimitiveType(\"I\");\n  loadPrimitiveType(\"J\");\n  loadPrimitiveType(\"F\");\n  loadPrimitiveType(\"D\");\n  loadPrimitiveType(\"L\");\n  for (  DexFile dexFile : dexFiles) {\n    for (    ClassDef classDef : dexFile.getClasses()) {\n      ClassDef prev=availableClasses.get(classDef.getType());\n      if (prev == null) {\n        availableClasses.put(classDef.getType(),classDef);\n      }\n    }\n  }\n}\n", "nl": "Creates a new ClassPath instance that can load classes from the given dex files"}
{"code": "private Map<String,ChartObject> buildRange(List<ChartObject> base,Period period){\n  final LongSummaryStatistics statistics=base.stream().mapToLong(null).summaryStatistics();\n  final DateTime start=new DateTime(statistics.getMin());\n  final DateTime end=new DateTime(statistics.getMax());\n  DateTime intermediate=start;\n  final LinkedHashMap<String,ChartObject> map=new LinkedHashMap<>();\n  if (base.isEmpty())   return map;\n  while (intermediate.isBefore(end)) {\n    map.put(intermediate.toString(DATE_PATTERN),createChartObject(base.get(0)));\nswitch (period) {\ncase DAY:\n      intermediate=intermediate.plusDays(1);\n    break;\ncase WEEK:\n  intermediate=intermediate.plusDays(1);\nbreak;\ncase MONTH:\nintermediate=intermediate.plusMonths(1);\nbreak;\n}\n}\nmap.put(end.toString(DATE_PATTERN),createChartObject(base.get(0)));\nreturn map;\n}\n", "nl": "Create ranged empty timeline billet"}
{"code": "static Type<?> parseTypeDescriptor(final String typeDescriptor) throws InvalidTypeDescriptorException {\n  final ClassLoader cl=Thread.currentThread().getContextClassLoader();\n  StringBuilder descriptor=new StringBuilder(typeDescriptor);\n  int split=descriptor.indexOf(\"<\");\n  if (split >= 0) {\n    String className=descriptor.substring(0,split);\n    if (!descriptor.subSequence(descriptor.length() - 1,descriptor.length()).equals(\">\")) {\n      throw new InvalidTypeDescriptorException();\n    }\n else {\n      descriptor.setLength(descriptor.length() - 1);\n      descriptor.replace(0,split + 1,\"\");\n    }\n    String[] subDescriptors=splitTypeArguments(descriptor.toString());\n    Type<?>[] typeArguments=new Type<?>[subDescriptors.length];\n    int index=-1;\n    for (    String subDescriptor : subDescriptors) {\n      typeArguments[++index]=parseTypeDescriptor(subDescriptor);\n    }\n    return TypeFactory.valueOf(loadClass(className,cl),typeArguments);\n  }\n else {\n    return TypeFactory.valueOf(loadClass(typeDescriptor,cl));\n  }\n}\n", "nl": "Parses a type descriptor to produce the Type instance with a matching representation"}
{"code": "public static void saveToSdCard(List<Entry> entries,String path){\n  File sdcard=Environment.getExternalStorageDirectory();\n  File saved=new File(sdcard,path);\n  if (!saved.exists()) {\n    try {\n      saved.createNewFile();\n    }\n catch (    IOException e) {\n      Log.e(LOG,e.toString());\n    }\n  }\n  try {\n    BufferedWriter buf=new BufferedWriter(new FileWriter(saved,true));\n    for (    Entry e : entries) {\n      buf.append(e.getY() + \"#\" + e.getX());\n      buf.newLine();\n    }\n    buf.close();\n  }\n catch (  IOException e) {\n    Log.e(LOG,e.toString());\n  }\n}\n", "nl": "Saves an Array of Entries to the specified location on the sdcard"}
{"code": "public void read(IInputReader dataIndexReader) throws IOException {\n  for (  Object[] dataRecord : data) {\nswitch ((Character)dataRecord[1]) {\ncase 'i':\n      dataRecord[2]=dataIndexReader.readInt();\n    break;\ncase 'f':\n  dataRecord[2]=dataIndexReader.readFloat();\nbreak;\ncase 'l':\ndataRecord[2]=dataIndexReader.readLong();\nbreak;\ncase 'b':\ndataRecord[2]=(byte)dataIndexReader.read();\nbreak;\ncase 'B':\ndataRecord[2]=dataIndexReader.readByteByteInt();\nbreak;\ncase 'c':\ndataRecord[2]=dataIndexReader.readChar();\nbreak;\n}\n}\n}\n", "nl": "read the fixed part of the reads block"}
{"code": "protected void checkDirectoriesContainSameContent(File dir1,File dir2) throws DifferentDirectoryContentException {\n  try {\n    Collection<File> listFiles1=FileUtils.listFiles(dir1,null,true);\n    Collection<File> listFiles2=FileUtils.listFiles(dir2,null,true);\n    if (listFiles1.size() != listFiles2.size()) {\n      throw new DifferentDirectoryContentException(\"Different file list size\");\n    }\n else {\n      logger.debug(\"Same file list size\");\n    }\n    for (    File file1 : listFiles1) {\n      Path relativePath1=dir1.toPath().relativize(file1.toPath());\n      logger.debug(\"Test file: {}\",relativePath1);\n      File file2=new File(dir2,relativePath1.toString());\n      if (!file2.exists()) {\n        throw new DifferentDirectoryContentException(\"File: \" + file2.toString() + \" doesn't exist\");\n      }\n      if (file2.isFile() && !Files.equal(file1,file2)) {\n        throw new DifferentDirectoryContentException(\"File: \" + file2.toString() + \" has different content\");\n      }\n    }\n  }\n catch (  IOException e) {\n    throw new DifferentDirectoryContentException(\"Failed to compare \",e);\n  }\n}\n", "nl": "Checks that the two directories have the same structure and that their files content are the same"}
{"code": "public synchronized void close(){\n  try {\n    File file=new File(baseName);\n    InputStream is=new SequenceInputStream(outputList.elements());\n    AudioInputStream ais=new AudioInputStream(is,currentFormat,totBytes / currentFormat.getFrameSize());\n    if (false) {\n      System.out.println(\"Avail \" + ais.available());\n      System.out.println(\"totBytes \" + totBytes);\n      System.out.println(\"FS \" + currentFormat.getFrameSize());\n    }\n    System.out.println(\"Wrote synthesized speech to \" + baseName);\n    AudioSystem.write(ais,outputType,file);\n  }\n catch (  IOException ioe) {\n    System.err.println(\"Can't write audio to \" + baseName);\n  }\ncatch (  IllegalArgumentException iae) {\n    System.err.println(\"Can't write audio type \" + outputType);\n  }\n}\n", "nl": "Closes this audio player"}
{"code": "@Override public boolean onPreferenceClick(Preference preference){\n  if (!isResumed()) {\n    return false;\n  }\n  if (preference == mSyncEncryption && mProfileSyncService.isBackendInitialized()) {\n    if (mProfileSyncService.isPassphraseRequiredForDecryption()) {\n      displayPassphraseDialog();\n    }\n else {\n      displayPassphraseTypeDialog();\n      return true;\n    }\n  }\n else   if (preference == mManageSyncData) {\n    openDashboardTabInNewActivityStack();\n    return true;\n  }\n  return false;\n}\n", "nl": "Callback for OnPreferenceClickListener"}
{"code": "public IntFileGetterInMemory(File file) throws IOException {\n  limit=file.length() / 4;\n  data=new int[(int)((limit >>> BITS)) + 1][];\n  final int length0=1 << BITS;\n  for (int i=0; i < data.length; i++) {\n    int length=(i < data.length - 1 ? length0 : (int)(limit & BIT_MASK) + 1);\n    data[i]=new int[length];\n  }\n  try (InputStream ins=new BufferedInputStream(new FileInputStream(file));ProgressPercentage progress=new ProgressPercentage(\"Reading file: \" + file,limit)){\n    int whichArray=0;\n    int indexInArray=0;\n    int[] row=data[0];\n    for (long index=0; index < limit; index++) {\n      row[indexInArray]=((ins.read() & 0xFF) << 24) + (((ins.read()) & 0xFF) << 16) + (((ins.read()) & 0xFF) << 8)+ (ins.read() & 0xFF);\n      if (++indexInArray == length0) {\n        row=data[++whichArray];\n        indexInArray=0;\n      }\n      progress.setProgress(index);\n    }\n  }\n }\n", "nl": "int file getter in memory"}
{"code": "private void showDialog(){\n  int index=getValueIndex();\n  index=index < 0 ? 0 : index;\n  final int height=LIST_ITEM_HEIGHT * getEntries().length + LIST_PADDING * 2;\n  View parent=((View)mViewHolder.itemView.getParent().getParent().getParent());\n  int parentHeight=parent.getHeight();\n  if (height > parentHeight) {\n    mPopupWindow.setHeight(parentHeight - LIST_PADDING * 2);\n    mRecyclerView.setOverScrollMode(View.OVER_SCROLL_IF_CONTENT_SCROLLS);\n    mRecyclerView.scrollToPosition(index);\n  }\n else {\n    mRecyclerView.setOverScrollMode(View.OVER_SCROLL_NEVER);\n  }\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n    mPopupWindow.setElevation(48f);\n  }\n  mPopupWindow.setAnimationStyle(R.style.Animation_SimpleMenuCenter);\n  int width=mViewHolder.itemView.getWidth() - POPUP_PADDING_X * 2;\n  mPopupWindow.setWidth(width);\n  mPopupWindow.showAtLocation(mViewHolder.itemView,Gravity.CENTER_VERTICAL,0,0);\n}\n", "nl": "Show dialog"}
{"code": "public void openSelectedFiles(){\n  StringBuilder buf=new StringBuilder();\n  int count=0;\n  Set<String> openFiles=getCurrentlyOpenRemoteFiles();\n  for (  String fileName : getSelectedFiles()) {\n    if (openFiles.contains(fileName)) {\n      buf.append(\"toFront file='\").append(fileName).append(\"';\");\n    }\n else {\n      buf.append(\"open file='\").append(fileName).append(\"' readOnly=true;\");\n      count++;\n    }\n  }\n  if (count > 10) {\n    if (JOptionPane.showConfirmDialog(remoteServiceBrowser.getFrame(),\"Do you really want to open \" + count + \" new files?\",\"Confirm\",JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION)     return;\n  }\n  Director dir=remoteServiceBrowser.getDir();\n  dir.execute(buf.toString(),remoteServiceBrowser.getCommandManager());\n}\n", "nl": "open all currently selected files"}
{"code": "protected boolean needsAccessor(polyglot.types.MemberInstance inst){\n  if (inst.flags().isPrivate()) {\n    if (!Util.getSootType(inst.container()).equals(body.getMethod().getDeclaringClass().getType())) {\n      return true;\n    }\n  }\n else   if (inst.flags().isProtected()) {\n    if (Util.getSootType(inst.container()).equals(body.getMethod().getDeclaringClass().getType())) {\n      return false;\n    }\n    soot.SootClass currentClass=body.getMethod().getDeclaringClass();\n    if (currentClass.getSuperclass().getType().equals(Util.getSootType(inst.container()))) {\n      return false;\n    }\n    while (currentClass.hasOuterClass()) {\n      currentClass=currentClass.getOuterClass();\n      if (Util.getSootType(inst.container()).equals(currentClass.getType())) {\n        return false;\n      }\n else       if (Util.getSootType(inst.container()).equals(currentClass.getSuperclass().getType())) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return false;\n}\n", "nl": "needs accessors: when field or meth is private and in some other class when field or meth is protected and in"}
{"code": "public Configurator fromAsset(String assetName){\n  InputStream stream=null;\n  try {\n    stream=getContext().getAssets().open(assetName);\n    return new Configurator(assetName,true);\n  }\n catch (  IOException e) {\n    throw new FileNotFoundException(assetName + \" does not exist.\",e);\n  }\n finally {\n    try {\n      if (stream != null) {\n        stream.close();\n      }\n    }\n catch (    IOException e) {\n    }\n  }\n}\n", "nl": "Use an asset file as the pdf source"}
{"code": "@ApiMethod(path=\"{type}/{id}\",verb=ApiVerb.DELETE,description=\"Gets and deletes the entry from space with the provided id.\",produces={MediaType.APPLICATION_JSON_VALUE}) @RequestMapping(value=\"/{type}/{id}\",method=RequestMethod.DELETE,produces={MediaType.APPLICATION_JSON_VALUE}) public @ResponseBody Map<String,Object> deleteById(@ApiPathParam(name=\"type\",description=TYPE_DESCRIPTION) @PathVariable String type,@ApiPathParam(name=\"id\") @PathVariable String id) throws ObjectNotFoundException {\n  GigaSpace gigaSpace=ControllerUtils.xapCache.get();\n  Object typedBasedId=getTypeBasedIdObject(gigaSpace,type,id);\n  if (logger.isLoggable(Level.FINE))   logger.fine(\"creating takebyid query with type: \" + type + \" and id: \"+ id);\n  Object doc;\n  try {\n    doc=gigaSpace.takeById(new IdQuery<Object>(type,typedBasedId));\n  }\n catch (  DataAccessException e) {\n    throw translateDataAccessException(gigaSpace,e,type);\n  }\n  if (doc == null) {\n    doc=emptyObject;\n  }\n  try {\n    Map<String,Object> result=new HashMap<String,Object>();\n    result.put(\"status\",\"success\");\n    result.put(\"data\",ControllerUtils.mapper.readValue(ControllerUtils.mapper.writeValueAsString(doc),Map.class));\n    return result;\n  }\n catch (  IOException e) {\n    throw new RestException(e.getMessage());\n  }\n}\n", "nl": "REST DELETE by id request handler"}
{"code": "public static String generateRandomFinNumber(Delegator delegator,int length,boolean isId) throws GenericEntityException {\n  if (length > 19) {\n    length=19;\n  }\n  Random rand=new Random();\n  boolean isValid=false;\n  String number=null;\n  while (!isValid) {\n    number=\"\";\n    for (int i=0; i < length; i++) {\n      int randInt=rand.nextInt(9);\n      number=number + randInt;\n    }\n    if (isId) {\n      int check=UtilValidate.getLuhnCheckDigit(number);\n      number=number + check;\n      if (checkFinAccountNumber(number)) {\n        isValid=checkIsNumberInDatabase(delegator,number);\n      }\n    }\n else {\n      isValid=true;\n    }\n  }\n  return number;\n}\n", "nl": "Generate a random financial number"}
{"code": "public void createProjection(List<SelectColumn> columns){\n  ArrayList<Object> fieldValues=new ArrayList<Object>();\n  for (int i=0; i < columns.size(); i++) {\n    SelectColumn column=columns.get(i);\n    if (!column.isVisible())     continue;\n    QueryTableData columnTableData=column.getColumnTableData();\n    if (columnTableData == null) {\n      fieldValues.add(null);\n      continue;\n    }\n    IEntryPacket entry=getEntry(columnTableData.getTableIndex());\n    if (entry == null) {\n      fieldValues.add(null);\n    }\n else     if (column.isUid()) {\n      fieldValues.add(entry.getUID());\n    }\n else {\n      fieldValues.add(column.getFieldValue(entry));\n    }\n  }\n  setFieldsValues(fieldValues.toArray());\n}\n", "nl": "Create columns projection from the joined entries"}
{"code": "public static boolean writeFile(File file,InputStream stream,boolean append){\n  OutputStream o=null;\n  try {\n    makeDirs(file.getAbsolutePath());\n    o=new FileOutputStream(file,append);\n    byte data[]=new byte[1024];\n    int length=-1;\n    while ((length=stream.read(data)) != -1) {\n      o.write(data,0,length);\n    }\n    o.flush();\n    return true;\n  }\n catch (  FileNotFoundException e) {\n    throw new RuntimeException(\"FileNotFoundException occurred. \",e);\n  }\ncatch (  IOException e) {\n    throw new RuntimeException(\"IOException occurred. \",e);\n  }\n finally {\n    IOUtil.close(o);\n    IOUtil.close(stream);\n  }\n}\n", "nl": "write file"}
{"code": "private boolean canAddMember(){\n  int memberSize=getLegionMembers().size();\nswitch (getLegionLevel()) {\ncase 1:\n    return memberSize < LegionConfig.LEGION_LEVEL1_MAX_MEMBERS;\ncase 2:\n  return memberSize < LegionConfig.LEGION_LEVEL2_MAX_MEMBERS;\ncase 3:\nreturn memberSize < LegionConfig.LEGION_LEVEL3_MAX_MEMBERS;\ncase 4:\nreturn memberSize < LegionConfig.LEGION_LEVEL4_MAX_MEMBERS;\ncase 5:\nreturn memberSize < LegionConfig.LEGION_LEVEL5_MAX_MEMBERS;\ncase 6:\nreturn memberSize < LegionConfig.LEGION_LEVEL6_MAX_MEMBERS;\ncase 7:\nreturn memberSize < LegionConfig.LEGION_LEVEL7_MAX_MEMBERS;\ncase 8:\nreturn memberSize < LegionConfig.LEGION_LEVEL8_MAX_MEMBERS;\n}\nreturn false;\n}\n", "nl": "This method will return true if a legion is able to add a member"}
{"code": "@RequestMapping(value=\"/order/list\",method=RequestMethod.GET) public PageRespJson selectOrderList(@RequestParam(value=\"reqId\",required=false,defaultValue=StringConstant.ZERO) Integer reqId,@RequestParam(value=\"start\",required=false) Integer start,@RequestParam(value=\"rows\",required=false) Integer rows,@RequestParam(value=\"orderNo\",required=false) String orderNo,@RequestParam(value=\"orderType\",required=false) Integer orderType,@RequestParam(value=\"customerName\",required=false) String customerName,@RequestParam(value=\"customerMobile\",required=false) String customerMobile,@RequestParam(value=\"customerIdNumber\",required=false) String customerIdNumber,@RequestParam(value=\"skuCode\",required=false) String skuCode,@RequestParam(value=\"startDate\",required=false) String startDate,@RequestParam(value=\"endDate\",required=false) String endDate){\n  OrderReqDto reqDto=new OrderReqDto(reqId,start,rows);\n  reqDto.setOrderNo(orderNo);\n  reqDto.setOrderType(orderType);\n  reqDto.setCustomerName(customerName);\n  reqDto.setCustomerMobile(customerMobile);\n  reqDto.setCustomerIdNumber(customerIdNumber);\n  reqDto.setSkuCode(skuCode);\n  reqDto.setStartDate(startDate);\n  reqDto.setEndDate(endDate);\n  try {\n    List<Order> orderList=orderDao.searchOrder(reqDto);\n    int count=orderDao.searchOrderCount(reqDto);\n    return PageRespJson.buildSuccessResponse(orderList,reqId,count);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return PageRespJson.buildFailureResponse(StringUtils.getValidString(e.getMessage()),reqId);\n  }\n}\n", "nl": "Select orders by search criteria"}
{"code": "public UpdateItem addItem(final long readUid,int readWeight,final Integer[] classIds) throws IOException {\n  if (classIds.length != numberOfClassifications)   throw new IOException(\"classIds has wrong length: \" + classIds.length + \", should be: \"+ numberOfClassifications);\n  UpdateItem item=new UpdateItem(numberOfClassifications);\n  item.setReadUId(readUid);\n  add(item);\n  readUid2UpdateItem.put(readUid,item);\n  if (readWeight == 0) {\n    readWeight=1;\n  }\n  for (int i=0; i < numberOfClassifications; i++) {\n    final int id=classIds[i];\n    if (id != 0) {\n      item.setClassId(i,id);\n      UpdateItem lastInClass=last[i].get(id);\n      if (lastInClass == null) {\n        first[i].put(id,item);\n        last[i].put(id,item);\n        size[i].put(id,readWeight);\n      }\n else {\n        lastInClass.setNextInClassifaction(i,readUid);\n        last[i].put(id,item);\n        size[i].put(id,size[i].get(id) + readWeight);\n      }\n    }\n  }\n  return item;\n}\n", "nl": "add an item"}
{"code": "@Override public boolean canSetParameter(String name,Object state){\n  if (state == null) {\n    return true;\n  }\n  if (state instanceof Boolean) {\n    boolean value=((Boolean)state).booleanValue();\n    if (name.equalsIgnoreCase(Constants.DOM_NAMESPACES) || name.equalsIgnoreCase(Constants.DOM_SPLIT_CDATA) || name.equalsIgnoreCase(Constants.DOM_DISCARD_DEFAULT_CONTENT)|| name.equalsIgnoreCase(Constants.DOM_XMLDECL)|| name.equalsIgnoreCase(Constants.DOM_WELLFORMED)|| name.equalsIgnoreCase(Constants.DOM_INFOSET)|| name.equalsIgnoreCase(Constants.DOM_ENTITIES)|| name.equalsIgnoreCase(Constants.DOM_CDATA_SECTIONS)|| name.equalsIgnoreCase(Constants.DOM_COMMENTS)|| name.equalsIgnoreCase(Constants.DOM_FORMAT_PRETTY_PRINT)|| name.equalsIgnoreCase(Constants.DOM_NAMESPACE_DECLARATIONS)) {\n      return true;\n    }\n else     if (name.equalsIgnoreCase(Constants.DOM_CANONICAL_FORM) || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA) || name.equalsIgnoreCase(Constants.DOM_VALIDATE)|| name.equalsIgnoreCase(Constants.DOM_CHECK_CHAR_NORMALIZATION)|| name.equalsIgnoreCase(Constants.DOM_DATATYPE_NORMALIZATION)|| name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)) {\n      return !value;\n    }\n else     if (name.equalsIgnoreCase(Constants.DOM_ELEMENT_CONTENT_WHITESPACE) || name.equalsIgnoreCase(Constants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {\n      return value;\n    }\n  }\n else   if (name.equalsIgnoreCase(Constants.DOM_ERROR_HANDLER) && state == null || state instanceof DOMErrorHandler) {\n    return true;\n  }\n  return false;\n}\n", "nl": "DOM L3-EXPERIMENTAL: Check if parameter can be set"}
{"code": "private void load(String fileName) throws IOException, MaryConfigurationException {\n  DataInputStream dis=null;\n  try {\n    dis=new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)));\n  }\n catch (  FileNotFoundException e) {\n    Log.d(Mary.LOG,\"File [\" + fileName + \"] was not found.\");\n    throw new MaryConfigurationException(\"File [\" + fileName + \"] was not found.\");\n  }\n  hdr=new MaryHeader(dis);\n  if (hdr.getType() != MaryHeader.LISTENERFEATS) {\n    Log.d(Mary.LOG,\"File [\" + fileName + \"] is not a valid Mary Units file.\");\n    throw new MaryConfigurationException(\"File [\" + fileName + \"] is not a valid Mary Units file.\");\n  }\n  numberOfUnits=dis.readInt();\n  if (numberOfUnits < 0) {\n    Log.d(Mary.LOG,\"File [\" + fileName + \"] has a negative number of units. Aborting.\");\n    throw new MaryConfigurationException(\"File [\" + fileName + \"] has a negative number of units. Aborting.\");\n  }\n  hnmSignals=new HntmSpeechSignal[numberOfUnits];\n  for (int i=0; i < numberOfUnits; i++) {\n    hnmSignals[i]=new HntmSpeechSignal(0,0,0);\n    hnmSignals[i].read(dis,HntmAnalyzerParams.WAVEFORM);\n  }\n  System.out.println();\n}\n", "nl": "Load the given feature file"}
{"code": "public static void main(String[] args){\n  byte[] json=\"{\\\"name\\\":\\\"Elvis\\\"}\".getBytes(StandardCharsets.UTF_8);\n  JsonParser parser=new JsonParser(StandardCharsets.UTF_8);\n  int pos=0;\n  int event;\n  do {\n    while ((event=parser.nextEvent()) == JsonEvent.NEED_MORE_INPUT) {\n      pos+=parser.getFeeder().feed(json,pos,json.length - pos);\n      if (pos == json.length) {\n        parser.getFeeder().done();\n      }\n    }\n    System.out.println(\"JSON event: \" + event);\n    if (event == JsonEvent.ERROR) {\n      throw new IllegalStateException(\"Syntax error in JSON text\");\n    }\n    if (event == JsonEvent.VALUE_STRING) {\n      System.out.println(\"VALUE: \" + parser.getCurrentString());\n    }\n  }\n while (event != JsonEvent.EOF);\n}\n", "nl": "The main program"}
{"code": "private boolean verifyChecksum(byte[] data,int offset,int length){\n  if ((length & 3) != 0 || (length <= 4)) {\n    return false;\n  }\n  long chksum=0;\n  int count=length - 4;\n  long check;\n  int i;\n  for (i=offset; i < count; i+=4) {\n    check=data[i] & 0xff;\n    check|=data[i + 1] << 8 & 0xff00;\n    check|=data[i + 2] << 0x10 & 0xff0000;\n    check|=data[i + 3] << 0x18 & 0xff000000;\n    chksum^=check;\n  }\n  check=data[i] & 0xff;\n  check|=data[i + 1] << 8 & 0xff00;\n  check|=data[i + 2] << 0x10 & 0xff0000;\n  check|=data[i + 3] << 0x18 & 0xff000000;\n  check=data[i] & 0xff;\n  check|=data[i + 1] << 8 & 0xff00;\n  check|=data[i + 2] << 0x10 & 0xff0000;\n  check|=data[i + 3] << 0x18 & 0xff000000;\n  return 0 == chksum;\n}\n", "nl": "Verify checksum in a packet"}
{"code": "public static Matrix computeDoubleCenteringOfSquaredMatrix(Matrix matrix){\n  int size=matrix.getColumnDimension();\n  Matrix result=new Matrix(matrix.getColumnDimension(),matrix.getRowDimension());\n  for (int i=0; i < size; i++) {\n    for (int j=0; j < size; j++) {\n      double v1=0;\n      for (int k=0; k < size; k++) {\n        v1+=matrix.get(k,j) * matrix.get(k,j) / size;\n      }\n      double v2=0;\n      for (int k=0; k < size; k++) {\n        v2+=matrix.get(i,k) * matrix.get(i,k) / size;\n      }\n      double v3=0;\n      for (int k=0; k < size; k++) {\n        for (int l=0; l < size; l++) {\n          v3+=matrix.get(k,l) * matrix.get(k,l) / (size * size);\n        }\n      }\n      double v4=matrix.get(i,j);\n      result.set(i,j,0.5 * (v1 + v2 - v3 - (v4 * v4)));\n    }\n  }\n  return result;\n}\n", "nl": "compute centered inner product matrix"}
{"code": "public short[] interpolate(int oldSampleRate,int newSampleRate,short[] samples){\n  if (oldSampleRate == newSampleRate) {\n    return samples;\n  }\n  int newLength=Math.round(((float)samples.length / oldSampleRate * newSampleRate));\n  float lengthMultiplier=(float)newLength / samples.length;\n  short[] interpolatedSamples=new short[newLength];\n  for (int i=0; i < newLength; i++) {\n    float currentPosition=i / lengthMultiplier;\n    int nearestLeftPosition=(int)currentPosition;\n    int nearestRightPosition=nearestLeftPosition + 1;\n    if (nearestRightPosition >= samples.length) {\n      nearestRightPosition=samples.length - 1;\n    }\n    float slope=samples[nearestRightPosition] - samples[nearestLeftPosition];\n    float positionFromLeft=currentPosition - nearestLeftPosition;\n    interpolatedSamples[i]=(short)(slope * positionFromLeft + samples[nearestLeftPosition]);\n  }\n  return interpolatedSamples;\n}\n", "nl": "Do interpolation on the samples according to the original and destinated sample rates"}
{"code": "private void init(){\n  InputStream in=null;\n  props=new Properties();\n  try {\n    URI uri=getClass().getClassLoader().getResource(PROPERTY_FILE_NAME).toURI();\n    File file=new File(uri);\n    in=new FileInputStream(file);\n    props.load(in);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  URISyntaxException e) {\n    e.printStackTrace();\n  }\n finally {\n    CarbonUtil.closeStreams(in);\n  }\n}\n", "nl": "this method will read the property file for required details like dbName, tableName, etc"}
{"code": "private void startList(Attributes attributes){\n  List listTag=null;\n  if (!mParagraphStyles.isEmpty()) {\n    AccumulatedParagraphStyle currentStyle=mParagraphStyles.peek();\n    ParagraphType type=currentStyle.getType();\n    int indent=currentStyle.getAbsoluteIndent();\n    boolean isIndentation=isIndentation(attributes);\n    if (type.isIndentation() || isIndentation) {\n      listTag=new UL(indent,true);\n    }\n else     if (type.isNumbering()) {\n      listTag=new OL(indent,false);\n    }\n else     if (type.isBullet()) {\n      listTag=new UL(indent,false);\n    }\n  }\n else {\n    listTag=new UL(0,false);\n  }\n  if (listTag != null)   start(listTag);\n}\n", "nl": "Handles LI tags"}
{"code": "public Date parse(String rawDate) throws DateParseException {\n  for (  Locale locale : LOCALES) {\n    for (    String format : DATE_FORMATS) {\n      DateTimeFormatter formatter=DateTimeFormat.forPattern(format).withLocale(locale).withDefaultYear(DateConstants.NO_YEAR);\n      try {\n        LocalDate parsedDate=formatter.parseLocalDate(rawDate);\n        int dayOfMonth=parsedDate.getDayOfMonth();\n        @MonthInt int month=parsedDate.getMonthOfYear();\n        int year=parsedDate.getYear();\n        if (year == DateConstants.NO_YEAR) {\n          return Date.on(dayOfMonth,month);\n        }\n else {\n          return Date.on(dayOfMonth,month,year);\n        }\n      }\n catch (      IllegalArgumentException e) {\n        if (BuildConfig.DEBUG && isNotAboutInvalidFormat(e)) {\n          e.printStackTrace();\n        }\n      }\n    }\n  }\n  throw new DateParseException(\"Unable to parse \" + rawDate);\n}\n", "nl": "Parses the given date using the default date formats"}
{"code": "int findCenterViewIndex(){\n  int count=getChildCount();\n  int index=RecyclerView.NO_POSITION;\n  int closest=Integer.MAX_VALUE;\n  int centerY=getCenterYPos();\n  for (int i=0; i < count; ++i) {\n    View child=getChildAt(i);\n    int childCenterY=mTicklableRecyclerView.getTop() + ViewPropertiesHelper.getCenterYPos(child);\n    int distance=Math.abs(centerY - childCenterY);\n    if (distance < closest) {\n      closest=distance;\n      index=i;\n    }\n  }\n  if (index == RecyclerView.NO_POSITION) {\n    throw new IllegalStateException(\"Can\\'t find central view.\");\n  }\n else {\n    return index;\n  }\n}\n", "nl": "Find a view closest to center, return its index (relative the children views)"}
{"code": "private void addApplicationCallbackMethods(){\n  if (!this.callbackFunctions.containsKey(applicationClass.getName()))   return;\n  if (applicationClass.isAbstract())   return;\n  if (applicationClass.isPhantom()) {\n    System.err.println(\"Skipping possible application callbacks in \" + \"phantom class \" + applicationClass);\n    return;\n  }\n  for (  String methodSig : this.callbackFunctions.get(applicationClass.getName())) {\n    SootMethodAndClass methodAndClass=SootMethodRepresentationParser.v().parseSootMethodString(methodSig);\n    if (AndroidEntryPointConstants.getApplicationLifecycleMethods().contains(methodAndClass.getSubSignature()))     continue;\n    SootMethod method=findMethod(Scene.v().getSootClass(methodAndClass.getClassName()),methodAndClass.getSubSignature());\n    if (method == null)     continue;\n    if (method.getDeclaringClass().getName().startsWith(\"android.\") || method.getDeclaringClass().getName().startsWith(\"java.\"))     continue;\n    Local local=this.localVarsForClasses.get(methodAndClass.getClassName());\n    if (local == null) {\n      System.err.println(\"Could not create call to application callback \" + method.getSignature() + \". Local was null.\");\n      continue;\n    }\n    JNopStmt thenStmt=new JNopStmt();\n    createIfStmt(thenStmt);\n    buildMethodCall(method,body,local,generator);\n    body.getUnits().add(thenStmt);\n  }\n}\n", "nl": "Adds calls to the callback methods defined in the application class"}
{"code": "public static PkgInfo recvPackage(InputStream in,byte expect_cmd,long expect_body_len) throws IOException {\n  PkgHeader header=recvHeader(in,expect_cmd,expect_body_len);\n  if (header.status != 0) {\n    return new PkgInfo(header,null);\n  }\n  byte[] body=new byte[header.body_len];\n  int totalBytes=0;\n  int remainBytes=header.body_len;\n  int bytes;\n  while (totalBytes < header.body_len) {\n    if ((bytes=in.read(body,totalBytes,remainBytes)) < 0) {\n      break;\n    }\n    totalBytes+=bytes;\n    remainBytes-=bytes;\n  }\n  if (totalBytes != header.body_len) {\n    throw new IOException(\"recv package size \" + totalBytes + \" != \"+ header.body_len);\n  }\n  return new PkgInfo(header,body);\n}\n", "nl": "receive whole pack"}
{"code": "@deprecated public StringTokenizer(String str,UnicodeSet delim,boolean returndelims,boolean coalescedelims){\n  this.m_source_=str;\n  this.m_length_=str.length();\n  if (delim == null) {\n    this.m_delimiters_=EMPTY_DELIMITER_;\n  }\n else {\n    this.m_delimiters_=delim;\n  }\n  this.m_returnDelimiters_=returndelims;\n  this.m_coalesceDelimiters_=coalescedelims;\n  this.m_tokenOffset_=-1;\n  this.m_tokenSize_=-1;\n  if (this.m_length_ == 0) {\n    this.m_nextOffset_=-1;\n  }\n else {\n    this.m_nextOffset_=0;\n    if (!returndelims) {\n      this.m_nextOffset_=getNextNonDelimiter(0);\n    }\n  }\n}\n", "nl": "/*    "}
{"code": "private void calcAngles(){\n  mDrawAngles=new float[mData.getYValCount()];\n  mAbsoluteAngles=new float[mData.getYValCount()];\n  float yValueSum=mData.getYValueSum();\n  List<IPieDataSet> dataSets=mData.getDataSets();\n  int cnt=0;\n  for (int i=0; i < mData.getDataSetCount(); i++) {\n    IPieDataSet set=dataSets.get(i);\n    for (int j=0; j < set.getEntryCount(); j++) {\n      mDrawAngles[cnt]=calcAngle(Math.abs(set.getEntryForIndex(j).getVal()),yValueSum);\n      if (cnt == 0) {\n        mAbsoluteAngles[cnt]=mDrawAngles[cnt];\n      }\n else {\n        mAbsoluteAngles[cnt]=mAbsoluteAngles[cnt - 1] + mDrawAngles[cnt];\n      }\n      cnt++;\n    }\n  }\n}\n", "nl": "calculates the needed angles for the chart slices"}
{"code": "public boolean hasRequiredMembers(){\n  int memberSize=getLegionMembers().size();\nswitch (getLegionLevel()) {\ncase 1:\n    return memberSize >= LegionConfig.LEGION_LEVEL2_REQUIRED_MEMBERS;\ncase 2:\n  return memberSize >= LegionConfig.LEGION_LEVEL3_REQUIRED_MEMBERS;\ncase 3:\nreturn memberSize >= LegionConfig.LEGION_LEVEL4_REQUIRED_MEMBERS;\ncase 4:\nreturn memberSize >= LegionConfig.LEGION_LEVEL5_REQUIRED_MEMBERS;\ncase 5:\nreturn memberSize >= LegionConfig.LEGION_LEVEL6_REQUIRED_MEMBERS;\ncase 6:\nreturn memberSize >= LegionConfig.LEGION_LEVEL7_REQUIRED_MEMBERS;\ncase 7:\nreturn memberSize >= LegionConfig.LEGION_LEVEL8_REQUIRED_MEMBERS;\n}\nreturn false;\n}\n", "nl": "This method will check whether a legion has enough members to level up"}
{"code": "protected void wrapContent(){\n  mWidget.setMinWidth(100);\n  mWidget.setMinHeight(100);\n  int tw=mWidget.getMinWidth();\n  int th=mWidget.getMinHeight();\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setWidth(tw);\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setHeight(th);\n  }\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getWidth() <= mWidget.getMinWidth()) {\n      mWidget.setHorizontalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getHeight() <= mWidget.getMinHeight()) {\n      mWidget.setVerticalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  mWidget.setBaselineDistance(0);\n}\n", "nl": "Utility method computing the size of the widget if dimensions are set to wrap_content, using the default font"}
{"code": "private SyncResult taskDetailsToSyncResult(JSONObject taskDetails){\n  try {\n    JSONObject results=taskDetails.getJSONObject(\"result\");\n    JSONArray changesJSON=results.getJSONArray(\"changes\");\n    JSONArray conflictsJSON=results.getJSONArray(\"conflicts\");\n    String serializedLibrary=results.getString(\"library\");\n    SyncResult result=new SyncResult();\n    for (int i=0; i < changesJSON.length(); i++) {\n      result.getChanges().add(changesJSON.getString(i));\n    }\n    for (int i=0; i < conflictsJSON.length(); i++) {\n      result.getConflicts().add(conflictsJSON.getString(i));\n    }\n    result.setSerializedLibrary(serializedLibrary);\n    result.setSuccessful(true);\n    return result;\n  }\n catch (  JSONException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Convert a task detail to a sync result (only call this when the sync is complete without errors)"}
{"code": "public void paintNames(Graphics g0){\n  final Graphics2D g=(Graphics2D)g0;\n  final Rectangle visibleRect=getVisibleRect();\n  final Rectangle2D drawRect=new Rectangle2D.Double();\n  g.setColor(Color.WHITE);\n  g.fillRect(0,0,getWidth(),getHeight());\n  g.setBackground(Color.WHITE);\n  if (sequenceFont.getSize() > 14)   sequenceFont=sequenceFont.deriveFont(14.0f);\n  g.setFont(sequenceFont);\n  boolean showText=(sequenceFont.getSize() > 6);\n  if (showText)   g.setColor(Color.BLACK);\n else   g.setColor(Color.GRAY);\n  if (alignment != null && !alignment.getRowCompressor().isEnabled()) {\n    int minVisibleRow=(int)Math.max(0,(visibleRect.getY() / cellHeight));\n    int maxVisibleRow=(int)Math.min(alignment.getNumberOfSequences() - 1,(visibleRect.getY() + visibleRect.getHeight()) / cellHeight);\n    for (int row=minVisibleRow; row <= maxVisibleRow; row++) {\n      String name=alignment.getName(row);\n      int y=(int)Math.round(getY(row)) - 2;\n      if (showText)       g.drawString(name,Math.round(getX(0)),y - (int)(cellHeight - sequenceFont.getSize()) / 2);\n else {\n        drawRect.setRect(0,getY(row) - cellHeight + 2,getX(name.length()),Math.max(1,cellHeight - 1));\n        g.fill(drawRect);\n      }\n    }\n  }\n}\n", "nl": "Paints the names of the alignment"}
{"code": "public int compareTo(GenericEntity that){\n  if (that == null)   return -1;\n  int tempResult=this.entityName.compareTo(that.entityName);\n  if (tempResult != 0)   return tempResult;\n  Iterator<ModelField> pkIter=getModelEntity().getPksIterator();\n  while (pkIter.hasNext()) {\n    ModelField curField=pkIter.next();\n    tempResult=compareToFields(that,curField.getName());\n    if (tempResult != 0)     return tempResult;\n  }\n  Iterator<ModelField> nopkIter=getModelEntity().getNopksIterator();\n  while (nopkIter.hasNext()) {\n    ModelField curField=nopkIter.next();\n    if (!curField.getIsAutoCreatedInternal()) {\n      tempResult=compareToFields(that,curField.getName());\n      if (tempResult != 0)       return tempResult;\n    }\n  }\n  return tempResult;\n}\n", "nl": "Compares this GenericEntity to the passed object"}
{"code": "public void commit() throws GenericDataSourceException {\n  if (_connection == null) {\n    return;\n  }\n  if (Debug.verboseOn())   Debug.logVerbose(\"SQLProcessor:commit() _manualTX=\" + _manualTX,module);\n  if (_manualTX) {\n    try {\n      _connection.commit();\n      if (Debug.verboseOn())       Debug.logVerbose(\"SQLProcessor:commit() : called commit on connection\",module);\n    }\n catch (    SQLException sqle) {\n      Debug.logError(sqle,\"Error committing transaction: \" + sqle.toString());\n      try {\n        rollback();\n      }\n catch (      GenericDataSourceException rbsqle) {\n        Debug.logError(rbsqle,\"Got another error when trying to rollback after error committing transaction: \" + sqle.toString());\n      }\n      throw new GenericDataSourceException(\"SQL Exception occurred on commit\",sqle);\n    }\n  }\n}\n", "nl": "Commit all modifications"}
{"code": "public String toString(){\n  StringBuilder buffer=new StringBuilder();\n  buffer.append(getQueryName()).append(\"\\t\");\n  buffer.append(getFlag()).append(\"\\t\");\n  buffer.append(getRefName()).append(\"\\t\");\n  buffer.append(getPos()).append(\"\\t\");\n  buffer.append(getMapQuality()).append(\"\\t\");\n  buffer.append(getCigarString()).append(\"\\t\");\n  buffer.append(getRNext()).append(\"\\t\");\n  buffer.append(getPNext()).append(\"\\t\");\n  buffer.append(getTLength()).append(\"\\t\");\n  buffer.append(getSequence()).append(\"\\t\");\n  buffer.append(getQuality());\n  for (  String a : getOptionalFields().keySet()) {\n    Object value=getOptionalFields().get(a);\n    buffer.append(\"\\t\").append(a).append(\":\").append(getType(value)).append(\":\").append(value);\n  }\n  return buffer.toString();\n}\n", "nl": "return string representation"}
{"code": "public RequestFailedException bad(String param,String reason,Throwable cause){\n  StringBuilder sb=new StringBuilder();\n  buildPath(sb);\n  if (param != null) {\n    Param p=type.params.get(param);\n    if (p == null && param.indexOf('[') == -1) {\n      assert false : \"name \\\"\" + param + \"\\\" is not a known parameter\";\n    }\n    if (sb.length() > 0) {\n      sb.append(\" > \");\n    }\n    sb.append(param);\n  }\n  RequestFailedException e=new RequestFailedException(this,param,sb.toString(),reason);\n  if (cause != null) {\n    e.initCause(cause);\n  }\n  return e;\n}\n", "nl": "Constructs the exception to throw representing this failure"}
{"code": "public void processKeepAliveRespond(LeaseKeepAliveResponse leaseKeepAliveResponse){\n  long id=leaseKeepAliveResponse.getID();\n  Lease lease=this.keepAlives.get(id);\n  if (lease != null) {\nsynchronized (lease) {\n      if (leaseKeepAliveResponse.getTTL() <= 0) {\n        if (lease != null && lease.isContainHandler()) {\n          lease.getEtcdLeaseHandler().onLeaseExpired(id);\n        }\n        removeLease(id);\n      }\n else {\n        long nextKeepAlive=System.currentTimeMillis() + 1000 + leaseKeepAliveResponse.getTTL() * 1000 / 3;\n        lease.setNextKeepAlive(nextKeepAlive);\n        lease.setDeadLine(System.currentTimeMillis() + leaseKeepAliveResponse.getTTL() * 1000);\n      }\n    }\n  }\n}\n", "nl": "This method update the deadline and NextKeepAlive time"}
{"code": "private boolean addViewFromPreviousActivity(){\n  if (mCurrentContentView.getChildCount() == 0) {\n    mPreviousActivity=null;\n    mPreviousContentView=null;\n    return false;\n  }\n  SwipeBackApplication application=(SwipeBackApplication)mCurrentWindow.getContext().getApplicationContext();\n  mPreviousActivity=application.getActivityLifecycleHelper().getPreActivity();\n  if (mPreviousActivity == null) {\n    mPreviousActivity=null;\n    mPreviousContentView=null;\n    return false;\n  }\n  ViewGroup previousActivityContainer=getContentView(mPreviousActivity.getWindow());\n  if (previousActivityContainer == null || previousActivityContainer.getChildCount() == 0) {\n    mPreviousActivity=null;\n    mPreviousContentView=null;\n    return false;\n  }\n  mPreviousContentView=(ViewGroup)previousActivityContainer.getChildAt(0);\n  previousActivityContainer.removeView(mPreviousContentView);\n  mCurrentContentView.addView(mPreviousContentView,0);\n  return true;\n}\n", "nl": "Remove view from previous Activity and add into current Activity"}
{"code": "GraqlShell(String historyFilename,String namespace,GraqlClient client,URI uri,Optional<List<String>> queryStrings) throws Throwable {\n  this.historyFilename=historyFilename;\n  try {\n    console=new ConsoleReader(System.in,System.out);\n    Signal signal=new Signal(\"INT\");\n    GraqlSignalHandler signalHandler=new GraqlSignalHandler(this);\n    Signal.handle(signal,signalHandler);\n    try {\n      session=client.connect(this,uri).get();\n    }\n catch (    ExecutionException e) {\n      throw e.getCause();\n    }\n    sendJson(Json.object(ACTION,ACTION_NAMESPACE,NAMESPACE,namespace));\n    start(queryStrings);\n  }\n  finally {\n    client.close();\n    console.flush();\n  }\n}\n", "nl": "Create a new Graql shell"}
{"code": "public static void copyJarsFromAssets(final Context cxt,final String[] names){\n  if (debug) {\n    Log.d(TAG,\"copyJarsFromAssets(\" + Arrays.deepToString(names) + \")\");\n  }\n  final File dexDir=cxt.getDir(DIR_SUBDEX,Context.MODE_PRIVATE);\n  File apkFile=new File(cxt.getApplicationInfo().sourceDir);\n  final boolean shouldInit=shouldDexOpt(apkFile,dexDir,names);\n  if (shouldInit) {\n    try {\n      copyToInternal(cxt,dexDir,names);\n      appendOdexesToClassPath(cxt,dexDir,names);\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n else {\n    if (!inAppended(names)) {\n      appendOdexesToClassPath(cxt,dexDir,names);\n    }\n  }\n}\n", "nl": "MUST be called on non-Main Thread"}
{"code": "private boolean resizeAndSaveImage(int maxWidth,int maxHeight) throws IOException {\n  boolean saved=false;\n  File targetFile=configuration.diskCache.get(uri);\n  if (targetFile != null && targetFile.exists()) {\n    ImageSize targetImageSize=new ImageSize(maxWidth,maxHeight);\n    DisplayImageOptions specialOptions=new DisplayImageOptions.Builder().cloneFrom(options).imageScaleType(ImageScaleType.IN_SAMPLE_INT).build();\n    ImageDecodingInfo decodingInfo=new ImageDecodingInfo(memoryCacheKey,Scheme.FILE.wrap(targetFile.getAbsolutePath()),uri,targetImageSize,ViewScaleType.FIT_INSIDE,getDownloader(),specialOptions);\n    Bitmap bmp=decoder.decode(decodingInfo);\n    if (bmp != null && configuration.processorForDiskCache != null) {\n      L.d(LOG_PROCESS_IMAGE_BEFORE_CACHE_ON_DISK,memoryCacheKey);\n      bmp=configuration.processorForDiskCache.process(bmp);\n      if (bmp == null) {\n        L.e(ERROR_PROCESSOR_FOR_DISK_CACHE_NULL,memoryCacheKey);\n      }\n    }\n    if (bmp != null) {\n      saved=configuration.diskCache.save(uri,bmp);\n      bmp.recycle();\n    }\n  }\n  return saved;\n}\n", "nl": "Decodes image file into Bitmap, resize it and save it back"}
{"code": "public static <T>void addService(ProviderConfig<T> providerConfig) throws RpcException {\n  if (StringUtils.isBlank(providerConfig.getUrl())) {\n    providerConfig.setUrl(getServiceUrl(providerConfig));\n  }\n else   if (providerConfig.isSupported() && !getServiceUrl(providerConfig).equals(providerConfig.getUrl())) {\n    logger.warn(\"customized [serviceName] cannot provide service to OCTO invoker \" + \"unless set the [serviceName] to canonical name of the interface class \" + \"or just keep [serviceName] config to blank. more help refer to: \"+ ConfigManagerLoader.getConfigManager().getStringValue(\"pigeon.help.provider.octo.url\",\"http://wiki.sankuai.com/pages/viewpage.action?pageId=606809899\"));\n  }\n  try {\n    ServicePublisher.addService(providerConfig);\n    ServerConfig serverConfig=ProviderBootStrap.startup(providerConfig);\n    providerConfig.setServerConfig(serverConfig);\n    ServicePublisher.publishService(providerConfig,false);\n  }\n catch (  RegistryException t) {\n    throw new RpcException(\"error while adding service:\" + providerConfig,t);\n  }\ncatch (  Throwable t) {\n    throw new RpcException(\"error while adding service:\" + providerConfig,t);\n  }\n}\n", "nl": "add the service to pigeon and publish the service to registry"}
{"code": "private static int[] computeDetectionThreshold(int numberOfSamples,Map<Integer,Integer[]> srcClass2counts,float detectionThresholdPercent){\n  final int[] array=new int[numberOfSamples];\n  if (detectionThresholdPercent > 0) {\n    for (    Integer id : srcClass2counts.keySet()) {\n      if (id > 0) {\n        final Integer[] counts=srcClass2counts.get(id);\n        if (counts != null) {\n          for (int i=0; i < counts.length; i++) {\n            array[i]+=counts[i];\n          }\n        }\n      }\n    }\n    for (int i=0; i < array.length; i++) {\n      array[i]*=detectionThresholdPercent / 100.0;\n    }\n    System.err.println(\"Read detection thresholds: \" + Basic.toString(array,\", \"));\n  }\n  for (int i=0; i < array.length; i++) {\n    array[i]=Math.max(1,array[i]);\n  }\n  return array;\n}\n", "nl": "determines the number of counts necessary for a taxon to be considered detected, for each sample"}
{"code": "synchronized void modifyParticipant(ParticipantHandle handle,int state){\n  if (operationsLogger.isLoggable(Level.FINER)) {\n    operationsLogger.entering(TxnManagerTransaction.class.getName(),\"modifyParticipant\",new Object[]{handle,new Integer(state)});\n  }\n  ParticipantHandle ph=null;\n  if (handle == null)   throw new NullPointerException(\"ParticipantHolder: \" + \"modifyParticipant: cannot modify null handle\");\n  if (handle.equals(_singleHandle))   ph=_singleHandle;\n else   ph=_parts.get(_parts.get(handle));\n  if (ph == null) {\n    if (operationsLogger.isLoggable(Level.FINER)) {\n      operationsLogger.exiting(TxnManagerTransaction.class.getName(),\"modifyParticipant\");\n    }\n    return;\n  }\n  ph.setPrepState(state);\n  if (operationsLogger.isLoggable(Level.FINER)) {\n    operationsLogger.exiting(TxnManagerTransaction.class.getName(),\"modifyParticipant\");\n  }\n}\n", "nl": "Convenience method which allows the caller to modify the prepState associated with a given <code>ParticipantHandle</code>"}
{"code": "private static byte[] computeSAM(BlastMode blastMode,int maxNumberOfReads,String matchesText) throws IOException {\n  final ISAMIterator iterator;\nswitch (blastMode) {\ncase BlastN:\n    iterator=new BlastN2SAMIterator(matchesText,maxNumberOfReads);\n  break;\ncase BlastP:\niterator=new BlastP2SAMIterator(matchesText,maxNumberOfReads);\nbreak;\ncase BlastX:\niterator=new BlastX2SAMIterator(matchesText,maxNumberOfReads);\nbreak;\ndefault :\nthrow new IOException(\"Unknown BLAST mode: \" + blastMode.toString());\n}\ntry {\niterator.next();\nreturn iterator.getMatchesText();\n}\n  finally {\niterator.close();\n}\n}\n", "nl": "compute SAM representation"}
{"code": "@Pollable(async=true,message=\"Start Adding Box SDK Service Config\",expectedSubTaskNumber=1) public PollableFuture<BoxSDKServiceConfigEntity> addConfig(String clientId,String clientSecret,String publicKeyId,String privateKey,String privateKeyPassword,String enterpriseId,@InjectCurrentTask PollableTask currentTask) throws ExecutionException, InterruptedException, BoxSDKServiceException {\n  BoxSDKServiceConfigEntity boxSDKServiceConfig=boxSDKServiceConfigEntityRepository.findFirstByOrderByIdAsc();\n  if (boxSDKServiceConfig != null) {\n    throw new BoxSDKServiceException(\"Config must be deleted first before adding a new one\");\n  }\n  boxSDKServiceConfig=new BoxSDKServiceConfigEntity(clientId,clientSecret,publicKeyId,privateKey,privateKeyPassword,enterpriseId,null,null,null,false);\n  logger.debug(\"Initial saving of the config so that it can be used immediately\");\n  boxSDKServiceConfigEntityRepository.save(boxSDKServiceConfig);\n  BoxUser.Info appUser=boxSDKAppUserService.createAppUser(boxSDKServiceConfig.getClientId(),boxSDKServiceConfig.getClientSecret(),boxSDKServiceConfig.getPublicKeyId(),boxSDKServiceConfig.getPrivateKey(),boxSDKServiceConfig.getPrivateKeyPassword(),boxSDKServiceConfig.getEnterpriseId());\n  boxSDKServiceConfig.setAppUserId(appUser.getID());\n  logger.debug(\"Saving of the config with updated app user id: {}\",appUser.getID());\n  boxSDKServiceConfigEntityRepository.save(boxSDKServiceConfig);\n  MojitoAppUserInfo mojitoFolderStructure=createMojitoFolderStructure();\n  boxSDKServiceConfig.setRootFolderId(mojitoFolderStructure.getRootFolderId());\n  boxSDKServiceConfig.setDropsFolderId(mojitoFolderStructure.getDropsFolderId());\n  boxSDKServiceConfig.setBootstrap(true);\n  validateConfig(boxSDKServiceConfig,currentTask);\n  logger.debug(\"Saving of the config with updated IDs\");\n  boxSDKServiceConfigEntityRepository.save(boxSDKServiceConfig);\n  return new PollableFutureTaskResult<>(boxSDKServiceConfig);\n}\n", "nl": "Add a new config"}
{"code": "@Override public void postPages(Application.Name applicationName,Experiment.ID experimentID,ExperimentPageList experimentPageList) throws RepositoryException {\n  ExperimentPageList oldPageList=getExperimentPages(experimentID);\n  StringBuilder cqlQuery=new StringBuilder(\"begin batch \");\n  MutationBatch m=driver.getKeyspace().prepareMutationBatch();\n  for (  ExperimentPage experimentPage : experimentPageList.getPages()) {\n    cqlQuery.append(\"insert into page_experiment_index(app_name, page, exp_id, assign) \" + \"values(?,?,?,?);\");\n    m.withRow(keyspace.experiment_page_CF(),experimentID).putColumn(experimentPage.getName(),experimentPage.getAllowNewAssignment());\n    m.withRow(keyspace.app_page_index_CF(),applicationName).putColumn(experimentPage.getName().toString(),experimentPage.getAllowNewAssignment());\n  }\n  cqlQuery.append(\"apply batch;\");\n  PreparedCqlQuery<ExperimentsKeyspace.AppNamePageComposite,String> preparedQuery=driver.getKeyspace().prepareQuery(keyspace.page_experiment_index_CF()).withCql(cqlQuery.toString()).asPreparedStatement();\n  for (  ExperimentPage experimentPage : experimentPageList.getPages()) {\n    preparedQuery.withByteBufferValue(applicationName,ApplicationNameSerializer.get());\n    preparedQuery.withByteBufferValue(experimentPage.getName(),PageNameSerializer.get());\n    preparedQuery.withByteBufferValue(experimentID,ExperimentIDSerializer.get());\n    preparedQuery.withBooleanValue(experimentPage.getAllowNewAssignment());\n  }\n  try {\n    preparedQuery.execute();\n    m.execute();\n  }\n catch (  ConnectionException e) {\n    throw new RepositoryException(\"Could not add the page(s) to the experiment:\\\"\" + experimentID + \"\\\"\",e);\n  }\n  ExperimentPageList newPageList=getExperimentPages(experimentID);\n  saveExperimentPageState(experimentID,oldPageList,newPageList);\n}\n", "nl": "Add a list of pages to an experiment"}
{"code": "public static void createCarbonStore(){\n  try {\n    String factFilePath=new File(\"src/test/resources/data.csv\").getCanonicalPath();\n    File storeDir=new File(absoluteTableIdentifier.getStorePath());\n    CarbonUtil.deleteFoldersAndFiles(storeDir);\n    CarbonProperties.getInstance().addProperty(CarbonCommonConstants.STORE_LOCATION_HDFS,absoluteTableIdentifier.getStorePath());\n    String kettleHomePath=\"../processing/carbonplugins\";\n    CarbonTable table=createTable();\n    writeDictionary(factFilePath,table);\n    CarbonDataLoadSchema schema=new CarbonDataLoadSchema(table);\n    LoadModel loadModel=new LoadModel();\n    String partitionId=\"0\";\n    loadModel.setSchema(schema);\n    loadModel.setDatabaseName(absoluteTableIdentifier.getCarbonTableIdentifier().getDatabaseName());\n    loadModel.setTableName(absoluteTableIdentifier.getCarbonTableIdentifier().getTableName());\n    loadModel.setTableName(absoluteTableIdentifier.getCarbonTableIdentifier().getTableName());\n    loadModel.setFactFilePath(factFilePath);\n    loadModel.setLoadMetadataDetails(new ArrayList<LoadMetadataDetails>());\n    executeGraph(loadModel,absoluteTableIdentifier.getStorePath(),kettleHomePath);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Create store without any restructure"}
{"code": "@Override public void actionPerformed(ActionEvent ev){\n  final AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  final Alignment alignment=viewer.getAlignment();\n  final SelectedBlock block=viewer.getSelectedBlock();\n  final ArrayList<String> names=new ArrayList<>();\n  for (int row=0; row < alignment.getRowCompressor().getNumberRows(); row++) {\n    if (block.isSelectedRow(row)) {\n      for (      Integer read : alignment.getRowCompressor().getCompressedRow2Reads(row)) {\n        Lane lane=alignment.getLane(read);\n        int firstJump=alignment.getGapColumnContractor().getTotalJumpBeforeLayoutColumn(block.getFirstCol());\n        if ((block.isSelectedCol(lane.getFirstNonGapPosition() - firstJump + 1))) {\n          names.add(Basic.getFirstWord(lane.getName()));\n        }\n      }\n    }\n  }\n  if (names.size() > 0) {\n    executeImmediately(\"show window=Inspector;\");\n    final InspectorWindow inspectorWindow=(InspectorWindow)getDir().getViewerByClass(InspectorWindow.class);\n    if (inspectorWindow != null) {\n      final String command=\"show read='\\\\Q\" + Basic.toString(names,\"\\\\E|\\\\Q\") + \"\\\\E';\";\n      System.err.println(command);\n      getDir().execute(command,inspectorWindow.getCommandManager());\n    }\n  }\n}\n", "nl": "action to be performed"}
{"code": "public static Map<String,Object> testXmlRpcClientAdd(DispatchContext dctx,Map<String,?> context){\n  Locale locale=(Locale)context.get(\"locale\");\n  Map<String,Object> result=null;\n  Integer num1=125;\n  Integer num2=365;\n  try {\n    Map<String,Object> localMap=dctx.makeValidContext(\"testXmlRpcLocalEngine\",\"IN\",context);\n    localMap.put(\"num1\",num1);\n    localMap.put(\"num2\",num2);\n    result=dctx.getDispatcher().runSync(\"testXmlRpcLocalEngine\",localMap);\n  }\n catch (  GenericServiceException e) {\n    return ServiceUtil.returnError(e.getLocalizedMessage());\n  }\n  if (ServiceUtil.isError(result))   return result;\n  Integer res=(Integer)result.get(\"resulting\");\n  if (res == (num1 + num2)) {\n    result=ServiceUtil.returnSuccess(UtilProperties.getMessage(resource,\"ServiceTestXmlRpcCalculationOK\",locale) + res);\n  }\n else {\n    result=ServiceUtil.returnError(UtilProperties.getMessage(resource,\"ServiceTestXmlRpcCalculationKO\",locale));\n  }\n  return result;\n}\n", "nl": "Service to send information to xml-rpc service"}
{"code": "public static long addItem(Player player,int itemId,long count,Item sourceItem,ItemUpdatePredicate predicate){\n  ItemTemplate itemTemplate=DataManager.ITEM_DATA.getItemTemplate(itemId);\n  if (count <= 0 || itemTemplate == null) {\n    return 0;\n  }\n  Preconditions.checkNotNull(itemTemplate,\"No item with id \" + itemId);\n  Preconditions.checkNotNull(predicate,\"Predicate is not supplied\");\n  if (LoggingConfig.LOG_ITEM) {\n    log.info(\"[ITEM] ID/Count\" + (LoggingConfig.ENABLE_ADVANCED_LOGGING ? \"/Item Name - \" + itemTemplate.getTemplateId() + \"/\"+ count+ \"/\"+ itemTemplate.getName() : \" - \" + itemTemplate.getTemplateId() + \"/\"+ count) + \" to player \"+ player.getName());\n  }\n  Storage inventory=player.getInventory();\n  if (itemTemplate.isKinah()) {\n    inventory.increaseKinah(count);\n    return 0;\n  }\n  if (itemTemplate.isStackable()) {\n    count=addStackableItem(player,itemTemplate,count,predicate);\n  }\n else {\n    count=addNonStackableItem(player,itemTemplate,count,sourceItem,predicate);\n  }\n  if (inventory.isFull(itemTemplate.getExtraInventoryId()) && count > 0) {\n    PacketSendUtility.sendPacket(player,SM_SYSTEM_MESSAGE.STR_MSG_DICE_INVEN_ERROR);\n  }\n  return count;\n}\n", "nl": "Add new item based on sourceItem values"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set color=\");\n  Color color=null;\n  if (np.peekMatchIgnoreCase(\"null\"))   np.matchIgnoreCase(\"null\");\n else   color=np.getColor();\n  np.matchIgnoreCase(\";\");\n  if (getViewer() instanceof GraphView) {\n    boolean changed=false;\n    GraphView viewer=(GraphView)getViewer();\n    for (    Node v : viewer.getSelectedNodes()) {\n      viewer.setColor(v,color);\n      changed=true;\n    }\n    for (    Edge edge : viewer.getSelectedEdges()) {\n      viewer.setColor(edge,color);\n      changed=true;\n    }\n    if (changed) {\n      viewer.repaint();\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private int measureWidth(int measureSpec){\n  int result=0;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    int count=3;\n    if (viewFlow != null) {\n      count=viewFlow.getAdapter().getCount();\n    }\n    float temp=circleSeparation - 2 * radius;\n    result=(int)(getPaddingLeft() + getPaddingRight() + (count * 2 * radius)+ (count - 1) * temp + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the width of this view"}
{"code": "public static String dbStringToCamelStyle(String str){\n  if (str != null) {\n    StringBuilder sb=new StringBuilder();\n    sb.append(String.valueOf(str.charAt(0)).toUpperCase());\n    for (int i=1; i < str.length(); i++) {\n      char c=str.charAt(i);\n      if (c != '_') {\n        sb.append(c);\n      }\n else {\n        if (i + 1 < str.length()) {\n          sb.append(String.valueOf(str.charAt(i + 1)).toUpperCase());\n          i++;\n        }\n      }\n    }\n    return sb.toString();\n  }\n  return null;\n}\n", "nl": "convert string from slash style to camel style, such as a_b_c will convert to A_B_C"}
{"code": "protected void wrapContent(){\n  mWidget.setMinWidth(100);\n  mWidget.setMinHeight(30);\n  int tw=mWidget.getMinWidth();\n  int th=mWidget.getMinHeight();\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setWidth(tw);\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setHeight(th);\n  }\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getWidth() <= mWidget.getMinWidth()) {\n      mWidget.setHorizontalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getHeight() <= mWidget.getMinHeight()) {\n      mWidget.setVerticalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  mWidget.setBaselineDistance(0);\n}\n", "nl": "Utility method computing the size of the widget if dimensions are set to wrap_content, using the default font"}
{"code": "public SearchResult search(String queryString,int page){\n  SearchResult searchResult=new SearchResult();\n  statsService.incrementSearchCount();\n  try {\n    IndexReader reader=DirectoryReader.open(FSDirectory.open(Paths.get(this.INDEXPATH)));\n    IndexSearcher searcher=new IndexSearcher(reader);\n    Analyzer analyzer=new CodeAnalyzer();\n    QueryParser parser=new QueryParser(CODEFIELD,analyzer);\n    Query query=parser.parse(queryString);\n    LOGGER.info(\"Searching for: \" + query.toString(CODEFIELD));\n    LOGGER.searchLog(query.toString(CODEFIELD) + \" \" + page);\n    searchResult=this.doPagingSearch(reader,searcher,query,page);\n    reader.close();\n  }\n catch (  Exception ex) {\n    LOGGER.warning(\" caught a \" + ex.getClass() + \"\\n with message: \"+ ex.getMessage());\n  }\n  return searchResult;\n}\n", "nl": "Given a query and what page of results we are on return the matching results for that search"}
{"code": "public Pair<DAAQueryRecord,DAAMatchRecord[]> readQueryAndMatches(InputReaderLittleEndian ins,InputReaderLittleEndian refIns,int maxMatchesPerRead,ByteInputBuffer inputBuffer,DAAMatchRecord[] matchRecords) throws IOException {\n  final DAAQueryRecord queryRecord=new DAAQueryRecord(this);\n  if (inputBuffer == null)   inputBuffer=new ByteInputBuffer();\n else   inputBuffer.rewind();\n  if (matchRecords == null)   matchRecords=new DAAMatchRecord[maxMatchesPerRead];\n  queryRecord.setLocation(ins.getPosition());\n  ins.readSizePrefixedBytes(inputBuffer);\n  queryRecord.parseBuffer(inputBuffer);\n  int numberOfMatches=0;\n  while (inputBuffer.getPosition() < inputBuffer.size()) {\n    DAAMatchRecord matchRecord=new DAAMatchRecord(queryRecord);\n    matchRecord.parseBuffer(inputBuffer,refIns);\n    if (numberOfMatches < maxMatchesPerRead)     matchRecords[numberOfMatches++]=matchRecord;\n else     break;\n  }\n  if (numberOfMatches > 0) {\n    DAAMatchRecord[] usedMatchRecords=new DAAMatchRecord[numberOfMatches];\n    System.arraycopy(matchRecords,0,usedMatchRecords,0,numberOfMatches);\n    return new Pair<>(queryRecord,usedMatchRecords);\n  }\n else   return new Pair<>(queryRecord,new DAAMatchRecord[0]);\n}\n", "nl": "read a query and its matches"}
{"code": "@Override public void map(Text key,MapWritable value,Context ctx) throws IOException, InterruptedException {\n  logger.debug(\"key = \" + key.toString());\n  logger.debug(\"value: \" + StringUtils.mapWritableToString(value));\n  boolean passFilter=true;\n  if (filter != null) {\n    passFilter=((DataFilter)filter).filterDataElement(value,dSchema);\n  }\n  if (passFilter) {\n    Tuple2<Integer,BytesArrayWritable> returnTuple;\n    try {\n      returnTuple=HashSelectorAndPartitionData.hashSelectorAndFormPartitions(value,qSchema,dSchema,queryInfo);\n    }\n catch (    Exception e) {\n      logger.error(\"Error in partitioning data element value = \" + StringUtils.mapWritableToString(value));\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n    keyOut.set(returnTuple._1);\n    ctx.write(keyOut,returnTuple._2);\n  }\n}\n", "nl": "The key is the docID/line number and the value is the doc"}
{"code": "public String inflateByteArray2String(int numberOfBytes,byte[] bytes) throws DataFormatException {\n  if (numberOfBytes == 0)   return \"\";\n  if (numberOfBytes < 0) {\n    try {\n      return new String(bytes,0,-numberOfBytes,\"UTF-8\");\n    }\n catch (    UnsupportedEncodingException e) {\n      StringBuilder buf=new StringBuilder();\n      for (int i=0; i < -numberOfBytes; i++)       buf.append((char)bytes[i]);\n      return buf.toString();\n    }\n  }\n  inflater.setInput(bytes,0,numberOfBytes);\n  if (buffer.length < 10 * bytes.length)   buffer=new byte[10 * bytes.length];\n  int resultLength=inflater.inflate(buffer);\n  String outputString;\n  try {\n    outputString=new String(buffer,0,resultLength,\"UTF-8\");\n  }\n catch (  UnsupportedEncodingException e) {\n    StringBuilder buf=new StringBuilder();\n    for (int i=0; i < resultLength; i++)     buf.append((char)buffer[i]);\n    outputString=buf.toString();\n  }\n  inflater.reset();\n  return outputString;\n}\n", "nl": "decompresses an array of bytes to a string"}
{"code": "public static DockerImage fromImageName(String imageName){\n  imageName=prepare(imageName);\n  String[] parts=imageName.split(SECTION_SEPARATOR);\nswitch (parts.length) {\ncase 1:\n    return fromParts(null,null,parts[0]);\ncase 2:\n  if (isValidNamespace(parts[0])) {\n    return fromParts(null,parts[0],parts[1]);\n  }\n else {\n    return fromParts(parts[0],null,parts[1]);\n  }\ncase 3:\nreturn fromParts(parts[0],parts[1],parts[2]);\ndefault :\nthrow new IllegalArgumentException(\"Invalid image format: \" + imageName);\n}\n}\n", "nl": "parse a full image name (myhost:300/namespace/repo:tag) into its components"}
{"code": "private void changeNickname(Player activePlayer,String charName,String newNickname){\n  Legion legion=activePlayer.getLegion();\n  LegionMember legionMember;\n  Player targetPlayer;\n  if ((targetPlayer=World.getInstance().findPlayer(charName)) != null) {\n    legionMember=targetPlayer.getLegionMember();\n    if (targetPlayer.getLegion() != legion) {\n      return;\n    }\n  }\n else {\n    LegionMemberEx LM=getLegionMemberEx(charName);\n    if (LM == null || LM.getLegion() != legion) {\n      return;\n    }\n    legionMember=getLegionMember(LM.getObjectId());\n  }\n  if (legionRestrictions.canChangeNickname(legion,legionMember.getObjectId(),newNickname)) {\n    legionMember.setNickname(newNickname);\n    PacketSendUtility.broadcastPacketToLegion(legion,new SM_LEGION_UPDATE_NICKNAME(legionMember.getObjectId(),newNickname));\n    if (targetPlayer == null) {\n      DAOManager.getDAO(LegionMemberDAO.class).storeLegionMember(legionMember.getObjectId(),legionMember);\n    }\n  }\n}\n", "nl": "This method will handle the changement of a nickname"}
{"code": "private void assignAnglesToEdges(SplitSystem splits,int[] cycle,PhyloGraph graph,Set forbiddenSplits) throws NotOwnerException {\n  double[] TaxaAngles=new double[ntax + 1];\n  for (int t=1; t < ntax + 1; t++) {\n    TaxaAngles[t]=(Math.PI * 2 * t / (double)ntax);\n  }\n  double[] split2angle=new double[splits.size() + 1];\n  assignAnglesToSplits(TaxaAngles,split2angle,splits,cycle);\n  Iterator it=graph.edgeIterator();\n  while (it.hasNext()) {\n    Edge e=(Edge)it.next();\n    if (!forbiddenSplits.contains(new Integer(graph.getSplit(e)))) {\n      try {\n        graph.setAngle(e,split2angle[graph.getSplit(e)]);\n      }\n catch (      Exception ex) {\n      }\n    }\n  }\n}\n", "nl": "assigns angles to all edges in the graph"}
{"code": "@Override public boolean onTouchEvent(MotionEvent event){\nswitch (event.getAction()) {\ncase MotionEvent.ACTION_DOWN:\n    pressPaint.setAlpha(pressAlpha);\n  invalidate();\nbreak;\ncase MotionEvent.ACTION_UP:\npressPaint.setAlpha(0);\ninvalidate();\nbreak;\ncase MotionEvent.ACTION_MOVE:\nbreak;\ndefault :\npressPaint.setAlpha(0);\ninvalidate();\nbreak;\n}\nreturn super.onTouchEvent(event);\n}\n", "nl": "monitor if touched"}
{"code": "public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set select=\");\n  TimeSeriesViewer viewer=(TimeSeriesViewer)getViewer();\n  DataJTable dataJTable=viewer.getDataJTable();\n  if (np.peekMatchIgnoreCase(\"all\")) {\n    np.matchIgnoreCase(\"all\");\n    dataJTable.selectAll();\n  }\n else   if (np.peekMatchIgnoreCase(\"none\")) {\n    np.matchIgnoreCase(\"none\");\n    dataJTable.clearSelection();\n  }\n else   if (np.peekMatchIgnoreCase(\"name\")) {\n    np.matchIgnoreCase(\"name=\");\n    String name=np.getWordRespectCase();\n    dataJTable.select(name,true);\n  }\n  np.matchIgnoreCase(\";\");\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static Map<String,List<Distributable>> nodeBlockMapping(List<Distributable> blockInfos,int noOfNodesInput,List<String> activeNodes){\n  Map<String,List<Distributable>> nodeBlocksMap=new HashMap<String,List<Distributable>>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n  List<NodeBlockRelation> flattenedList=new ArrayList<NodeBlockRelation>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n  Set<Distributable> uniqueBlocks=new HashSet<Distributable>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n  Set<String> nodes=new HashSet<String>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n  createFlattenedListFromMap(blockInfos,flattenedList,uniqueBlocks,nodes);\n  int noofNodes=(-1 == noOfNodesInput) ? nodes.size() : noOfNodesInput;\n  if (null != activeNodes) {\n    noofNodes=activeNodes.size();\n  }\n  int blocksPerNode=blockInfos.size() / noofNodes;\n  blocksPerNode=blocksPerNode <= 0 ? 1 : blocksPerNode;\n  Collections.sort(flattenedList);\n  Map<String,List<Distributable>> nodeAndBlockMapping=new LinkedHashMap<String,List<Distributable>>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n  createNodeVsBlockMapping(flattenedList,nodeAndBlockMapping);\n  createOutputMap(nodeBlocksMap,blocksPerNode,uniqueBlocks,nodeAndBlockMapping,activeNodes);\n  assignLeftOverBlocks(nodeBlocksMap,uniqueBlocks,blocksPerNode,activeNodes);\n  return nodeBlocksMap;\n}\n", "nl": "This method will divide the blocks among the nodes as per the data locality"}
{"code": "public static IClassificationBlock loadClassification(DAAHeader daaHeader,String classificationName) throws IOException {\n  for (int i=0; i < daaHeader.getBlockTypeRankArrayLength() - 1; i++) {\n    if (daaHeader.getBlockType(i) == BlockType.megan_classification_key_block) {\n      long keyBase=daaHeader.computeBlockStart(i);\n      try (InputReaderLittleEndian ins=new InputReaderLittleEndian(new FileRandomAccessReadOnlyAdapter(daaHeader.getFileName()))){\n        ins.seek(keyBase);\n        String cName=ins.readNullTerminatedBytes();\n        if (cName.equalsIgnoreCase(classificationName)) {\n          final ClassificationBlockDAA classificationBlock=new ClassificationBlockDAA(classificationName);\n          int numberOfClasses=ins.readInt();\n          for (int c=0; c < numberOfClasses; c++) {\n            int classId=ins.readInt();\n            classificationBlock.setSum(classId,ins.readInt());\n            ins.skipBytes(12);\n          }\n          return classificationBlock;\n        }\n      }\n     }\n  }\n  return null;\n}\n", "nl": "load a named classification block"}
{"code": "protected boolean isAjax(){\n  String request=this.getHeader(\"X-Requested-With\");\n  if (request != null && request.equals(\"XMLHttpRequest\")) {\n    return true;\n  }\n  String type=this.getHeader(\"Content-Type\");\n  if (type != null && type.contains(\"application/json\")) {\n    return true;\n  }\n  String output=this.getString(\"output\");\n  if (X.isSame(\"json\",output)) {\n    return true;\n  }\n  output=this.getHeader(\"output\");\n  if (X.isSame(\"json\",output)) {\n    return true;\n  }\n  return false;\n}\n", "nl": "test the request is Ajax ? <br> X-Request-With:XMLHttpRequest<br> Content-Type: application/json <br> output: json <br>"}
{"code": "public static void main(String[] args) throws Exception {\n  if (args.length == 0 && System.getProperty(\"user.name\").equals(\"huson\")) {\n    args=new String[]{\"-i\",\"/Users/huson/data/michael/adam/PF04563_meta.out\",\"-o\",\"/Users/huson/data/michael/adam/PF04563_meta.blastx\",\"-r\",\"/Users/huson/data/michael/input/SRR172902-rpoB.fasta\"};\n    args=new String[]{\"-i\",\"/Users/huson/data/michael/adam/next2/880_rpoB_sequences_min_1000_AAs.out\",\"-o\",\"/Users/huson/data/michael/adam/next2/880_rpoB_sequences_min_1000_AAs.blastx\",\"-r\",\"/Users/huson/data/michael/adam/next2/SRR172902-rpoB.fasta\"};\n    args=new String[]{\"-i\",\"/Users/huson/data/michael/adam/next/orthodb_EOG6M9DS6_bacteria_all.out\",\"-o\",\"/Users/huson/data/michael/adam/next/orthodb_EOG6M9DS6_bacteria_all.blastx\",\"-r\",\"/Users/huson/data/michael/adam/next/SRR172902-rpoB.fasta\"};\n    args=new String[]{\"-i\",\"/Users/huson/data/michael/adam/next/33_uniprot_seqs_with_specific_RNA_pol_Rpb2_arch.out\",\"-o\",\"/Users/huson/data/michael/adam/next/33_uniprot_seqs_with_specific_RNA_pol_Rpb2_arch.blastx\",\"-r\",\"/Users/huson/data/michael/adam/next/SRR172902-rpoB.fasta\"};\n    args=new String[]{\"-i\",\"/Users/huson/data/michael/adam/next3/SRR172902.out\",\"-o\",\"/Users/huson/data/michael/adam/next3/SRR172902.blastx\",\"-r\",\"/Users/huson/data/hmp-mock/input-wgs/SRR172902.fastq.gz\"};\n    args=new String[]{\"-i\",\"/Users/huson/data/michael/adam/next4/rpoB_reference_sequences_malt_matches.out\",\"-o\",\"/Users/huson/data/michael/adam/next4/rpoB_reference_sequences_malt_matches.blastx\",\"-r\",\"/Users/huson/data/michael/adam/next/SRR172902-rpoB.fasta\"};\n    args=new String[]{\"-i\",\"/Users/huson/data/michael/adam/next5/rpoB_reference_sequences_SRR172902.out\",\"-o\",\"/Users/huson/data/michael/adam/next5/rpoB_reference_sequences_SRR172902.blastx\",\"-r\",\"/Users/huson/data/hmp-mock/input-wgs/SRR172902.fastq.gz\"};\n  }\n  try {\n    ProgramProperties.setProgramName(\"HMM2BlastX\");\n    ProgramProperties.setProgramVersion(megan.main.Version.SHORT_DESCRIPTION);\n    long start=System.currentTimeMillis();\n    (new HMM2Blastx()).run(args);\n    System.err.println(\"Time: \" + ((System.currentTimeMillis() - start) / 1000) + \"s\");\n    System.exit(0);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n    System.exit(1);\n  }\n}\n", "nl": "converts the file"}
{"code": "private void fingerScroll(final float yDiff){\n  float ratio=mDragRatio;\n  float yScrolled=yDiff * ratio;\n  float tmpTargetOffset=yScrolled + mTargetOffset;\n  if ((tmpTargetOffset > 0 && mTargetOffset < 0) || (tmpTargetOffset < 0 && mTargetOffset > 0)) {\n    yScrolled=-mTargetOffset;\n  }\n  if (mRefreshFinalDragOffset >= mRefreshTriggerOffset && tmpTargetOffset > mRefreshFinalDragOffset) {\n    yScrolled=mRefreshFinalDragOffset - mTargetOffset;\n  }\n else   if (mLoadMoreFinalDragOffset >= mLoadMoreTriggerOffset && -tmpTargetOffset > mLoadMoreFinalDragOffset) {\n    yScrolled=-mLoadMoreFinalDragOffset - mTargetOffset;\n  }\n  if (STATUS.isRefreshStatus(mStatus)) {\n    mRefreshCallback.onMove(mTargetOffset,false,false);\n  }\n else   if (STATUS.isLoadMoreStatus(mStatus)) {\n    mLoadMoreCallback.onMove(mTargetOffset,false,false);\n  }\n  updateScroll(yScrolled);\n}\n", "nl": "scrolling by physical touch with your fingers"}
{"code": "private boolean checkCurrentAnimationPart(AnimationPart part){\nswitch (part) {\ncase FIRST:\n{\n      return mLoadingAnimationTime < getAnimationTimePart(AnimationPart.FOURTH);\n    }\ncase SECOND:\ncase THIRD:\n{\n    return mLoadingAnimationTime < getAnimationTimePart(part);\n  }\ncase FOURTH:\n{\n  return mLoadingAnimationTime > getAnimationTimePart(AnimationPart.THIRD);\n}\ndefault :\nreturn false;\n}\n}\n", "nl": "On drawing we should check current part of animation"}
{"code": "public void actionPerformed(ActionEvent ev){\n  File lastOpenFile=ProgramProperties.getFile(MeganProperties.TAXONOMYFILE);\n  getDir().notifyLockInput();\n  File file=ChooseFileDialog.chooseFileToOpen(getViewer().getFrame(),lastOpenFile,new TextFileFilter(\"tre\"),new TextFileFilter(\"tre\"),ev,\"Open Tree File\");\n  getDir().notifyUnlockInput();\n  if (file != null && file.exists() && file.canRead()) {\n    ProgramProperties.put(MeganProperties.TAXONOMYFILE,file.getAbsolutePath());\n    String mappingFile=Basic.replaceFileSuffix(file.getPath(),\".map\");\n    if (!(new File(mappingFile)).exists()) {\n      mappingFile=null;\n    }\n    StringBuilder buf=new StringBuilder();\n    buf.append(\"load taxonomyFile='\").append(file.getPath()).append(\"'\");\n    if (mappingFile != null)     buf.append(\" mapFile='\").append(mappingFile).append(\"';\");\n else     buf.append(\";\");\n    buf.append(\"collapse level=2;\");\n    execute(buf.toString());\n  }\n}\n", "nl": "action to be performed"}
{"code": "private void readFromVersion2Stream(StatusFromBytesStream dis) throws IOException {\n  String urlString=dis.readUTF();\n  if (urlString.equals(\"\")) {\n    url=null;\n  }\n else {\n    url=urlString;\n  }\n  lastChangedRevision=dis.readLong();\n  lastChangedDate=dis.readLong();\n  String lastCommitAuthorString=dis.readUTF();\n  if ((url == null) || (lastCommitAuthorString.equals(\"\"))) {\n    lastCommitAuthor=null;\n  }\n else {\n    lastCommitAuthor=lastCommitAuthorString;\n  }\n  textStatus=dis.readInt();\n  propStatus=dis.readInt();\n  setRevisionNumber(dis.readLong());\n  nodeKind=dis.readInt();\n}\n", "nl": "Just for backwards compatibility with workspaces stored with previous version"}
{"code": "XMLInputSource dom2xmlInputSource(LSInput is){\n  XMLInputSource xis=null;\n  if (is.getCharacterStream() != null) {\n    xis=new XMLInputSource(is.getPublicId(),is.getSystemId(),is.getBaseURI(),is.getCharacterStream(),\"UTF-16\");\n  }\n else   if (is.getByteStream() != null) {\n    xis=new XMLInputSource(is.getPublicId(),is.getSystemId(),is.getBaseURI(),is.getByteStream(),is.getEncoding());\n  }\n else   if (is.getStringData() != null && is.getStringData().length() > 0) {\n    xis=new XMLInputSource(is.getPublicId(),is.getSystemId(),is.getBaseURI(),new StringReader(is.getStringData()),\"UTF-16\");\n  }\n else   if ((is.getSystemId() != null && is.getSystemId().length() > 0) || (is.getPublicId() != null && is.getPublicId().length() > 0)) {\n    xis=new XMLInputSource(is.getPublicId(),is.getSystemId(),is.getBaseURI());\n  }\n else {\n    if (fErrorHandler != null) {\n      DOMErrorImpl error=new DOMErrorImpl();\n      error.fType=\"no-input-specified\";\n      error.fMessage=\"no-input-specified\";\n      error.fSeverity=DOMError.SEVERITY_FATAL_ERROR;\n      fErrorHandler.getErrorHandler().handleError(error);\n    }\n    throw new LSException(LSException.PARSE_ERR,\"no-input-specified\");\n  }\n  return xis;\n}\n", "nl": "NON-DOM: convert LSInput to XNIInputSource"}
{"code": "public static int gaps(int[] start,int[] end){\n  Arrays.sort(start);\n  Arrays.sort(end);\n  int overlap=0;\n  int gaps=0;\n  for (int i=0, j=0; j < end.length; ) {\n    if (i < start.length && start[i] < end[j]) {\n      overlap++;\n      i++;\n    }\n else {\n      j++;\n      overlap--;\n    }\n    if (overlap == 0) {\n      gaps++;\n    }\n  }\n  return gaps;\n}\n", "nl": "Calculate the number of gaps + 1 given a start and end range"}
{"code": "public Builder cloneFrom(DisplayImageOptions options){\n  imageResOnLoading=options.imageResOnLoading;\n  imageResForEmptyUri=options.imageResForEmptyUri;\n  imageResOnFail=options.imageResOnFail;\n  imageOnLoading=options.imageOnLoading;\n  imageForEmptyUri=options.imageForEmptyUri;\n  imageOnFail=options.imageOnFail;\n  resetViewBeforeLoading=options.resetViewBeforeLoading;\n  cacheInMemory=options.cacheInMemory;\n  cacheOnDisk=options.cacheOnDisk;\n  imageScaleType=options.imageScaleType;\n  decodingOptions=options.decodingOptions;\n  delayBeforeLoading=options.delayBeforeLoading;\n  considerExifParams=options.considerExifParams;\n  extraForDownloader=options.extraForDownloader;\n  preProcessor=options.preProcessor;\n  postProcessor=options.postProcessor;\n  displayer=options.displayer;\n  handler=options.handler;\n  isSyncLoading=options.isSyncLoading;\n  return this;\n}\n", "nl": "Sets all options equal to incoming options"}
{"code": "protected void internalTransform(Body b,String phaseName,Map options){\n  SmartLocalDefs sld=SmartLocalDefsPool.v().getSmartLocalDefsFor(b);\n  UnitGraph g=sld.getGraph();\n  NaiveSideEffectTester nset=new NaiveSideEffectTester();\n  LoopFinder lf=new LoopFinder();\n  lf.internalTransform(b,phaseName,options);\n  Collection<Loop> loops=lf.loops();\n  constants=new ArrayList();\n  if (loops.isEmpty())   return;\n  Iterator<Loop> lIt=loops.iterator();\n  while (lIt.hasNext()) {\n    Loop loop=lIt.next();\n    Stmt header=loop.getHead();\n    Collection<Stmt> loopStmts=loop.getLoopStatements();\n    Iterator<Stmt> bIt=loopStmts.iterator();\n    while (bIt.hasNext()) {\n      Stmt tStmt=bIt.next();\n      handleLoopBodyStmt(tStmt,nset,loopStmts);\n    }\n  }\n}\n", "nl": "this one uses the side effect tester"}
{"code": "private static AuthCredential authCredentialsFromUrl(String url){\n  if (isValidLoginSchema(url)) {\n    url=url.replace(Utils.getCallbackUrl() + \"#\",Utils.getCallbackUrl() + \"?\");\n    HttpUrl parsed=HttpUrl.parse(url);\n    try {\n      String idToken=parsed.queryParameter(\"id_token\");\n      AuthCredential authCredentials=new AuthCredential();\n      authCredentials.setAccessToken(idToken);\n      authCredentials.setTokenType(parsed.queryParameter(\"token_type\"));\n      authCredentials.setRefreshToken(parsed.queryParameter(\"refresh_token\"));\n      JwtConsumer consumer=new JwtConsumerBuilder().setSkipAllValidators().setDisableRequireSignature().setSkipSignatureVerification().build();\n      JwtClaims claims=consumer.processToClaims(idToken);\n      authCredentials.setUserId(claims.getSubject());\n      authCredentials.setExpiresAt(new Date(claims.getExpirationTime().getValueInMillis()));\n      return authCredentials;\n    }\n catch (    InvalidJwtException|MalformedClaimException e) {\n      e.printStackTrace();\n    }\n  }\n  return null;\n}\n", "nl": "Generates an authCredentials object from a url"}
{"code": "private static boolean checkParameters(Method method,Class[] types){\n  boolean result=true;\n  Class[] parameters=method.getParameterTypes();\n  if (parameters.length != types.length) {\n    result=false;\n  }\n else {\n    for (int i=0; i < parameters.length; ++i) {\n      Class parameter=parameters[i];\n      if (types[i] == null) {\n        if (parameter.isPrimitive()) {\n          result=false;\n          break;\n        }\n      }\n else       if (!parameter.isAssignableFrom(types[i]) && !parameter.isAssignableFrom(getPrimitiveType(types[i]))) {\n        result=false;\n        break;\n      }\n    }\n  }\n  return result;\n}\n", "nl": "Helper to determine if a list of argument types match that of a method"}
{"code": "private Encoding fromExternalToWrapperEncoding(org.apache.carbondata.format.Encoding encoder){\n  if (null == encoder) {\n    return null;\n  }\nswitch (encoder) {\ncase DICTIONARY:\n    return Encoding.DICTIONARY;\ncase DELTA:\n  return Encoding.DELTA;\ncase RLE:\nreturn Encoding.RLE;\ncase INVERTED_INDEX:\nreturn Encoding.INVERTED_INDEX;\ncase BIT_PACKED:\nreturn Encoding.BIT_PACKED;\ncase DIRECT_DICTIONARY:\nreturn Encoding.DIRECT_DICTIONARY;\ndefault :\nreturn Encoding.DICTIONARY;\n}\n}\n", "nl": "convert from external to wrapper encoding"}
{"code": "public static boolean addSmiles(Context context,Spannable spannable){\n  boolean hasChanges=false;\n  for (  Entry<Pattern,Integer> entry : emoticons.entrySet()) {\n    Matcher matcher=entry.getKey().matcher(spannable);\n    while (matcher.find()) {\n      boolean set=true;\n      for (      ImageSpan span : spannable.getSpans(matcher.start(),matcher.end(),ImageSpan.class))       if (spannable.getSpanStart(span) >= matcher.start() && spannable.getSpanEnd(span) <= matcher.end())       spannable.removeSpan(span);\n else {\n        set=false;\n        break;\n      }\n      if (set) {\n        hasChanges=true;\n        spannable.setSpan(new ImageSpan(context,entry.getValue()),matcher.start(),matcher.end(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n      }\n    }\n  }\n  return hasChanges;\n}\n", "nl": "replace existing spannable with smiles"}
{"code": "private boolean isKineticSkill(){\nswitch (getSkillId()) {\ncase 2440:\ncase 2441:\ncase 2442:\ncase 2443:\ncase 2444:\ncase 2445:\ncase 2446:\ncase 2447:\ncase 2448:\ncase 2449:\ncase 2579:\ncase 2580:\ncase 2581:\n    return true;\n}\nreturn false;\n}\n", "nl": "Just for Rider class skills"}
{"code": "public static String byteDesc(long len){\n  double val;\n  String ending;\n  if (len < 1024 * 1024) {\n    val=(1.0 * len) / 1024;\n    ending=\" KB\";\n  }\n else   if (len < 1024 * 1024 * 1024) {\n    val=(1.0 * len) / (1024 * 1024);\n    ending=\" MB\";\n  }\n else   if (len < 1024L * 1024 * 1024* 1024) {\n    val=(1.0 * len) / (1024 * 1024 * 1024);\n    ending=\" GB\";\n  }\n else   if (len < 1024L * 1024 * 1024* 1024* 1024) {\n    val=(1.0 * len) / (1024L * 1024 * 1024* 1024);\n    ending=\" TB\";\n  }\n else {\n    val=(1.0 * len) / (1024L * 1024 * 1024* 1024* 1024);\n    ending=\" PB\";\n  }\n  return limitDecimalTo2(val) + ending;\n}\n", "nl": "Return an abbreviated English-language desc of the byte length"}
{"code": "private void initFxLater(JFXPanel jfxPanel){\n  if (!initialized) {\nsynchronized (lock) {\n      if (!initialized) {\n        try {\n          final BorderPane rootNode=new BorderPane();\n          jfxPanel.setScene(new Scene(rootNode,600,600));\n          final Node main=createMainNode();\n          rootNode.setCenter(main);\n          BorderPane.setMargin(main,new Insets(3,3,3,3));\n          String css=NotificationsInSwing.getControlStylesheetURL();\n          if (css != null)           jfxPanel.getScene().getStylesheets().add(css);\n          css=getControlStylesheetURL();\n          if (css != null) {\n            jfxPanel.getScene().getStylesheets().add(css);\n            spreadsheetView.getStylesheets().add(css);\n          }\n          columnContextMenu=new PopupMenuFX(GUIConfiguration.getAttributeColumnHeaderPopupConfiguration(),samplesViewer.getCommandManager());\n          rowContextMenu=new PopupMenuFX(GUIConfiguration.getSampleRowHeaderPopupConfiguration(),samplesViewer.getCommandManager());\n          originalRowContextMenuLength=rowContextMenu.getItems().size();\n        }\n  finally {\n          initialized=true;\n        }\n      }\n    }\n  }\n}\n", "nl": "initialize JavaFX"}
{"code": "public static void backup(String filename){\n  File f=new File(filename);\n  f.getParentFile().mkdirs();\n  Connection c=null;\n  ResultSet r1=null;\n  try {\n    ZipOutputStream zip=new ZipOutputStream(new FileOutputStream(f));\n    zip.putNextEntry(new ZipEntry(\"db\"));\n    PrintStream out=new PrintStream(zip);\n    c=getConnection();\n    DatabaseMetaData m1=c.getMetaData();\n    r1=m1.getTables(null,null,null,new String[]{\"TABLE\"});\n    while (r1.next()) {\n      _backup(out,c,r1.getString(\"TABLE_NAME\"));\n    }\n    zip.closeEntry();\n    zip.close();\n  }\n catch (  Exception e) {\n    log.error(e.getMessage(),e);\n  }\n finally {\n    close(r1,c);\n  }\n}\n", "nl": "backup the data to file"}
{"code": "public static byte[] decompressForZlib(byte[] bytesToDecompress){\n  byte[] returnValues=null;\n  Inflater inflater=new Inflater();\n  int numberOfBytesToDecompress=bytesToDecompress.length;\n  inflater.setInput(bytesToDecompress,0,numberOfBytesToDecompress);\n  int bufferSizeInBytes=numberOfBytesToDecompress;\n  int numberOfBytesDecompressedSoFar=0;\n  List<Byte> bytesDecompressedSoFar=new ArrayList<Byte>();\n  try {\n    while (inflater.needsInput() == false) {\n      byte[] bytesDecompressedBuffer=new byte[bufferSizeInBytes];\n      int numberOfBytesDecompressedThisTime=inflater.inflate(bytesDecompressedBuffer);\n      numberOfBytesDecompressedSoFar+=numberOfBytesDecompressedThisTime;\n      for (int b=0; b < numberOfBytesDecompressedThisTime; b++) {\n        bytesDecompressedSoFar.add(bytesDecompressedBuffer[b]);\n      }\n    }\n    returnValues=new byte[bytesDecompressedSoFar.size()];\n    for (int b=0; b < returnValues.length; b++) {\n      returnValues[b]=(byte)(bytesDecompressedSoFar.get(b));\n    }\n  }\n catch (  DataFormatException dfe) {\n    dfe.printStackTrace();\n  }\n  inflater.end();\n  return returnValues;\n}\n", "nl": "zlib decompress 2 byte"}
{"code": "protected void wrapContent(){\n  mWidget.setMinWidth(32);\n  mWidget.setMinHeight(32);\n  int tw=mWidget.getMinWidth();\n  int th=mWidget.getMinHeight();\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setWidth(tw);\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setHeight(th);\n  }\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getWidth() <= mWidget.getMinWidth()) {\n      mWidget.setHorizontalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getHeight() <= mWidget.getMinHeight()) {\n      mWidget.setVerticalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  mWidget.setBaselineDistance(0);\n}\n", "nl": "Utility method computing the size of the widget if dimensions are set to wrap_content, using the default font"}
{"code": "public boolean apply(ClusterViewer clusterViewer,String attributeThatDefinesBiologicalSamples){\n  final SampleAttributeTable sampleAttributeTable=clusterViewer.getDocument().getSampleAttributeTable();\n  final ArrayList<Triplet<String,String,String>> triangles=computeTriangluation(sampleAttributeTable,attributeThatDefinesBiologicalSamples);\n  System.err.println(\"Triangulation (\" + triangles.size() + \"):\");\n  for (  Triplet<String,String,String> triangle : triangles) {\n    System.err.println(triangle.toString());\n  }\n  final int minNumberOfNonConflictedTrianglesRequired=computeMinNumberOfNonConflictedTrianglesRequired(triangles.size());\n  System.err.println(\"Minimum number of non-conflicted triangles required to reject H0: \" + minNumberOfNonConflictedTrianglesRequired);\n  final Taxa taxa=clusterViewer.getTaxa();\n  final Distances distances=clusterViewer.getDistances();\n  int numberOfNonconflictedTriangles=0;\n  for (  Triplet<String,String,String> triangle : triangles) {\n    double ab=distances.get(taxa.indexOf(triangle.get1()),taxa.indexOf(triangle.get2()));\n    double ac=distances.get(taxa.indexOf(triangle.get1()),taxa.indexOf(triangle.get3()));\n    double bc=distances.get(taxa.indexOf(triangle.get2()),taxa.indexOf(triangle.get3()));\n    if (ac < ab || bc < ab) {\n      System.err.println(\"Conflicted triangle a=\" + triangle.get1() + \",b=\"+ triangle.get2()+ \" vs c=\"+ triangle.get3()+ \", distances: \"+ String.format(\"ab=%.4f, ac=%.4f, bc=%.4f\",ab,ac,bc));\n    }\n else     numberOfNonconflictedTriangles++;\n  }\n  if (numberOfNonconflictedTriangles < minNumberOfNonConflictedTrianglesRequired)   System.err.println(\"Insufficient number of non-conflicted triangles: \" + numberOfNonconflictedTriangles + \", null hypothesis not rejected\");\n  return numberOfNonconflictedTriangles >= minNumberOfNonConflictedTrianglesRequired;\n}\n", "nl": "performs the triangulation test described in Huson et al, A statistical test for detecting taxonomic inhomogeneity in replicated metagenomic samples"}
{"code": "private void toggleAlphabetic(){\n  List<Pokemon> pokemonList=Pokedex.getAllPokemonAlphabetic();\n  List<UndoAdapter.UndoItem> list=new ArrayList<>();\n  if (isAlphabetic) {\n    for (int i=0; i < pokemonList.size(); i++) {\n      UndoAdapter.UndoItem undoItem=new UndoAdapter.UndoItem(pokemonList.get(i).type,pokemonList.get(i));\n      list.add(i,undoItem);\n    }\n    isAlphabetic=false;\n  }\n else {\n    for (int i=0; i < pokemonList.size(); i++) {\n      UndoAdapter.UndoItem undoItem=new UndoAdapter.UndoItem(pokemonList.get(i).name.substring(0,1),pokemonList.get(i));\n      list.add(i,undoItem);\n    }\n    isAlphabetic=true;\n  }\n  adapter.swap(list);\n}\n", "nl": "Toggles headers between type and alphabetic"}
{"code": "@Override public void onTabClosed(long time,int id,int nextId,boolean incognito){\n  super.onTabClosed(time,id,nextId,incognito);\n  if (mClosedTab != null) {\n    TabModel nextModel=mTabModelSelector.getModelForTabId(nextId);\n    if (nextModel != null) {\n      LayoutTab nextLayoutTab=createLayoutTab(nextId,nextModel.isIncognito(),NO_CLOSE_BUTTON,NO_TITLE);\n      nextLayoutTab.setDrawDecoration(false);\n      mLayoutTabs=new LayoutTab[]{nextLayoutTab,mClosedTab};\n      updateCacheVisibleIds(new LinkedList<Integer>(Arrays.asList(nextId,mClosedTab.getId())));\n    }\n else {\n      mLayoutTabs=new LayoutTab[]{mClosedTab};\n    }\n    forceAnimationToFinish();\n    mAnimatedTab=mClosedTab;\n    addToAnimation(this,Property.DISCARD_AMOUNT,0,getDiscardRange(),TAB_CLOSED_ANIMATION_DURATION,0,false,BakedBezierInterpolator.FADE_OUT_CURVE);\n    mClosedTab=null;\n    if (nextModel != null) {\n      mTabModelSelector.selectModel(nextModel.isIncognito());\n    }\n  }\n  startHiding(nextId,false);\n}\n", "nl": "Animate the closing of a tab"}
{"code": "public static void copyAssets(Context context,String assetsFilename,File file,String mode) throws IOException, InterruptedException {\n  String abi=Build.CPU_ABI;\n  String libraryName;\n  if (abi.equalsIgnoreCase(\"armeabi\")) {\n    libraryName=\"armeabi\";\n  }\n else   if (abi.equalsIgnoreCase(\"x86\")) {\n    libraryName=\"x86\";\n  }\n else   if (abi.contains(\"armeabi-v7\")) {\n    libraryName=\"armeabi-v7a\";\n  }\n else {\n    return;\n  }\n  AssetManager manager=context.getAssets();\n  final InputStream is=manager.open(libraryName + \"/\" + assetsFilename);\n  copyFile(file,is,mode);\n}\n", "nl": "copy file in assets into destination file"}
{"code": "@Override public List<Object[]> collectData(AbstractScannedResult scannedResult,int batchSize){\n  List<Object[]> listBasedResult=new ArrayList<>(batchSize);\n  QueryMeasure[] queryMeasures=tableBlockExecutionInfos.getQueryMeasures();\n  ByteArrayWrapper wrapper=null;\n  int rowCounter=0;\n  while (scannedResult.hasNext() && rowCounter < batchSize) {\n    Object[] row=new Object[1 + queryMeasures.length];\n    wrapper=new ByteArrayWrapper();\n    wrapper.setDictionaryKey(scannedResult.getDictionaryKeyArray());\n    wrapper.setNoDictionaryKeys(scannedResult.getNoDictionaryKeyArray());\n    wrapper.setComplexTypesKeys(scannedResult.getComplexTypeKeyArray());\n    row[0]=wrapper;\n    fillMeasureData(row,1,scannedResult);\n    listBasedResult.add(row);\n    rowCounter++;\n  }\n  updateData(listBasedResult);\n  return listBasedResult;\n}\n", "nl": "This method will add a record both key and value to list object it will keep track of how many record is processed, to handle limit scenario"}
{"code": "public double[] generate(int nSamples){\n  int m=nSamples / 2;\n  double r;\n  double pi=Math.PI;\n  double[] w=new double[nSamples];\nswitch (windowType) {\ncase BARTLETT:\n    for (int n=0; n < nSamples; n++)     w[n]=1.0f - Math.abs(n - m) / m;\n  break;\ncase HANNING:\nr=pi / (m + 1);\nfor (int n=-m; n < m; n++) w[m + n]=0.5f + 0.5f * Math.cos(n * r);\nbreak;\ncase HAMMING:\nr=pi / m;\nfor (int n=-m; n < m; n++) w[m + n]=0.54f + 0.46f * Math.cos(n * r);\nbreak;\ncase BLACKMAN:\nr=pi / m;\nfor (int n=-m; n < m; n++) w[m + n]=0.42f + 0.5f * Math.cos(n * r) + 0.08f * Math.cos(2 * n * r);\nbreak;\ndefault :\nfor (int n=0; n < nSamples; n++) w[n]=1.0f;\n}\nreturn w;\n}\n", "nl": "Generate a window"}
{"code": "protected void addJob(BundleContext context,Class<? extends Job> clazz,String cronExpression){\n  String jobName=clazz.getName();\n  String jobGroup=FrameworkUtil.getBundle(clazz).getSymbolicName();\n  JobDetail job=new JobDetail(jobName,jobGroup,clazz);\n  job.setDurability(false);\n  job.setVolatility(true);\n  job.setDescription(jobName);\n  try {\n    CronTrigger trigger=new CronTrigger(jobName,jobGroup,cronExpression);\n    if (scheduler == null) {\n      if (schedulerProperties == null) {\n        schedulerProperties=getDefaultSchedulerProperties();\n      }\n      scheduler=new StdSchedulerFactory(schedulerProperties).getScheduler();\n      scheduler.start();\n    }\n    Date date=scheduler.scheduleJob(job,trigger);\n    Logger.info(this,\"Scheduled job \" + jobName + \", next trigger is on \"+ date);\n  }\n catch (  ParseException e) {\n    Logger.error(this,\"Cron expression '\" + cronExpression + \"' has an exception. Throwing IllegalArgumentException\",e);\n    throw new IllegalArgumentException(e);\n  }\ncatch (  SchedulerException e) {\n    Logger.error(this,\"Unable to schedule job \" + jobName,e);\n  }\n}\n", "nl": "Adds a Job, and starts a Scheduler when none was yet started"}
{"code": "private Object[] compile(String path){\n  List list=new ArrayList();\n  if (path == null) {\n    return list.toArray();\n  }\n  StringTokenizer tok=new StringTokenizer(path,\":.\");\n  while (tok.hasMoreTokens()) {\n    String token=tok.nextToken();\n    OpEnum op=OpEnum.getInstance(token);\n    if (op == null) {\n      throw new Error(\"Bad path compiled \" + path);\n    }\n    list.add(op);\n    if (op == OpEnum.RELATION) {\n      list.add(tok.nextToken());\n    }\n  }\n  return list.toArray();\n}\n", "nl": "Compiles the given path into the compiled form"}
{"code": "public int computeNaiveLCA(Collection<Integer> taxonIds){\n  if (taxonIds.size() == 0)   return IdMapper.NOHITS_ID;\n else   if (taxonIds.size() == 1)   return taxonIds.iterator().next();\n  if (taxonIds.size() > addresses.length) {\n    addresses=new String[taxonIds.size()];\n    weights=new int[taxonIds.size()];\n  }\n  int numberOfAddresses=0;\n  for (  Integer taxonId : taxonIds) {\n    if (!TaxonomyData.isTaxonDisabled(taxonId)) {\n      String address=TaxonomyData.getAddress(taxonId);\n      if (address != null) {\n        addresses[numberOfAddresses++]=address;\n      }\n    }\n  }\n  if (numberOfAddresses > 0) {\n    final String address=LCAAddressing.getCommonPrefix(addresses,numberOfAddresses,true);\n    return TaxonomyData.getAddress2Id(address);\n  }\n  return IdMapper.UNASSIGNED_ID;\n}\n", "nl": "returns the LCA of a set of taxon ids"}
{"code": "@SuppressWarnings({\"rawtypes\",\"unchecked\"}) private static ITaintPropagationWrapper createLibrarySummaryTW() throws IOException {\n  try {\n    Class clzLazySummary=Class.forName(\"soot.jimple.infoflow.methodSummary.data.impl.LazySummary\");\n    Object lazySummary=clzLazySummary.getConstructor(File.class).newInstance(new File(summaryPath));\n    ITaintPropagationWrapper summaryWrapper=(ITaintPropagationWrapper)Class.forName(\"soot.jimple.infoflow.methodSummary.taintWrappers.SummaryTaintWrapper\").getConstructor(clzLazySummary).newInstance(lazySummary);\n    final TaintWrapperSet taintWrapperSet=new TaintWrapperSet();\n    taintWrapperSet.addWrapper(summaryWrapper);\n    taintWrapperSet.addWrapper(new EasyTaintWrapper(\"EasyTaintWrapperConversion.txt\"));\n    return taintWrapperSet;\n  }\n catch (  ClassNotFoundException|NoSuchMethodException ex) {\n    System.err.println(\"Could not find library summary classes: \" + ex.getMessage());\n    ex.printStackTrace();\n    return null;\n  }\ncatch (  InvocationTargetException ex) {\n    System.err.println(\"Could not initialize library summaries: \" + ex.getMessage());\n    ex.printStackTrace();\n    return null;\n  }\ncatch (  IllegalAccessException|InstantiationException ex) {\n    System.err.println(\"Internal error in library summary initialization: \" + ex.getMessage());\n    ex.printStackTrace();\n    return null;\n  }\n}\n", "nl": "Creates the taint wrapper for using library summaries"}
{"code": "private void endList(){\n  List list=(List)getLast(List.class);\n  if (list != null) {\n    if (mResult.length() == 0 || mResult.charAt(mResult.length() - 1) != '\\n') {\n      mResult.append('\\n');\n    }\n    int start=mResult.getSpanStart(list);\n    int end=mResult.length();\n    int nrOfIndents=list.mNrOfIndents;\n    if (!list.mIsIndentation) {\n      nrOfIndents--;\n      int margin=Helper.getLeadingMarging();\n      Object span=list instanceof UL ? new BulletSpan(margin,start == end,false,false) : new NumberSpan(1,margin,start == end,false,false);\n      mResult.setSpan(span,start,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n    }\n    if (nrOfIndents > 0) {\n      int margin=nrOfIndents * Helper.getLeadingMarging();\n      IndentationSpan span=new IndentationSpan(margin,start == end,false,false);\n      mResult.setSpan(span,start,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n    }\n    mResult.removeSpan(list);\n  }\n}\n", "nl": "Handles LI tags"}
{"code": "public boolean matches(InventoryCrafting inv,World worldIn){\n  ItemStack itemstack=null;\n  List<ItemStack> list=Lists.<ItemStack>newArrayList();\n  for (int i=0; i < inv.getSizeInventory(); ++i) {\n    ItemStack itemstack1=inv.getStackInSlot(i);\n    if (itemstack1 != null) {\n      if (itemstack1.getItem() instanceof ItemArmor) {\n        ItemArmor itemarmor=(ItemArmor)itemstack1.getItem();\n        if (itemarmor.getArmorMaterial() != CyberwareContent.trenchMat || itemstack != null) {\n          return false;\n        }\n        itemstack=itemstack1;\n      }\n else {\n        if (itemstack1.getItem() != Items.DYE) {\n          return false;\n        }\n        list.add(itemstack1);\n      }\n    }\n  }\n  return itemstack != null && !list.isEmpty();\n}\n", "nl": "Used to check if a recipe matches current crafting inventory"}
{"code": "public void saveMergeSource(String mergeFrom,String commonRoot){\n  List<String> fromUrls=new ArrayList<String>();\n  fromUrls.add(mergeFrom);\n  String previousFromUrls=null;\n  try {\n    previousFromUrls=Activator.getDefault().getDialogSettings().get(\"mergeFromUrls_\" + commonRoot);\n  }\n catch (  Exception e) {\n  }\n  if (previousFromUrls != null) {\n    String[] urls=previousFromUrls.split(\"\\\\,\");\n    for (    String url : urls) {\n      if (!fromUrls.contains(url))       fromUrls.add(url);\n    }\n  }\n  StringBuffer mergeFromBuffer=new StringBuffer(mergeFrom);\n  for (  String url : fromUrls) {\n    mergeFromBuffer.append(\",\" + url);\n  }\n  Activator.getDefault().getDialogSettings().put(\"mergeFromUrls_\" + commonRoot,mergeFromBuffer.toString());\n}\n", "nl": "Save a previous merge source location"}
{"code": "public static StructType fromSchema(Schema schema){\n  StructField[] structFields=new StructField[schema.numColumns()];\n  for (int i=0; i < structFields.length; i++) {\nswitch (schema.getColumnTypes().get(i)) {\ncase Double:\n      structFields[i]=new StructField(schema.getName(i),DataTypes.DoubleType,false,Metadata.empty());\n    break;\ncase Integer:\n  structFields[i]=new StructField(schema.getName(i),DataTypes.IntegerType,false,Metadata.empty());\nbreak;\ncase Long:\nstructFields[i]=new StructField(schema.getName(i),DataTypes.LongType,false,Metadata.empty());\nbreak;\ncase Float:\nstructFields[i]=new StructField(schema.getName(i),DataTypes.FloatType,false,Metadata.empty());\nbreak;\ndefault :\nthrow new IllegalStateException(\"This api should not be used with strings , binary data or ndarrays. This is only for columnar data\");\n}\n}\nreturn new StructType(structFields);\n}\n", "nl": "Convert a datavec schema to a struct type in spark"}
{"code": "public final boolean isFallBackFileEmpty(){\n  boolean isEmpty=false;\n  try {\n    openFallbackInputStream();\n    if (!getInput().ready()) {\n      isEmpty=true;\n    }\n  }\n catch (  IOException e) {\n    LOG.error(\"isFallBackFileEmpty() : A problem has ocurred while trying to determine if the file was empty\",e);\n  }\ncatch (  Exception ex) {\n    LOG.error(\"isFallBackFileEmpty() : \" + ex.getMessage());\n  }\n finally {\n    try {\n      closeFallbackInputStream();\n    }\n catch (    Exception ex) {\n      LOG.error(\"isFallBackFileEmpty() : \" + ex.getMessage());\n    }\n  }\n  if (LOG.isDebugEnabled())   LOG.debug(\"isFallBackFileEmpty() : The result of checking whether the file is empty or not is \" + isEmpty);\n  return isEmpty;\n}\n", "nl": "Checks whether the fallback log file has any contents or not"}
{"code": "void notifyPendingReceivedCallback(final MessageImpl message,Exception exception){\n  if (!pendingReceives.isEmpty()) {\n    CompletableFuture<Message> receivedFuture=pendingReceives.poll();\n    if (exception == null) {\n      checkNotNull(message,\"received message can't be null\");\n      if (receivedFuture != null) {\n        if (conf.getReceiverQueueSize() == 0) {\n          receivedFuture.complete(message);\n        }\n else {\n          messageProcessed(message);\n          listenerExecutor.execute(null);\n        }\n      }\n    }\n else {\n      listenerExecutor.execute(null);\n    }\n  }\n}\n", "nl": "Notify waiting asyncReceive request with the received message"}
{"code": "public ResizeHandle findResizeHandle(float x,float y,ViewTransform transform){\n  for (  Selection.Element element : mSelection.getElements()) {\n    ConstraintWidget widget=element.widget;\n    ResizeHandle handle=findResizeHandleInWidget(widget,x,y,transform);\n    if (handle != null) {\n      return handle;\n    }\n  }\n  for (  ConstraintWidget widget : mWidgets.values()) {\n    if (widget.isRootContainer()) {\n      continue;\n    }\n    ResizeHandle handle=findResizeHandleInWidget(widget,x,y,transform);\n    if (handle != null) {\n      return handle;\n    }\n  }\n  return null;\n}\n", "nl": "Find which ResizeHandle is close to the (x, y) coordinates"}
{"code": "private AbstractEntryReplicaData buildEntryReplicaData(IEntryHolder entry,ISynchronizationCallback syncCallback){\n  while (entry != null) {\n    XtnEntry wlXtn=entry.getWriteLockOwner();\n    boolean locked=acquireTransactionLock(entry,wlXtn);\n    ILockObject entryLock=_engine.getCacheManager().getLockManager().getLockObject(entry);\n    try {\nsynchronized (entryLock) {\n        IEntryPacket entryPacket=getEntryPacketSafely(entry,wlXtn,locked);\n        if (entryPacket == null)         return null;\n        AbstractEntryReplicaData data=newEntryReplicaData(entryPacket);\n        boolean duplicateUid=syncCallback.synchronizationDataGenerated(data);\n        if (duplicateUid)         return null;\n        return data;\n      }\n    }\n catch (    TransactionConflictException e) {\n      entry=handleTransactionConflict(entry);\n    }\n finally {\n      _engine.getCacheManager().getLockManager().freeLockObject(entryLock);\n      releaseTransactionLock(wlXtn,locked);\n    }\n  }\n  return null;\n}\n", "nl": "Creates the replica data from the entry holder"}
{"code": "public final void fileNotReachable(final boolean alarmUp,final File file){\n  if (alarmUp == FallbackAlarmsInterface.ACTIVATED) {\n    ArrayList recipients=new ArrayList();\n    MailDetailsBean mailDetails=new MailDetailsBean();\n    mailDetails.setSender(\"mruizgar@cern.ch\");\n    recipients.add(\"mruizgar@cern.ch\");\n    mailDetails.setToRecipients(recipients);\n    mailDetails.setSubject(\"File not reachable\");\n    mailDetails.setServer(\"cernmx.cern.ch\");\n    mailDetails.setMessage(\"The file \" + file.getAbsolutePath() + \" could not be reached\");\n    SMTPMailSender mailSender=new SMTPMailSender();\n    try {\n      mailSender.sendMail(mailDetails);\n    }\n catch (    MailSenderException e) {\n      LOG.debug(e.getMessage());\n    }\n  }\n}\n", "nl": "Sends an email warning about not being able to access to a concrete file"}
{"code": "@Override public void handleMessage(Message msg){\nswitch (msg.what) {\ncase 0:\n    invalidate();\n  if (isSpinning) {\n    progress+=spinSpeed;\n    if (progress > 360) {\n      progress=0;\n    }\n    spinHandler.sendEmptyMessageDelayed(0,delayMillis);\n  }\nbreak;\ncase 1:\nspinHandler.removeMessages(0);\nisSpinning=false;\ninvalidate();\nbreak;\n}\n}\n", "nl": "This is the code that will increment the progress variable and so spin the wheel"}
{"code": "public void testDeployIntermediateVersionWithoutSignalStartEvent(){\n  String deploymentId1=deployStartSignalTestProcess();\n  assertEquals(1,getAllEventSubscriptions().size());\n  assertEquals(0,runtimeService.createProcessInstanceQuery().count());\n  runtimeService.signalEventReceived(\"myStartSignal\");\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  assertEventSubscriptionsCount(1);\n  String deploymentId2=deployProcessWithoutEvents();\n  assertEquals(0,getAllEventSubscriptions().size());\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  runtimeService.signalEventReceived(\"myStartSignal\");\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  assertEventSubscriptionsCount(0);\n  String deploymentId3=deployStartSignalTestProcess();\n  assertEquals(1,getAllEventSubscriptions().size());\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  runtimeService.signalEventReceived(\"myStartSignal\");\n  assertEquals(2,runtimeService.createProcessInstanceQuery().count());\n  assertEventSubscriptionsCount(1);\n  List<EventSubscriptionEntity> eventSubscriptions=getAllEventSubscriptions();\n  assertEquals(repositoryService.createProcessDefinitionQuery().deploymentId(deploymentId3).singleResult().getId(),eventSubscriptions.get(0).getProcessDefinitionId());\n  cleanup(deploymentId1,deploymentId2,deploymentId3);\n}\n", "nl": "v1 -> has start signal event v2 -> has no start signal event v3 -> has start signal event"}
{"code": "public static void drawTableControls(ViewTransform transform,Graphics2D g,ConstraintTableLayout table){\n  ArrayList<Guideline> vertical=table.getVerticalGuidelines();\n  Graphics2D g2=(Graphics2D)g.create();\n  g2.setStroke(new BasicStroke(1));\n  int l=transform.getSwingX(table.getDrawX());\n  int t=transform.getSwingY(table.getDrawY());\n  g2.setFont(sFont);\n  g2.drawRect(l,t - 20 - 4,20,20);\n  int column=0;\n  String align=table.getColumnAlignmentRepresentation(column++);\n  g2.drawString(align,l + 5,t - 4 - 5);\n  for (  ConstraintWidget v : vertical) {\n    int x=transform.getSwingX(v.getX()) + l;\n    g2.drawRect(x,t - 20 - 4,20,20);\n    align=table.getColumnAlignmentRepresentation(column++);\n    g2.drawString(align,x + 5,t - 4 - 5);\n  }\n  g2.dispose();\n}\n", "nl": "Draw table controls when selected"}
{"code": "public int computeNaiveLCA(Collection<Integer> taxonIds){\n  if (taxonIds.size() == 0)   return IdMapper.NOHITS_ID;\n else   if (taxonIds.size() == 1)   return taxonIds.iterator().next();\n  if (taxonIds.size() > addresses.length) {\n    addresses=new String[taxonIds.size()];\n  }\n  int numberOfAddresses=0;\n  for (  Integer id : taxonIds) {\n    if (!idMapper.isDisabled(id)) {\n      final String address=fullTree.getAddress(id);\n      if (address != null) {\n        addresses[numberOfAddresses++]=address;\n      }\n    }\n  }\n  if (numberOfAddresses > 0) {\n    final String address=LCAAddressing.getCommonPrefix(addresses,numberOfAddresses,true);\n    return fullTree.getAddress2Id(address);\n  }\n  return IdMapper.UNASSIGNED_ID;\n}\n", "nl": "returns the LCA of a set of taxon ids"}
{"code": "public void loadMultipleFragments(FragmentManager fragmentManager,int containerId,int showPos,BaseFragment... fragments){\n  FragmentTransaction ft=fragmentManager.beginTransaction();\n  ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);\n  for (int i=0; i < fragments.length; i++) {\n    BaseFragment fragment=fragments[i];\n    if (fragment == null) {\n      throw new IllegalArgumentException(\"loadMultipleFragments fragment in list can not be null \");\n    }\n    String tag=fragment.getClass().getName();\n    ft.add(containerId,fragment,tag);\n    if (showPos != i) {\n      ft.hide(fragment);\n    }\n    Bundle bundle=fragment.getArguments();\n    if (bundle != null) {\n      bundle.putBoolean(ARG_IS_ROOT,true);\n    }\n  }\n  ft.commit();\n}\n", "nl": "load multiple fragments"}
{"code": "public static void saveDocument(final Document document,final String outputFullFilename){\n  OutputStream outputStream=null;\n  try {\n    TransformerFactory transformerFactory=TransformerFactory.newInstance();\n    Transformer transformer=transformerFactory.newTransformer();\n    DOMSource domSource=new DOMSource(document);\n    transformer.setOutputProperty(OutputKeys.ENCODING,Constant.Encoding.UTF8);\n    outputStream=new FileOutputStream(outputFullFilename);\n    StreamResult result=new StreamResult(outputStream);\n    transformer.transform(domSource,result);\n  }\n catch (  Exception e) {\n    throw new JavaXmlUtilException(e);\n  }\n finally {\n    if (outputStream != null) {\n      try {\n        outputStream.close();\n      }\n catch (      Exception e) {\n        throw new JavaXmlUtilException(e);\n      }\n    }\n  }\n}\n", "nl": "save document"}
{"code": "private void addLegionMember(Legion legion,Player player,LegionRank rank){\n  player.setLegionMember(new LegionMember(player.getObjectId(),legion,rank));\n  storeLegionMember(player.getLegionMember(),true);\n  PacketSendUtility.sendPacket(player,new SM_LEGION_INFO(legion));\n  ArrayList<LegionMemberEx> totalMembers=loadLegionMemberExList(legion,player.getObjectId());\n  ListSplitter<LegionMemberEx> splits=new ListSplitter<LegionMemberEx>(totalMembers,128);\n  boolean isFirst=true;\n  while (!splits.isLast()) {\n    boolean result=false;\n    List<LegionMemberEx> curentMembers=splits.getNext();\n    if (isFirst && curentMembers.size() < totalMembers.size()) {\n      result=true;\n    }\n    PacketSendUtility.sendPacket(player,new SM_LEGION_MEMBERLIST(curentMembers,result,isFirst));\n    isFirst=false;\n  }\n  PacketSendUtility.broadcastPacketToLegion(legion,new SM_LEGION_ADD_MEMBER(player,false,1300260,player.getName()),player.getObjectId());\n  PacketSendUtility.sendPacket(player,new SM_LEGION_ADD_MEMBER(player,false,0,\"\"));\n  LegionEmblem legionEmblem=legion.getLegionEmblem();\n  PacketSendUtility.broadcastPacket(player,new SM_LEGION_UPDATE_EMBLEM(legion.getLegionId(),legionEmblem.getEmblemId(),legionEmblem.getColor_r(),legionEmblem.getColor_g(),legionEmblem.getColor_b(),legionEmblem.getEmblemType()),true);\n  PacketSendUtility.broadcastPacketToLegion(legion,new SM_LEGION_EDIT(0x08));\n  PacketSendUtility.broadcastPacket(player,new SM_LEGION_UPDATE_TITLE(player.getObjectId(),legion.getLegionId(),legion.getLegionName(),player.getLegionMember().getRank().getRankId()),true);\n}\n", "nl": "This method will add a new legion member to a legion with input rank"}
{"code": "private void fillDictionaryValuesAndAddToDictionaryChunks(DictionaryInfo dictionaryInfo,Iterator<byte[]> columnDictionaryChunkWrapper){\n  int dictionaryChunkSize=CarbonUtil.getDictionaryChunkSize();\n  int sizeOfLastDictionaryChunk=dictionaryInfo.getSizeOfLastDictionaryChunk();\n  int sizeOfOneDictionaryChunk=dictionaryChunkSize - sizeOfLastDictionaryChunk;\n  if (sizeOfOneDictionaryChunk <= 0) {\n    sizeOfOneDictionaryChunk=dictionaryChunkSize;\n  }\n  List<List<byte[]>> dictionaryChunks=new ArrayList<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n  List<byte[]> oneDictionaryChunk=new ArrayList<>(sizeOfOneDictionaryChunk);\n  dictionaryChunks.add(oneDictionaryChunk);\n  while (columnDictionaryChunkWrapper.hasNext()) {\n    oneDictionaryChunk.add(columnDictionaryChunkWrapper.next());\n    if (oneDictionaryChunk.size() >= sizeOfOneDictionaryChunk) {\n      sizeOfOneDictionaryChunk=dictionaryChunkSize;\n      oneDictionaryChunk=new ArrayList<>(sizeOfOneDictionaryChunk);\n      dictionaryChunks.add(oneDictionaryChunk);\n    }\n  }\n  for (  List<byte[]> dictionaryChunk : dictionaryChunks) {\n    if (!dictionaryChunk.isEmpty()) {\n      dictionaryInfo.addDictionaryChunk(dictionaryChunk);\n    }\n  }\n}\n", "nl": "This method will fill the dictionary values according to dictionary bucket size and add to the dictionary chunk list"}
{"code": "protected static String cast(VariableRef value,Type<?> type){\n  String castValue=value.toString();\n  String typeName=type.getCanonicalName();\n  if (type.isPrimitive()) {\n    if (value.isWrapper()) {\n      castValue=format(\"%s.%sValue()\",castValue,type);\n    }\n else     if (Character.TYPE == type.getRawType() && value.type().isString()) {\n      castValue=format(\"%s.charAt(0)\",value);\n    }\n else     if (!value.isPrimitive()) {\n      castValue=format(\"%s.valueOf(\\\"\\\"+%s).%sValue()\",type.getWrapperType().getCanonicalName(),castValue,typeName);\n    }\n  }\n else   if (type.isPrimitiveWrapper() && value.isPrimitive()) {\n    castValue=format(\"%s.valueOf(%s)\",type.getCanonicalName(),castValue);\n  }\n else   if (type.isString() && !value.type().isString()) {\n    castValue=\"\\\"\\\" + \" + castValue;\n  }\n else   if (!castValue.replace(\"(\",\"\").startsWith(typeName)) {\n    castValue=\"((\" + typeName + \")\"+ castValue+ \")\";\n  }\n  return castValue;\n}\n", "nl": "Returns Java code which provides a cast of the specified value to the type of this property ref"}
{"code": "private ResultPoint correctTopRight(ResultPoint bottomLeft,ResultPoint bottomRight,ResultPoint topLeft,ResultPoint topRight,int dimension){\n  float corr=distance(bottomLeft,bottomRight) / (float)dimension;\n  int norm=distance(topLeft,topRight);\n  float cos=(topRight.getX() - topLeft.getX()) / norm;\n  float sin=(topRight.getY() - topLeft.getY()) / norm;\n  ResultPoint c1=new ResultPoint(topRight.getX() + corr * cos,topRight.getY() + corr * sin);\n  corr=distance(bottomLeft,topLeft) / (float)dimension;\n  norm=distance(bottomRight,topRight);\n  cos=(topRight.getX() - bottomRight.getX()) / norm;\n  sin=(topRight.getY() - bottomRight.getY()) / norm;\n  ResultPoint c2=new ResultPoint(topRight.getX() + corr * cos,topRight.getY() + corr * sin);\n  if (!isValid(c1)) {\n    if (isValid(c2)) {\n      return c2;\n    }\n    return null;\n  }\n  if (!isValid(c2)) {\n    return c1;\n  }\n  int l1=Math.abs(transitionsBetween(topLeft,c1).getTransitions() - transitionsBetween(bottomRight,c1).getTransitions());\n  int l2=Math.abs(transitionsBetween(topLeft,c2).getTransitions() - transitionsBetween(bottomRight,c2).getTransitions());\n  return l1 <= l2 ? c1 : c2;\n}\n", "nl": "Calculates the position of the white top right module using the output of the rectangle detector for a square matrix"}
{"code": "public TileLayerOptions build(){\n  TileLayerOptions options=new TileLayerOptions();\n  options.minZoom=this.minZoom;\n  options.maxZoom=this.maxZoom;\n  options.maxNativeZoom=this.maxNativeZoom;\n  options.tileSize=this.tileSize;\n  options.subdomains=this.subdomains;\n  options.errorTileUrl=this.errorTileUrl;\n  options.attribution=this.attribution;\n  options.tms=this.tms;\n  options.continuousWorld=this.continuousWorld;\n  options.noWrap=this.noWrap;\n  options.zoomOffset=this.zoomOffset;\n  options.zoomReverse=this.zoomReverse;\n  options.opacity=this.opacity;\n  options.zIndex=this.zIndex;\n  options.unloadInvisibleTiles=this.unloadInvisibleTiles;\n  options.updateWhenIdle=this.updateWhenIdle;\n  options.detectRetina=this.detectRetina;\n  options.reuseTiles=this.reuseTiles;\n  options.bounds=this.bounds;\n  return options;\n}\n", "nl": "Builds the TileLayerOptions new instance"}
{"code": "public PolylineOptions build(){\n  PolylineOptions options=new PolylineOptions();\n  options.smoothFactor=this.smoothFactor;\n  options.noClip=this.noClip;\n  options.stroke=this.stroke;\n  options.color=this.color;\n  options.weight=this.weight;\n  options.opacity=this.opacity;\n  options.fill=this.fill;\n  options.fillColor=this.fillColor;\n  options.fillOpacity=this.fillOpacity;\n  options.fillRule=this.fillRule;\n  options.dashArray=this.dashArray;\n  options.lineCap=this.lineCap;\n  options.lineJoin=this.lineJoin;\n  options.clickable=this.clickable;\n  options.pointerEvents=this.pointerEvents;\n  options.className=this.className;\n  return options;\n}\n", "nl": "Builds the PolylineOptions new instance"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  ClassificationViewer classificationViewer=(ClassificationViewer)((Director)getDir()).getViewerByClassName(cName);\n  if (classificationViewer == null) {\n    try {\n      classificationViewer=new ClassificationViewer((Director)getDir(),ClassificationManager.get(cName,true),true);\n      getDir().addViewer(classificationViewer);\n    }\n catch (    Exception e) {\n      Basic.caught(e);\n    }\n  }\n  if (classificationViewer != null) {\n    classificationViewer.updateView(Director.ALL);\n    classificationViewer.getFrame().setVisible(true);\n    classificationViewer.getFrame().setState(JFrame.NORMAL);\n    classificationViewer.getFrame().toFront();\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private boolean canDisbandLegion(Player activePlayer,Legion legion){\n  if (legion == null) {\n    return false;\n  }\n  if (!isBrigadeGeneral(activePlayer)) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_DISPERSE_ONLY_MASTER_CAN_DISPERSE);\n    return false;\n  }\n else   if (legion.getLegionWarehouse().size() > 0) {\n    return false;\n  }\n else   if (legion.isDisbanding()) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_DISPERSE_ALREADY_REQUESTED);\n    return false;\n  }\n else   if (legion.getLegionWarehouse().size() > 0) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_DISPERSE_CANT_DISPERSE_GUILD_STORE_ITEM_IN_WAREHOUSE);\n    return false;\n  }\n  return true;\n}\n", "nl": "This method checks all restrictions for disband legion"}
{"code": "public static boolean isSuitableAttribute(SampleAttributeTable sampleAttributeTable,String attribute){\n  if (sampleAttributeTable.isSecretAttribute(attribute) || sampleAttributeTable.isHiddenAttribute(attribute))   return false;\n  boolean ok=true;\n  Map<Object,Integer> value2count=new HashMap<>();\n  for (  String sample : sampleAttributeTable.getSampleOrder()) {\n    Object value=sampleAttributeTable.get(sample,attribute);\n    if (value == null) {\n      ok=false;\n      break;\n    }\n else {\n      Integer count=value2count.get(value);\n      if (count == null)       value2count.put(value,1);\n else       value2count.put(value,count + 1);\n    }\n  }\n  if (ok) {\n    for (    Integer count : value2count.values()) {\n      if (count < 2) {\n        ok=false;\n        break;\n      }\n    }\n  }\n  return ok;\n}\n", "nl": "test whether there are at least two samples for each attribute value"}
{"code": "private org.apache.carbondata.format.DataType fromWrapperToExternalDataType(DataType dataType){\n  if (null == dataType) {\n    return null;\n  }\nswitch (dataType) {\ncase STRING:\n    return org.apache.carbondata.format.DataType.STRING;\ncase INT:\n  return org.apache.carbondata.format.DataType.INT;\ncase SHORT:\nreturn org.apache.carbondata.format.DataType.SHORT;\ncase LONG:\nreturn org.apache.carbondata.format.DataType.LONG;\ncase DOUBLE:\nreturn org.apache.carbondata.format.DataType.DOUBLE;\ncase DECIMAL:\nreturn org.apache.carbondata.format.DataType.DECIMAL;\ncase TIMESTAMP:\nreturn org.apache.carbondata.format.DataType.TIMESTAMP;\ncase ARRAY:\nreturn org.apache.carbondata.format.DataType.ARRAY;\ncase STRUCT:\nreturn org.apache.carbondata.format.DataType.STRUCT;\ndefault :\nreturn org.apache.carbondata.format.DataType.STRING;\n}\n}\n", "nl": "convert from wrapper to external data type"}
{"code": "public static void drawSnapVerticalMargin(ViewTransform transform,Graphics2D g,int x1,int y1,int y2,String text){\n  Canvas c=new Canvas();\n  FontMetrics fm=c.getFontMetrics(sFont);\n  g.setFont(sFont);\n  int padding=transform.getSwingDimension(4);\n  Rectangle2D bounds=fm.getStringBounds(text,g);\n  int th=(int)bounds.getHeight();\n  int offset=6 * CONNECTION_ARROW_SIZE;\n  if (y1 > y2) {\n    int temp=y1;\n    y1=y2;\n    y2=temp;\n  }\n  int h=((y2 - y1) - (th + 2 * padding)) / 2;\n  if (h <= padding) {\n    g.drawLine(x1,y1,x1,y2);\n    g.drawString(text,(int)(x1 - bounds.getWidth() / 2) + offset,y2 - h - padding);\n  }\n else {\n    g.drawLine(x1,y1,x1,y1 + h);\n    g.drawLine(x1,y2 - h,x1,y2);\n    g.drawString(text,(int)(x1 - bounds.getWidth() / 2),y2 - h - padding);\n  }\n  g.drawLine(x1 - CONNECTION_ARROW_SIZE,y1,x1 + CONNECTION_ARROW_SIZE,y1);\n  g.drawLine(x1 - CONNECTION_ARROW_SIZE,y2,x1 + CONNECTION_ARROW_SIZE,y2);\n}\n", "nl": "Draw a snap vertical margin indicator"}
{"code": "String[] parserOfCommandSyntax(String commandSyntax){\n  String sCommandWords[]=new String[Settings.nMaximumCommandWordSize];\n  int nSyntexOnePosition;\n  int nRepeatCounter=0;\n  for (; ; ) {\n    nSyntexOnePosition=commandSyntax.toLowerCase().indexOf(\" \");\n    if (nRepeatCounter >= Settings.nMaximumCommandWordSize)     return null;\n    if (Settings.ERRORCODE == nSyntexOnePosition) {\n      sCommandWords[nRepeatCounter]=commandSyntax;\n      break;\n    }\n else     if (0 == nSyntexOnePosition) {\n      return null;\n    }\n else {\n      sCommandWords[nRepeatCounter]=commandSyntax.substring(0,nSyntexOnePosition);\n      commandSyntax=commandSyntax.substring(nSyntexOnePosition + 1,commandSyntax.length());\n    }\n    nRepeatCounter++;\n  }\n  for (int i=nRepeatCounter + 1; i < Settings.nMaximumCommandWordSize; i++) {\n    sCommandWords[i]=\" \";\n  }\n  for (int i=0; i < Settings.nMaximumCommandWordSize; i++) {\n    if (sCommandWords[i] != \" \")     System.out.println(\"execution command Queue[\" + i + \"] :\"+ sCommandWords[i]);\n  }\n  return sCommandWords;\n}\n", "nl": "parse shell commends"}
{"code": "private Object evaluate(String val){\n  if (val == null || val.isEmpty())   return null;\n  if (\"?\".equals(val))   return PARAMETER_PLACEHOLDER;\n  boolean isValue=stringPattern.matcher(val).matches();\n  if (isValue) {\n    return val.substring(1,val.length() - 1);\n  }\n  isValue=booleanPattern.matcher(val).matches();\n  if (isValue) {\n    return Boolean.valueOf(val);\n  }\n  isValue=numberPattern.matcher(val).matches();\n  if (isValue) {\n    int floatIndex=val.indexOf('.');\n    if (floatIndex > -1) {\n      return Double.valueOf(val);\n    }\n    return Long.valueOf(val);\n  }\n  throw new IllegalArgumentException(val);\n}\n", "nl": "Evaluate string presentation to object"}
{"code": "public static Map<String,Object> performFindItem(DispatchContext dctx,Map<String,Object> context){\n  context.put(\"viewSize\",1);\n  context.put(\"viewIndex\",0);\n  Map<String,Object> result=org.ofbiz.common.FindServices.performFind(dctx,context);\n  List<GenericValue> list=null;\n  GenericValue item=null;\n  try {\n    EntityListIterator it=(EntityListIterator)result.get(\"listIt\");\n    list=it.getPartialList(1,1);\n    if (UtilValidate.isNotEmpty(list)) {\n      item=list.get(0);\n    }\n    it.close();\n  }\n catch (  Exception e) {\n    Debug.logInfo(\"Problem getting list Item\" + e,module);\n  }\n  if (!UtilValidate.isEmpty(item)) {\n    result.put(\"item\",item);\n  }\n  result.remove(\"listIt\");\n  if (result.containsKey(\"listSize\")) {\n    result.remove(\"listSize\");\n  }\n  return result;\n}\n", "nl": "Returns the first generic item of the service 'performFind' Same parameters as performFind service but returns a single GenericValue"}
{"code": "private static void resolveConstantReference(ConstantReference objSubjectExpression,@Nullable Function objScope,PhpIndex objIndex,HashSet<String> objTypesSet){\n  if (ExpressionSemanticUtil.isBoolean(objSubjectExpression)) {\n    objTypesSet.add(Types.strBoolean);\n    return;\n  }\n  if (PhpLangUtil.isNull(objSubjectExpression)) {\n    objTypesSet.add(Types.strNull);\n    return;\n  }\n  final String types;\n  final Collection<? extends PhpNamedElement> declaration=objSubjectExpression.resolveGlobal(false);\n  if (declaration.size() > 0) {\n    types=declaration.iterator().next().getType().toString();\n  }\n else {\n    types=objSubjectExpression.getType().toString();\n  }\n  storeAsTypeWithSignaturesImport(types,objScope,objIndex,objTypesSet);\n}\n", "nl": "Will resolve constants references"}
{"code": "private Double completeOperation(Double first,Double second,Character operation){\n  Double result=0.0;\nswitch (operation) {\ncase '+':\n    result=first + second;\n  break;\ncase '-':\nif (first == null) {\n  result=-second;\n}\n else {\n  result=first - second;\n}\nbreak;\ncase '*':\nresult=first * second;\nbreak;\ncase '/':\nresult=first / second;\nbreak;\ndefault :\nbreak;\n}\nreturn result;\n}\n", "nl": "A function returns the value of [first] [operation] [second]"}
{"code": "public int computeNaiveLCA(final int[] taxonIds,final int length){\n  if (length == 0)   return IdMapper.NOHITS_ID;\n else   if (length == 1)   return taxonIds[0];\n  if (taxonIds.length > addresses.length) {\n    addresses=new String[taxonIds.length];\n    weights=new int[taxonIds.length];\n  }\n  int numberOfAddresses=0;\n  for (int i=0; i < length; i++) {\n    int taxonId=taxonIds[i];\n    if (!TaxonomyData.isTaxonDisabled(taxonId)) {\n      String address=TaxonomyData.getAddress(taxonId);\n      if (address != null) {\n        addresses[numberOfAddresses++]=address;\n      }\n    }\n  }\n  if (numberOfAddresses > 0) {\n    final String address=LCAAddressing.getCommonPrefix(addresses,numberOfAddresses,true);\n    return TaxonomyData.getAddress2Id(address);\n  }\n  return IdMapper.UNASSIGNED_ID;\n}\n", "nl": "returns the LCA of a set of taxon ids"}
{"code": "private void moveToFirst() throws IOException {\n  nextHeaderPosition=position;\n  nextHeader=r.readLine();\n  if (nextHeader != null) {\n    position+=nextHeader.length() + endOfLineBytes;\n    String aLine;\n    while ((aLine=r.readLine()) != null) {\n      if (aLine.startsWith(\">\")) {\n        nextNextHeaderPosition=position;\n        nextNextHeader=aLine;\n        position+=aLine.length() + endOfLineBytes;\n        break;\n      }\n else {\n        position+=aLine.length() + endOfLineBytes;\n        parts.add(aLine);\n      }\n    }\n    nextSequence=Basic.concatenateAndRemoveWhiteSpaces(parts);\n    parts.clear();\n  }\n else   close();\n}\n", "nl": "move to first fastA record"}
{"code": "public static boolean login(String url,Context context,LoginCallback callback){\n  AuthErrors authError=authErrorsFromUrl(url);\n  if (authError != null) {\nswitch (authError.type) {\ncase EmailVerification:\n      callback.onEmailVerificationNeeded(authError.resendLink);\n    return true;\ncase DomainBlackList:\n  callback.onErrorDomainBlackList();\nreturn true;\n}\nreturn false;\n}\nAuthCredential authCredentials=authCredentialsFromUrl(url);\nif (authCredentials != null) {\nAirMap.getInstance().setAuthToken(authCredentials.getAccessToken());\nif (authCredentials.getRefreshToken() != null && !authCredentials.getRefreshToken().isEmpty()) {\nSharedPreferences preferences=PreferenceManager.getDefaultSharedPreferences(context);\npreferences.edit().putString(Utils.REFRESH_TOKEN_KEY,authCredentials.getRefreshToken()).apply();\n}\ncallback.onSuccess(authCredentials);\nreturn true;\n}\ncallback.onContinue();\nreturn false;\n}\n", "nl": "Checks for Auth Errors or AuthCredentials, if Valid, Saves AuthCredentials"}
{"code": "public static void sendSetBindPoint(Player player){\n  int worldId;\n  float x, y, z;\n  if (player.getBindPoint() != null) {\n    BindPointPosition bplist=player.getBindPoint();\n    worldId=bplist.getMapId();\n    x=bplist.getX();\n    y=bplist.getY();\n    z=bplist.getZ();\n  }\n else {\n    PlayerInitialData.LocationData locationData=DataManager.PLAYER_INITIAL_DATA.getSpawnLocation(player.getRace());\n    worldId=locationData.getMapId();\n    x=locationData.getX();\n    y=locationData.getY();\n    z=locationData.getZ();\n  }\n  PacketSendUtility.sendPacket(player,new SM_BIND_POINT_INFO(worldId,x,y,z,player));\n}\n", "nl": "This method will send the set bind point packet"}
{"code": "private Map<String,List<ChartObject>> calculateDiffs(List<ChartObject> initial,Sort sorting){\n  if (initial.isEmpty())   return new HashMap<>();\n  if (sorting.toString().contains(Sort.Direction.DESC.name())) {\n    Integer previous=Integer.valueOf(initial.get(initial.size() - 1).getValues().get(getTotalFieldName()));\n    for (int i=initial.size() - 1; i >= 0; i--) {\n      Integer current=Integer.valueOf(initial.get(i).getValues().get(getTotalFieldName()));\n      initial.get(i).getValues().put(DELTA,String.valueOf(current - previous));\n      previous=current;\n    }\n  }\n else {\n    Integer previous=Integer.valueOf(initial.get(0).getValues().get(getTotalFieldName()));\n    for (    ChartObject anInitial : initial) {\n      Integer current=Integer.valueOf(anInitial.getValues().get(getTotalFieldName()));\n      anInitial.getValues().put(DELTA,String.valueOf(current - previous));\n      previous=current;\n    }\n  }\n  Map<String,List<ChartObject>> result=new HashMap<>();\n  result.put(RESULT,initial);\n  return result;\n}\n", "nl": "Calculation of differences in one group or in overall array of items"}
{"code": "@Override public String toString(){\n  StringBuilder theString=new StringBuilder();\n  theString.append(\"[GenericEntity:\");\n  theString.append(getEntityName());\n  theString.append(']');\n  for (  String curKey : new TreeSet<String>(fields.keySet())) {\n    Object curValue=fields.get(curKey);\n    ModelField field=this.getModelEntity().getField(curKey);\n    if (field.getEncryptMethod().isEncrypted() && curValue instanceof String) {\n      String encryptField=(String)curValue;\n      curValue=HashCrypt.cryptBytes(null,null,encryptField.getBytes());\n    }\n    theString.append('[');\n    theString.append(curKey);\n    theString.append(',');\n    theString.append(curValue);\n    theString.append('(');\n    theString.append(curValue != null ? curValue.getClass().getName() : \"\");\n    theString.append(')');\n    theString.append(']');\n  }\n  return theString.toString();\n}\n", "nl": "Creates a String for the entity, overrides the default toString This method is secure, it will not display encrypted fields"}
{"code": "private static void updateNetwork(WifiManager wifiManager,WifiConfiguration config){\n  Integer foundNetworkID=findNetworkInExistingConfig(wifiManager,config.SSID);\n  if (foundNetworkID != null) {\n    Log.i(TAG,\"Removing old configuration for network \" + config.SSID);\n    wifiManager.removeNetwork(foundNetworkID);\n    wifiManager.saveConfiguration();\n  }\n  int networkId=wifiManager.addNetwork(config);\n  if (networkId >= 0) {\n    if (wifiManager.enableNetwork(networkId,true)) {\n      Log.i(TAG,\"Associating to network \" + config.SSID);\n      wifiManager.saveConfiguration();\n    }\n else {\n      Log.w(TAG,\"Failed to enable network \" + config.SSID);\n    }\n  }\n else {\n    Log.w(TAG,\"Unable to add network \" + config.SSID);\n  }\n}\n", "nl": "Update the network: either create a new network or modify an existing network"}
{"code": "public ServiceType(Class clazz,ServiceType superclass,ServiceType[] interfaces) throws MarshalException {\n  if (!Proxy.isProxyClass(clazz)) {\n    name=clazz.getName();\n  }\n else   if (interfaces.length == 0) {\n    name=\";\";\n  }\n else {\n    StringBuffer buf=new StringBuffer();\n    for (int i=0; i < interfaces.length; i++) {\n      buf.append(';');\n      buf.append(interfaces[i].getName());\n    }\n    name=buf.toString();\n  }\n  this.superclass=superclass;\n  if (clazz != Object.class)   this.interfaces=interfaces;\n  try {\n    computeHash();\n  }\n catch (  Exception e) {\n    throw new MarshalException(\"unable to calculate the type hash for \" + name,e);\n  }\n}\n", "nl": "Should only be called by ClassMapper"}
{"code": "public static final String formatSpeed(float speed){\n  float realSpeed=speed * KB_CONSTANT;\n  if (realSpeed < KB_CONSTANT) {\n    float kSize=realSpeed / KB_CONSTANT;\n    kSize=((float)((int)(kSize * 10))) / 10;\n    return kSize + \" B/s\";\n  }\n else   if (realSpeed < MB_CONSTANT) {\n    float kSize=realSpeed / KB_CONSTANT;\n    kSize=((float)((int)(kSize * 10))) / 10;\n    return kSize + \" KB/s\";\n  }\n else   if (realSpeed < GB_CONSTANT) {\n    float kSize=realSpeed / MB_CONSTANT;\n    kSize=((float)((int)(kSize * 10))) / 10;\n    return kSize + \" MB/s\";\n  }\n else {\n    float kSize=realSpeed / GB_CONSTANT;\n    kSize=((float)((int)(kSize * 100))) / 100;\n    return kSize + \" GB/s\";\n  }\n}\n", "nl": "Format the download speed"}
{"code": "private ResultPoint correctTopRightRectangular(ResultPoint bottomLeft,ResultPoint bottomRight,ResultPoint topLeft,ResultPoint topRight,int dimensionTop,int dimensionRight){\n  float corr=distance(bottomLeft,bottomRight) / (float)dimensionTop;\n  int norm=distance(topLeft,topRight);\n  float cos=(topRight.getX() - topLeft.getX()) / norm;\n  float sin=(topRight.getY() - topLeft.getY()) / norm;\n  ResultPoint c1=new ResultPoint(topRight.getX() + corr * cos,topRight.getY() + corr * sin);\n  corr=distance(bottomLeft,topLeft) / (float)dimensionRight;\n  norm=distance(bottomRight,topRight);\n  cos=(topRight.getX() - bottomRight.getX()) / norm;\n  sin=(topRight.getY() - bottomRight.getY()) / norm;\n  ResultPoint c2=new ResultPoint(topRight.getX() + corr * cos,topRight.getY() + corr * sin);\n  if (!isValid(c1)) {\n    if (isValid(c2)) {\n      return c2;\n    }\n    return null;\n  }\n  if (!isValid(c2)) {\n    return c1;\n  }\n  int l1=Math.abs(dimensionTop - transitionsBetween(topLeft,c1).getTransitions()) + Math.abs(dimensionRight - transitionsBetween(bottomRight,c1).getTransitions());\n  int l2=Math.abs(dimensionTop - transitionsBetween(topLeft,c2).getTransitions()) + Math.abs(dimensionRight - transitionsBetween(bottomRight,c2).getTransitions());\n  if (l1 <= l2) {\n    return c1;\n  }\n  return c2;\n}\n", "nl": "Calculates the position of the white top right module using the output of the rectangle detector for a rectangular matrix"}
{"code": "protected int findClosest(Color c){\n  if (colorTab == null)   return -1;\n  int r=c.getRed();\n  int g=c.getGreen();\n  int b=c.getBlue();\n  int minpos=0;\n  int dmin=256 * 256 * 256;\n  int len=colorTab.length;\n  for (int i=0; i < len; ) {\n    int dr=r - (colorTab[i++] & 0xff);\n    int dg=g - (colorTab[i++] & 0xff);\n    int db=b - (colorTab[i] & 0xff);\n    int d=dr * dr + dg * dg + db * db;\n    int index=i / 3;\n    if (usedEntry[index] && (d < dmin)) {\n      dmin=d;\n      minpos=index;\n    }\n    i++;\n  }\n  return minpos;\n}\n", "nl": "Returns index of palette color closest to c"}
{"code": "public void apply(Map<Integer,String> taxId2TaxName,Map<String,Integer> taxName2TaxId){\n  for (  Edit edit : list) {\nswitch (edit.type) {\ncase Edit.APPEND:\n      taxId2TaxName.put(edit.taxId,edit.taxName);\n    taxName2TaxId.put(edit.taxName,edit.taxId);\n  break;\ncase Edit.RENAME:\ntaxId2TaxName.put(edit.taxId,edit.taxName);\ntaxName2TaxId.put(edit.taxName,edit.taxId);\nbreak;\ncase Edit.DELETE:\ntaxId2TaxName.remove(edit.taxId);\ntaxName2TaxId.remove(edit.taxName);\nbreak;\ndefault :\nbreak;\n}\n}\n}\n", "nl": "apply the edits to the tax mapping"}
{"code": "public ByteFileGetterInMemory(File file) throws IOException, CanceledException {\n  limit=file.length();\n  data=new byte[(int)((limit >>> BITS)) + 1][];\n  final int length0=(1 << BITS);\n  for (int i=0; i < data.length; i++) {\n    int length=(i < data.length - 1 ? length0 : (int)(limit & BIT_MASK) + 1);\n    data[i]=new byte[length];\n  }\n  try (InputStream ins=new BufferedInputStream(new FileInputStream(file));ProgressPercentage progress=new ProgressPercentage(\"Reading file: \" + file,limit)){\n    int whichArray=0;\n    int indexInArray=0;\n    for (long index=0; index < limit; index++) {\n      data[whichArray][indexInArray]=(byte)ins.read();\n      if (++indexInArray == length0) {\n        whichArray++;\n        indexInArray=0;\n      }\n      progress.setProgress(index);\n    }\n    progress.close();\n  }\n }\n", "nl": "int file getter in memory"}
{"code": "protected int findClosest(Color c){\n  if (colorTab == null)   return -1;\n  int r=c.getRed();\n  int g=c.getGreen();\n  int b=c.getBlue();\n  int minpos=0;\n  int dmin=256 * 256 * 256;\n  int len=colorTab.length;\n  for (int i=0; i < len; ) {\n    int dr=r - (colorTab[i++] & 0xff);\n    int dg=g - (colorTab[i++] & 0xff);\n    int db=b - (colorTab[i] & 0xff);\n    int d=dr * dr + dg * dg + db * db;\n    int index=i / 3;\n    if (usedEntry[index] && (d < dmin)) {\n      dmin=d;\n      minpos=index;\n    }\n    i++;\n  }\n  return minpos;\n}\n", "nl": "Returns index of palette color closest to c"}
{"code": "public static String loadCartFromQuote(HttpServletRequest request,HttpServletResponse response){\n  LocalDispatcher dispatcher=(LocalDispatcher)request.getAttribute(\"dispatcher\");\n  HttpSession session=request.getSession();\n  GenericValue userLogin=(GenericValue)session.getAttribute(\"userLogin\");\n  String quoteId=request.getParameter(\"quoteId\");\n  ShoppingCart cart=null;\n  try {\n    Map<String,Object> outMap=dispatcher.runSync(\"loadCartFromQuote\",UtilMisc.<String,Object>toMap(\"quoteId\",quoteId,\"applyQuoteAdjustments\",\"true\",\"userLogin\",userLogin));\n    if (!ServiceUtil.isSuccess(outMap)) {\n      request.setAttribute(\"_ERROR_MESSAGE_\",ServiceUtil.getErrorMessage(outMap));\n      return \"error\";\n    }\n    cart=(ShoppingCart)outMap.get(\"shoppingCart\");\n  }\n catch (  GenericServiceException exc) {\n    request.setAttribute(\"_ERROR_MESSAGE_\",exc.getMessage());\n    return \"error\";\n  }\n  cart.setDefaultCheckoutOptions(dispatcher);\n  cart.setReadOnlyCart(true);\n  session.setAttribute(\"shoppingCart\",cart);\n  session.setAttribute(\"productStoreId\",cart.getProductStoreId());\n  session.setAttribute(\"orderMode\",cart.getOrderType());\n  session.setAttribute(\"orderPartyId\",cart.getOrderPartyId());\n  return \"success\";\n}\n", "nl": "Initialize order entry from a quote"}
{"code": "public static String parseHumpName(String str,boolean isFirstUpper,boolean isHump){\n  str=str.toLowerCase();\n  if (isHump && str.indexOf(\"_\") != -1) {\n    boolean isUpper=false;\n    StringBuilder builder=new StringBuilder();\n    for (    char c : str.toCharArray()) {\n      if (isUpper) {\n        c=Character.toUpperCase(c);\n        isUpper=false;\n      }\n      if (c == '_') {\n        isUpper=true;\n        continue;\n      }\n      builder.append(c);\n    }\n    str=builder.toString();\n  }\n  if (isFirstUpper) {\n    return upperFirst(str);\n  }\n  return lowerFirst(str);\n}\n", "nl": "parse str to hump type<p> if class name ,param isFirstUpper should be true,else false"}
{"code": "protected void writeGraphicCtrlExt() throws IOException {\n  out.write(0x21);\n  out.write(0xf9);\n  out.write(4);\n  int transp, disp;\n  if (transparent == -1) {\n    transp=0;\n    disp=0;\n  }\n else {\n    transp=1;\n    disp=2;\n  }\n  if (dispose >= 0) {\n    disp=dispose & 7;\n  }\n  disp<<=2;\n  out.write(0 | disp | 0| transp);\n  writeShort(delay);\n  out.write(transIndex);\n  out.write(0);\n}\n", "nl": "Writes Graphic Control Extension"}
{"code": "public static long toEpochDay(int packedDate){\n  long y=PackedLocalDate.getYear(packedDate);\n  long m=PackedLocalDate.getMonthValue(packedDate);\n  long total=0;\n  total+=365 * y;\n  if (y >= 0) {\n    total+=(y + 3) / 4 - (y + 99) / 100 + (y + 399) / 400;\n  }\n else {\n    total-=y / -4 - y / -100 + y / -400;\n  }\n  total+=((367 * m - 362) / 12);\n  total+=getDayOfMonth(packedDate) - 1;\n  if (m > 2) {\n    total--;\n    if (!isLeapYear(packedDate)) {\n      total--;\n    }\n  }\n  return total - DAYS_0000_TO_1970;\n}\n", "nl": "Returns the epoch day in a form consistent with the java standard"}
{"code": "public void computeStandaloneResponse() throws IOException {\n  String inputData=SystemConfiguration.getProperty(\"pir.inputData\");\n  try {\n    BufferedReader br=new BufferedReader(new FileReader(inputData));\n    String line;\n    JSONParser jsonParser=new JSONParser();\n    while ((line=br.readLine()) != null) {\n      logger.info(\"line = \" + line);\n      JSONObject jsonData=(JSONObject)jsonParser.parse(line);\n      logger.info(\"jsonData = \" + jsonData.toJSONString());\n      String selector=QueryUtils.getSelectorByQueryTypeJSON(qSchema,jsonData);\n      addDataElement(selector,jsonData);\n    }\n    br.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  String outputFile=SystemConfiguration.getProperty(\"pir.outputFile\");\n  setResponseElements();\n  new LocalFileSystemStore().store(outputFile,response);\n}\n", "nl": "Method to compute the standalone response <p> Assumes that the input data is a single file in the local filesystem and is fully qualified"}
{"code": "public void readRep(Repository rep,ObjectId idStep,List<DatabaseMeta> databases,Map<String,Counter> counters) throws KettleException {\n  try {\n    this.tabelName=rep.getStepAttributeString(idStep,\"TableName\");\n    this.outputRowSize=rep.getStepAttributeString(idStep,\"outputRowSize\");\n    this.databaseName=rep.getStepAttributeString(idStep,\"databaseName\");\n    this.tableName=rep.getStepAttributeString(idStep,\"tableName\");\n    this.dimensionCount=rep.getStepAttributeString(idStep,\"dimensionCount\");\n    this.noDictionaryDims=rep.getStepAttributeString(idStep,\"noDictionaryDims\");\n    this.noDictionaryDims=rep.getStepAttributeString(idStep,\"noDictionaryDimsMapping\");\n    this.complexDimensionCount=rep.getStepAttributeString(idStep,\"complexDimensionCount\");\n    this.measureCount=rep.getStepAttributeString(idStep,\"measureCount\");\n    this.updateMemberRequest=rep.getStepAttributeString(idStep,\"isUpdateMemberRequest\");\n    this.measureDataType=rep.getStepAttributeString(idStep,\"measureDataType\");\n    this.partitionID=rep.getStepAttributeString(idStep,\"partitionID\");\n    this.segmentId=rep.getStepAttributeString(idStep,\"segmentId\");\n    this.taskNo=rep.getStepAttributeString(idStep,\"taskNo\");\n  }\n catch (  Exception ex) {\n    throw new KettleException(BaseMessages.getString(PKG,\"CarbonDataWriterStepMeta.Exception.UnexpectedErrorInReadingStepInfo\",new String[0]),ex);\n  }\n}\n", "nl": "Read the steps information from a Kettle repository"}
{"code": "@deprecated protected int handleGetExtendedYear(){\n  int eyear;\n  int eyear;\n  if (newerField(19,1) == 19) {\n    eyear=internalGet(19,1);\n  }\n else {\n    int eyear;\n    if (isAmeteAlemEra()) {\n      eyear=internalGet(1,5501) - 5500;\n    }\n else {\n      int era=internalGet(0,1);\n      int eyear;\n      if (era == 1) {\n        eyear=internalGet(1,1);\n      }\n else       eyear=internalGet(1,1) - 5500;\n    }\n  }\n  return eyear;\n}\n", "nl": "/*    "}
{"code": "public SyllableIterator(FeatureFileReader features,int fromUnitIndex,int toUnitIndex){\n  this.features=features;\n  this.fromUnitIndex=fromUnitIndex;\n  this.toUnitIndex=toUnitIndex;\n  FeatureDefinition featureDefinition=features.getFeatureDefinition();\n  fiPhone=featureDefinition.getFeatureIndex(\"phone\");\n  fvPhone_0=featureDefinition.getFeatureValueAsByte(fiPhone,\"0\");\n  fvPhone_Silence=featureDefinition.getFeatureValueAsByte(fiPhone,\"_\");\n  fiSylStart=featureDefinition.getFeatureIndex(\"segs_from_syl_start\");\n  fiSylEnd=featureDefinition.getFeatureIndex(\"segs_from_syl_end\");\n  String halfphoneFeature=\"halfphone_lr\";\n  if (featureDefinition.hasFeature(halfphoneFeature)) {\n    isHalfphone=true;\n    fiLR=featureDefinition.getFeatureIndex(halfphoneFeature);\n    fvLR_L=featureDefinition.getFeatureValueAsByte(fiLR,\"L\");\n    fvLR_R=featureDefinition.getFeatureValueAsByte(fiLR,\"R\");\n  }\n else {\n    isHalfphone=false;\n    fiLR=fvLR_L=fvLR_R=0;\n  }\n  i=fromUnitIndex;\n}\n", "nl": "Create a syllable iterator over the given feature file, starting from the given fromUnitIndex and reaching up to (and including) the  given toUnitIndex"}
{"code": "protected void cloneNode(CoreDocumentImpl newdoc,boolean deep){\n  if (needsSyncChildren()) {\n    synchronizeChildren();\n  }\n  if (deep) {\n    HashMap reversedIdentifiers=null;\n    if (identifiers != null) {\n      reversedIdentifiers=new HashMap();\n      Iterator entries=identifiers.entrySet().iterator();\n      while (entries.hasNext()) {\n        Map.Entry entry=(Map.Entry)entries.next();\n        Object elementId=entry.getKey();\n        Object elementNode=entry.getValue();\n        reversedIdentifiers.put(elementNode,elementId);\n      }\n    }\n    for (ChildNode kid=firstChild; kid != null; kid=kid.nextSibling) {\n      newdoc.appendChild(newdoc.importNode(kid,true,true,reversedIdentifiers));\n    }\n  }\n  newdoc.allowGrammarAccess=allowGrammarAccess;\n  newdoc.errorChecking=errorChecking;\n}\n", "nl": "internal method to share code with subclass"}
{"code": "private void addMissingToTree(String unclassifiedNodeLabel,int unclassifiedNodeId,String labelFormat,final int maxId){\n  Node unclassified=null;\n  for (int id=1; id <= maxId; id++) {\n    if (!containsId(id)) {\n      if (unclassified == null) {\n        unclassified=newNode();\n        Edge before=null;\n        for (Edge e=getRoot().getFirstOutEdge(); e != null; e=getRoot().getNextOutEdge(e)) {\n          Node w=e.getTarget();\n          Integer wid=(Integer)w.getInfo();\n          if (wid < 0) {\n            before=e;\n            break;\n          }\n        }\n        if (before != null)         newEdge(getRoot(),before,unclassified,null,Edge.BEFORE,Edge.AFTER,null);\n else         newEdge(getRoot(),unclassified);\n        unclassified.setInfo(unclassifiedNodeId);\n        addId2Node(unclassifiedNodeId,unclassified);\n        name2IdMap.put(unclassifiedNodeLabel,unclassifiedNodeId);\n      }\n      Node v=newNode(id);\n      newEdge(unclassified,v);\n      name2IdMap.put(String.format(labelFormat,id),id);\n      addId2Node(id,v);\n    }\n  }\n}\n", "nl": "add all ids that many be missing from the tree to the tree"}
{"code": "private void insertTargetF0Values() throws Exception {\n  NodeList phoneNodes;\n  try {\n    phoneNodes=getPhoneNodes();\n  }\n catch (  Exception e) {\n    Log.d(Mary.LOG,new Exception(\"Could not get the phone Nodes from the Document\",e).toString());\n    throw new Exception(\"Could not get the phone Nodes from the Document\",e);\n  }\n  int totalNumberOfFrames=getNumberOfFrames();\n  ProsodyElementHandler elementHandler=new ProsodyElementHandler();\n  double[] f0Targets=elementHandler.getF0Contour(phoneNodes,totalNumberOfFrames);\n  int f0TargetStartIndex=0;\n  for (  Phone phone : phones) {\n    int numberOfLeftUnitFrames=phone.getNumberOfLeftUnitFrames();\n    int f0TargetMidIndex=f0TargetStartIndex + numberOfLeftUnitFrames;\n    double[] leftF0Targets=ArrayUtils.subarray(f0Targets,f0TargetStartIndex,f0TargetMidIndex);\n    phone.setLeftTargetF0Values(leftF0Targets);\n    int numberOfRightUnitFrames=phone.getNumberOfRightUnitFrames();\n    int f0TargetEndIndex=f0TargetMidIndex + numberOfRightUnitFrames;\n    double[] rightF0Targets=ArrayUtils.subarray(f0Targets,f0TargetMidIndex,f0TargetEndIndex);\n    phone.setRightTargetF0Values(rightF0Targets);\n    f0TargetStartIndex=f0TargetEndIndex;\n  }\n  return;\n}\n", "nl": "Assign predicted F0 values to the phones by parsing the XML Document"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set showGroups=\");\n  final boolean show=np.getBoolean();\n  final String style;\n  if (np.peekMatchIgnoreCase(\"style\")) {\n    np.matchIgnoreCase(\"style=\");\n    style=np.getWordMatchesIgnoringCase(\"ellipses convexHulls\");\n  }\n else   style=\"ellipses\";\n  np.matchIgnoreCase(\";\");\n  final ClusterViewer viewer=getViewer();\n  if (style.equalsIgnoreCase(\"ellipses\"))   viewer.getPcoaTab().setShowGroupsAsEllipses(show);\n else   viewer.getPcoaTab().setShowGroupsAsConvexHulls(show);\n  try {\n    if (show)     viewer.getPcoaTab().computeConvexHullsAndEllipsesForGroups(viewer.getGroup2Nodes());\n    viewer.updateView(IDirector.ENABLE_STATE);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static boolean addSmiles(Context context,Spannable spannable){\n  boolean hasChanges=false;\n  for (  Entry<Pattern,Integer> entry : emoticons.entrySet()) {\n    Matcher matcher=entry.getKey().matcher(spannable);\n    while (matcher.find()) {\n      boolean set=true;\n      for (      ImageSpan span : spannable.getSpans(matcher.start(),matcher.end(),ImageSpan.class))       if (spannable.getSpanStart(span) >= matcher.start() && spannable.getSpanEnd(span) <= matcher.end())       spannable.removeSpan(span);\n else {\n        set=false;\n        break;\n      }\n      if (set) {\n        hasChanges=true;\n        spannable.setSpan(new ImageSpan(context,entry.getValue()),matcher.start(),matcher.end(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n      }\n    }\n  }\n  return hasChanges;\n}\n", "nl": "replace existing spannable with smiles"}
{"code": "public void closeSharedIterator(){\n  _sharedObjectListLock.writeLock().lock();\n  try {\n    _numberOfConsumers--;\n    if (_closed)     return;\n    if (_sourceIteratorExhausted || _numberOfConsumers == 0) {\n      if (_logger.isLoggable(Level.FINEST))       _logger.finest(\"closed shared iterator source [\" + _identifier + \"]\");\n      triggerClosedEvent();\n      if (_sourceDataIterator != null) {\n        _sharedObjectListLock.writeLock().lock();\n        try {\n          _sourceDataIterator.close();\n        }\n  finally {\n          _sharedObjectListLock.writeLock().unlock();\n        }\n      }\n      _closed=true;\n    }\n  }\n  finally {\n    _sharedObjectListLock.writeLock().unlock();\n  }\n}\n", "nl": "Signal the source this shared data iterator is closed"}
{"code": "public static Map<String,Object> convertDocument(DispatchContext dctx,Map<String,? extends Object> context){\n  XMultiComponentFactory xmulticomponentfactory=null;\n  String stringUrl=\"file:///\" + context.get(\"filenameFrom\");\n  String stringConvertedFile=\"file:///\" + context.get(\"filenameTo\");\n  String filterName=\"file:///\" + context.get(\"filterName\");\n  String oooHost=(String)context.get(\"oooHost\");\n  String oooPort=(String)context.get(\"oooPort\");\n  try {\n    xmulticomponentfactory=OpenOfficeWorker.getRemoteServer(oooHost,oooPort);\n    OpenOfficeWorker.convertOODocToFile(xmulticomponentfactory,stringUrl,stringConvertedFile,filterName);\n    Map results=ServiceUtil.returnSuccess();\n    return results;\n  }\n catch (  IOException e) {\n    Debug.logError(e,\"Error in OpenOffice operation: \",module);\n    return ServiceUtil.returnError(e.toString());\n  }\ncatch (  Exception e) {\n    Debug.logError(e,\"Error in OpenOffice operation: \",module);\n    return ServiceUtil.returnError(e.toString());\n  }\n}\n", "nl": "Use OpenOffice to convert documents between types"}
{"code": "@SuppressWarnings(\"unchecked\") public static Object eval(String expression,Map<String,Object> context) throws CompilationFailedException {\n  Object o;\n  if (expression == null || expression.equals(\"\")) {\n    Debug.logError(\"Groovy Evaluation error. Empty expression\",module);\n    return null;\n  }\n  if (Debug.verboseOn()) {\n    Debug.logVerbose(\"Evaluating -- \" + expression,module);\n    Debug.logVerbose(\"Using Context -- \" + context,module);\n  }\n  try {\n    GroovyShell shell=new GroovyShell(getBinding(context));\n    o=shell.evaluate(StringUtil.convertOperatorSubstitutions(expression));\n    if (Debug.verboseOn()) {\n      Debug.logVerbose(\"Evaluated to -- \" + o,module);\n    }\n    Binding binding=shell.getContext();\n    context.putAll(binding.getVariables());\n  }\n catch (  CompilationFailedException e) {\n    Debug.logError(e,\"Groovy Evaluation error.\",module);\n    throw e;\n  }\n  return o;\n}\n", "nl": "Evaluate a Groovy condition or expression"}
{"code": "public static void drawCircledText(Graphics2D g,Font font,String text,int x,int y){\n  Graphics2D g2=(Graphics2D)g.create();\n  g2.setFont(font);\n  FontMetrics fm=g2.getFontMetrics();\n  int padding=4;\n  Rectangle2D bounds=fm.getStringBounds(text,g2);\n  double th=bounds.getHeight();\n  double tw=bounds.getWidth();\n  float radius=(float)(Math.max(th,tw) / 2f + padding);\n  Ellipse2D.Float circle=new Ellipse2D.Float(x - radius,y - radius,2 * radius + 1,2 * radius + 1);\n  g2.fill(circle);\n  g2.setColor(Color.BLACK);\n  g2.drawString(text,(int)(x - tw / 2),(y + fm.getAscent() / 2));\n  if (DEBUG) {\n    g2.setColor(Color.RED);\n    g2.drawLine(x - 50,y,x + 50,y);\n    g2.drawLine(x,y - 50,x,y + 50);\n  }\n  g2.dispose();\n}\n", "nl": "Utility function to draw a circle text centered at coordinates (x, y)"}
{"code": "private void findClassLayoutMappings(){\n  Iterator<MethodOrMethodContext> rmIterator=Scene.v().getReachableMethods().listener();\n  while (rmIterator.hasNext()) {\n    SootMethod sm=rmIterator.next().method();\n    if (!sm.isConcrete())     continue;\n    for (    Unit u : sm.retrieveActiveBody().getUnits())     if (u instanceof Stmt) {\n      Stmt stmt=(Stmt)u;\n      if (stmt.containsInvokeExpr()) {\n        InvokeExpr inv=stmt.getInvokeExpr();\n        if (invokesSetContentView(inv)) {\n          for (          Value val : inv.getArgs())           if (val instanceof IntConstant) {\n            IntConstant constVal=(IntConstant)val;\n            Set<Integer> layoutIDs=this.layoutClasses.get(sm.getDeclaringClass().getName());\n            if (layoutIDs == null) {\n              layoutIDs=new HashSet<Integer>();\n              this.layoutClasses.put(sm.getDeclaringClass().getName(),layoutIDs);\n            }\n            layoutIDs.add(constVal.value);\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "Finds the mappings between classes and their respective layout files"}
{"code": "@deprecated public static int matchAfter(CharSequence a,CharSequence b,int aIndex,int bIndex){\n  int i=aIndex;\n  int j=bIndex;\n  int alen=a.length();\n  int blen=b.length();\n  for (; (i < alen) && (j < blen); j++) {\n    char ca=a.charAt(i);\n    char cb=b.charAt(j);\n    if (ca != cb) {\n      break;\n    }\n    i++;\n  }\n  int result=i - aIndex;\n  if ((result != 0) && (!onCharacterBoundary(a,i)) && (!onCharacterBoundary(b,j))) {\n    result--;\n  }\n  return result;\n}\n", "nl": "/*    "}
{"code": "public static int convertToColorInt(String argb,boolean useAlpha) throws NumberFormatException {\n  if (argb.startsWith(\"#\")) {\n    argb=argb.replace(\"#\",\"\");\n  }\n  int alpha=-1, red=-1, green=-1, blue=-1;\n  if (argb.length() == 8) {\n    alpha=Integer.parseInt(argb.substring(0,2),16);\n    red=Integer.parseInt(argb.substring(2,4),16);\n    green=Integer.parseInt(argb.substring(4,6),16);\n    blue=Integer.parseInt(argb.substring(6,8),16);\n  }\n else   if (argb.length() == 6) {\n    alpha=255;\n    red=Integer.parseInt(argb.substring(0,2),16);\n    green=Integer.parseInt(argb.substring(2,4),16);\n    blue=Integer.parseInt(argb.substring(4,6),16);\n  }\n  return Color.argb(useAlpha ? alpha : -1,red,green,blue);\n}\n", "nl": "Concerts a String color (#ff882465) to an int color"}
{"code": "@Override public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (obj == null) {\n    return false;\n  }\n  if (!(obj instanceof CarbonDimension)) {\n    return false;\n  }\n  CarbonDimension other=(CarbonDimension)obj;\n  if (columnSchema == null) {\n    if (other.columnSchema != null) {\n      return false;\n    }\n  }\n else   if (!columnSchema.equals(other.columnSchema)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "to check whether to dimension are equal or not"}
{"code": "public static String decompressForGzip(byte[] compressed){\n  final int BUFFER_SIZE=compressed.length;\n  GZIPInputStream gis=null;\n  ByteArrayInputStream is=null;\n  try {\n    is=new ByteArrayInputStream(compressed);\n    gis=new GZIPInputStream(is,BUFFER_SIZE);\n    StringBuilder string=new StringBuilder();\n    byte[] data=new byte[BUFFER_SIZE];\n    int bytesRead;\n    while ((bytesRead=gis.read(data)) != -1) {\n      string.append(new String(data,0,bytesRead,\"UTF-8\"));\n    }\n    return string.toString();\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n finally {\n    okhttp3.internal.Util.closeQuietly(gis);\n    okhttp3.internal.Util.closeQuietly(is);\n  }\n  return null;\n}\n", "nl": "gzip decompress 2 string"}
{"code": "private void transfer(Entry[] src,Entry[] dest){\n  for (int j=0; j < src.length; ++j) {\n    Entry e=src[j];\n    src[j]=null;\n    while (e != null) {\n      Entry next=e.next;\n      Object key=e.get();\n      if (key == null || (timeToLive > 0 && ((TimedEntry)e).isExpired(timeToLive))) {\n        e.next=null;\n        size--;\n      }\n else {\n        int i=indexFor(e.hash,dest.length);\n        e.next=dest[i];\n        dest[i]=e;\n      }\n      e=next;\n    }\n  }\n}\n", "nl": "Transfer all entries from src to dest tables"}
{"code": "public static void dismiss(Context context){\n  try {\n    if (context instanceof Activity) {\n      if (((Activity)context).isFinishing()) {\n        loadDialog=null;\n        return;\n      }\n    }\n    if (loadDialog != null && loadDialog.isShowing()) {\n      Context loadContext=loadDialog.getContext();\n      if (loadContext != null && loadContext instanceof Activity) {\n        if (((Activity)loadContext).isFinishing()) {\n          loadDialog=null;\n          return;\n        }\n      }\n      loadDialog.dismiss();\n      loadDialog=null;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    loadDialog=null;\n  }\n}\n", "nl": "dismiss the mDialogTextView"}
{"code": "protected ContentCreateOptions newContentCreateOptions(DocumentMetadata meta){\n  ContentCreateOptions opt=(ContentCreateOptions)options.clone();\n  if (meta != null) {\n    if (opt.getQuality() == 0) {\n      opt.setQuality(meta.quality);\n    }\n    HashSet<String> colSet=new HashSet<String>(meta.collectionsList);\n    if (opt.getCollections() != null) {\n      for (      String s : opt.getCollections()) {\n        colSet.add(s);\n      }\n    }\n    opt.setCollections(colSet.toArray(new String[colSet.size()]));\n    HashSet<ContentPermission> pSet=new HashSet<ContentPermission>(meta.permissionsList);\n    if (opt.getPermissions() != null) {\n      for (      ContentPermission p : opt.getPermissions()) {\n        pSet.add(p);\n      }\n    }\n    opt.setPermissions(pSet.toArray(new ContentPermission[pSet.size()]));\n    opt.setMetadata(meta.meta);\n  }\n  return opt;\n}\n", "nl": "fetch the options information from conf and metadata, set to the field \"options\""}
{"code": "public Rectangle[] computeGaps(){\n  ArrayList<Rectangle> ret=new ArrayList<>();\n  Rectangle gap=new Rectangle();\n  for (int i=0; i < mRectList.length; i++) {\n    Rectangle rectangleA=mRectList[i];\n    for (int j=i + 1; j < mRectList.length; j++) {\n      Rectangle rectangleB=mRectList[j];\n      boolean viable=calculateGap(rectangleA,rectangleB,gap);\n      if (viable) {\n        for (int k=0; k < mRectList.length; k++) {\n          if (k != j && k != i) {\n            if (gap.intersects(mRectList[k])) {\n              viable=false;\n              break;\n            }\n          }\n        }\n      }\n      if (viable) {\n        ret.add(new Rectangle(gap));\n      }\n    }\n  }\n  return ret.toArray(new Rectangle[ret.size()]);\n}\n", "nl": "build a array of rectangles representing the gaps used for debugging purposes"}
{"code": "public void sync() throws CanceledException {\n  if (!inSync) {\n    inSync=true;\n    setChartTitle(cName + \" rarefaction plot for \" + doc.getTitle());\n    for (    String name : doc.getSampleNames()) {\n      ((Plot2DDrawer)getChartDrawer()).setShowLines(name,true);\n      ((Plot2DDrawer)getChartDrawer()).setShowDots(name,true);\n    }\n    Map<String,Collection<Pair<Number,Number>>> name2counts=computeCounts(doc,1,parentViewer,doc.getProgressListener());\n    IPlot2DData chartData=(IPlot2DData)getChartData();\n    chartData.clear();\n    chartData.setDataSetName(doc.getTitle());\n    for (    String name : doc.getSampleNames())     chartData.setDataForSeries(name,name2counts.get(name));\n    getChartData().setSeriesLabel(\"Number of reads sampled from leaves\");\n    getChartData().setCountsLabel(\"Number of leaves in \" + cName + \" tree\");\n    super.sync();\n    inSync=false;\n  }\n}\n", "nl": "synchronize chart to reflect latest user selection in taxon chart"}
{"code": "private static void updateNetwork(WifiManager wifiManager,WifiConfiguration config){\n  Integer foundNetworkID=findNetworkInExistingConfig(wifiManager,config.SSID);\n  if (foundNetworkID != null) {\n    Log.i(TAG,\"Removing old configuration for network \" + config.SSID);\n    wifiManager.removeNetwork(foundNetworkID);\n    wifiManager.saveConfiguration();\n  }\n  int networkId=wifiManager.addNetwork(config);\n  if (networkId >= 0) {\n    if (wifiManager.enableNetwork(networkId,true)) {\n      Log.i(TAG,\"Associating to network \" + config.SSID);\n      wifiManager.saveConfiguration();\n    }\n else {\n      Log.w(TAG,\"Failed to enable network \" + config.SSID);\n    }\n  }\n else {\n    Log.w(TAG,\"Unable to add network \" + config.SSID);\n  }\n}\n", "nl": "Update the network: either create a new network or modify an existing network"}
{"code": "private void algorithmDouglasPeucker(List<Entry> entries,double epsilon,int start,int end){\n  if (end <= start + 1) {\n    return;\n  }\n  int maxDistIndex=0;\n  double distMax=0;\n  Entry firstEntry=entries.get(start);\n  Entry lastEntry=entries.get(end);\n  for (int i=start + 1; i < end; i++) {\n    double dist=calcAngleBetweenLines(firstEntry,lastEntry,firstEntry,entries.get(i));\n    if (dist > distMax) {\n      distMax=dist;\n      maxDistIndex=i;\n    }\n  }\n  if (distMax > epsilon) {\n    keep[maxDistIndex]=true;\n    algorithmDouglasPeucker(entries,epsilon,start,maxDistIndex);\n    algorithmDouglasPeucker(entries,epsilon,maxDistIndex,end);\n  }\n}\n", "nl": "apply the Douglas-Peucker-Reduction to an List of Entry with a given epsilon (tolerance)"}
{"code": "@Override public CompletableFuture<Void> close(){\n  CompletableFuture<Void> closeFuture=new CompletableFuture<>();\n  lock.writeLock().lock();\n  try {\n    if (!isFenced) {\n      isFenced=true;\n    }\n else {\n      log.warn(\"[{}] Topic is already being closed or deleted\",topic);\n      closeFuture.completeExceptionally(new TopicFencedException(\"Topic is already fenced\"));\n      return closeFuture;\n    }\n  }\n  finally {\n    lock.writeLock().unlock();\n  }\n  List<CompletableFuture<Void>> futures=Lists.newArrayList();\n  replicators.forEach(null);\n  producers.forEach(null);\n  subscriptions.forEach(null);\n  FutureUtil.waitForAll(futures).thenRun(null).exceptionally(null);\n  return closeFuture;\n}\n", "nl": "Close this topic - close all producers and subscriptions associated with this topic"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  if (getParent() instanceof OverlapGraphViewer) {\n    final OverlapGraphViewer overlapGraphViewer=(OverlapGraphViewer)getParent();\n    final GraphView graphView=overlapGraphViewer.getGraphView();\n    final NodeMap<String> node2ReadNameMap=overlapGraphViewer.getNode2ReadNameMap();\n    final Set<String> previousSelection=ProjectManager.getPreviouslySelectedNodeLabels();\n    if (previousSelection.size() > 0) {\n      Graph graph=graphView.getGraph();\n      NodeSet toSelect=new NodeSet(graph);\n      for (Node v=graph.getFirstNode(); v != null; v=graph.getNextNode(v)) {\n        String label=node2ReadNameMap.get(v);\n        if (label != null && previousSelection.contains(label))         toSelect.add(v);\n      }\n      if (toSelect.size() > 0) {\n        graphView.setSelected(toSelect,true);\n        graphView.repaint();\n      }\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private static ConstraintWidget nearestHorizontal(ConstraintWidget nextTo,ArrayList<ConstraintWidget> list){\n  int min=Integer.MAX_VALUE;\n  ConstraintWidget ret=null;\n  int nextToLeft=nextTo.getX();\n  int nextToRight=nextToLeft + nextTo.getWidth();\n  for (  ConstraintWidget widget : list) {\n    if (widget == nextTo) {\n      continue;\n    }\n    int left=widget.getX();\n    int right=left + widget.getWidth();\n    int dist=Math.abs(left - nextToLeft);\n    dist=Math.min(dist,Math.abs(left - nextToRight));\n    dist=Math.min(dist,Math.abs(right - nextToRight));\n    dist=Math.min(dist,Math.abs(right - nextToLeft));\n    if (dist < min) {\n      min=dist;\n      ret=widget;\n    }\n  }\n  return ret;\n}\n", "nl": "find the nearest widget in a list of widgets only considering the horizontal location"}
{"code": "public static void createCarbonStore(){\n  try {\n    String factFilePath=new File(\"../hadoop/src/test/resources/data.csv\").getCanonicalPath();\n    File storeDir=new File(absoluteTableIdentifier.getStorePath());\n    CarbonUtil.deleteFoldersAndFiles(storeDir);\n    CarbonProperties.getInstance().addProperty(CarbonCommonConstants.STORE_LOCATION_HDFS,absoluteTableIdentifier.getStorePath());\n    String kettleHomePath=\"../processing/carbonplugins\";\n    CarbonTable table=createTable();\n    writeDictionary(factFilePath,table);\n    CarbonDataLoadSchema schema=new CarbonDataLoadSchema(table);\n    LoadModel loadModel=new LoadModel();\n    String partitionId=\"0\";\n    loadModel.setSchema(schema);\n    loadModel.setDatabaseName(absoluteTableIdentifier.getCarbonTableIdentifier().getDatabaseName());\n    loadModel.setTableName(absoluteTableIdentifier.getCarbonTableIdentifier().getTableName());\n    loadModel.setTableName(absoluteTableIdentifier.getCarbonTableIdentifier().getTableName());\n    loadModel.setFactFilePath(factFilePath);\n    loadModel.setLoadMetadataDetails(new ArrayList<LoadMetadataDetails>());\n    executeGraph(loadModel,absoluteTableIdentifier.getStorePath(),kettleHomePath);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Create store without any restructure"}
{"code": "public Pair<String,String> next(){\n  try {\n    currentHeaderPosition=nextHeaderPosition;\n    String readHeader=nextLine;\n    nextHeaderPosition+=readHeader.length() + endOfLineBytes;\n    readHeader=\">\" + readHeader.substring(1);\n    String readSequence=r.readLine();\n    nextHeaderPosition+=readSequence.length() + endOfLineBytes;\n    String comments=r.readLine();\n    nextHeaderPosition+=comments.length() + endOfLineBytes;\n    if (comments.startsWith(\"+\")) {\n      String qualityValues=r.readLine();\n      nextHeaderPosition+=qualityValues.length() + endOfLineBytes;\n    }\n    nextLine=r.readLine();\n    return new Pair<>(readHeader,readSequence);\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n  return null;\n}\n", "nl": "gets next fastA record"}
{"code": "public static DockerPortMapping fromString(String portMappingStr){\n  DockerPortMapping portMapping=new DockerPortMapping();\n  Matcher matcher=PORT_PATTERN.matcher(portMappingStr);\n  if (!matcher.matches()) {\n    throw new IllegalArgumentException(\"Invalid format for port mapping: \" + portMappingStr);\n  }\n  portMapping.hostIp=matcher.group(1);\n  portMapping.hostPort=matcher.group(2);\n  portMapping.containerPort=matcher.group(3);\n  String protocolStr=matcher.group(5);\n  if (protocolStr != null) {\n    portMapping.protocol=Protocol.fromString(protocolStr);\n  }\n else {\n    portMapping.protocol=Protocol.TCP;\n  }\n  if (\"\".equals(portMapping.hostPort)) {\n    portMapping.hostPort=null;\n  }\n  return portMapping;\n}\n", "nl": "Parse a port string format: ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort | containerPort"}
{"code": "public void saveFolderInDB(){\n  if (mCreateFullPath && getStorageManager().getFileByPath(FileStorageUtils.getParentPath(mRemotePath)) == null) {\n    String[] subFolders=mRemotePath.split(\"/\");\n    String composedRemotePath=\"/\";\n    for (int i=0; i < subFolders.length; i++) {\n      String subFolder=subFolders[i];\n      if (!subFolder.isEmpty()) {\n        composedRemotePath=composedRemotePath + subFolder + \"/\";\n        mRemotePath=composedRemotePath;\n        saveFolderInDB();\n      }\n    }\n  }\n else {\n    OCFile newDir=new OCFile(mRemotePath);\n    newDir.setMimetype(MimeType.DIRECTORY);\n    long parentId=getStorageManager().getFileByPath(FileStorageUtils.getParentPath(mRemotePath)).getFileId();\n    newDir.setParentId(parentId);\n    newDir.setModificationTimestamp(System.currentTimeMillis());\n    getStorageManager().saveFile(newDir);\n    Log_OC.d(TAG,\"Create directory \" + mRemotePath + \" in Database\");\n  }\n}\n", "nl": "Save new directory in local database"}
{"code": "public Configuration(File config,File outputFile,File oldApkFile,File newApkFile) throws IOException, ParserConfigurationException, SAXException, TinkerPatchException {\n  mUsingGradle=false;\n  mSoFilePattern=new HashSet<>();\n  mDexFilePattern=new HashSet<>();\n  mDexLoaderPattern=new HashSet<>();\n  mResFilePattern=new HashSet<>();\n  mResRawPattern=new HashSet<>();\n  mResIgnoreChangePattern=new HashSet<>();\n  mPackageFields=new HashMap<>();\n  mOutFolder=outputFile.getAbsolutePath();\n  FileOperation.cleanDir(outputFile);\n  mOldApkFile=oldApkFile;\n  mOldApkPath=oldApkFile.getAbsolutePath();\n  mNewApkFile=newApkFile;\n  mNewApkPath=newApkFile.getAbsolutePath();\n  mLargeModSize=100;\n  readXmlConfig(config);\n  createTempDirectory();\n  checkInputPatternParameter();\n}\n", "nl": "use by command line with xml config"}
{"code": "public int[] calculateAspectRatio(int origWidth,int origHeight){\n  int newWidth=this.targetWidth;\n  int newHeight=this.targetHeight;\n  if (newWidth <= 0 && newHeight <= 0) {\n    newWidth=origWidth;\n    newHeight=origHeight;\n  }\n else   if (newWidth > 0 && newHeight <= 0) {\n    newHeight=(newWidth * origHeight) / origWidth;\n  }\n else   if (newWidth <= 0 && newHeight > 0) {\n    newWidth=(newHeight * origWidth) / origHeight;\n  }\n else {\n    double newRatio=newWidth / (double)newHeight;\n    double origRatio=origWidth / (double)origHeight;\n    if (origRatio > newRatio) {\n      newHeight=(newWidth * origHeight) / origWidth;\n    }\n else     if (origRatio < newRatio) {\n      newWidth=(newHeight * origWidth) / origHeight;\n    }\n  }\n  int[] retval=new int[2];\n  retval[0]=newWidth;\n  retval[1]=newHeight;\n  return retval;\n}\n", "nl": "Maintain the aspect ratio so the resulting image does not look smooshed"}
{"code": "@SuppressLint(\"NewApi\") private String launchPing(String url) throws Exception {\n  Process p;\n  String command=String.format(PING_CMD_FORMMAT,ttl);\n  Log.e(\"TAG\",\"The command is : \" + command + url);\n  long startTime=System.nanoTime();\n  new TimeOutAsyncTask(this,ttl).execute();\n  p=Runtime.getRuntime().exec(command + url);\n  BufferedReader stdInput=new BufferedReader(new InputStreamReader(p.getInputStream()));\n  String s;\n  String res=\"\";\n  while ((s=stdInput.readLine()) != null) {\n    res+=s + \"\\n\";\n    if (s.contains(FROM_PING) || s.contains(SMALL_FROM_PING)) {\n      elapsedTime=(System.nanoTime() - startTime) / 1000000.0f;\n    }\n  }\n  p.destroy();\n  if (res.equals(\"\")) {\n    throw new IllegalArgumentException();\n  }\n  if (ttl == 1) {\n    Log.e(\"TAG\",\"ipToPings is : \" + ipToPing + \"res is:\"+ res);\n    ipToPing=parseIpToPingFromPing(res);\n  }\n  Log.e(\"TAG\",\"launch ping result is : \" + res);\n  return res;\n}\n", "nl": "Launches ping command"}
{"code": "public static int apply(final ViewerBase viewer,String method,final int threshold,final Distances distances) throws IOException {\n  System.err.println(\"Computing \" + method + \" distances\");\n  for (int s=1; s <= distances.getNtax(); s++) {\n    for (int t=s + 1; t <= distances.getNtax(); t++) {\n      distances.set(s,t,0);\n    }\n  }\n  int countNodes=0;\n  for (Node v=viewer.getTree().getFirstNode(); v != null; v=v.getNext()) {\n    if (v.getOutDegree() != 1 && (Integer)v.getInfo() > 0) {\n      countNodes++;\n      final int[] counts=(v.getOutDegree() == 0 ? viewer.getNodeData(v).getSummarized() : viewer.getNodeData(v).getAssigned());\n      for (int s=1; s <= distances.getNtax(); s++) {\n        for (int t=s + 1; t <= distances.getNtax(); t++) {\n          if ((counts[s - 1] < threshold) != (counts[t - 1] < threshold))           distances.increment(s,t);\n        }\n      }\n    }\n  }\n  if (countNodes > 0) {\n    for (int s=1; s <= distances.getNtax(); s++) {\n      for (int t=s + 1; t <= distances.getNtax(); t++) {\n        distances.set(s,t,distances.get(s,t) / countNodes);\n      }\n    }\n  }\n  return countNodes;\n}\n", "nl": "apply the named computation to the taxonomy"}
{"code": "public static byte[] compressForGzip(String string){\n  ByteArrayOutputStream os=null;\n  GZIPOutputStream gos=null;\n  try {\n    os=new ByteArrayOutputStream(string.length());\n    gos=new GZIPOutputStream(os);\n    gos.write(string.getBytes(\"UTF-8\"));\n    byte[] compressed=os.toByteArray();\n    return compressed;\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n finally {\n    okhttp3.internal.Util.closeQuietly(gos);\n    okhttp3.internal.Util.closeQuietly(os);\n  }\n  return null;\n}\n", "nl": "gzip compress 2 byte"}
{"code": "private static void drawTableLayoutGuidelines(ViewTransform transform,Graphics2D g,ConstraintTableLayout table){\n  Graphics2D g2=(Graphics2D)g.create();\n  ArrayList<Guideline> vertical=table.getVerticalGuidelines();\n  ArrayList<Guideline> horizontal=table.getHorizontalGuidelines();\n  g2.setStroke(SnapDraw.sThinDashedStroke);\n  int l=transform.getSwingX(table.getDrawX());\n  int t=transform.getSwingY(table.getDrawY());\n  int r=transform.getSwingX(table.getDrawX() + table.getDrawWidth());\n  int b=transform.getSwingY(table.getDrawY() + table.getDrawHeight());\n  for (  ConstraintWidget v : vertical) {\n    int x=transform.getSwingX(v.getX()) + l;\n    g2.drawLine(x,t,x,b);\n  }\n  for (  ConstraintWidget h : horizontal) {\n    int y=transform.getSwingY(h.getY()) + t;\n    g2.drawLine(l,y,r,y);\n  }\n  g2.dispose();\n}\n", "nl": "Draw the internal guidelines of a ConstraintTableLayout"}
{"code": "@Override public void json(String json){\n  if (TextUtils.isEmpty(json)) {\n    d(\"Empty/Null json content\");\n    return;\n  }\n  try {\n    json=json.trim();\n    if (json.startsWith(\"{\")) {\n      JSONObject jsonObject=new JSONObject(json);\n      String message=jsonObject.toString(JSON_INDENT);\n      d(message);\n      return;\n    }\n    if (json.startsWith(\"[\")) {\n      JSONArray jsonArray=new JSONArray(json);\n      String message=jsonArray.toString(JSON_INDENT);\n      d(message);\n    }\n  }\n catch (  JSONException e) {\n    e(e.getCause().getMessage() + \"\\n\" + json);\n  }\n}\n", "nl": "Formats the json content and print it"}
{"code": "public static boolean addSmiles(Context context,Spannable spannable){\n  boolean hasChanges=false;\n  for (  Entry<Pattern,Integer> entry : emoticons.entrySet()) {\n    Matcher matcher=entry.getKey().matcher(spannable);\n    while (matcher.find()) {\n      boolean set=true;\n      for (      ImageSpan span : spannable.getSpans(matcher.start(),matcher.end(),ImageSpan.class))       if (spannable.getSpanStart(span) >= matcher.start() && spannable.getSpanEnd(span) <= matcher.end())       spannable.removeSpan(span);\n else {\n        set=false;\n        break;\n      }\n      if (set) {\n        hasChanges=true;\n        spannable.setSpan(new ImageSpan(context,entry.getValue()),matcher.start(),matcher.end(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n      }\n    }\n  }\n  return hasChanges;\n}\n", "nl": "replace existing spannable with smiles"}
{"code": "public void swapDirectory(OCFile directory,FileDataStorageManager updatedStorageManager,boolean onlyOnDevice){\n  if (updatedStorageManager != null && updatedStorageManager != mStorageManager) {\n    mStorageManager=updatedStorageManager;\n    mAccount=AccountUtils.getCurrentOwnCloudAccount(mContext);\n  }\n  if (mStorageManager != null) {\n    mFiles=mStorageManager.getFolderContent(directory,onlyOnDevice);\n    if (mJustFolders) {\n      mFiles=getFolders(mFiles);\n    }\n    if (!mShowHiddenFiles) {\n      mFiles=filterHiddenFiles(mFiles);\n    }\n  }\n else {\n    mFiles=null;\n  }\n  mFiles=FileStorageUtils.sortOcFolder(mFiles);\n  mFilesAll.clear();\n  mFilesAll.addAll(mFiles);\n  notifyDataSetChanged();\n}\n", "nl": "Change the adapted directory for a new one"}
{"code": "public BitSet isScanRequired(byte[][] blkMaxVal,byte[][] blkMinVal){\n  BitSet bitSet=new BitSet(1);\n  byte[][] filterValues=dimColumnExecuterInfo.getFilterKeys();\n  int columnIndex=dimColumnEvaluatorInfo.getColumnIndex();\n  int blockIndex=segmentProperties.getDimensionOrdinalToBlockMapping().get(columnIndex);\n  int[] cols=getAllColumns(columnIndex);\n  byte[] maxValue=getMinMaxData(cols,blkMaxVal[blockIndex],columnIndex);\n  byte[] minValue=getMinMaxData(cols,blkMinVal[blockIndex],columnIndex);\n  boolean isScanRequired=false;\n  for (int k=0; k < filterValues.length; k++) {\n    int maxCompare=ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[k],maxValue);\n    int minCompare=ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterValues[k],minValue);\n    if (maxCompare <= 0 && minCompare >= 0) {\n      isScanRequired=true;\n      break;\n    }\n  }\n  if (isScanRequired) {\n    bitSet.set(0);\n  }\n  return bitSet;\n}\n", "nl": "Check if scan is required on given block based on min and max value"}
{"code": "@Override public void onSelectionChanged(Selection selection){\n  SelectionModel selectionModel=myNlModel.getSelectionModel();\n  if (selection.isEmpty()) {\n    selectionModel.clear();\n    return;\n  }\n  List<NlComponent> components=new ArrayList<>();\n  for (  Selection.Element selectedElement : mySelection.getElements()) {\n    if (selectedElement.widget == myDragDropWidget) {\n      continue;\n    }\n    WidgetCompanion companion=(WidgetCompanion)selectedElement.widget.getCompanionWidget();\n    NlComponent component=(NlComponent)companion.getWidgetModel();\n    components.add(component);\n  }\n  if (!components.isEmpty()) {\n    selectionModel.setSelection(components);\n  }\n else {\n    selectionModel.clear();\n  }\n}\n", "nl": "Something has changed in our selection"}
{"code": "public static String inflate(String previous,String current){\n  if (previous == null)   return current;\n  StringBuilder buf=new StringBuilder();\n  int start1=0;\n  int start2=0;\n  while (start1 < previous.length() && start2 < current.length()) {\n    int end1=start1;\n    while (end1 < previous.length() && previous.charAt(end1) != '\\t') {\n      end1++;\n    }\n    int end2=start2;\n    while (end2 < current.length() && current.charAt(end2) != '\\t') {\n      end2++;\n    }\n    if (current.charAt(start2) == '&' && end2 == start2 + 1) {\n      for (int i=start1; i < end1; i++)       buf.append(previous.charAt(i));\n    }\n else {\n      for (int i=start2; i < end2; i++)       buf.append(current.charAt(i));\n    }\n    if (end2 < current.length())     buf.append(\"\\t\");\n    start1=end1 + 1;\n    start2=end2 + 1;\n  }\n  return buf.toString();\n}\n", "nl": "inflate the current SAM line by replacing all & by the corresponding field in the previous SAM line"}
{"code": "public void actionPerformed(ActionEvent event){\n  final Director newDir=Director.newProject();\n  newDir.getMainViewer().getFrame().setVisible(true);\n  newDir.getMainViewer().setDoReInduce(true);\n  newDir.getMainViewer().setDoReset(true);\n  boolean ok=false;\n  final CompareWindow compareWindow=new CompareWindow(newDir.getMainViewer().getFrame(),newDir,null);\n  if (!compareWindow.isCanceled()) {\n    String command=compareWindow.getCommand();\n    if (command != null) {\n      newDir.execute(command,newDir.getCommandManager());\n      ok=true;\n    }\n  }\n  if (!ok) {\n    try {\n      newDir.close();\n    }\n catch (    CanceledException e) {\n      e.printStackTrace();\n    }\n    ProjectManager.removeProject(newDir);\n  }\n}\n", "nl": "display the dialog and then execute the command entered, if any"}
{"code": "static float distance(ScoutWidget a,ScoutWidget b){\n  float ax1, ax2, ay1, ay2;\n  float bx1, bx2, by1, by2;\n  ax1=a.mX;\n  ax2=a.mX + a.mWidth;\n  ay1=a.mY;\n  ay2=a.mY + a.mHeight;\n  bx1=b.mX;\n  bx2=b.mX + b.mWidth;\n  by1=b.mY;\n  by2=b.mY + b.mHeight;\n  float xdiff11=Math.abs(ax1 - bx1);\n  float xdiff12=Math.abs(ax1 - bx2);\n  float xdiff21=Math.abs(ax2 - bx1);\n  float xdiff22=Math.abs(ax2 - bx2);\n  float ydiff11=Math.abs(ay1 - by1);\n  float ydiff12=Math.abs(ay1 - by2);\n  float ydiff21=Math.abs(ay2 - by1);\n  float ydiff22=Math.abs(ay2 - by2);\n  float xmin=Math.min(Math.min(xdiff11,xdiff12),Math.min(xdiff21,xdiff22));\n  float ymin=Math.min(Math.min(ydiff11,ydiff12),Math.min(ydiff21,ydiff22));\n  boolean yOverlap=ay1 <= by2 && by1 <= ay2;\n  boolean xOverlap=ax1 <= bx2 && bx1 <= ax2;\n  float xReturn=(yOverlap) ? xmin : (float)Math.hypot(xmin,ymin);\n  float yReturn=(xOverlap) ? ymin : (float)Math.hypot(xmin,ymin);\n  return Math.min(xReturn,yReturn);\n}\n", "nl": "calculates the distance between two widgets (assumed to be rectangles)"}
{"code": "private void initResourcesIfNecessary(){\n  if (itemsPaint == null) {\n    itemsPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);\n    itemsPaint.setTextSize(TEXT_SIZE);\n    itemsPaint.setColor(0xFF666666);\n  }\n  if (valuePaint == null) {\n    valuePaint=new TextPaint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);\n    valuePaint.setTextSize(TEXT_SIZE);\n  }\n  if (centerDrawable == null) {\n    centerDrawable=getContext().getResources().getDrawable(R.drawable.wheel_val);\n  }\n  if (topShadow == null) {\n    topShadow=new GradientDrawable(Orientation.TOP_BOTTOM,SHADOWS_COLORS);\n  }\n  if (bottomShadow == null) {\n    bottomShadow=new GradientDrawable(Orientation.BOTTOM_TOP,SHADOWS_COLORS);\n  }\n}\n", "nl": "Initializes resources"}
{"code": "private static int inferAlignment(ConstraintWidget[] widget){\n  float[] start=new float[widget.length];\n  float[] center=new float[widget.length];\n  float[] end=new float[widget.length];\n  for (int i=0; i < end.length; i++) {\n    if (widget[i] == null) {\n      start[i]=Float.NaN;\n      end[i]=Float.NaN;\n      center[i]=Float.NaN;\n      continue;\n    }\n    start[i]=widget[i].getX();\n    end[i]=start[i] + widget[i].getWidth();\n    center[i]=(start[i] + end[i]) / 2;\n  }\n  float startDiv=standardDeviation(start);\n  float centerDiv=standardDeviation(center);\n  float endDiv=standardDeviation(end);\n  if (endDiv > startDiv && centerDiv > startDiv) {\n    return ALIGN_LEFT;\n  }\n else   if (startDiv > endDiv && centerDiv > endDiv) {\n    return ALIGN_RIGHT;\n  }\n  return ALIGN_CENTER;\n}\n", "nl": "Infer alignment for each column"}
{"code": "public static ScoutWidget[] create(ConstraintWidget[] array){\n  ScoutWidget[] ret=new ScoutWidget[array.length];\n  ConstraintWidget root=array[0];\n  ScoutWidget rootwidget=new ScoutWidget(root,null);\n  ret[0]=rootwidget;\n  int count=1;\n  for (int i=0; i < ret.length; i++) {\n    if (array[i] != root) {\n      ret[count++]=new ScoutWidget(array[i],rootwidget);\n    }\n  }\n  Arrays.sort(ret);\n  if (DEBUG) {\n    for (int i=0; i < ret.length; i++) {\n      System.out.println(\"[\" + i + \"] -> \"+ ret[i].mConstraintWidget+ \"    \"+ ret[i].mRootDistance);\n    }\n  }\n  return ret;\n}\n", "nl": "Wrap an array of ConstraintWidgets into an array of InferWidgets"}
{"code": "public synchronized void endEffect(){\n  if (isStopped) {\n    return;\n  }\n  for (  EffectTemplate template : successEffects.values()) {\n    template.endEffect(this);\n  }\n  if (effector instanceof Player) {\n    Player player=(Player)effector;\n    if (player.getController().getStanceSkillId() == getSkillId()) {\n      PacketSendUtility.sendPacket(player,new SM_PLAYER_STANCE(player,0));\n      player.getController().startStance(0);\n    }\n  }\n  if (isToggle() && effector instanceof Player || isRiderEffect(getSkillId())) {\n    deactivateToggleSkill();\n  }\n  stopTasks();\n  effected.getEffectController().clearEffect(this);\n  this.isStopped=true;\n  this.addedToController=false;\n}\n", "nl": "End effect and all effect actions This method is synchronized and prevented to be called several times which could cause unexpected behavior"}
{"code": "private void checkForNewEpisods(){\n  Logger.printInfo(TAG,\"Checking for new episodes...\");\n  ArrayList<Podcast> subscribedPodcasts;\n  try {\n    subscribedPodcasts=ProfileManager.getInstance().getSubscribedPodcasts();\n  }\n catch (  Exception e) {\n    subscribedPodcasts=new ArrayList<>();\n    Logger.printError(TAG,\"Can't get favorites\");\n    e.printStackTrace();\n  }\n  if (subscribedPodcasts.size() > 0) {\n    for (    Podcast podcast : subscribedPodcasts) {\n      try {\n        ArrayList<Episode> parsedEpisodes=BackendManager.getInstance().fetchEpisodes(podcast.getFeedUrl());\n        if (Feed.handleUpdates(parsedEpisodes,podcast)) {\n          sendNewEpisodsNotification(podcast);\n        }\n        Logger.printError(TAG,\"Finished for podcast with url: \" + podcast.getFeedUrl());\n      }\n catch (      Exception e) {\n        Logger.printError(TAG,\"Can't check for updates for podcast with url: \" + podcast.getFeedUrl());\n        e.printStackTrace();\n      }\n    }\n  }\n  Logger.printInfo(TAG,\"Finished!\");\n}\n", "nl": "Will check for new episodes by fetching full episodes list for each subscribed podcast"}
{"code": "public static int[] mergeArrays(int[] a1,int[] a2){\n  int[] a3=new int[a1.length + a2.length];\n  int i=0;\n  int j=0;\n  while (i + j < a3.length) {\n    if (i < a1.length && j < a2.length) {\n      if (a1[i] < a2[j]) {\n        a3[i + j]=a1[i];\n        i++;\n      }\n else {\n        a3[i + j]=a2[j];\n        j++;\n      }\n    }\n else {\n      if (i < a1.length) {\n        a3[i + j]=a1[i];\n        i++;\n      }\n      if (j < a2.length) {\n        a3[i + j]=a2[j];\n        j++;\n      }\n    }\n  }\n  return a3;\n}\n", "nl": "Merges two given sorted arrays into one"}
{"code": "void STAR_encoding_diag1(){\n  int i, j, stripe, k;\n  char[][] tmp;\n  tmp=new char[block_nbr + 1][block_size];\n  for (stripe=0; stripe < block_nbr + 1; stripe++) {\n    for (i=0; i < data_disk_nbr; i++) {\n      for (j=0; j < block_size; j++) {\n        k=(stripe - i + p) % p;\n        if (k < block_nbr) {\n          tmp[stripe][j]^=check_data[i][(stripe - i + p) % p * block_size + j];\n        }\n      }\n    }\n  }\n  for (i=0; i < block_nbr; i++) {\n    for (j=0; j < block_size; j++) {\n      tmp[i][j]=(char)(tmp[i][j] ^ tmp[block_nbr][j]);\n    }\n  }\n  for (i=0; i < block_nbr; i++) {\n    System.arraycopy(tmp[i],0,check_data[data_disk_nbr + 1],i * block_size,block_size);\n  }\n}\n", "nl": "entry function for encoding computing checksum in every row,*check_data[p]"}
{"code": "static void processSearchResults(final String logName,final LedgerDescriptor ld,final LogSegmentMetadata segment,final long transactionId,final ExecutorService executorService,final LedgerHandleCache handleCache,final List<LogRecordWithDLSN> searchResults,final int nWays,final Optional<LogRecordWithDLSN> prevFoundRecord,final Promise<Optional<LogRecordWithDLSN>> promise){\n  int found=-1;\n  for (int i=0; i < searchResults.size(); i++) {\n    LogRecordWithDLSN record=searchResults.get(i);\n    if (record.getTransactionId() >= transactionId) {\n      found=i;\n      break;\n    }\n  }\n  if (found == -1) {\n    promise.setValue(prevFoundRecord);\n    return;\n  }\n  LogRecordWithDLSN foundRecord=searchResults.get(found);\n  if (foundRecord.getDlsn().getSlotId() != 0L || found == 0 || foundRecord.getDlsn().getEntryId() == (searchResults.get(found - 1).getDlsn().getEntryId() + 1)) {\n    promise.setValue(Optional.of(foundRecord));\n    return;\n  }\n  List<Long> nextSearchBatch=getEntriesToSearch(transactionId,searchResults.get(found - 1),searchResults.get(found),nWays);\n  if (nextSearchBatch.isEmpty()) {\n    promise.setValue(prevFoundRecord);\n    return;\n  }\n  getLogRecordNotLessThanTxIdFromEntries(logName,ld,segment,transactionId,executorService,handleCache,nextSearchBatch,nWays,Optional.of(foundRecord),promise);\n}\n", "nl": "Process the search results"}
{"code": "static <T>void buildError(Subscriber<T> subscriber,DatabaseError error){\nswitch (error.getCode()) {\ncase DatabaseError.INVALID_TOKEN:\n    subscriber.onError(new FirebaseInvalidTokenException(error.getMessage()));\n  break;\ncase DatabaseError.EXPIRED_TOKEN:\nsubscriber.onError(new FirebaseExpiredTokenException(error.getMessage()));\nbreak;\ncase DatabaseError.NETWORK_ERROR:\nsubscriber.onError(new FirebaseNetworkErrorException(error.getMessage()));\nbreak;\ncase DatabaseError.PERMISSION_DENIED:\nsubscriber.onError(new FirebasePermissionDeniedException(error.getMessage()));\nbreak;\ncase DatabaseError.OPERATION_FAILED:\nsubscriber.onError(new FirebaseOperationFailedException(error.getMessage()));\nbreak;\ndefault :\nsubscriber.onError(new FirebaseGeneralException(error.getMessage()));\nbreak;\n}\n}\n", "nl": "This method add to subsriber the proper error according to the"}
{"code": "public void addGp(int additionalGp){\n  dailyGP+=additionalGp;\n  if (dailyGP < 0) {\n    dailyGP=0;\n  }\n  weeklyGP+=additionalGp;\n  if (weeklyGP < 0) {\n    weeklyGP=0;\n  }\n  int GpcappedCount=0;\n  if (CustomConfig.ENABLE_GP_CAP) {\n    GpcappedCount=(long)(currentGp + additionalGp) > CustomConfig.GP_CAP_VALUE ? (int)(CustomConfig.GP_CAP_VALUE - currentGp) : additionalGp;\n  }\n else {\n    GpcappedCount=additionalGp;\n  }\n  currentGp+=GpcappedCount;\n  if (currentGp < 0) {\n    currentGp=0;\n  }\n  AbyssRankEnum newRank=AbyssRankEnum.getRankForGp(currentGp);\n  if (newRank.getId() <= 18 && newRank.getId() > 9) {\n    setRank(newRank);\n  }\n  setPersistentState(PersistentState.UPDATE_REQUIRED);\n}\n", "nl": "Add GP to a player (current player GP + added GP)"}
{"code": "private static void flipCoordinates(final PhyloTreeView treeView,final SIDE rootSide){\n  final PhyloTree tree=treeView.getPhyloTree();\n  for (Node v=tree.getFirstNode(); v != null; v=tree.getNextNode(v)) {\n    final Point2D loc=treeView.getLocation(v);\nswitch (rootSide) {\ncase TOP:\n      treeView.setLocation(v,loc.getY(),loc.getX());\n    break;\ncase BOTTOM:\n  treeView.setLocation(v,loc.getY(),-loc.getX());\nbreak;\ncase RIGHT:\ntreeView.setLocation(v,-loc.getX(),loc.getY());\nbreak;\ndefault :\ncase LEFT:\nbreak;\n}\n}\n}\n", "nl": "flip coordinates so as to fit the specified root side"}
{"code": "private void parseIncludeAttributes(String layoutFile,AXmlNode rootNode){\n  for (  Entry<String,AXmlAttribute<?>> entry : rootNode.getAttributes().entrySet()) {\n    String attrName=entry.getKey().trim();\n    AXmlAttribute<?> attr=entry.getValue();\n    if (attrName.equals(\"layout\")) {\n      if ((attr.getType() == AxmlVisitor.TYPE_REFERENCE || attr.getType() == AxmlVisitor.TYPE_INT_HEX) && attr.getValue() instanceof Integer) {\n        AbstractResource targetRes=resParser.findResource((Integer)attr.getValue());\n        if (targetRes == null) {\n          System.err.println(\"Target resource \" + attr.getValue() + \" for layout include not found\");\n          return;\n        }\n        if (!(targetRes instanceof StringResource)) {\n          System.err.println(\"Invalid target node for include tag in layout XML, was \" + targetRes.getClass().getName());\n          return;\n        }\n        String targetFile=((StringResource)targetRes).getValue();\n        if (callbackMethods.containsKey(targetFile))         for (        String callback : callbackMethods.get(targetFile))         addCallbackMethod(layoutFile,callback);\n else {\n          addToMapSet(includeDependencies,targetFile,layoutFile);\n        }\n      }\n    }\n  }\n}\n", "nl": "Parses the attributes required for a layout file inclusion"}
{"code": "private Map<String,Collection<Pair<Number,Number>>> computeCounts(Document doc,ViewerBase viewer,ProgressListener progressListener) throws CanceledException {\n  progressListener.setTasks(cName + \" vs \" + cName,\"Sampling from current leaves\");\n  progressListener.setMaximum(11 * doc.getNumberOfSamples());\n  progressListener.setProgress(0);\n  Map<String,Collection<Pair<Number,Number>>> plotName2Counts=new HashMap<>();\n  String[] sampleNames=doc.getSampleNamesAsArray();\n  for (int i=0; i < sampleNames.length; i++) {\n    String name1=sampleNames[i];\n    for (int j=i + 1; j < sampleNames.length; j++) {\n      String name2=sampleNames[j];\n      String name=name1 + \" vs \" + name2;\n      for (      Node v : viewer.getSelectedNodes()) {\n        int[] counts=((NodeData)v.getData()).getAssigned();\n        if (j < counts.length && counts[i] > 0 || counts[j] > 0) {\n          Collection<Pair<Number,Number>> pairs=plotName2Counts.get(name);\n          if (pairs == null) {\n            pairs=new LinkedList<>();\n            plotName2Counts.put(name,pairs);\n          }\n          pairs.add(new Pair<Number,Number>(counts[i],counts[i + 1]));\n        }\n      }\n    }\n  }\n  return plotName2Counts;\n}\n", "nl": "compute sample vs sample data"}
{"code": "public ShapelessMaterialRecipe(ItemStack output,Object... input){\n  this.output=output;\n  this.matchers=new ArrayList<>();\n  for (  Object obj : input) {\n    if (obj instanceof Predicate) {\n      matchers.add((Predicate<ItemStack>)obj);\n    }\n else     if (obj instanceof ItemStack) {\n      matchers.add(ItemStackDictionary.matcherOf((ItemStack)obj));\n    }\n else     if (obj instanceof Item) {\n      matchers.add(ItemStackDictionary.matcherOf(new ItemStack((Item)obj)));\n    }\n else     if (obj instanceof Block) {\n      matchers.add(ItemStackDictionary.matcherOf(new ItemStack((Block)obj)));\n    }\n else     if (obj instanceof String) {\n      matchers.add(Dictionaries.MATERIALS.get((String)obj));\n    }\n  }\n}\n", "nl": "Creates a new shapeless material recipe"}
{"code": "private static Menu insertOrUpdate(long parent,String name,V v){\n  String node=Model.node();\n  W q=W.create().and(\"parent\",parent).and(\"name\",name).and(\"node\",node);\n  try {\n    if (Helper.exists(q,Menu.class)) {\n      Helper.update(q,v,Menu.class);\n    }\n else {\n      long id=UID.next(\"menu.id\");\n      while (Helper.exists(W.create(X.ID,id),Menu.class)) {\n        id=UID.next(\"menu.id\");\n        log.debug(\"id=\" + id);\n      }\n      Helper.insert(v.set(X.ID,id).set(\"id\",id).set(\"parent\",parent).set(\"name\",name).set(\"node\",node),Menu.class);\n    }\n  }\n catch (  Exception e1) {\n    log.error(e1.getMessage(),e1);\n  }\n  long count=Helper.count(W.create(\"parent\",parent),Menu.class);\n  Helper.update(parent,V.create(\"childs\",count),Menu.class);\n  return Helper.load(q,Menu.class);\n}\n", "nl": "test and create new menu if not exists"}
{"code": "public void updateStatusBar(){\n  statusBar.setText1(\"Terms=\" + getTree().getNumberOfNodes());\n  final long totalReads=doc.getNumberOfReads();\n  final StringBuilder buf2=new StringBuilder();\n  if (doc.getNumberOfSamples() > 1) {\n    Comparer.COMPARISON_MODE mode=Comparer.parseMode(doc.getDataTable().getParameters());\n    if (mode.equals(Comparer.COMPARISON_MODE.RELATIVE)) {\n      buf2.append(String.format(\"Relative comparison, Reads=%,d (normalized to %,d reads per sample)\",totalReads,Comparer.parseNormalizedTo(doc.getDataTable().getParameters())));\n    }\n else     buf2.append(String.format(\"Absolute comparison, Reads=%,d Assigned=%,d\",totalReads,totalAssignedReads));\n  }\n else   if (totalReads > 0) {\n    buf2.append(String.format(\"Reads=%,d Assigned=%,d\",totalReads,totalAssignedReads));\n    if (doc.getBlastMode() != BlastMode.Unknown)     buf2.append(\" mode=\").append(doc.getBlastMode().toString());\n  }\n else {\n    if (getTree().getNumberOfNodes() > 0)     buf2.append(String.format(\" total terms=%,d\",getTree().getNumberOfNodes()));\n  }\n  if (Document.getVersionInfo().get(getClassName() + \" tree\") != null)   buf2.append(\"     \").append(Basic.skipFirstLine(Document.getVersionInfo().get(getClassName() + \" tree\")).replaceAll(\"\\\\s+\",\" \"));\n  statusBar.setText2(buf2.toString());\n}\n", "nl": "rescan the status bar"}
{"code": "@Deployment(resources={\"org/activiti/examples/bpmn/tasklistener/TaskListenerTest.bpmn20.xml\"}) public void testTaskAssignmentListenerNotCalledWhenAssigneeNotUpdated(){\n  ProcessInstance processInstance=runtimeService.startProcessInstanceByKey(\"taskListenerProcess\");\n  Task task=taskService.createTaskQuery().singleResult();\n  assertEquals(\"TaskCreateListener is listening!\",task.getDescription());\n  taskService.setAssignee(task.getId(),\"kermit\");\n  task=taskService.createTaskQuery().singleResult();\n  assertEquals(\"TaskAssignmentListener is listening: kermit\",task.getDescription());\n  task.setDescription(\"Clear\");\n  taskService.saveTask(task);\n  taskService.setAssignee(task.getId(),\"kermit\");\n  task=taskService.createTaskQuery().singleResult();\n  assertEquals(\"Clear\",task.getDescription());\n  task.setAssignee(\"kermit\");\n  taskService.saveTask(task);\n  task=taskService.createTaskQuery().singleResult();\n  assertEquals(\"Clear\",task.getDescription());\n  task.setName(\"test\");\n  taskService.saveTask(task);\n  task=taskService.createTaskQuery().singleResult();\n  assertEquals(\"Clear\",task.getDescription());\n  task.setAssignee(\"john\");\n  taskService.saveTask(task);\n  task=taskService.createTaskQuery().singleResult();\n  assertEquals(\"TaskAssignmentListener is listening: john\",task.getDescription());\n  runtimeService.deleteProcessInstance(processInstance.getProcessInstanceId(),\"\");\n}\n", "nl": "Validate fix for ACT-1627: Not throwing assignment event on every update"}
{"code": "public void trim(int leftTrimNumberOfSample,int rightTrimNumberOfSample){\n  long chunkSize=waveHeader.getChunkSize();\n  long subChunk2Size=waveHeader.getSubChunk2Size();\n  long totalTrimmed=leftTrimNumberOfSample + rightTrimNumberOfSample;\n  if (totalTrimmed > subChunk2Size) {\n    leftTrimNumberOfSample=(int)subChunk2Size;\n  }\n  chunkSize-=totalTrimmed;\n  subChunk2Size-=totalTrimmed;\n  if (chunkSize >= 0 && subChunk2Size >= 0) {\n    waveHeader.setChunkSize(chunkSize);\n    waveHeader.setSubChunk2Size(subChunk2Size);\n    byte[] trimmedData=new byte[(int)subChunk2Size];\n    System.arraycopy(data,leftTrimNumberOfSample,trimmedData,0,(int)subChunk2Size);\n    data=trimmedData;\n  }\n else {\n    System.err.println(\"Trim error: Negative length\");\n  }\n}\n", "nl": "Trim the wave data"}
{"code": "public void replaceAuxiliaryData(Map<String,byte[]> label2data) throws IOException {\n  loadInfoSection();\n  try (InputOutputReaderWriter io=new InputOutputReaderWriter(new FileRandomAccessReadWriteAdapter(file.getPath(),\"rw\"))){\n    long newPos=infoSection.getAuxiliaryDataStart();\n    if (newPos == 0)     newPos=infoSection.getInfoSectionStart();\n    io.seek(newPos);\n    infoSection.setAuxiliaryDataStart(newPos);\n    StringBuilder buf=new StringBuilder();\n    for (    String label : label2data.keySet()) {\n      byte[] bytes=label2data.get(label);\n      if (bytes != null) {\n        buf.append(\"<<<\").append(label).append(\">>>\").append(new String(bytes));\n      }\n    }\n    byte[] bytes=buf.toString().getBytes();\n    io.write(bytes,0,bytes.length);\n    infoSection.setAuxiliaryDataEnd(io.getPosition());\n    infoSection.write(io);\n    io.setLength(io.getPosition());\n  }\n }\n", "nl": "replace the auxiliary data associated with the dataset"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"move dir=\");\n  String dir=np.getWordMatchesIgnoringCase(\"up down\");\n  AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  SelectedBlock selectedBlock=viewer.getSelectedBlock();\n  if (selectedBlock.isSelected()) {\n    if (dir.equals(\"up\")) {\n      if ((viewer.isShowAsMapping() && viewer.getAlignment().getRowCompressor().moveUp(selectedBlock.getFirstRow(),selectedBlock.getLastRow())) || (!viewer.isShowAsMapping() && AlignmentSorter.moveUp(viewer.getAlignment(),selectedBlock.getFirstRow(),selectedBlock.getLastRow()))) {\n        selectedBlock.setFirstRow(selectedBlock.getFirstRow() - 1);\n        selectedBlock.setLastRow(selectedBlock.getLastRow() - 1);\n        selectedBlock.fireSelectionChanged();\n      }\n    }\n else     if (dir.equals(\"down\")) {\n      if ((viewer.isShowAsMapping() && viewer.getAlignment().getRowCompressor().moveDown(selectedBlock.getFirstRow(),selectedBlock.getLastRow())) || (!viewer.isShowAsMapping() && AlignmentSorter.moveDown(viewer.getAlignment(),selectedBlock.getFirstRow(),selectedBlock.getLastRow()))) {\n        selectedBlock.setFirstRow(selectedBlock.getFirstRow() + 1);\n        selectedBlock.setLastRow(selectedBlock.getLastRow() + 1);\n        selectedBlock.fireSelectionChanged();\n      }\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static Map<String,String> toKeyValuePairs(String httpString,boolean performUrlDecode){\n  if (httpString == null || httpString.length() == 0) {\n    return null;\n  }\n  Map<String,String> keyValuePairs=new HashMap<String,String>();\n  StringTokenizer st=new StringTokenizer(httpString);\n  String newToken=null;\n  String param, val;\n  int equalSignInd;\n  while (st.hasMoreTokens() && (newToken=st.nextToken(\"&\")) != null) {\n    equalSignInd=newToken.indexOf(\"=\");\n    param=newToken;\n    val=\"\";\n    if (equalSignInd > -1) {\n      param=newToken.substring(0,equalSignInd);\n      val=newToken.substring(equalSignInd + 1);\n    }\n    if (performUrlDecode) {\n      param=StringUtils.urlDecode(param);\n      val=StringUtils.urlDecode(val);\n    }\n    keyValuePairs.put(param,val);\n  }\n  return keyValuePairs;\n}\n", "nl": "Convert HTTP request string into key-value pairs"}
{"code": "public void markDownloadTaskFinished(long downloadId){\n  DownloadManager downloadManager=(DownloadManager)UpodsApplication.getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n  DownloadManager.Query query=new DownloadManager.Query();\n  query.setFilterById(downloadId);\n  Cursor c=downloadManager.query(query);\n  if (c.moveToFirst()) {\n    DownloadTask task=getTaskById(downloadId);\n    int columnIndex=c.getColumnIndex(DownloadManager.COLUMN_STATUS);\n    if (task != null) {\n      if (DownloadManager.STATUS_SUCCESSFUL == c.getInt(columnIndex)) {\n        if (task.track instanceof Episode) {\n          ((Episode)task.track).setPathOnDisk(task.filePath);\n        }\n        ProfileManager.getInstance().addDownloadedTrack(task.mediaItem,task.track);\n        task.contentLoadListener.onContentLoaded();\n      }\n      allTasks.remove(task);\n    }\n  }\n  c.close();\n}\n", "nl": "Should be called when DownloadManager finishes to download item"}
{"code": "private boolean resizeAndSaveImage(int maxWidth,int maxHeight) throws IOException {\n  boolean saved=false;\n  File targetFile=configuration.diskCache.get(uri);\n  if (targetFile != null && targetFile.exists()) {\n    ImageSize targetImageSize=new ImageSize(maxWidth,maxHeight);\n    DisplayImageOptions specialOptions=new DisplayImageOptions.Builder().cloneFrom(options).imageScaleType(ImageScaleType.IN_SAMPLE_INT).build();\n    ImageDecodingInfo decodingInfo=new ImageDecodingInfo(memoryCacheKey,Scheme.FILE.wrap(targetFile.getAbsolutePath()),uri,targetImageSize,ViewScaleType.FIT_INSIDE,getDownloader(),specialOptions);\n    Bitmap bmp=decoder.decode(decodingInfo);\n    if (bmp != null && configuration.processorForDiskCache != null) {\n      L.d(LOG_PROCESS_IMAGE_BEFORE_CACHE_ON_DISK,memoryCacheKey);\n      bmp=configuration.processorForDiskCache.process(bmp);\n      if (bmp == null) {\n        L.e(ERROR_PROCESSOR_FOR_DISK_CACHE_NULL,memoryCacheKey);\n      }\n    }\n    if (bmp != null) {\n      saved=configuration.diskCache.save(uri,bmp);\n      bmp.recycle();\n    }\n  }\n  return saved;\n}\n", "nl": "Decodes image file into Bitmap, resize it and save it back"}
{"code": "public static String execute(String command,File cwd){\n  try {\n    StringBuffer output=new StringBuffer();\n    Process process=Runtime.getRuntime().exec(command,null,cwd);\n    BufferedReader input=new BufferedReader(new InputStreamReader(process.getInputStream()));\n    String line;\n    while ((line=input.readLine()) != null) {\n      String trimmed=line.trim();\n      if (trimmed.length() == 0) {\n        continue;\n      }\n      output.append(trimmed);\n      output.append(\"\\n\");\n    }\n    process.waitFor();\n    return output.toString();\n  }\n catch (  Exception e) {\n    LOGGER.log(Level.WARNING,\"Exception encountered while running command \" + command,e);\n    return \"\";\n  }\n}\n", "nl": "Execute a command in the runtime environment"}
{"code": "public void updateClassifications(String[] cNames,Map<Integer,ListOfLongs>[] fName2ClassId2Location,Map<Integer,Integer>[] fName2ClassId2Weight) throws IOException {\n  io=new InputOutputReaderWriter(new File(fileName),READ_WRITE);\n  io.seek(footerSectionRMA6.getStartClassificationsSection());\n  io.setLength(io.getPosition());\n  footerSectionRMA6.getAvailableClassification2Position().clear();\n  for (int i=0; i < cNames.length; i++) {\n    final String cName=cNames[i];\n    final ClassificationBlockRMA6 classification=new ClassificationBlockRMA6(cName);\n    final Map<Integer,ListOfLongs> id2locations=fName2ClassId2Location[i];\n    for (    int id : id2locations.keySet()) {\n      final Integer weight=fName2ClassId2Weight[i].get(id);\n      classification.setSum(id,weight != null ? weight : 0);\n    }\n    footerSectionRMA6.getAvailableClassification2Position().put(cName,io.getPosition());\n    classification.write(io,id2locations);\n    System.err.println(String.format(\"Numb. %4s classes: %,10d\",Basic.abbreviate(cName,4),id2locations.size()));\n  }\n  footerSectionRMA6.setEndClassificationsSection(io.getPosition());\n  footerSectionRMA6.setStartAuxDataSection(io.getPosition());\n  io.writeInt(0);\n  footerSectionRMA6.setEndAuxDataSection(io.getPosition());\n  footerSectionRMA6.setStartFooterSection(io.getPosition());\n  footerSectionRMA6.write(io);\n  close();\n}\n", "nl": "update the classifications"}
{"code": "public EnumActionResult onItemUse(ItemStack stack,EntityPlayer playerIn,World worldIn,BlockPos pos,EnumHand hand,EnumFacing facing,float hitX,float hitY,float hitZ){\n  if (facing != EnumFacing.UP) {\n    return EnumActionResult.FAIL;\n  }\n else {\n    IBlockState iblockstate=worldIn.getBlockState(pos);\n    Block block=iblockstate.getBlock();\n    if (!block.isReplaceable(worldIn,pos)) {\n      pos=pos.offset(facing);\n    }\n    if (playerIn.canPlayerEdit(pos,facing,stack) && this.block.canPlaceBlockAt(worldIn,pos)) {\n      EnumFacing enumfacing=EnumFacing.fromAngle((double)playerIn.rotationYaw);\n      int i=enumfacing.getFrontOffsetX();\n      int j=enumfacing.getFrontOffsetZ();\n      placeDoor(worldIn,pos,enumfacing,this.block);\n      SoundType soundtype=this.block.getSoundType();\n      worldIn.playSound(playerIn,pos,soundtype.getPlaceSound(),SoundCategory.BLOCKS,(soundtype.getVolume() + 1.0F) / 2.0F,soundtype.getPitch() * 0.8F);\n      --stack.stackSize;\n      return EnumActionResult.SUCCESS;\n    }\n else {\n      return EnumActionResult.FAIL;\n    }\n  }\n}\n", "nl": "Called when a Block is right-clicked with this Item"}
{"code": "public Node(String permission,boolean value,boolean override,long expireAt,String server,String world,ContextSet contexts){\n  if (permission == null || permission.equals(\"\")) {\n    throw new IllegalArgumentException(\"Empty permission\");\n  }\n  if (server != null && (server.equalsIgnoreCase(\"global\") || server.equals(\"\"))) {\n    server=null;\n  }\n  if (world != null && world.equals(\"\")) {\n    world=null;\n  }\n  if (world != null && server == null) {\n    server=\"global\";\n  }\n  this.permission=permission;\n  this.value=value;\n  this.override=override;\n  this.expireAt=expireAt;\n  this.server=server;\n  this.world=world;\n  this.contexts=contexts == null ? ContextSet.empty() : contexts.makeImmutable();\n}\n", "nl": "Make an immutable node instance"}
{"code": "public static Map<String,Object> createNote(DispatchContext ctx,Map<String,?> context){\n  Delegator delegator=ctx.getDelegator();\n  GenericValue userLogin=(GenericValue)context.get(\"userLogin\");\n  Timestamp noteDate=(Timestamp)context.get(\"noteDate\");\n  String partyId=(String)context.get(\"partyId\");\n  String noteName=(String)context.get(\"noteName\");\n  String note=(String)context.get(\"note\");\n  String noteId=delegator.getNextSeqId(\"NoteData\");\n  Locale locale=(Locale)context.get(\"locale\");\n  if (noteDate == null) {\n    noteDate=UtilDateTime.nowTimestamp();\n  }\n  if (partyId == null) {\n    if (userLogin != null && userLogin.get(\"partyId\") != null)     partyId=userLogin.getString(\"partyId\");\n  }\n  Map<String,Object> fields=UtilMisc.toMap(\"noteId\",noteId,\"noteName\",noteName,\"noteInfo\",note,\"noteParty\",partyId,\"noteDateTime\",noteDate);\n  try {\n    GenericValue newValue=delegator.makeValue(\"NoteData\",fields);\n    delegator.create(newValue);\n  }\n catch (  GenericEntityException e) {\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonNoteCannotBeUpdated\",UtilMisc.toMap(\"errorString\",e.getMessage()),locale));\n  }\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  result.put(\"noteId\",noteId);\n  result.put(\"partyId\",partyId);\n  return result;\n}\n", "nl": "Create Note Record"}
{"code": "public static void storePlayer(Player player){\n  DAOManager.getDAO(PlayerDAO.class).storePlayer(player);\n  DAOManager.getDAO(PlayerSkillListDAO.class).storeSkills(player);\n  DAOManager.getDAO(PlayerSettingsDAO.class).saveSettings(player);\n  DAOManager.getDAO(PlayerQuestListDAO.class).store(player);\n  DAOManager.getDAO(AbyssRankDAO.class).storeAbyssRank(player);\n  DAOManager.getDAO(PlayerPunishmentsDAO.class).storePlayerPunishments(player,PunishmentType.PRISON);\n  DAOManager.getDAO(PlayerPunishmentsDAO.class).storePlayerPunishments(player,PunishmentType.GATHER);\n  DAOManager.getDAO(InventoryDAO.class).store(player);\n  for (  House house : player.getHouses()) {\n    DAOManager.getDAO(HousesDAO.class).storeHouse(house);\n    if (house.getRegistry() != null && house.getRegistry().getPersistentState() == PersistentState.UPDATE_REQUIRED) {\n      DAOManager.getDAO(PlayerRegisteredItemsDAO.class).store(house.getRegistry(),player.getCommonData().getPlayerObjId());\n    }\n  }\n  DAOManager.getDAO(ItemStoneListDAO.class).save(player);\n  DAOManager.getDAO(MailDAO.class).storeMailbox(player);\n  DAOManager.getDAO(PortalCooldownsDAO.class).storePortalCooldowns(player);\n  DAOManager.getDAO(CraftCooldownsDAO.class).storeCraftCooldowns(player);\n  DAOManager.getDAO(PlayerNpcFactionsDAO.class).storeNpcFactions(player);\n}\n", "nl": "Stores player data into db"}
{"code": "public ServerKey(final InputStream certificateStream) throws InvalidKeystoreException {\n  try {\n    this.trustStore=keystoreOf(certificateStream);\n    certificateStream.close();\n  }\n catch (  final CertificateException e) {\n    throw new InvalidKeystoreException(e);\n  }\ncatch (  final NoSuchAlgorithmException e) {\n    throw new InvalidKeystoreException(e);\n  }\ncatch (  final KeyStoreException e) {\n    throw new InvalidKeystoreException(e);\n  }\ncatch (  final IOException e) {\n    throw new InvalidKeystoreException(e);\n  }\n finally {\n    IOUtils.closeQuietly(certificateStream);\n  }\n}\n", "nl": "Create new ServerKey instance based on data provided in the stream"}
{"code": "public static org.apache.carbondata.format.DataType fromWrapperToExternalDataType(DataType dataType){\n  if (null == dataType) {\n    return null;\n  }\nswitch (dataType) {\ncase STRING:\n    return org.apache.carbondata.format.DataType.STRING;\ncase INT:\n  return org.apache.carbondata.format.DataType.INT;\ncase LONG:\nreturn org.apache.carbondata.format.DataType.LONG;\ncase DOUBLE:\nreturn org.apache.carbondata.format.DataType.DOUBLE;\ncase DECIMAL:\nreturn org.apache.carbondata.format.DataType.DECIMAL;\ncase TIMESTAMP:\nreturn org.apache.carbondata.format.DataType.TIMESTAMP;\ncase ARRAY:\nreturn org.apache.carbondata.format.DataType.ARRAY;\ncase STRUCT:\nreturn org.apache.carbondata.format.DataType.STRUCT;\ndefault :\nreturn org.apache.carbondata.format.DataType.STRING;\n}\n}\n", "nl": "convert from wrapper to external data type"}
{"code": "public static List<String> readFileToList(String filePath,String charsetName){\n  File file=new File(filePath);\n  List<String> fileContent=new ArrayList<String>();\n  if (file == null || !file.isFile()) {\n    return null;\n  }\n  BufferedReader reader=null;\n  try {\n    InputStreamReader is=new InputStreamReader(new FileInputStream(file),charsetName);\n    reader=new BufferedReader(is);\n    String line=null;\n    while ((line=reader.readLine()) != null) {\n      fileContent.add(line);\n    }\n    return fileContent;\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"IOException occurred. \",e);\n  }\n finally {\n    IOUtil.close(reader);\n  }\n}\n", "nl": "read file to string list, a element of list is a line"}
{"code": "public static void saveClassifications(DAAHeader header,String[] cNames,Map<Integer,ListOfLongs>[] fName2ClassId2Location,Map<Integer,Integer>[] fName2ClassId2Weight) throws IOException {\n  DAAModifier.removeMEGANClassificationData(header);\n  for (int f=0; f < cNames.length; f++) {\n    final String cName=cNames[f];\n    final ByteOutputStream outKey=new ByteOutputStream(1000000);\n    final OutputWriterLittleEndian wKey=new OutputWriterLittleEndian(outKey);\n    final ByteOutputStream outDump=new ByteOutputStream(1000000);\n    final OutputWriterLittleEndian wDump=new OutputWriterLittleEndian(outDump);\n    final Map<Integer,ListOfLongs> id2locations=fName2ClassId2Location[f];\n    wKey.writeNullTerminatedString(cName.getBytes());\n    wKey.writeInt(id2locations.size());\n    wDump.writeNullTerminatedString(cName.getBytes());\n    for (    int classId : id2locations.keySet()) {\n      wKey.writeInt(classId);\n      wKey.writeInt(fName2ClassId2Weight[f].get(classId));\n      final ListOfLongs list=id2locations.get(classId);\n      wKey.writeInt(list.size());\n      wKey.writeLong(wDump.getPosition());\n      for (int i=0; i < list.size(); i++) {\n        wDump.writeLong(list.get(i));\n      }\n    }\n    DAAModifier.appendBlocks(header,new BlockType[]{BlockType.megan_classification_key_block,BlockType.megan_classification_dump_block},new byte[][]{outKey.getBytes(),outDump.getBytes()},new int[]{outKey.size(),outDump.size()});\n  }\n}\n", "nl": "update the classifications"}
{"code": "private AudioInputStream imposeF0ContourOnVocalization(int sourceIndex,int targetIndex,AudioFileFormat aft,Element domElement) throws SynthesisException {\n  int numberOfBackChannels=unitFileReader.getNumberOfUnits();\n  if (targetIndex >= numberOfBackChannels) {\n    throw new IllegalArgumentException(\"This voice has \" + numberOfBackChannels + \" backchannels only. so it doesn't support unit number \"+ targetIndex);\n  }\n  if (sourceIndex >= numberOfBackChannels) {\n    throw new IllegalArgumentException(\"This voice has \" + numberOfBackChannels + \" backchannels only. so it doesn't support unit number \"+ sourceIndex);\n  }\n  VocalizationUnit bUnit=unitFileReader.getUnit(sourceIndex);\n  Unit[] units=bUnit.getUnits();\n  String[] unitNames=bUnit.getUnitNames();\n  long endTime=0l;\n  for (int i=0; i < units.length; i++) {\n    int unitDuration=units[i].duration * 1000 / unitFileReader.getSampleRate();\n    endTime+=unitDuration;\n    Element element=MaryXML.createElement(domElement.getOwnerDocument(),MaryXML.PHONE);\n    element.setAttribute(\"d\",Integer.toString(unitDuration));\n    element.setAttribute(\"end\",Long.toString(endTime));\n    element.setAttribute(\"p\",unitNames[i]);\n    domElement.appendChild(element);\n  }\n  return this.vSynthesizer.synthesizeUsingImposedF0(sourceIndex,targetIndex,aft);\n}\n", "nl": "Impose a target f0 contour onto a (source) unit"}
{"code": "public polyglot.ast.Node compile(polyglot.frontend.Compiler compiler,String fileName,polyglot.frontend.ExtensionInfo extInfo){\n  SourceLoader source_loader=compiler.sourceExtension().sourceLoader();\n  try {\n    FileSource source=new FileSource(new File(fileName));\n    if (false)     throw new IOException(\"Bogus exception\");\n    SourceJob job=null;\n    if (compiler.sourceExtension() instanceof soot.javaToJimple.jj.ExtensionInfo) {\n      soot.javaToJimple.jj.ExtensionInfo jjInfo=(soot.javaToJimple.jj.ExtensionInfo)compiler.sourceExtension();\n      if (jjInfo.sourceJobMap() != null) {\n        job=(SourceJob)jjInfo.sourceJobMap().get(source);\n      }\n    }\n    if (job == null) {\n      job=compiler.sourceExtension().addJob(source);\n    }\n    boolean result=false;\n    result=compiler.sourceExtension().runToCompletion();\n    if (!result) {\n      throw new soot.CompilationDeathException(0,\"Could not compile\");\n    }\n    polyglot.ast.Node node=job.ast();\n    return node;\n  }\n catch (  IOException e) {\n    return null;\n  }\n}\n", "nl": "uses polyglot to compile source and build AST"}
{"code": "private FilterResolverIntf createFilterResolverTree(Expression expressionTree,AbsoluteTableIdentifier tableIdentifier,Expression intermediateExpression){\n  ExpressionType filterExpressionType=expressionTree.getFilterExpressionType();\n  BinaryExpression currentExpression=null;\nswitch (filterExpressionType) {\ncase OR:\n    currentExpression=(BinaryExpression)expressionTree;\n  return new LogicalFilterResolverImpl(createFilterResolverTree(currentExpression.getLeft(),tableIdentifier,currentExpression),createFilterResolverTree(currentExpression.getRight(),tableIdentifier,currentExpression),currentExpression);\ncase AND:\ncurrentExpression=(BinaryExpression)expressionTree;\nreturn new LogicalFilterResolverImpl(createFilterResolverTree(currentExpression.getLeft(),tableIdentifier,currentExpression),createFilterResolverTree(currentExpression.getRight(),tableIdentifier,currentExpression),currentExpression);\ncase EQUALS:\ncase IN:\nreturn getFilterResolverBasedOnExpressionType(ExpressionType.EQUALS,((BinaryConditionalExpression)expressionTree).isNull,expressionTree,tableIdentifier,expressionTree);\ncase GREATERTHAN:\ncase GREATERTHAN_EQUALTO:\ncase LESSTHAN:\ncase LESSTHAN_EQUALTO:\nreturn getFilterResolverBasedOnExpressionType(ExpressionType.EQUALS,true,expressionTree,tableIdentifier,expressionTree);\ncase NOT_EQUALS:\ncase NOT_IN:\nreturn getFilterResolverBasedOnExpressionType(ExpressionType.NOT_EQUALS,false,expressionTree,tableIdentifier,expressionTree);\ncase FALSE:\nreturn getFilterResolverBasedOnExpressionType(ExpressionType.FALSE,false,expressionTree,tableIdentifier,expressionTree);\ndefault :\nreturn getFilterResolverBasedOnExpressionType(ExpressionType.UNKNOWN,false,expressionTree,tableIdentifier,expressionTree);\n}\n}\n", "nl": "Pattern used : Visitor Pattern Method will create filter resolver tree based on the filter expression tree, in this algorithm based on the expression instance the resolvers will created"}
{"code": "public boolean canUseSkill(){\n  Properties properties=skillTemplate.getProperties();\n  if (properties != null && !properties.validate(this)) {\n    log.debug(\"properties failed\");\n    return false;\n  }\n  if (!preCastCheck()) {\n    return false;\n  }\n  if (effector instanceof Player) {\n    Player player=(Player)effector;\n    if (this.skillTemplate.getCounterSkill() != null) {\n      long time=player.getLastCounterSkill(skillTemplate.getCounterSkill());\n      if ((time + 5000) < System.currentTimeMillis()) {\n        log.debug(\"chain skill failed, too late\");\n        return false;\n      }\n    }\n    if (skillMethod == SkillMethod.ITEM && duration > 0 && player.getMoveController().isInMove()) {\n      PacketSendUtility.sendPacket(player,SM_SYSTEM_MESSAGE.STR_ITEM_CANCELED(new DescriptionId(getItemTemplate().getNameId())));\n      return false;\n    }\n  }\n  if (!validateEffectedList()) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Check if the skill can be used"}
{"code": "protected void addSourceFileTag(soot.SootClass sc){\n  soot.tagkit.SourceFileTag tag=null;\n  if (sc.hasTag(\"SourceFileTag\")) {\n    tag=(soot.tagkit.SourceFileTag)sc.getTag(\"SourceFileTag\");\n  }\n else {\n    tag=new soot.tagkit.SourceFileTag();\n    sc.addTag(tag);\n  }\n  String name=Util.getSourceFileOfClass(sc);\n  if (InitialResolver.v().classToSourceMap() != null) {\n    if (InitialResolver.v().classToSourceMap().containsKey(name)) {\n      name=InitialResolver.v().classToSourceMap().get(name);\n    }\n  }\n  int slashIndex=name.lastIndexOf(\"/\");\n  if (slashIndex != -1) {\n    name=name.substring(slashIndex + 1);\n  }\n  tag.setSourceFile(name);\n}\n", "nl": "adds source file tag to each sootclass"}
{"code": "@Nullable private static Configuration pickConfiguration(AndroidFacet facet,Module module,PsiFile file){\n  VirtualFile virtualFile=file.getVirtualFile();\n  if (virtualFile == null) {\n    return null;\n  }\n  VirtualFile parent=virtualFile.getParent();\n  if (parent == null) {\n    return null;\n  }\n  VirtualFile layout;\n  String parentName=parent.getName();\n  if (!parentName.startsWith(FD_RES_LAYOUT)) {\n    layout=pickLayoutFile(module,facet);\n    if (layout == null) {\n      return null;\n    }\n  }\n else {\n    layout=virtualFile;\n  }\n  return facet.getConfigurationManager().getConfiguration(layout);\n}\n", "nl": "Picks a suitable configuration to use for resource resolution"}
{"code": "public synchronized void shutdown(){\n  if (!isActive) {\n    return;\n  }\n  log.info(\"Shutting down the default async job executor [{}].\",getClass().getName());\n  if (timerJobRunnable != null) {\n    timerJobRunnable.stop();\n  }\n  if (asyncJobsDueRunnable != null) {\n    asyncJobsDueRunnable.stop();\n  }\n  if (resetExpiredJobsRunnable != null) {\n    resetExpiredJobsRunnable.stop();\n  }\n  stopResetExpiredJobsThread();\n  stopTimerAcquisitionThread();\n  stopJobAcquisitionThread();\n  stopExecutingAsyncJobs();\n  timerJobRunnable=null;\n  asyncJobsDueRunnable=null;\n  resetExpiredJobsRunnable=null;\n  isActive=false;\n}\n", "nl": "Shuts down the whole job executor"}
{"code": "private boolean canInvitePlayer(Player activePlayer,Player targetPlayer){\n  Legion legion=activePlayer.getLegion();\n  if (activePlayer.getLifeStats().isAlreadyDead()) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_INVITE_CANT_INVITE_WHEN_DEAD);\n    return false;\n  }\n  if (isSelf(activePlayer,targetPlayer.getObjectId())) {\n    PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_INVITE_CAN_NOT_INVITE_SELF);\n    return false;\n  }\n else   if (targetPlayer.isLegionMember()) {\n    if (legion.isMember(targetPlayer.getObjectId())) {\n      PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_INVITE_HE_IS_MY_GUILD_MEMBER(targetPlayer.getName()));\n    }\n else {\n      PacketSendUtility.sendPacket(activePlayer,SM_SYSTEM_MESSAGE.STR_GUILD_INVITE_HE_IS_OTHER_GUILD_MEMBER(targetPlayer.getName()));\n    }\n    return false;\n  }\n else   if (!activePlayer.getLegionMember().hasRights(LegionPermissionsMask.INVITE)) {\n    return false;\n  }\n else   if (activePlayer.getRace() != targetPlayer.getRace() && !LegionConfig.LEGION_INVITEOTHERFACTION) {\n    return false;\n  }\n  return true;\n}\n", "nl": "This method checks all restrictions for invite player to legion"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set labelColor=\");\n  Color color=null;\n  if (np.peekMatchIgnoreCase(\"null\"))   np.matchIgnoreCase(\"null\");\n else   color=np.getColor();\n  np.matchIgnoreCase(\";\");\n  if (getViewer() instanceof GraphView) {\n    boolean changed=false;\n    GraphView viewer=(GraphView)getViewer();\n    for (    Node v : viewer.getSelectedNodes()) {\n      if (viewer.isLabelVisible(v)) {\n        viewer.setLabelColor(v,color);\n        changed=true;\n      }\n    }\n    for (    Edge edge : viewer.getSelectedEdges()) {\n      if (viewer.isLabelVisible(edge)) {\n        viewer.setLabelColor(edge,color);\n        changed=true;\n      }\n    }\n    if (changed) {\n      viewer.repaint();\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "protected static String cast(String value,Type<?> type){\n  String castValue=value.trim();\n  String typeName=type.getCanonicalName();\n  if (!\"null\".equals(value)) {\n    if (type.isPrimitive()) {\n      if (type.getRawType() == Character.TYPE) {\n        castValue=format(\"(\\\"\\\"+%s).charAt(0)\",castValue);\n      }\n else       if (!isPrimitiveLiteral(castValue,type)) {\n        castValue=format(\"%s.valueOf(\\\"\\\"+%s).%sValue()\",type.getWrapperType().getCanonicalName(),castValue,type);\n      }\n    }\n else     if (type.isPrimitiveWrapper() && isPrimitiveLiteral(castValue,type)) {\n      castValue=format(\"%s.valueOf(%s)\",type.getWrapperType().getCanonicalName(),castValue);\n    }\n else     if (!value.startsWith(\"(\" + typeName + \")\") && !value.startsWith(\"((\" + typeName + \")\")) {\n      castValue=\"((\" + typeName + \")\"+ castValue+ \")\";\n    }\n  }\n  return castValue;\n}\n", "nl": "Returns Java code which provides a cast of the specified value to the type of this property ref"}
{"code": "public void putAndEnsureCapacity(long index,int value){\n  int segment=(int)(index >>> SEGMENT_BITS);\n  int position=(int)(index & SEGMENT_MASK);\n  if (segment >= segments.length) {\n    grow(segment + 1);\n    segments[segment][position]=value;\n    if (value != 0)     numberOfNonZeroEntries++;\n  }\n else {\n    final int old=segments[segment][position];\n    if (old == 0) {\n      if (value != 0) {\n        segments[segment][position]=value;\n        numberOfNonZeroEntries++;\n      }\n    }\n else {\n      segments[segment][position]=value;\n      if (value == 0)       numberOfNonZeroEntries--;\n    }\n  }\n  maxIndex=Math.max(maxIndex,index);\n}\n", "nl": "put a value, If the index is larger than current maxIndex(), increases length of array"}
{"code": "private void position(){\n  velocity.x=(int)(sx * 160);\n  velocity.y=(int)(sy * 160);\n  if (position.x < posX + this.map_controler.syncCnt)   dir=2;\n else   dir=14;\n  if (position.y < posY)   dir=(dir == 2) ? 2 : 14;\n  if (Math.abs(position.y - posY) <= 4) {\n    position.y=posY;\n    velocity.y=0;\n    if (position.x < posX + this.map_controler.syncCnt)     dir=4;\n else     dir=12;\n  }\n  if (Math.abs(position.x - (posX + this.map_controler.syncCnt)) <= 4) {\n    position.x=posX + this.map_controler.syncCnt;\n    velocity.x=0;\n    dir=0;\n  }\n  if (position.y == posY && position.x == posX + this.map_controler.syncCnt) {\n    dir=0;\n    sx=1;\n    status=SYNC;\n    return;\n  }\n  sx=this.map_controler.get_Direc_Dis_X(dir);\n  sy=this.map_controler.get_Direc_Dis_Y(dir);\n}\n", "nl": "enemy position event"}
{"code": "public T onCreateViewHolderItemType(ViewGroup parent,ItemType itemType){\nswitch (itemType) {\ncase LVL3_ITEM:\n    return onCreateLvl3ItemViewHolder(parent);\ncase LVL2_ITEM:\n  return onCreateLvl2ItemViewHolder(parent);\ncase LVL1_ITEM:\nreturn onCreateLvl1ItemViewHolder(parent);\ncase LVL0_ITEM:\nreturn onCreateLvl0ItemViewHolder(parent);\ncase LVL3_SECTION:\nreturn onCreateLvl3SectionViewHolder(parent);\ncase LVL2_SECTION:\nreturn onCreateLvl2SectionViewHolder(parent);\ncase LVL1_SECTION:\nreturn onCreateLvl1SectionViewHolder(parent);\ndefault :\nreturn null;\n}\n}\n", "nl": "main onCreate method do not overwrite unless necessary"}
{"code": "@TargetApi(23) private static boolean checkSelfPermissionForXiaomi(Context context,String permission){\n  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {\n    try {\n      return checkSelfPermission(context,permission) == PackageManager.PERMISSION_GRANTED;\n    }\n catch (    RuntimeException t) {\n      return false;\n    }\n  }\n  int auth=ActivityCompat.checkSelfPermission(context,permission);\n  AppOpsManager appOpsManager=(AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);\n  int checkOp=appOpsManager.checkOp(AppOpsManager.permissionToOp(permission),Process.myUid(),context.getPackageName());\n  if (auth == PackageManager.PERMISSION_GRANTED && checkOp == AppOpsManager.MODE_ALLOWED) {\n    return true;\n  }\n  if (auth == PackageManager.PERMISSION_GRANTED && checkOp == AppOpsManager.MODE_IGNORED) {\n    return false;\n  }\n  return false;\n}\n", "nl": "\"Xiaomi\" phone is different others,need add AppOpsManager"}
{"code": "private static BitMatrix bitMatrixFromEncoder(PDF417 encoder,String contents,int errorCorrectionLevel,int width,int height,int margin) throws WriterException {\n  encoder.generateBarcodeLogic(contents,errorCorrectionLevel);\n  int aspectRatio=4;\n  byte[][] originalScale=encoder.getBarcodeMatrix().getScaledMatrix(1,aspectRatio);\n  boolean rotated=false;\n  if ((height > width) ^ (originalScale[0].length < originalScale.length)) {\n    originalScale=rotateArray(originalScale);\n    rotated=true;\n  }\n  int scaleX=width / originalScale[0].length;\n  int scaleY=height / originalScale.length;\n  int scale;\n  if (scaleX < scaleY) {\n    scale=scaleX;\n  }\n else {\n    scale=scaleY;\n  }\n  if (scale > 1) {\n    byte[][] scaledMatrix=encoder.getBarcodeMatrix().getScaledMatrix(scale,scale * aspectRatio);\n    if (rotated) {\n      scaledMatrix=rotateArray(scaledMatrix);\n    }\n    return bitMatrixFrombitArray(scaledMatrix,margin);\n  }\n  return bitMatrixFrombitArray(originalScale,margin);\n}\n", "nl": "Takes encoder, accounts for width/height, and retrieves bit matrix"}
{"code": "public void onDie(Creature lastAttacker){\n  this.getOwner().getMoveController().abortMove();\n  this.getOwner().setCasting(null);\n  this.getOwner().getEffectController().removeAllEffects();\n  if (getOwner() instanceof Player) {\n    if (((Player)getOwner()).getIsFlyingBeforeDeath()) {\n      getOwner().unsetState(CreatureState.ACTIVE);\n      getOwner().setState(CreatureState.FLOATING_CORPSE);\n    }\n else {\n      this.getOwner().setState(CreatureState.DEAD);\n    }\n  }\n else {\n    if (getOwner() instanceof Npc) {\n      if (((Npc)getOwner()).getObjectTemplate().isFloatCorpse()) {\n        getOwner().setState(CreatureState.FLOATING_CORPSE);\n      }\n    }\n    this.getOwner().setState(CreatureState.DEAD);\n  }\n  this.getOwner().getObserveController().notifyDeathObservers(lastAttacker);\n}\n", "nl": "Perform tasks on Creature death"}
{"code": "@Override public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (obj == null) {\n    return false;\n  }\n  if (!(obj instanceof ColumnSchema)) {\n    return false;\n  }\n  ColumnSchema other=(ColumnSchema)obj;\n  if (columnName == null) {\n    if (other.columnName != null) {\n      return false;\n    }\n  }\n else   if (!columnName.equals(other.columnName)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Overridden equals method for columnSchema"}
{"code": "private static void buildId2AddressRec(Node v,String path,Map<Integer,String> id2address,Map<String,Integer> address2id){\n  int id=(Integer)v.getInfo();\n  id2address.put(id,path);\n  address2id.put(path,id);\n  if (v.getOutDegree() < Character.MAX_VALUE) {\n    char count=1;\n    for (Edge f=v.getFirstOutEdge(); f != null; f=v.getNextOutEdge(f)) {\n      buildId2AddressRec(f.getOpposite(v),path + count,id2address,address2id);\n      count++;\n    }\n  }\n else {\n    char count1=1;\n    char count2=1;\n    for (Edge f=v.getFirstOutEdge(); f != null; f=v.getNextOutEdge(f)) {\n      if (count1 == Character.MAX_VALUE) {\n        count2++;\n        count1=1;\n      }\n      buildId2AddressRec(f.getOpposite(v),(path + count1) + count2,id2address,address2id);\n      count1++;\n    }\n  }\n}\n", "nl": "computes the id to address mapping"}
{"code": "private NumericSummaryTable splitGroupingColumn(NumericSummaryTable groupTable){\n  List<Column> newColumns=new ArrayList<>();\n  List<Column> columns=sortedOriginal.columns(splitColumnNames);\n  for (  Column column : columns) {\n    Column newColumn=column.emptyCopy();\n    newColumns.add(newColumn);\n  }\n  for (int row=0; row < groupTable.rowCount(); row++) {\n    List<String> strings=SPLITTER.splitToList(groupTable.categoryColumn(\"Group\").get(row));\n    for (int col=0; col < newColumns.size(); col++) {\n      newColumns.get(col).addCell(strings.get(col));\n    }\n  }\n  for (int col=0; col < newColumns.size(); col++) {\n    Column c=newColumns.get(col);\n    groupTable.addColumn(col,c);\n  }\n  groupTable.removeColumns(\"Group\");\n  return groupTable;\n}\n", "nl": "For a subtable that is grouped by the values in more than one column, split the grouping column into separate cols and return the revised view"}
{"code": "public static void element2Map(Element e,Map<String,Object> map){\n  List<Object> list=e.elements();\n  if (e.attributeCount() > 0) {\n    for (    Object attri : e.attributes()) {\n      Attribute at=(Attribute)attri;\n      map.put(at.getName(),at.getValue());\n    }\n  }\n  if (list.size() < 1 && DataUtil.isEmpty(e.getText())) {\n    return;\n  }\n else   if (list.size() < 1 && !DataUtil.isEmpty(e.getText())) {\n    map.put(\"text\",e.getText());\n  }\n  for (  Object aList : list) {\n    Element iter=(Element)aList;\n    Map<String,Object> cMap=new HashMap<String,Object>();\n    element2Map(iter,cMap);\n    map.put(iter.getName(),cMap);\n  }\n}\n", "nl": "Element to map"}
{"code": "private void handleOuterClassParams(ArrayList sootParams,soot.Value qVal,ArrayList sootParamsTypes,polyglot.types.ClassType typeToInvoke){\n  ArrayList needsRef=soot.javaToJimple.InitialResolver.v().getHasOuterRefInInit();\n  boolean addRef=needsOuterClassRef(typeToInvoke);\n  if (addRef) {\n    soot.SootClass outerClass=((soot.RefType)Util.getSootType(typeToInvoke.outer())).getSootClass();\n    sootParamsTypes.add(outerClass.getType());\n  }\n  if (addRef && !typeToInvoke.isAnonymous() && (qVal != null)) {\n    sootParams.add(qVal);\n  }\n else   if (addRef && !typeToInvoke.isAnonymous()) {\n    soot.SootClass outerClass=((soot.RefType)Util.getSootType(typeToInvoke.outer())).getSootClass();\n    sootParams.add(getThis(outerClass.getType()));\n  }\n else   if (addRef && typeToInvoke.isAnonymous()) {\n    soot.SootClass outerClass=((soot.RefType)Util.getSootType(typeToInvoke.outer())).getSootClass();\n    sootParams.add(getThis(outerClass.getType()));\n  }\n  if (typeToInvoke.isAnonymous() && (qVal != null)) {\n    sootParamsTypes.add(qVal.getType());\n    sootParams.add(qVal);\n  }\n}\n", "nl": "adds outer class params"}
{"code": "public Boolean createCustomer(EntityManager em,String customerId){\n  Boolean status=true;\n  Customer bupa=null;\n  Date date=null;\n  DateFormat formatter=new SimpleDateFormat(\"yyyymmdd\");\n  try {\n    if (!em.getTransaction().isActive()) {\n      em.getTransaction().begin();\n    }\n    Calendar cal=Calendar.getInstance();\n    date=formatter.parse(\"19770707\");\n    cal.setTime(date);\n    bupa=new Customer();\n    bupa.setCustomerId(customerId);\n    bupa.setPhoneNumber(\"009180437980098\");\n    bupa.setDateOfBirth(cal);\n    em.persist(bupa);\n    em.getTransaction().commit();\n  }\n catch (  Exception e) {\n    status=false;\n    logger.error(\"Error occured during creation of Business Partner. Detailed info: \" + e);\n  }\n  return status;\n}\n", "nl": "Helper method to create Business Partner"}
{"code": "private boolean itemIsObscuredByHeader(RecyclerView parent,View item,View header,int orientation){\n  RecyclerView.LayoutParams layoutParams=(RecyclerView.LayoutParams)item.getLayoutParams();\n  mDimensionCalculator.initMargins(mTempRect1,header);\n  int adapterPosition=parent.getChildAdapterPosition(item);\n  if (adapterPosition == RecyclerView.NO_POSITION || mHeaderProvider.getHeader(parent,adapterPosition) != header) {\n    return false;\n  }\n  if (orientation == LinearLayoutManager.VERTICAL) {\n    int itemTop=item.getTop() - layoutParams.topMargin;\n    int headerBottom=getListTop(parent) + header.getBottom() + mTempRect1.bottom+ mTempRect1.top;\n    if (itemTop >= headerBottom) {\n      return false;\n    }\n  }\n else {\n    int itemLeft=item.getLeft() - layoutParams.leftMargin;\n    int headerRight=getListLeft(parent) + header.getRight() + mTempRect1.right+ mTempRect1.left;\n    if (itemLeft >= headerRight) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines if an item is obscured by a header"}
{"code": "public static int javaNewInstance(int luaState,String className) throws LuaException {\n  LuaState L=LuaStateFactory.getExistingState(luaState);\nsynchronized (L) {\n    Class clazz;\n    try {\n      ClassLoader loader=ModuleContext.getInstance().getBaseClassLoader();\n      if (loader != null) {\n        clazz=loader.loadClass(className);\n      }\n else {\n        clazz=Class.forName(className);\n      }\n    }\n catch (    ClassNotFoundException e) {\n      throw new LuaException(e);\n    }\n    Object ret=getObjInstance(L,clazz);\n    L.pushJavaObject(ret);\n    return 1;\n  }\n}\n", "nl": "Pushes a new instance of a java Object of the type className"}
{"code": "private String makeSAM(String queryName,String refName,int referenceLength,float bitScore,float expect,int rawScore,float percentIdentity,int frame,int queryStart,int queryEnd,int referenceStart,int referenceEnd,String alignedQuery,String alignedReference){\n  final StringBuilder buffer=new StringBuilder();\n  buffer.append(queryName).append(\"\\t\");\n  buffer.append(0);\n  buffer.append(\"\\t\");\n  buffer.append(refName).append(\"\\t\");\n  buffer.append(referenceStart).append(\"\\t\");\n  buffer.append(\"255\\t\");\n  Utilities.appendCigar(alignedQuery,alignedReference,buffer);\n  buffer.append(\"\\t\");\n  buffer.append(\"*\\t\");\n  buffer.append(\"0\\t\");\n  buffer.append(\"0\\t\");\n  buffer.append(alignedQuery.replaceAll(\"-\",\"\")).append(\"\\t\");\n  buffer.append(\"*\\t\");\n  buffer.append(String.format(\"AS:i:%d\\t\",(int)Math.round(bitScore)));\n  buffer.append(String.format(\"NM:i:%d\\t\",Utilities.computeEditDistance(alignedQuery,alignedReference)));\n  buffer.append(String.format(\"ZL:i:%d\\t\",referenceLength));\n  buffer.append(String.format(\"ZR:i:%d\\t\",rawScore));\n  buffer.append(String.format(\"ZE:f:%g\\t\",expect));\n  buffer.append(String.format(\"ZI:i:%d\\t\",(int)Math.round(percentIdentity)));\n  if (frame != 0)   buffer.append(String.format(\"ZF:i:%d\\t\",frame));\n  buffer.append(String.format(\"ZS:i:%s\\t\",queryStart));\n  Utilities.appendMDString(alignedQuery,alignedReference,buffer);\n  return buffer.toString();\n}\n", "nl": "make a SAM line"}
{"code": "public boolean isSet(_Fields field){\n  if (field == null) {\n    throw new IllegalArgumentException();\n  }\nswitch (field) {\ncase MESSAGE_TYPE:\n    return isSetMessageType();\ncase REQUEST_INFO:\n  return isSetRequestInfo();\ncase RESPONSE_INFO:\nreturn isSetResponseInfo();\ncase TRACE_INFO:\nreturn isSetTraceInfo();\ncase GLOBAL_CONTEXT:\nreturn isSetGlobalContext();\ncase LOCAL_CONTEXT:\nreturn isSetLocalContext();\ncase HEARTBEAT_INFO:\nreturn isSetHeartbeatInfo();\n}\nthrow new IllegalStateException();\n}\n", "nl": "Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise"}
{"code": "public static void replaceBlock(DAAHeader header,BlockType blockType,byte[] bytes,int size) throws IOException {\n  int index=header.getIndexForBlockType(blockType);\n{\n    if (index != -1) {\n      header.setBlockTypeRank(index,BlockType.rank(BlockType.empty));\n      header.setBlockSize(index,0);\n      if (index >= header.getLastDefinedBlockIndex()) {\n        long newSize=header.getLocationOfBlockInFile(index);\n        if (newSize > 0) {\n          RandomAccessFile raf=new RandomAccessFile(header.getFileName(),\"rw\");\n          raf.setLength(newSize);\n        }\n      }\n else       throw new IOException(\"Can't replace block, not last\");\n    }\n  }\n  try (OutputStream outs=new BufferedOutputStream(new FileOutputStream(header.getFileName(),true))){\n    index=header.getFirstAvailableBlockIndex();\n    header.setBlockTypeRank(index,BlockType.rank(blockType));\n    header.setBlockSize(index,size);\n    outs.write(bytes,0,size);\n  }\n   header.save();\n}\n", "nl": "replace a block"}
{"code": "public void close() throws IOException {\n  if (enable) {\nsynchronized (closed) {\n      closed.set(true);\n      if (!future.isDone()) {\n        done=true;\n        future.cancel(true);\n      }\n      if (isClosable) {\n        ((ICloseableIterator)iterator).close();\n      }\n    }\n  }\n else {\n    if (isClosable) {\n      ((ICloseableIterator)iterator).close();\n    }\n  }\n}\n", "nl": "shutdown thread used by getLetterCodeIterator"}
{"code": "@Override public void loadXML(Node stepnode,List<DatabaseMeta> databases,Map<String,Counter> counters) throws KettleXMLException {\n  try {\n    databaseName=XMLHandler.getTagValue(stepnode,\"databaseName\");\n    tabelName=XMLHandler.getTagValue(stepnode,\"TableName\");\n    mdkeySize=XMLHandler.getTagValue(stepnode,\"MDKeySize\");\n    measureCount=XMLHandler.getTagValue(stepnode,\"Measurecount\");\n    heirAndKeySize=XMLHandler.getTagValue(stepnode,\"HeirAndKeySize\");\n    tableName=XMLHandler.getTagValue(stepnode,\"tableName\");\n    groupByEnabled=XMLHandler.getTagValue(stepnode,\"isGroupByEnabled\");\n    aggregatorClassString=XMLHandler.getTagValue(stepnode,\"aggregatorClassString\");\n    aggregatorString=XMLHandler.getTagValue(stepnode,\"aggregatorString\");\n    factDimLensString=XMLHandler.getTagValue(stepnode,\"factDimLensString\");\n    levelAnddataTypeString=XMLHandler.getTagValue(stepnode,\"levelAnddataTypeString\");\n    partitionID=XMLHandler.getTagValue(stepnode,\"partitionID\");\n    segmentId=XMLHandler.getTagValue(stepnode,\"segmentId\");\n    taskNo=XMLHandler.getTagValue(stepnode,\"taskNo\");\n  }\n catch (  Exception e) {\n    throw new KettleXMLException(\"Unable to read step info from XML node\",e);\n  }\n}\n", "nl": "Load the values for this step from an XML Node"}
{"code": "public static int checkSignatureAndTinkerID(Context context,File patchFile,ShareSecurityCheck securityCheck){\n  if (!securityCheck.verifyPatchMetaSignature(patchFile)) {\n    return ShareConstants.ERROR_PACKAGE_CHECK_SIGNATURE_FAIL;\n  }\n  String oldTinkerId=getManifestTinkerID(context);\n  if (oldTinkerId == null) {\n    return ShareConstants.ERROR_PACKAGE_CHECK_APK_TINKER_ID_NOT_FOUND;\n  }\n  HashMap<String,String> properties=securityCheck.getPackagePropertiesIfPresent();\n  if (properties == null) {\n    return ShareConstants.ERROR_PACKAGE_CHECK_PACKAGE_META_NOT_FOUND;\n  }\n  String patchTinkerId=properties.get(ShareConstants.TINKER_ID);\n  if (patchTinkerId == null) {\n    return ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND;\n  }\n  if (!oldTinkerId.equals(patchTinkerId)) {\n    return ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL;\n  }\n  return ShareConstants.ERROR_PACKAGE_CHECK_OK;\n}\n", "nl": "check patch file signature and TINKER_ID"}
{"code": "public Boolean deleteCustomerReview(EntityManager em,String customerReviewId){\n  Boolean status=true;\n  CustomerReview customerReview=null;\n  try {\n    if (!em.getTransaction().isActive()) {\n      em.getTransaction().begin();\n    }\n    customerReview=em.find(CustomerReview.class,customerReviewId);\n    if (customerReview != null) {\n      em.remove(customerReview);\n      em.getTransaction().commit();\n    }\n else {\n      logger.info(\"CustomerReview \" + customerReviewId + \" does not exist in the db\");\n      status=false;\n    }\n  }\n catch (  Exception e) {\n    status=false;\n    logger.error(\"Error occured during deletion of customer review. Detailed info: \" + e);\n  }\n  return status;\n}\n", "nl": "Helper method to delete CustomerReview"}
{"code": "@Override public int compareTo(ByteArrayWrapper other){\n  int compareTo=UnsafeComparer.INSTANCE.compareTo(dictionaryKey,other.dictionaryKey);\n  if (compareTo == 0) {\n    for (int i=0; i < noDictionaryKeys.length; i++) {\n      compareTo=UnsafeComparer.INSTANCE.compareTo(noDictionaryKeys[i],other.noDictionaryKeys[i]);\n      if (compareTo != 0) {\n        return compareTo;\n      }\n    }\n  }\n  if (compareTo == 0) {\n    for (int i=0; i < complexTypesKeys.length; i++) {\n      compareTo=UnsafeComparer.INSTANCE.compareTo(complexTypesKeys[i],other.complexTypesKeys[i]);\n      if (compareTo != 0) {\n        return compareTo;\n      }\n    }\n  }\n  return compareTo;\n}\n", "nl": "Compare method for ByteArrayWrapper class this will used to compare Two ByteArrayWrapper data object, basically it will compare two byte array"}
{"code": "private void updateSpaceItems(final int selectedIndex){\n  if (currentSelectedItem == selectedIndex) {\n    if (spaceOnClickListener != null)     spaceOnClickListener.onItemReselected(selectedIndex,spaceItems.get(selectedIndex).getItemName());\n    return;\n  }\n  for (int i=0; i < spaceItemList.size(); i++) {\n    if (i == selectedIndex) {\n      RelativeLayout textAndIconContainer=(RelativeLayout)spaceItemList.get(selectedIndex);\n      ImageView spaceItemIcon=(ImageView)textAndIconContainer.findViewById(R.id.space_icon);\n      TextView spaceItemText=(TextView)textAndIconContainer.findViewById(R.id.space_text);\n      spaceItemText.setTextColor(activeSpaceItemColor);\n      Utils.changeImageViewTint(spaceItemIcon,activeSpaceItemColor);\n    }\n else     if (i == currentSelectedItem) {\n      RelativeLayout textAndIconContainer=(RelativeLayout)spaceItemList.get(i);\n      ImageView spaceItemIcon=(ImageView)textAndIconContainer.findViewById(R.id.space_icon);\n      TextView spaceItemText=(TextView)textAndIconContainer.findViewById(R.id.space_text);\n      spaceItemText.setTextColor(inActiveSpaceItemColor);\n      Utils.changeImageViewTint(spaceItemIcon,inActiveSpaceItemColor);\n    }\n  }\n  if (spaceOnClickListener != null)   spaceOnClickListener.onItemClick(selectedIndex,spaceItems.get(selectedIndex).getItemName());\n  currentSelectedItem=selectedIndex;\n}\n", "nl": "Update selected item and change it's and non selected item tint"}
{"code": "public synchronized boolean verifyAndAdvanceState(Byte newStep){\n  logger.debug(\"NODE {}: ZWaveSecurityCommandClass in verifyAndAdvanceState with newstep={}, currentstep={}\",node.getNodeId(),ZWaveSecurityCommandClass.commandToString(newStep),ZWaveSecurityCommandClass.commandToString(currentStep));\n  if (!INIT_COMMAND_ORDER_LIST.contains(newStep)) {\n    return true;\n  }\n  if (INIT_COMMAND_ORDER_LIST.indexOf(newStep) > 0) {\n    int currentIndex=INIT_COMMAND_ORDER_LIST.indexOf(currentStep);\n    int newIndex=INIT_COMMAND_ORDER_LIST.indexOf(newStep);\n    if (newIndex != currentIndex && newIndex - currentIndex > 1) {\n      if (HALT_ON_IMPROPER_ORDER) {\n        setErrorState(String.format(\"NODE %d: Commands received out of order, aborting current=%s, new=%s\",node.getNodeId(),ZWaveSecurityCommandClass.commandToString(currentStep),ZWaveSecurityCommandClass.commandToString(newStep)));\n        return false;\n      }\n else {\n        logger.warn(\"NODE {}: Commands received out of order (warning only, continuing) current={}, new={}\",node.getNodeId(),ZWaveSecurityCommandClass.commandToString(currentStep),ZWaveSecurityCommandClass.commandToString(newStep));\n      }\n    }\n  }\n  currentStep=newStep;\n  return true;\n}\n", "nl": "Since these operations are security sensitive we must ensure they are executing in the proper sequence"}
{"code": "public Builder cloneFrom(DisplayImageOptions options){\n  imageResOnLoading=options.imageResOnLoading;\n  imageResForEmptyUri=options.imageResForEmptyUri;\n  imageResOnFail=options.imageResOnFail;\n  imageOnLoading=options.imageOnLoading;\n  imageForEmptyUri=options.imageForEmptyUri;\n  imageOnFail=options.imageOnFail;\n  resetViewBeforeLoading=options.resetViewBeforeLoading;\n  cacheInMemory=options.cacheInMemory;\n  cacheOnDisk=options.cacheOnDisk;\n  imageScaleType=options.imageScaleType;\n  decodingOptions=options.decodingOptions;\n  delayBeforeLoading=options.delayBeforeLoading;\n  considerExifParams=options.considerExifParams;\n  extraForDownloader=options.extraForDownloader;\n  preProcessor=options.preProcessor;\n  postProcessor=options.postProcessor;\n  displayer=options.displayer;\n  handler=options.handler;\n  isSyncLoading=options.isSyncLoading;\n  return this;\n}\n", "nl": "Sets all options equal to incoming options"}
{"code": "protected void printXMLChar(int ch) throws IOException {\n  if (ch == '\\r') {\n    printHex(ch);\n  }\n else   if (ch == '<') {\n    _printer.printText(\"&lt;\");\n  }\n else   if (ch == '&') {\n    _printer.printText(\"&amp;\");\n  }\n else   if (ch == '>') {\n    _printer.printText(\"&gt;\");\n  }\n else   if (ch == '\\n' || ch == '\\t' || (ch >= ' ' && _encodingInfo.isPrintable((char)ch))) {\n    _printer.printText((char)ch);\n  }\n else {\n    printHex(ch);\n  }\n}\n", "nl": "print text data"}
{"code": "private void addModifiers(polyglot.types.Flags flags,polyglot.ast.ClassDecl cDecl){\n  int modifiers=0;\n  if (cDecl.type().isNested()) {\n    if (flags.isPublic() || flags.isProtected() || flags.isPrivate()) {\n      modifiers=soot.Modifier.PUBLIC;\n    }\n    if (flags.isInterface()) {\n      modifiers=modifiers | soot.Modifier.INTERFACE;\n    }\n    if (flags.isAbstract()) {\n      modifiers=modifiers | soot.Modifier.ABSTRACT;\n    }\n    if (cDecl.type().outer().flags().isInterface()) {\n      modifiers=modifiers | soot.Modifier.PUBLIC;\n    }\n  }\n else {\n    modifiers=getModifiers(flags);\n  }\n  sootClass.setModifiers(modifiers);\n}\n", "nl": "adds modifiers"}
{"code": "public void disconnectEntryFromXtn(Context context,IEntryHolder entryHolder,XtnEntry xtnEntry,boolean xtnEnd) throws SAException {\n  IEntryCacheInfo pEntry=getPEntryByUid(entryHolder.getUID());\n  if (pEntry == null)   return;\n  XtnData pXtn=xtnEntry.getXtnData();\n  if (!xtnEnd)   removeLockedEntry(pXtn,pEntry);\n  if ((pEntry.getEntryHolder(this).getWriteLockTransaction() == null) || !pEntry.getEntryHolder(this).getWriteLockTransaction().equals(pXtn.getXtn())) {\n    pEntry.getEntryHolder(this).removeReadLockOwner(pXtn.getXtnEntry());\n  }\n  if ((pEntry.getEntryHolder(this).getWriteLockTransaction() != null) && pEntry.getEntryHolder(this).getWriteLockTransaction().equals(pXtn.getXtn())) {\n    pEntry.getEntryHolder(this).resetWriteLockOwner();\n  }\n  if (xtnEntry == pEntry.getEntryHolder(this).getXidOriginated())   pEntry.getEntryHolder(this).resetXidOriginated();\n  pEntry.getEntryHolder(this).setMaybeUnderXtn(pEntry.getEntryHolder(this).anyReadLockXtn() || pEntry.getEntryHolder(this).getWriteLockTransaction() != null);\n  if (!pEntry.getEntryHolder(this).isMaybeUnderXtn()) {\n    if (!pEntry.getEntryHolder(this).isHasWaitingFor()) {\n      pEntry.getEntryHolder(this).resetEntryXtnInfo();\n      if (pEntry.isPinned() && xtnEnd)       unpinIfNeeded(context,pEntry.getEntryHolder(this),null,pEntry);\n    }\n  }\n}\n", "nl": "disconnect an entry from xtn"}
{"code": "public void updateFromInfo(ISVNInfo info){\n  if (info == null)   return;\n  Object aValue=null;\n  aValue=info.getNodeKind();\n  if (aValue != null)   this.nodeKind=((SVNNodeKind)aValue).toInt();\n  aValue=info.getLastChangedDate();\n  if (aValue == null) {\n    this.lastChangedDate=-1;\n  }\n else {\n    this.lastChangedDate=((Date)aValue).getTime();\n  }\n  aValue=info.getLastChangedRevision();\n  if (aValue == null) {\n    this.lastChangedRevision=SVNRevision.SVN_INVALID_REVNUM;\n  }\n else {\n    this.lastChangedRevision=((SVNRevision.Number)aValue).getNumber();\n  }\n  this.lastCommitAuthor=info.getLastCommitAuthor();\n  aValue=info.getUrl();\n  if (aValue == null) {\n    this.url=null;\n  }\n else {\n    this.url=((SVNUrl)aValue).toString();\n  }\n}\n", "nl": "Update missing data from the supplied info"}
{"code": "public void writeClassifications(String[] cNames,Map<Integer,ListOfLongs>[] fName2Location,Map<Integer,Integer>[] fName2weight) throws IOException {\n  getFooterSectionRMA6().setStartClassificationsSection(readerWriter.getPosition());\n  getFooterSectionRMA6().getAvailableClassification2Position().clear();\n  if (cNames != null) {\n    for (int i=0; i < cNames.length; i++) {\n      final String cName=cNames[i];\n      final ClassificationBlockRMA6 classification=new ClassificationBlockRMA6(cName);\n      final Map<Integer,ListOfLongs> id2locations=fName2Location[i];\n      for (      int id : id2locations.keySet()) {\n        final Integer weight=fName2weight[i].get(id);\n        classification.setSum(id,weight != null ? weight : 0);\n      }\n      getFooterSectionRMA6().getAvailableClassification2Position().put(cName,readerWriter.getPosition());\n      classification.write(readerWriter,id2locations);\n      System.err.println(String.format(\"Class. %-13s%,10d\",cName + \":\",id2locations.size()));\n    }\n  }\n  getFooterSectionRMA6().setEndClassificationsSection(readerWriter.getPosition());\n}\n", "nl": "writes the classifications"}
{"code": "public void loadXML(Node stepnode,List<DatabaseMeta> databases,Map<String,Counter> counters) throws KettleXMLException {\n  try {\n    this.tabelName=XMLHandler.getTagValue(stepnode,\"TableName\");\n    this.outputRowSize=XMLHandler.getTagValue(stepnode,\"outputRowSize\");\n    this.factDimLensString=XMLHandler.getTagValue(stepnode,\"factDimLensString\");\n    this.tableName=XMLHandler.getTagValue(stepnode,\"tableName\");\n    this.databaseName=XMLHandler.getTagValue(stepnode,\"databaseName\");\n    this.dimensionCount=XMLHandler.getTagValue(stepnode,\"dimensionCount\");\n    this.noDictionaryDims=XMLHandler.getTagValue(stepnode,\"noDictionaryDims\");\n    this.noDictionaryDimsMapping=XMLHandler.getTagValue(stepnode,\"noDictionaryDimsMapping\");\n    this.complexDimensionCount=XMLHandler.getTagValue(stepnode,\"complexDimensionCount\");\n    this.measureCount=XMLHandler.getTagValue(stepnode,\"measureCount\");\n    this.updateMemberRequest=XMLHandler.getTagValue(stepnode,\"isUpdateMemberRequest\");\n    this.measureDataType=XMLHandler.getTagValue(stepnode,\"measureDataType\");\n    this.partitionID=XMLHandler.getTagValue(stepnode,\"partitionID\");\n    this.segmentId=XMLHandler.getTagValue(stepnode,\"segmentId\");\n    this.taskNo=XMLHandler.getTagValue(stepnode,\"taskNo\");\n  }\n catch (  Exception e) {\n    throw new KettleXMLException(\"Unable to read step info from XML node\",e);\n  }\n}\n", "nl": "Load the values for this step from an XML Node"}
{"code": "public Map<String,Object> invoke(ServiceDispatcher dispatcher,String localName,Map<String,Object> context) throws GenericServiceException {\n  DispatchContext dctx=dispatcher.getLocalContext(localName);\n  ModelService model=dctx.getModelService(getName());\n  if (model == null)   throw new GenericServiceException(\"Group defined service (\" + getName() + \") is not a defined service.\");\n  Map<String,Object> thisContext=model.makeValid(context,ModelService.IN_PARAM);\n  Debug.logInfo(\"Running grouped service [\" + serviceName + \"]\",module);\n  if (getMode().equals(\"async\")) {\n    List<String> requiredOut=model.getParameterNames(ModelService.OUT_PARAM,false);\n    if (requiredOut.size() > 0) {\n      Debug.logWarning(\"Grouped service (\" + getName() + \") requested 'async' invocation; running sync because of required OUT parameters.\",module);\n      return dispatcher.runSync(localName,model,thisContext);\n    }\n else {\n      dispatcher.runAsync(localName,model,thisContext,false);\n      return new HashMap<String,Object>();\n    }\n  }\n else {\n    return dispatcher.runSync(localName,model,thisContext);\n  }\n}\n", "nl": "Invoker method to invoke this service"}
{"code": "private boolean addViewFromPreviousActivity(){\n  if (mCurrentContentView.getChildCount() == 0) {\n    mPreviousActivity=null;\n    mPreviousContentView=null;\n    return false;\n  }\n  CustomApplication application=(CustomApplication)mCurrentWindow.getContext().getApplicationContext();\n  mPreviousActivity=application.getActivityLifecycleHelper().getPreActivity();\n  if (mPreviousActivity == null) {\n    mPreviousActivity=null;\n    mPreviousContentView=null;\n    return false;\n  }\n  ViewGroup previousActivityContainer=getContentView(mPreviousActivity.getWindow());\n  if (previousActivityContainer == null || previousActivityContainer.getChildCount() == 0) {\n    mPreviousActivity=null;\n    mPreviousContentView=null;\n    return false;\n  }\n  mPreviousContentView=(ViewGroup)previousActivityContainer.getChildAt(0);\n  previousActivityContainer.removeView(mPreviousContentView);\n  mCurrentContentView.addView(mPreviousContentView,0);\n  return true;\n}\n", "nl": "Remove view from previous Activity and add into current Activity"}
{"code": "@Override protected void drawLabels(Canvas c,float pos,PointF anchor){\n  final float labelRotationAngleDegrees=mXAxis.getLabelRotationAngle();\n  float[] position=new float[]{0f,0f};\n  BarData bd=mChart.getData();\n  int step=bd.getDataSetCount();\n  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {\n    position[0]=i * step + i * bd.getGroupSpace() + bd.getGroupSpace() / 2f;\n    if (step > 1) {\n      position[0]+=((float)step - 1f) / 2f;\n    }\n    mTrans.pointValuesToPixel(position);\n    if (mViewPortHandler.isInBoundsX(position[0]) && i >= 0 && i < mXAxis.getValues().size()) {\n      String label=mXAxis.getValues().get(i);\n      if (mXAxis.isAvoidFirstLastClippingEnabled()) {\n        if (i == mXAxis.getValues().size() - 1) {\n          float width=Utils.calcTextWidth(mAxisLabelPaint,label);\n          if (position[0] + width / 2.f > mViewPortHandler.contentRight())           position[0]=mViewPortHandler.contentRight() - (width / 2.f);\n        }\n else         if (i == 0) {\n          float width=Utils.calcTextWidth(mAxisLabelPaint,label);\n          if (position[0] - width / 2.f < mViewPortHandler.contentLeft())           position[0]=mViewPortHandler.contentLeft() + (width / 2.f);\n        }\n      }\n      drawLabel(c,label,i,position[0],pos,anchor,labelRotationAngleDegrees);\n    }\n  }\n}\n", "nl": "draws the x-labels on the specified y-position"}
{"code": "public static boolean IsMaltOrDiamondSAMFile(File file){\n  String suffix=Basic.getFileSuffix(Basic.getFileNameWithoutZipOrGZipSuffix(file.getName()));\n  if (suffix == null)   return false;\n  if (!suffix.toLowerCase().equals(\".sam\"))   return false;\n  try {\n    try (FileInputIterator it=new FileInputIterator(file.getPath())){\n      while (it.hasNext()) {\n        String aLine=it.next();\n        if (aLine.startsWith(\"@\")) {\n          if (aLine.contains(\"PN:MALT\") || (aLine.contains(\"PN:DIAMOND\")))           return true;\n        }\n else {\n          return false;\n        }\n      }\n    }\n   }\n catch (  IOException e) {\n  }\n  return false;\n}\n", "nl": "is the given file a MALT or Diamond -generated SAM file?"}
{"code": "public boolean giveDefaultIfNeeded(User user,boolean save){\n  boolean hasGroup=false;\n  if (user.getPrimaryGroup() != null && !user.getPrimaryGroup().isEmpty()) {\n    for (    Node node : user.getPermissions(false)) {\n      if (node.isGroupNode()) {\n        hasGroup=true;\n        break;\n      }\n    }\n  }\n  if (hasGroup) {\n    return false;\n  }\n  user.setPrimaryGroup(\"default\");\n  try {\n    user.setPermission(\"group.default\",true);\n  }\n catch (  ObjectAlreadyHasException ignored) {\n  }\n  if (save) {\n    plugin.getDatastore().saveUser(user,Callback.empty());\n  }\n  return true;\n}\n", "nl": "Set a user to the default group"}
{"code": "private ULong(String value) throws NumberFormatException {\n  if (value == null) {\n    throw new NumberFormatException(\"null\");\n  }\n  int length=value.length();\n  if (length == 0) {\n    throw new NumberFormatException(\"Empty input string\");\n  }\n  if (value.charAt(0) == '-') {\n    throw new NumberFormatException(String.format(\"Illegal leading minus sign on unsigned string %s\",value));\n  }\n  if (length <= 18) {\n    this.value=Long.parseLong(value,10);\n    return;\n  }\n  final long first=Long.parseLong(value.substring(0,length - 1),10);\n  final int second=Character.digit(value.charAt(length - 1),10);\n  if (second < 0) {\n    throw new NumberFormatException(\"Bad digit at end of \" + value);\n  }\n  long result=first * 10 + second;\n  if (compare(result,first) < 0) {\n    throw new NumberFormatException(String.format(\"String value %s exceeds range of unsigned long\",value));\n  }\n  this.value=result;\n}\n", "nl": "Create an <code>unsigned long</code>"}
{"code": "public void removeWidget(ConstraintWidget widget){\n  if (widget == null) {\n    return;\n  }\n  if (widget instanceof ConstraintWidgetContainer) {\n    ConstraintWidgetContainer container=(ConstraintWidgetContainer)widget;\n    ArrayList<ConstraintWidget> children=new ArrayList<>(container.getChildren());\n    for (    ConstraintWidget w : children) {\n      removeWidget(w);\n    }\n  }\n  for (  ConstraintWidget w : mWidgets.values()) {\n    w.disconnectWidget(widget);\n  }\n  WidgetContainer parent=(WidgetContainer)widget.getParent();\n  if (parent != null) {\n    parent.remove(widget);\n  }\n  mWidgets.remove(getTag(widget));\n  if (mRoot == widget) {\n    mRoot=null;\n  }\n}\n", "nl": "Remove a widget from the tree, breaking any connections to it"}
{"code": "@Override protected Boolean doInBackground(Void... params){\n  while (!mLocalPaths.isEmpty()) {\n    String currentPath=mLocalPaths.get(0);\n    File currentFile=new File(currentPath);\n    String expectedPath=FileStorageUtils.getSavePath(mAccount.name) + mRemotePaths.get(0);\n    File expectedFile=new File(expectedPath);\n    if (expectedFile.equals(currentFile) || currentFile.renameTo(expectedFile)) {\n      OCFile file=mStorageManager.getFileByPath(mRemotePaths.get(0));\n      file.setStoragePath(expectedPath);\n      mStorageManager.saveFile(file);\n      mRemotePaths.remove(0);\n      mLocalPaths.remove(0);\n    }\n else {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Performs the movement"}
{"code": "private Map<AccessPath,Set<AccessPath>> computeGlobalAliases(SootMethod method){\n  Map<AccessPath,Set<AccessPath>> res=new HashMap<AccessPath,Set<AccessPath>>();\n  for (  Unit u : method.getActiveBody().getUnits()) {\n    if (!(u instanceof AssignStmt))     continue;\n    final AssignStmt assign=(AssignStmt)u;\n    if (!(assign.getLeftOp() instanceof FieldRef && (assign.getRightOp() instanceof FieldRef || assign.getRightOp() instanceof Local)))     if (!(assign.getRightOp() instanceof FieldRef && (assign.getLeftOp() instanceof FieldRef || assign.getLeftOp() instanceof Local)))     continue;\n    final AccessPath apLeft=new AccessPath(assign.getLeftOp(),true);\n    final AccessPath apRight=new AccessPath(assign.getRightOp(),true);\n    Set<AccessPath> mapLeft=res.get(apLeft);\n    if (mapLeft == null) {\n      mapLeft=new HashSet<AccessPath>();\n      res.put(apLeft,mapLeft);\n    }\n    mapLeft.add(apRight);\n    Set<AccessPath> mapRight=res.get(apRight);\n    if (mapRight == null) {\n      mapRight=new HashSet<AccessPath>();\n      res.put(apRight,mapRight);\n    }\n    mapLeft.add(apLeft);\n  }\n  return res;\n}\n", "nl": "Computes the global non-flow-sensitive alias information for the given method"}
{"code": "public static ControlTagCacheObject createTestProcessAlive(){\n  ControlTagCacheObject cacheObject=new ControlTagCacheObject(new Long(510),\"Test process alive tag\",\"Long\",DataTagConstants.MODE_TEST);\n  cacheObject.setDescription(\"test alive description\");\n  cacheObject.setLogged(false);\n  cacheObject.setUnit(\"seconds since 1970\");\n  cacheObject.setDipAddress(\"testDIPaddress\");\n  cacheObject.setJapcAddress(\"testJAPCaddress\");\n  cacheObject.setValue(new Long(System.currentTimeMillis()));\n  cacheObject.setValueDescription(\"test value description\");\n  cacheObject.setSimulated(false);\n  cacheObject.setMinValue(Long.MIN_VALUE);\n  cacheObject.setMaxValue(Long.MAX_VALUE);\n  cacheObject.setValueDictionary(new DataTagValueDictionary());\n  cacheObject.setAddress(new DataTagAddress());\n  cacheObject.setDataTagQuality(createValidQuality());\n  cacheObject.setCacheTimestamp(new Timestamp(System.currentTimeMillis()));\n  cacheObject.setDaqTimestamp(new Timestamp(System.currentTimeMillis()));\n  cacheObject.setSourceTimestamp(new Timestamp(System.currentTimeMillis()));\n  return cacheObject;\n}\n", "nl": "Creates an AliveTimer for a Process"}
{"code": "public static boolean updateProjectToInstantRunTools(@NotNull Project project,@Nullable GradleSyncListener listener){\n  String pluginVersion=MINIMUM_GRADLE_PLUGIN_VERSION_STRING;\n  if (GradleVersion.parse(GRADLE_PLUGIN_RECOMMENDED_VERSION).compareTo(MINIMUM_GRADLE_PLUGIN_VERSION) > 0) {\n    pluginVersion=GRADLE_PLUGIN_RECOMMENDED_VERSION;\n  }\n  if (GradleUtil.updateGradlePluginVersion(project,pluginVersion,GRADLE_LATEST_VERSION)) {\n    String buildToolsVersion=\"23.0.2\";\n    AndroidSdkHandler sdk=AndroidSdkUtils.tryToChooseSdkHandler();\n    BuildToolInfo latestBuildTool=sdk.getLatestBuildTool(new StudioLoggerProgressIndicator(InstantRunConfigurable.class),false);\n    if (latestBuildTool != null) {\n      Revision revision=latestBuildTool.getRevision();\n      if (revision.compareTo(Revision.parseRevision(buildToolsVersion)) > 0) {\n        buildToolsVersion=revision.toShortString();\n      }\n    }\n    GradleUtil.setBuildToolsVersion(project,buildToolsVersion);\n    File wrapperPropertiesFile=GradleUtil.findWrapperPropertiesFile(project);\n    if (wrapperPropertiesFile != null) {\n      GradleUtil.updateGradleDistributionUrl(project,wrapperPropertiesFile,GRADLE_LATEST_VERSION);\n    }\n    GradleProjectImporter.getInstance().syncProjectSynchronously(project,true,listener);\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Update versions relevant for Instant Run, and trigger a Gradle sync if successful"}
{"code": "private List<DavaFlowSet<T>> copyDavaFlowSetList(List<DavaFlowSet<T>> currentList,List<DavaFlowSet<T>> temp){\n  Iterator<DavaFlowSet<T>> tempIt=temp.iterator();\n  while (tempIt.hasNext()) {\n    DavaFlowSet<T> check=tempIt.next();\n    Iterator<DavaFlowSet<T>> currentListIt=currentList.iterator();\n    boolean found=false;\n    while (currentListIt.hasNext()) {\n      DavaFlowSet<T> currentSet=currentListIt.next();\n      if (check.equals(currentSet) && check.internalDataMatchesTo(currentSet)) {\n        found=true;\n        break;\n      }\n    }\n    if (!found) {\n      currentList.add(check);\n    }\n  }\n  return currentList;\n}\n", "nl": "An internal method used to copy non-duplicate entries from the temp list into the currentList"}
{"code": "private LocusInfo createNextUncoveredLocusInfo(final Locus stopBeforeLocus){\n  while (lastReferenceSequence <= stopBeforeLocus.getSequenceIndex() && lastReferenceSequence <= referenceSequenceMask.getMaxSequenceIndex()) {\n    if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex() && lastPosition + 1 >= stopBeforeLocus.getPosition()) {\n      return null;\n    }\n    final int nextbit=referenceSequenceMask.nextPosition(lastReferenceSequence,lastPosition);\n    if (nextbit == -1) {\n      if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex()) {\n        lastPosition=stopBeforeLocus.getPosition();\n        return null;\n      }\n      lastReferenceSequence++;\n      lastPosition=0;\n    }\n else     if (lastReferenceSequence < stopBeforeLocus.getSequenceIndex() || nextbit < stopBeforeLocus.getPosition()) {\n      lastPosition=nextbit;\n      return new LocusInfo(getReferenceSequence(lastReferenceSequence),lastPosition);\n    }\n else     if (nextbit >= stopBeforeLocus.getPosition()) {\n      return null;\n    }\n  }\n  return null;\n}\n", "nl": "Create the next relevant zero-coverage LocusInfo"}
{"code": "private void initial(){\n  int dayOfWeek=calendar.get(Calendar.DAY_OF_WEEK);\n  int monthStart=-1;\n  if (dayOfWeek >= 2 && dayOfWeek <= 7) {\n    monthStart=dayOfWeek - 2;\n  }\n else   if (dayOfWeek == 1) {\n    monthStart=6;\n  }\n  curStartIndex=monthStart;\n  date[monthStart]=1;\n  int daysOfMonth=daysOfCurrentMonth();\n  for (int i=1; i < daysOfMonth; i++) {\n    date[monthStart + i]=i + 1;\n  }\n  curEndIndex=monthStart + daysOfMonth;\n  if (mode == Constant.MODE_SHOW_DATA_OF_THIS_MONTH) {\n    todayIndex=Calendar.getInstance().get(Calendar.DAY_OF_MONTH) + monthStart - 1;\n  }\n else   if (mode == Constant.MODE_CALENDAR) {\n    if (calendar.get(Calendar.YEAR) == Calendar.getInstance().get(Calendar.YEAR) && calendar.get(Calendar.MONTH) == Calendar.getInstance().get(Calendar.MONTH)) {\n      todayIndex=Calendar.getInstance().get(Calendar.DAY_OF_MONTH) + monthStart - 1;\n    }\n else {\n      todayIndex=-1;\n    }\n  }\n}\n", "nl": "calculate the values of date[] and the legal range of index of date[]"}
{"code": "private static double[] computeShannonWeaver(ClassificationViewer viewer,ProgressListener progressListener) throws IOException, CanceledException {\n  progressListener.setMaximum(2 * viewer.getSelectedNodes().size());\n  progressListener.setProgress(0);\n  int numberOfDatasets=viewer.getDocument().getNumberOfSamples();\n  double[] total=new double[numberOfDatasets];\n  for (  Node v : viewer.getSelectedNodes()) {\n    int[] summarized=viewer.getNodeData(v).getSummarized();\n    for (int i=0; i < summarized.length; i++)     total[i]+=summarized[i];\n    progressListener.incrementProgress();\n  }\n  double[] result=new double[numberOfDatasets];\n  for (int i=0; i < result.length; i++)   result[0]=0d;\n  for (  Node v : viewer.getSelectedNodes()) {\n    int[] summarized=viewer.getNodeData(v).getSummarized();\n    for (int i=0; i < summarized.length; i++) {\n      if (summarized[i] > 0) {\n        double p=summarized[i] / total[i];\n        result[i]+=p * Math.log(p) / LOG2;\n      }\n    }\n    progressListener.incrementProgress();\n  }\n  for (int i=0; i < result.length; i++)   result[i]=-result[i];\n  return result;\n}\n", "nl": "compute the Shannon-Weaver diversity index in bits"}
{"code": "synchronized boolean visit() throws IOException {\n  if (exc != null) {\n    return true;\n  }\n  if (current == null) {\n    if (iter.hasNext() == false) {\n      c.close();\n      return true;\n    }\n    Map.Entry<String,FileMetaData> next=iter.next();\n    FileMetaData metaData=next.getValue();\n    String fileName=next.getKey();\n    long len=c.in.readVLong();\n    if (len != metaData.length) {\n      throw new IllegalStateException(\"file \" + fileName + \": meta data says length=\"+ metaData.length+ \" but c.in says \"+ len);\n    }\n    current=new CopyOneFile(c.in,dest,fileName,metaData,copyBuffer);\n  }\n  if (current.visit()) {\n    copiedFiles.put(current.name,current.tmpName);\n    totBytesCopied+=current.getBytesCopied();\n    assert totBytesCopied <= totBytes : \"totBytesCopied=\" + totBytesCopied + \" totBytes=\"+ totBytes;\n    current=null;\n    return false;\n  }\n  return false;\n}\n", "nl": "Do an iota of work; returns true if all copying is done"}
{"code": "public static String escape(String url,String encoding,boolean escapeAll) throws UnsupportedEncodingException {\n  if (url == null)   return url;\n  Matcher protocolMatcher=protocolPattern.matcher(url);\n  StringBuilder sb=new StringBuilder();\n  if (protocolMatcher.find())   sb.append(protocolMatcher.group());\n  Matcher contentMatcher=contentPattern.matcher(url);\n  while (contentMatcher.find()) {\n    sb.append(\"/\");\n    String content=contentMatcher.group(1);\n    if (escapeAll) {\n      sb.append(java.net.URLEncoder.encode(content,encoding));\n    }\n else {\n      if (content.matches(\"((%[A-Z0-9][A-Z0-9])|[a-zA-Z0-9_*\\\\.\\\\+-\\\\?=])*\"))       sb.append(content);\n else {\n        for (        String part : split(content)) {\n          if (part.equals(\"?\") || part.equals(\"=\"))           sb.append(part);\n else           sb.append(java.net.URLEncoder.encode(part,encoding));\n        }\n      }\n    }\n  }\n  return sb.toString();\n}\n", "nl": "escaped an url"}
{"code": "public int expandAttribute(String attribute,boolean allowReplaceAttribute){\n  final Set<Object> values=new TreeSet<>();\n  values.addAll(getSamples2Values(attribute).values());\n  final ArrayList<String> newOrder=new ArrayList<>(getAttributeOrder().size() + values.size());\n  newOrder.addAll(getAttributeOrder());\n  int pos=newOrder.indexOf(attribute);\n  int count=0;\n  for (  Object value : values) {\n    final String attributeName=attribute + \":\" + value;\n    if (!getAttributeOrder().contains(attributeName)) {\n      Map<String,Object> samples2values=new HashMap<>();\n      for (      String sample : getSampleOrder()) {\n        samples2values.put(sample,get(sample,attribute).equals(value) ? 1 : 0);\n      }\n      boolean result=addAttribute(attributeName,samples2values,allowReplaceAttribute,false);\n      if (result) {\n        attribute2type.put(attributeName,Type.Integer);\n        count++;\n        newOrder.add(pos + count,attributeName);\n      }\n    }\n  }\n  setAttributeOrder(newOrder);\n  return count;\n}\n", "nl": "expands an existing attribute"}
{"code": "Collection<? extends ClientRequestResult> handleTagConfigurationRequest(final ClientRequest tagConfigurationRequest){\n  final Collection<TagConfig> transferTags=new ArrayList<TagConfig>(tagConfigurationRequest.getIds().size());\n  for (  Long tagId : tagConfigurationRequest.getIds()) {\n    if (tagLocationService.isInTagCache(tagId)) {\n      final TagWithAlarms tagWithAlarms=tagFacadeGateway.getTagWithAlarms(tagId);\n      HashSet<Process> tagProcesses=new HashSet<Process>();\n      for (      Long procId : tagWithAlarms.getTag().getProcessIds()) {\n        tagProcesses.add(processCache.get(procId));\n      }\nswitch (tagConfigurationRequest.getResultType()) {\ncase TRANSFER_TAG_CONFIGURATION_LIST:\n        transferTags.add(TransferObjectFactory.createTagConfiguration(tagWithAlarms,tagProcesses));\n      break;\ndefault :\n    LOG.error(\"handleConfigurationRequest() - Could not generate response message. Unknown enum ResultType \" + tagConfigurationRequest.getResultType());\n}\n}\n else {\nLOG.warn(\"handleConfigurationRequest() - Received client request (TagConfigRequest) for unrecognized Tag with id \" + tagId);\n}\n}\nif (LOG.isDebugEnabled()) {\nLOG.debug(\"handleConfigurationRequest() - Finished processing Tag request (with config info): returning \" + transferTags.size() + \" Tags\");\n}\nreturn transferTags;\n}\n", "nl": "Handles the Tag Configuration Requests"}
{"code": "public static String determineOriginalFile(Context context,Uri uri){\n  String originalFile=null;\n  if (uri != null) {\n    if (uri.getScheme().startsWith(\"content\")) {\n      originalFile=getPathFromUri(context,uri);\n    }\n    if (uri.toString().matches(\"https?://\\\\w+\\\\.googleusercontent\\\\.com/.+\")) {\n      originalFile=uri.toString();\n    }\n    if (uri.getScheme().startsWith(\"file\")) {\n      originalFile=uri.toString().substring(7);\n    }\n    if (isNullOrEmpty(originalFile)) {\n      throw new IllegalArgumentException(\"File path was null\");\n    }\n  }\n else {\n    throw new IllegalArgumentException(\"Image Uri was null!\");\n  }\n  return originalFile;\n}\n", "nl": "Retrieve local file path for an arbitrary Uri"}
{"code": "public byte[] generateKek(PrivateKey privateKey) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException {\n  PublicKey vlPublic=this.getValueLinkPublicKey();\n  KeyAgreement ka=KeyAgreement.getInstance(\"DH\");\n  ka.init(privateKey);\n  ka.doPhase(vlPublic,true);\n  byte[] secretKey=ka.generateSecret();\n  if (debug) {\n    Debug.logInfo(\"Secret Key : \" + StringUtil.toHexString(secretKey) + \" / \"+ secretKey.length,module);\n  }\n  MessageDigest md=MessageDigest.getInstance(\"SHA1\");\n  byte[] digest=md.digest(secretKey);\n  byte[] des2=getByteRange(digest,0,16);\n  byte[] first8=getByteRange(des2,0,8);\n  byte[] kek=copyBytes(des2,first8,0);\n  if (debug) {\n    Debug.logInfo(\"Generated KEK : \" + StringUtil.toHexString(kek) + \" / \"+ kek.length,module);\n  }\n  return kek;\n}\n", "nl": "Generate a key exchange key for use in encrypting the mwk"}
{"code": "protected FloatControl(Type type,float minimum,float maximum,float precision,int updatePeriod,float initialValue,String units,String minLabel,String midLabel,String maxLabel){\n  super(type);\n  if (minimum > maximum) {\n    throw new IllegalArgumentException(\"Minimum value \" + minimum + \" exceeds maximum value \"+ maximum+ \".\");\n  }\n  if (initialValue < minimum) {\n    throw new IllegalArgumentException(\"Initial value \" + initialValue + \" smaller than allowable minimum value \"+ minimum+ \".\");\n  }\n  if (initialValue > maximum) {\n    throw new IllegalArgumentException(\"Initial value \" + initialValue + \" exceeds allowable maximum value \"+ maximum+ \".\");\n  }\n  this.minimum=minimum;\n  this.maximum=maximum;\n  this.precision=precision;\n  this.updatePeriod=updatePeriod;\n  this.value=initialValue;\n  this.units=units;\n  this.minLabel=((minLabel == null) ? \"\" : minLabel);\n  this.midLabel=((midLabel == null) ? \"\" : midLabel);\n  this.maxLabel=((maxLabel == null) ? \"\" : maxLabel);\n}\n", "nl": "Constructs a new float control object with the given parameters"}
{"code": "public LongFileGetterInMemory(File file) throws IOException {\n  limit=file.length() / 8;\n  data=new long[(int)((limit >>> BITS)) + 1][];\n  final int length0=(1 << BITS);\n  for (int i=0; i < data.length; i++) {\n    int length=(i < data.length - 1 ? length0 : (int)(limit & BIT_MASK) + 1);\n    data[i]=new long[length];\n  }\n  try (BufferedInputStream ins=new BufferedInputStream(new FileInputStream(file));ProgressPercentage progress=new ProgressPercentage(\"Reading file: \" + file,limit)){\n    int whichArray=0;\n    int indexInArray=0;\n    for (long index=0; index < limit; index++) {\n      data[whichArray][indexInArray]=(((long)ins.read()) << 56) | (((long)ins.read()) << 48) | (((long)ins.read()) << 40)| (((long)ins.read()) << 32)| (((long)ins.read()) << 24)| (((long)ins.read() & 0xFF) << 16)| (((long)ins.read() & 0xFF) << 8)| (((long)ins.read() & 0xFF));\n      if (++indexInArray == length0) {\n        whichArray++;\n        indexInArray=0;\n      }\n      progress.setProgress(index);\n    }\n  }\n }\n", "nl": "long file getter in memory"}
{"code": "public Matrix solve(Matrix B){\n  if (B.getRowDimension() != n) {\n    throw new IllegalArgumentException(\"Matrix row dimensions must agree.\");\n  }\n  if (!isspd) {\n    throw new RuntimeException(\"Matrix is not symmetric positive definite.\");\n  }\n  double[][] X=B.getArrayCopy();\n  int nx=B.getColumnDimension();\n  for (int k=0; k < n; k++) {\n    for (int j=0; j < nx; j++) {\n      for (int i=0; i < k; i++) {\n        X[k][j]-=X[i][j] * L[k][i];\n      }\n      X[k][j]/=L[k][k];\n    }\n  }\n  for (int k=n - 1; k >= 0; k--) {\n    for (int j=0; j < nx; j++) {\n      for (int i=k + 1; i < n; i++) {\n        X[k][j]-=X[i][j] * L[i][k];\n      }\n      X[k][j]/=L[k][k];\n    }\n  }\n  return new Matrix(X,n,nx);\n}\n", "nl": "Solve A*X = B"}
{"code": "private void parseFunctionParameter(){\n  PsiBuilder.Marker marker=builder.mark();\n  if (matches(TokenKind.STAR_STAR)) {\n    expectIdentifier(\"invalid parameter name\");\n    marker.done(BuildElementTypes.PARAM_STAR_STAR);\n    return;\n  }\n  if (matches(TokenKind.STAR)) {\n    if (atToken(TokenKind.IDENTIFIER)) {\n      builder.advanceLexer();\n    }\n    marker.done(BuildElementTypes.PARAM_STAR);\n    return;\n  }\n  expectIdentifier(\"invalid parameter name\");\n  if (matches(TokenKind.EQUALS)) {\n    parseNonTupleExpression();\n    marker.done(BuildElementTypes.PARAM_OPTIONAL);\n    return;\n  }\n  marker.done(BuildElementTypes.PARAM_MANDATORY);\n}\n", "nl": "arg ::= IDENTIFIER ['=' nontupleexpr]"}
{"code": "public void decipher(byte[] data,int offset,int length){\n  int blocks=length >> 3;\n  int p;\n  for (int k=0; k < blocks; k++) {\n    p=offset + (k << 3);\n    int lb=byteArrayToInteger(data,p);\n    int rb=byteArrayToInteger(data,p + 4);\n    int tmp;\n    for (int i=17; i > 1; i--) {\n      lb=lb ^ pArray[i];\n      rb=F(lb) ^ rb;\n      tmp=lb;\n      lb=rb;\n      rb=tmp;\n    }\n    tmp=lb;\n    lb=rb;\n    rb=tmp;\n    rb^=pArray[1];\n    lb^=pArray[0];\n    integerToByteArray(lb,data,p);\n    integerToByteArray(rb,data,p + 4);\n  }\n}\n", "nl": "Decipher the given byte-array with Blowfish cipher"}
{"code": "@Override public void instantiate(@NotNull File from,@NotNull File to) throws TemplateProcessingException {\n  try {\n    boolean isDirectory=from.getName().indexOf('.') == -1;\n    if (isDirectory) {\n      copyTemplateResource(from,to);\n    }\n else {\n      File sourceFile=myContext.getLoader().getSourceFile(from);\n      File targetFile=getTargetFile(to);\n      String content=processFreemarkerTemplate(myContext,sourceFile,null);\n      if (targetFile.exists()) {\n        if (!compareTextFile(targetFile,content)) {\n          addFileAlreadyExistWarning(targetFile);\n        }\n      }\n else {\n        myIO.writeFile(this,content,targetFile);\n        myReferences.addSourceFile(sourceFile);\n        myReferences.addTargetFile(targetFile);\n      }\n    }\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Instantiates the given template file into the given output file (running the freemarker engine over it)"}
{"code": "public static PkgHeader recvHeader(InputStream in,byte expect_cmd,long expect_body_len) throws IOException {\n  PkgHeader header;\n  byte[] bs;\n  int bytes;\n  header=new PkgHeader();\n  bs=new byte[FDHT_PROTO_PKG_HEADER_SIZE];\n  if ((bytes=in.read(bs)) != bs.length) {\n    throw new IOException(\"recv package size \" + bytes + \" != \"+ bs.length);\n  }\n  header.cmd=bs[PROTO_HEADER_CMD_INDEX];\n  if (header.cmd != expect_cmd) {\n    throw new IOException(\"recv cmd: \" + bs[PROTO_HEADER_CMD_INDEX] + \" is not correct, expect cmd: \"+ expect_cmd);\n  }\n  header.status=bs[PROTO_HEADER_STATUS_INDEX];\n  header.body_len=ProtoCommon.buff2int(bs,PROTO_HEADER_BODY_LEN_INDEX);\n  if (header.body_len < 0) {\n    throw new IOException(\"recv body length: \" + header.body_len + \" < 0!\");\n  }\n  if (header.status == 0) {\n    if (expect_body_len >= 0 && header.body_len != expect_body_len) {\n      throw new IOException(\"recv body length: \" + header.body_len + \" is not correct, expect length: \"+ expect_body_len);\n    }\n    header.timestamp=ProtoCommon.buff2int(bs,PROTO_HEADER_TIMESTAMP_INDEX);\n    header.expires=ProtoCommon.buff2int(bs,PROTO_HEADER_EXPIRES_INDEX);\n  }\n  return header;\n}\n", "nl": "receive pack header"}
{"code": "public List<String> updateDeletionStatus(String loadDate,LoadMetadataDetails[] listOfLoadFolderDetailsArray,List<String> invalidLoadTimestamps,Long loadStartTime){\n  boolean loadFound=false;\n  String loadStartTimeString=\"Load Start Time: \";\n  for (  LoadMetadataDetails loadMetadata : listOfLoadFolderDetailsArray) {\n    Integer result=compareDateValues(loadMetadata.getLoadStartTimeAsLong(),loadStartTime);\n    if (result < 0) {\n      if (CarbonCommonConstants.SEGMENT_COMPACTED.equalsIgnoreCase(loadMetadata.getLoadStatus())) {\n        LOG.info(\"Ignoring the segment : \" + loadMetadata.getLoadName() + \"as the segment has been compacted.\");\n        continue;\n      }\n      if (!CarbonCommonConstants.MARKED_FOR_DELETE.equals(loadMetadata.getLoadStatus())) {\n        loadFound=true;\n        loadMetadata.setLoadStatus(CarbonCommonConstants.MARKED_FOR_DELETE);\n        loadMetadata.setModificationOrdeletionTimesStamp(readCurrentTime());\n        LOG.info(\"Info: \" + loadStartTimeString + loadMetadata.getLoadStartTime()+ \" Marked for Delete\");\n      }\n    }\n  }\n  if (!loadFound) {\n    invalidLoadTimestamps.add(loadDate);\n    LOG.audit(\"Delete segment by date is failed. No matching segment found.\");\n    return invalidLoadTimestamps;\n  }\n  return invalidLoadTimestamps;\n}\n", "nl": "updates deletion status details for load and returns invalidLoadTimestamps"}
{"code": "public static boolean isUpgradeble(Item item){\n  if (item.getItemTemplate().isNoEnchant()) {\n    return false;\n  }\n  if (item.getItemTemplate().isWeapon()) {\n    return true;\n  }\n  if (item.getItemTemplate().getCategory() == ItemCategory.STIGMA) {\n    return false;\n  }\n  if (item.getEnchantLevel() == 15) {\n    return false;\n  }\n  if (item.getItemTemplate().isArmor()) {\n    int at=item.getItemTemplate().getItemSlot();\n    if (at == 1 || at == 2 || at == 8 || at == 16 || at == 32 || at == 2048 || at == 4096 || at == 131072 || at == 262144) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Verify if the item is enchantble and/or socketble"}
{"code": "@Override public void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.expanded_map_activity);\n  permissionCheck();\n  mapView=(MapView)findViewById(R.id.expanded_map);\n  mapView.onCreate(savedInstanceState);\n  mapView.getMapAsync(OpenMapActivity.this);\n  if (savedInstanceState == null) {\n    Bundle extras=getIntent().getExtras();\n    id_filial=extras.getInt(ID_FILIAL);\n    latitude=extras.getFloat(LATITUDE);\n    longitude=extras.getFloat(LONGITUDE);\n    logoPath=extras.getString(LOGO);\n    unidade=extras.getString(UNIDADE);\n    nome_fantasia=extras.getString(NOME_FANTASIA);\n    telefone=extras.getString(TELEFONE);\n    endereco=extras.getString(ENDERECO);\n    cep=extras.getString(CEP);\n  }\n  setTitle(\"Voltar\");\n  init();\n}\n", "nl": "Fragment LifeCycle Methods"}
{"code": "public void relocateDoping(Player player,int targetSlot,int destinationSlot){\n  Pet pet=player.getPet();\n  if (pet == null || pet.getCommonData().getDopingBag() == null) {\n    return;\n  }\n  int[] scrollBag=pet.getCommonData().getDopingBag().getScrollsUsed();\n  int targetItem=scrollBag[targetSlot - 2];\n  if (destinationSlot - 2 > scrollBag.length - 1) {\n    pet.getCommonData().getDopingBag().setItem(targetItem,destinationSlot);\n    PacketSendUtility.sendPacket(player,new SM_PET(0,targetItem,destinationSlot));\n    pet.getCommonData().getDopingBag().setItem(0,targetSlot);\n    PacketSendUtility.sendPacket(player,new SM_PET(0,0,targetSlot));\n  }\n else {\n    pet.getCommonData().getDopingBag().setItem(scrollBag[destinationSlot - 2],targetSlot);\n    PacketSendUtility.sendPacket(player,new SM_PET(0,scrollBag[destinationSlot - 2],targetSlot));\n    pet.getCommonData().getDopingBag().setItem(targetItem,destinationSlot);\n    PacketSendUtility.sendPacket(player,new SM_PET(0,targetItem,destinationSlot));\n  }\n}\n", "nl": "Currently only scrolls are can be relocated"}
{"code": "private boolean resizeAndSaveImage(int maxWidth,int maxHeight) throws IOException {\n  boolean saved=false;\n  String encodeURL=DiskCacheUtils.encodeURL(uri,maxWidth,maxHeight);\n  File targetFile=configuration.diskCache.get(uri);\n  if (targetFile != null && targetFile.exists()) {\n    ImageSize targetImageSize=new ImageSize(maxWidth,maxHeight);\n    DisplayImageOptions specialOptions=new DisplayImageOptions.Builder().cloneFrom(options).imageScaleType(ImageScaleType.IN_SAMPLE_INT).build();\n    ImageDecodingInfo decodingInfo=new ImageDecodingInfo(memoryCacheKey,Scheme.FILE.wrap(targetFile.getAbsolutePath()),Scheme.FILE.wrap(targetFile.getAbsolutePath()),targetImageSize,ViewScaleType.FIT_INSIDE,getDownloader(),specialOptions);\n    Bitmap bmp=decoder.decode(decodingInfo);\n    if (bmp != null && configuration.processorForDiskCache != null) {\n      L.d(LOG_PROCESS_IMAGE_BEFORE_CACHE_ON_DISK,memoryCacheKey);\n      bmp=configuration.processorForDiskCache.process(bmp);\n      if (bmp == null) {\n        L.e(ERROR_PROCESSOR_FOR_DISK_CACHE_NULL,memoryCacheKey);\n      }\n    }\n    if (bmp != null) {\n      saved=configuration.diskCache.save(encodeURL,bmp);\n      bmp.recycle();\n    }\n    if (saved) {\n      targetFile.delete();\n    }\n  }\n  return saved;\n}\n", "nl": "Decodes image file into Bitmap, resize it and save it back"}
{"code": "public static boolean hasPermission(Security security,GenericValue userLogin,GenericValue orderHeader){\n  if (userLogin == null || orderHeader == null)   return false;\n  if (security.hasEntityPermission(\"ORDERMGR\",\"_VIEW\",userLogin)) {\n    return true;\n  }\n else   if (security.hasEntityPermission(\"ORDERMGR\",\"_ROLEVIEW\",userLogin)) {\n    List<GenericValue> orderRoles=null;\n    try {\n      orderRoles=orderHeader.getRelated(\"OrderRole\",UtilMisc.toMap(\"partyId\",userLogin.getString(\"partyId\")),null,false);\n    }\n catch (    GenericEntityException e) {\n      Debug.logError(e,\"Cannot get OrderRole from OrderHeader\",module);\n    }\n    if (UtilValidate.isNotEmpty(orderRoles)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks to see if this user has read permission on the specified order"}
{"code": "public boolean isSubsetOf(XSWildcardDecl superWildcard){\n  if (superWildcard == null)   return false;\n  if (superWildcard.fType == NSCONSTRAINT_ANY) {\n    return true;\n  }\n  if (fType == NSCONSTRAINT_NOT) {\n    if (superWildcard.fType == NSCONSTRAINT_NOT && fNamespaceList[0] == superWildcard.fNamespaceList[0]) {\n      return true;\n    }\n  }\n  if (fType == NSCONSTRAINT_LIST) {\n    if (superWildcard.fType == NSCONSTRAINT_LIST && subset2sets(fNamespaceList,superWildcard.fNamespaceList)) {\n      return true;\n    }\n    if (superWildcard.fType == NSCONSTRAINT_NOT && !elementInSet(superWildcard.fNamespaceList[0],fNamespaceList) && !elementInSet(ABSENT,fNamespaceList)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Schema Component Constraint: Wildcard Subset"}
{"code": "public static AudioInputStream downSampling(AudioInputStream ais,int targetSamplingRate) throws Exception {\n  float currentSamplingRate=ais.getFormat().getSampleRate();\n  if (targetSamplingRate >= currentSamplingRate) {\n    throw new Exception(\"Requested sampling rate \" + targetSamplingRate + \" is greater than or equal to Audio sampling rate \"+ currentSamplingRate);\n  }\n  int noOfbitsPerSample=ais.getFormat().getSampleSizeInBits();\n  int channels=ais.getFormat().getChannels();\n  int nBytes=ais.available();\n  boolean bigEndian=ais.getFormat().isBigEndian();\n  double[] samples=new AudioDoubleDataSource(ais).getAllData();\n  double filterCutof=0.5 * targetSamplingRate / currentSamplingRate;\n  LowPassFilter filter=new LowPassFilter(filterCutof);\n  samples=filter.apply(samples);\n  double duration=(double)samples.length / currentSamplingRate;\n  int newSampleLen=(int)Math.floor(duration * targetSamplingRate);\n  double fraction=(double)currentSamplingRate / targetSamplingRate;\n  double[] newSignal=new double[newSampleLen];\n  for (int i=0; i < newSignal.length; i++) {\n    double posIdx=fraction * i;\n    int nVal=(int)Math.floor(posIdx);\n    double diffVal=posIdx - nVal;\n    newSignal[i]=(diffVal * samples[nVal + 1]) + ((1 - diffVal) * samples[nVal]);\n  }\n  boolean signed=true;\n  AudioFormat af=new AudioFormat(targetSamplingRate,noOfbitsPerSample,channels,signed,bigEndian);\n  DDSAudioInputStream oais=new DDSAudioInputStream(new BufferedDoubleDataSource(newSignal),af);\n  return oais;\n}\n", "nl": "DownSampling given Audio Input Stream"}
{"code": "public BaseResponseContext dispatchRequest(JsonPath jsonPath,String requestType,Map<String,Set<String>> parameters,RepositoryMethodParameterProvider parameterProvider,@SuppressWarnings(\"SameParameterValue\") RequestBody requestBody){\n  try {\n    BaseController controller=controllerRegistry.getController(jsonPath,requestType);\n    Class<?> resourceClass=getRequestedResource(jsonPath);\n    QueryAdapter queryAdapter=queryAdapterBuilder.build(resourceClass,parameters);\n    DefaultFilterRequestContext context=new DefaultFilterRequestContext(jsonPath,queryAdapter,parameterProvider,requestBody);\n    DefaultFilterChain chain=new DefaultFilterChain(controller);\n    return chain.doFilter(context);\n  }\n catch (  Exception e) {\n    Optional<JsonApiExceptionMapper> exceptionMapper=exceptionMapperRegistry.findMapperFor(e.getClass());\n    if (exceptionMapper.isPresent()) {\n      return exceptionMapper.get().toErrorResponse(e);\n    }\n else {\n      logger.error(\"failed to process request\",e);\n      throw e;\n    }\n  }\n}\n", "nl": "Dispatch the request from a client"}
{"code": "private void buildVmatchEdges(){\n  for (Iterator iter=pag.loadSourcesIterator(); iter.hasNext(); ) {\n    final FieldRefNode frn1=(FieldRefNode)iter.next();\n    for (Iterator iter2=pag.storeInvSourcesIterator(); iter2.hasNext(); ) {\n      final FieldRefNode frn2=(FieldRefNode)iter2.next();\n      VarNode base1=frn1.getBase();\n      VarNode base2=frn2.getBase();\n      if (frn1.getField().equals(frn2.getField())) {\n        if (base1.getP2Set().hasNonEmptyIntersection(base2.getP2Set())) {\n          Node[] src=pag.loadLookup(frn1);\n          Node[] dst=pag.storeInvLookup(frn2);\n          for (int i=0; i < src.length; i++) {\n            vmatches.put(src[i],dst);\n          }\n          for (int i=0; i < dst.length; i++) {\n            invVmatches.put(dst[i],src);\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "Build vmatchEdges and store them in vmatches field"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  final AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  final Alignment alignment=viewer.getAlignment();\n  final Document doc=((Director)getDir()).getDocument();\n  viewer.getSelectedBlock().clear();\n  String reference=viewer.getSelectedReference();\n  if (reference != null) {\n    final int posDoubleColon=reference.lastIndexOf(\"::\");\n    if (posDoubleColon > 0 && Basic.isInteger(reference.substring(posDoubleColon + 2)))     reference=reference.substring(0,posDoubleColon);\n    if (reference.length() > 0) {\n      doc.getProgressListener().setTasks(\"Alignment viewer\",\"Calculating alignment\");\n      viewer.getBlast2Alignment().makeAlignment(reference,alignment,viewer.isShowInsertions(),doc.getProgressListener());\n      viewer.setShowAminoAcids(alignment.getSequenceType().equals(Alignment.PROTEIN));\n      doc.getProgressListener().setTasks(\"Alignment viewer\",\"Drawing alignment\");\n      doc.getProgressListener().setMaximum(100);\n      doc.getProgressListener().setProgress(-1);\n      viewer.setAlignment(alignment,true);\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "protected void addJob(BundleContext context,Class<? extends Job> clazz,String cronExpression){\n  String jobName=clazz.getName();\n  String jobGroup=FrameworkUtil.getBundle(clazz).getSymbolicName();\n  JobDetail job=new JobDetail(jobName,jobGroup,clazz);\n  job.setDurability(false);\n  job.setVolatility(true);\n  job.setDescription(jobName);\n  try {\n    CronTrigger trigger=new CronTrigger(jobName,jobGroup,cronExpression);\n    if (scheduler == null) {\n      if (schedulerProperties == null) {\n        schedulerProperties=getDefaultSchedulerProperties();\n      }\n      scheduler=new StdSchedulerFactory(schedulerProperties).getScheduler();\n      scheduler.start();\n    }\n    Date date=scheduler.scheduleJob(job,trigger);\n    Logger.info(this,\"Scheduled job \" + jobName + \", next trigger is on \"+ date);\n  }\n catch (  ParseException e) {\n    Logger.error(this,\"Cron expression '\" + cronExpression + \"' has an exception. Throwing IllegalArgumentException\",e);\n    throw new IllegalArgumentException(e);\n  }\ncatch (  SchedulerException e) {\n    Logger.error(this,\"Unable to schedule job \" + jobName,e);\n  }\n}\n", "nl": "Adds a Job, and starts a Scheduler when none was yet started"}
{"code": "private void loadState(){\n  try {\n    IPath pluginStateLocation=SVNProviderPlugin.getPlugin().getStateLocation().append(REPOSITORIES_STATE_FILE);\n    File file=pluginStateLocation.toFile();\n    if (file.exists()) {\n      try {\n        DataInputStream dis=new DataInputStream(new FileInputStream(file));\n        readState(dis);\n        dis.close();\n      }\n catch (      IOException e) {\n        throw new TeamException(new Status(Status.ERROR,SVNProviderPlugin.ID,TeamException.UNABLE,Policy.bind(\"SVNProvider.ioException\"),e));\n      }\n    }\n  }\n catch (  TeamException e) {\n    Util.logError(Policy.bind(\"SVNProvider.errorLoading\"),e);\n  }\n}\n", "nl": "load the state of the plugin, ie the repositories locations"}
{"code": "private void spawnShieldControlRoomTeleporter(){\n  sendMsg(1402202);\n  deleteNpc(702010);\n  deleteNpc(702011);\n  deleteNpc(702012);\n  deleteNpc(702013);\n  spawn(730886,255.47392f,293.56177f,321.18497f,(byte)89);\n  spawn(730886,255.55742f,216.03549f,321.21344f,(byte)30);\n  spawn(730886,294.20718f,254.60352f,295.7729f,(byte)60);\n  spawn(730886,216.97739f,254.4616f,295.77353f,(byte)0);\n  GENTask.cancel(true);\n  CNT1Task.cancel(true);\n  CNT2Task.cancel(true);\n  CNT3Task.cancel(true);\n  CNT4Task.cancel(true);\n  CNT5Task.cancel(true);\n  CNT6Task.cancel(true);\n  CNT7Task.cancel(true);\n  SP1Task.cancel(true);\n  SP2Task.cancel(true);\n  SP3Task.cancel(true);\n  SP4Task.cancel(true);\n  isEnd=true;\n}\n", "nl": "* Shield Control Room Teleporter  *"}
{"code": "static String printTextPerRole(String[] roles,String[] textLines){\n  StringBuilder[] textByRoles=new StringBuilder[roles.length];\n  for (int i=0; i < roles.length; i++) {\n    textByRoles[i]=new StringBuilder(roles[i] + \":\");\n  }\n  for (int i=0; i < textLines.length; i++) {\n    String[] splitLine=textLines[i].split(\": \",2);\n    String role=splitLine[0];\n    String text=splitLine[1];\n    int j=0;\n    while (!roles[j].equals(role)) {\n      j++;\n    }\n    textByRoles[j].append(\"\\n\" + (i + 1) + \") \"+ text);\n  }\n  String result=\"\";\n  for (  StringBuilder line : textByRoles) {\n    result+=line + \"\\n\\n\";\n  }\n  return result;\n}\n", "nl": "Group the text of the play script by roles"}
{"code": "public void visitPhpFunctionCall(FunctionReference reference){\n  if (!this.isPropelDefined()) {\n    return;\n  }\n  final String strName=reference.getName();\n  final PsiElement[] arrParameters=reference.getParameters();\n  if (arrParameters.length != 1 || StringUtil.isEmpty(strName) || !strName.equals(\"count\")) {\n    return;\n  }\n  PsiElement objParameter=ExpressionSemanticUtil.getExpressionTroughParenthesis(arrParameters[0]);\n  if (null == objParameter) {\n    return;\n  }\n  if (objParameter instanceof MethodReference) {\n    this.inspectSignature(((MethodReference)objParameter).getSignature(),objParameter,\".count\");\n  }\n  if (objParameter instanceof Variable) {\n    this.inspectSignature(((Variable)objParameter).getSignature(),objParameter,\".count\");\n  }\n}\n", "nl": "Entry point: functions calls"}
{"code": "public void unexport(boolean force){\n  if (m_thisRemoteRef != null)   try {\n    if (force)     m_exporter.unexport(true);\n else {\n      long endTime=SystemTime.timeMillis() + MAX_UNEXPORT_DELAY;\n      boolean unexported=false;\n      while (!unexported && (SystemTime.timeMillis() < endTime)) {\n        unexported=m_exporter.unexport(false);\n        if (!unexported)         Thread.yield();\n      }\n      if (!unexported)       m_exporter.unexport(true);\n    }\n  }\n catch (  Exception ex) {\n    if (_logger.isLoggable(Level.SEVERE)) {\n      _logger.log(Level.SEVERE,ex.getMessage(),ex);\n    }\n  }\n}\n", "nl": "Unexport the ServiceAdmin"}
{"code": "private void onFriendsSelected(int resultCode,Intent data){\n  if (resultCode == GamesActivityResultCodes.RESULT_RECONNECT_REQUIRED) {\n    activity.getGameServicesHelper().onSignedOutFromOutside();\n    if (future != null) {\n      Gdx.app.postRunnable(future);\n      future=null;\n    }\n    return;\n  }\n  if (resultCode != Activity.RESULT_OK) {\n    if (future != null) {\n      Gdx.app.postRunnable(future);\n      future=null;\n    }\n    return;\n  }\n  if (controller != null) {\n    throw new IllegalStateException(\"tried to create new game, but there was already another!\");\n  }\n  final ArrayList<String> invitees=data.getStringArrayListExtra(Games.EXTRA_PLAYER_IDS);\n  controller=createController();\n  Games.RealTimeMultiplayer.create(client,RoomConfig.builder(controller).addPlayersToInvite(invitees).setRoomStatusUpdateListener(controller).setMessageReceivedListener(controller).setVariant(variant).build());\n}\n", "nl": "on main thread"}
{"code": "protected void writeGraphicCtrlExt() throws IOException {\n  out.write(0x21);\n  out.write(0xf9);\n  out.write(4);\n  int transp, disp;\n  if (transparent == null) {\n    transp=0;\n    disp=0;\n  }\n else {\n    transp=1;\n    disp=2;\n  }\n  if (dispose >= 0) {\n    disp=dispose & 7;\n  }\n  disp<<=2;\n  out.write(0 | disp | 0| transp);\n  writeShort(delay);\n  out.write(transIndex);\n  out.write(0);\n}\n", "nl": "Writes Graphic Control Extension"}
{"code": "private static void decodeHanziSegment(BitSource bits,StringBuilder result,int count) throws FormatException {\n  if (count * 13 > bits.available()) {\n    throw FormatException.getFormatInstance();\n  }\n  byte[] buffer=new byte[2 * count];\n  int offset=0;\n  while (count > 0) {\n    int twoBytes=bits.readBits(13);\n    int assembledTwoBytes=((twoBytes / 0x060) << 8) | (twoBytes % 0x060);\n    if (assembledTwoBytes < 0x003BF) {\n      assembledTwoBytes+=0x0A1A1;\n    }\n else {\n      assembledTwoBytes+=0x0A6A1;\n    }\n    buffer[offset]=(byte)((assembledTwoBytes >> 8) & 0xFF);\n    buffer[offset + 1]=(byte)(assembledTwoBytes & 0xFF);\n    offset+=2;\n    count--;\n  }\n  try {\n    result.append(new String(buffer,StringUtils.GB2312));\n  }\n catch (  UnsupportedEncodingException ignored) {\n    throw FormatException.getFormatInstance();\n  }\n}\n", "nl": "See specification GBT 18284-2000"}
{"code": "private int checkSpace(boolean writeCheck){\n  int s;\n  if (writeCheck) {\n    if (wp > rp) {\n      s=rp - wp + size - 1;\n    }\n else     if (wp < rp) {\n      s=rp - wp - 1;\n    }\n else     s=size - 1;\n  }\n else {\n    if (wp > rp) {\n      s=wp - rp;\n    }\n else     if (wp < rp) {\n      s=wp - rp + size;\n    }\n else {\n      s=0;\n    }\n  }\n  return s;\n}\n", "nl": "Check number of bytes left"}
{"code": "public void notifyDestroyViewer() throws CanceledException {\nsynchronized (directorListeners) {\n    while (directorListeners.size() > 0) {\n      IDirectorListener directorListener=directorListeners.get(0);\n      if (directorListener != this)       directorListener.destroyView();\n      if (directorListeners.size() > 0 && directorListeners.get(0) == directorListener)       directorListeners.remove(0);\n    }\n  }\n  while (viewers.size() > 0) {\n    removeViewer(viewers.get(0));\n  }\n  if (projectsChangedListener != null)   ProjectManager.removeProjectsChangedListener(projectsChangedListener);\n  if (future != null && !future.isDone()) {\n    try {\n      future.cancel(true);\n    }\n catch (    Exception ex) {\n    }\n    future=null;\n  }\n}\n", "nl": "notify all director event listeners to destroy themselves"}
{"code": "private boolean moveToAsyncIfNeeded(Throwable error){\nsynchronized (_operatingModeLock) {\n    if (_syncState && !isClosed()) {\n      int sampleTPBefore=getSampleTPBefore(10,TimeUnit.SECONDS);\n      IMarker currentMarker=getGroupBacklog().getCurrentMarker(getMemberName());\n      String msg=\"moving to async state (measured TP before state change \" + sampleTPBefore + \") minimal async completion marked position \"+ currentMarker;\n      logEventInHistory(msg);\n      if (_specificLogger.isLoggable(Level.FINE))       _specificLogger.fine(msg);\n      _throttleController.suggestThroughPut(sampleTPBefore);\n      _asyncMinimalCompletionMarker=currentMarker;\n      _unresolvedError=error;\n      _beginOfSyncStateMarker=null;\n      _syncState=false;\n      if (error != null) {\n        msg=\"channel changed to asynchronous mode until it will resolve the error [\" + error.getMessage() + \"]\";\n        logEventInHistory(msg);\n        if (_specificLogger.isLoggable(Level.INFO))         _specificLogger.info(msg);\n      }\n    }\n    return !_syncState;\n  }\n}\n", "nl": "This is synchronized in order to avoid concurrent reconnection state"}
{"code": "public void write(IOutputWriter writer) throws IOException {\n  writer.writeLong(numberOfReads);\n  writer.writeLong(numberOfMatches);\n  writer.writeInt(availableClassification2Position.size());\n  for (  String classificationName : availableClassification2Position.keySet()) {\n    writer.writeString(classificationName);\n    writer.writeLong(availableClassification2Position.get(classificationName));\n  }\n  writer.writeLong(startHeaderSection);\n  writer.writeLong(endHeaderSection);\n  writer.writeLong(startReadsSection);\n  writer.writeLong(endReadsSection);\n  writer.writeLong(startClassificationsSection);\n  writer.writeLong(endClassificationsSection);\n  writer.writeLong(startAuxDataSection);\n  writer.writeLong(endAuxDataSection);\n  writer.writeLong(startFooterSection);\n  endFooterSection=writer.length() + 8;\n  writer.writeLong(endFooterSection);\n}\n", "nl": "write the footer"}
{"code": "public static boolean guessTabSeparator(File file){\n  BufferedReader r=null;\n  try {\n    r=new BufferedReader(new FileReader(file));\n    String aLine=r.readLine();\n    while (aLine != null && (aLine.trim().length() == 0 || aLine.trim().startsWith(\"#\")))     aLine=r.readLine().trim();\n    if (aLine != null)     return aLine.contains(\"\\t\");\n  }\n catch (  Exception ex) {\n  }\n finally {\n    if (r != null)     try {\n      r.close();\n    }\n catch (    IOException e) {\n    }\n  }\n  return false;\n}\n", "nl": "guess whether the given file uses tab as the separator"}
{"code": "@Override public void actionPerformed(ActionEvent event){\n  ImportBlastDialog importBlastDialog=(ImportBlastDialog)getParent();\n  File lastOpenFile=ProgramProperties.getFile(MeganProperties.READSFILE);\n  if (lastOpenFile != null) {\n    lastOpenFile=new File(lastOpenFile.getParentFile(),Basic.replaceFileSuffix(lastOpenFile.getName(),\".fna\"));\n  }\n  final FastaFileFilter fastAFileFilter=new FastaFileFilter();\n  fastAFileFilter.add(\"fastq\");\n  fastAFileFilter.add(\"fnq\");\n  fastAFileFilter.add(\"faq\");\n  fastAFileFilter.setAllowGZipped(true);\n  fastAFileFilter.setAllowZipped(true);\n  List<File> files=ChooseFileDialog.chooseFilesToOpen(importBlastDialog,lastOpenFile,fastAFileFilter,fastAFileFilter,event,\"Open reads file(s)\");\n  if (files != null && files.size() > 0) {\n    ProgramProperties.put(MeganProperties.READSFILE,files.get(0).getPath());\n    try {\n      for (      File file : files) {\n        if (!file.exists())         throw new IOException(\"No such file: \" + file);\n        if (!file.canRead())         throw new IOException(\"Cannot read file: \" + file);\n      }\n      importBlastDialog.setReadFileName(Basic.toString(files,\"\\n\"));\n      importBlastDialog.getReadFileNameField().setText(Basic.toString(files,\"\\n\"));\n    }\n catch (    IOException ex) {\n      NotificationsInSwing.showError(getViewer().getFrame(),\"Failed to load file: \" + ex.getMessage());\n    }\n  }\n}\n", "nl": "action to be performed"}
{"code": "private void inflateConnectivity(){\n  if (isConnected) {\n    if (connectivityView.getVisibility() == VISIBLE) {\n      if (!isConnectivityLayoutOverridden()) {\n        showConnected();\n      }\n else {\n        showCustomConnected();\n      }\n    }\n  }\n else {\n    if (!isConnectivityLayoutOverridden()) {\n      showDisconnected();\n    }\n else {\n      showCustomDisonnected();\n    }\n  }\n}\n", "nl": "check connectivity and inflate connectivity view accordingly"}
{"code": "static float distance(Rectangle a,Rectangle b){\n  float ax1, ax2, ay1, ay2;\n  float bx1, bx2, by1, by2;\n  ax1=a.x;\n  ax2=a.x + a.width;\n  ay1=a.y;\n  ay2=a.y + a.height;\n  bx1=b.x;\n  bx2=b.x + b.width;\n  by1=b.y;\n  by2=b.y + b.height;\n  float xdiff11=Math.abs(ax1 - bx1);\n  float xdiff12=Math.abs(ax1 - bx2);\n  float xdiff21=Math.abs(ax2 - bx1);\n  float xdiff22=Math.abs(ax2 - bx2);\n  float ydiff11=Math.abs(ay1 - by1);\n  float ydiff12=Math.abs(ay1 - by2);\n  float ydiff21=Math.abs(ay2 - by1);\n  float ydiff22=Math.abs(ay2 - by2);\n  float xmin=Math.min(Math.min(xdiff11,xdiff12),Math.min(xdiff21,xdiff22));\n  float ymin=Math.min(Math.min(ydiff11,ydiff12),Math.min(ydiff21,ydiff22));\n  boolean yOverlap=ay1 <= by2 && by1 <= ay2;\n  boolean xOverlap=ax1 <= bx2 && bx1 <= ax2;\n  float xReturn=(yOverlap) ? xmin : (float)Math.hypot(xmin,ymin);\n  float yReturn=(xOverlap) ? ymin : (float)Math.hypot(xmin,ymin);\n  return Math.min(xReturn,yReturn);\n}\n", "nl": "calculates the distance between two widgets (assumed to be rectangles)"}
{"code": "public static boolean IsMaltOrDiamondSAMFile(File file){\n  String suffix=Basic.getFileSuffix(Basic.getFileNameWithoutZipOrGZipSuffix(file.getName()));\n  if (suffix == null)   return false;\n  if (!suffix.toLowerCase().equals(\".sam\"))   return false;\n  try {\n    try (FileInputIterator it=new FileInputIterator(file.getPath())){\n      while (it.hasNext()) {\n        String aLine=it.next();\n        if (aLine.startsWith(\"@\")) {\n          if (aLine.contains(\"PN:MALT\") || (aLine.contains(\"PN:DIAMOND\")))           return true;\n        }\n else {\n          return false;\n        }\n      }\n    }\n   }\n catch (  IOException e) {\n  }\n  return false;\n}\n", "nl": "is the given file a MALT or Diamond -generated SAM file?"}
{"code": "public SampleAttributeTable mergeSamples(Collection<String> samples,String newName){\n  SampleAttributeTable sampleAttributeTable=new SampleAttributeTable();\n  Map<String,Object> attribute2value=new HashMap<>();\n  for (  String attribute : getAttributeSet()) {\n    boolean valueMismatch=false;\n    Object previousValue=null;\n    for (    String sample : samples) {\n      Object value=table.get(sample,attribute);\n      if (value != null) {\n        if (previousValue == null)         previousValue=value;\n else         if (!value.equals(previousValue)) {\n          valueMismatch=true;\n          break;\n        }\n      }\n    }\n    if (!valueMismatch && previousValue != null) {\n      attribute2value.put(attribute,previousValue);\n    }\n  }\n  sampleAttributeTable.addSample(newName,attribute2value,true,true);\n  return sampleAttributeTable;\n}\n", "nl": "merges a set of samples and produces a new sample"}
{"code": "private void initArrays(){\n  int keyIndex=0;\n  for (int i=0; i < 18; i++) {\n    int data=0;\n    for (int j=0; j < 4; j++) {\n      data=(data << 8) | (blowfishKey[keyIndex++] & 0xFF);\n      if (keyIndex >= blowfishKey.length) {\n        keyIndex=0;\n      }\n    }\n    pArray[i]=PARRAY_INIT[i] ^ data;\n  }\n  byte[] b=new byte[8];\n  for (int i=0; i < 18; i+=2) {\n    cipher(b);\n    pArray[i]=byteArrayToInteger(b,0);\n    pArray[i + 1]=byteArrayToInteger(b,4);\n  }\n  for (int i=0; i < 4; i++) {\n    initSBox(b,sBoxes[i]);\n  }\n}\n", "nl": "Initialise the P-array and S-boxes"}
{"code": "public String decryptPin(String pin){\n  Cipher mwkCipher=this.getCipher(this.getMwkKey(),Cipher.DECRYPT_MODE);\n  String decryptedPinString=null;\n  try {\n    byte[] decryptedEan=mwkCipher.doFinal(StringUtil.fromHexString(pin));\n    byte[] decryptedPin=getByteRange(decryptedEan,8,8);\n    decryptedPinString=new String(decryptedPin);\n  }\n catch (  IllegalStateException e) {\n    Debug.logError(e,module);\n  }\ncatch (  IllegalBlockSizeException e) {\n    Debug.logError(e,module);\n  }\ncatch (  BadPaddingException e) {\n    Debug.logError(e,module);\n  }\n  if (debug) {\n    Debug.logInfo(\"decryptPin : \" + pin + \" / \"+ decryptedPinString,module);\n  }\n  return decryptedPinString;\n}\n", "nl": "Decrypt an encrypted pin using the configured keys"}
{"code": "public void updateBoundaries(){\n  PraatInterval prevInterval=null;\n  for (int index=0; index < getNumberOfIntervals(); index++) {\n    PraatInterval interval=getInterval(index);\n    if (!interval.isComplete()) {\n      if (prevInterval == null) {\n        interval.setXmin(0);\n      }\n else {\n        interval.setXmin(prevInterval.getXmax());\n      }\n      if (interval.getDuration() == 0.0) {\n        interval.setDuration(1e-15);\n      }\n      interval.setXmax(interval.getXmin() + interval.getDuration());\n    }\n    prevInterval=interval;\n  }\n}\n", "nl": "add times to underspecified (incomplete) intervals"}
{"code": "public CombinedOperation[] gather(){\n  final ArrayList<CombinedOperation> list=new ArrayList<>();\n  for (int i=0; i < size(); i++) {\n    PackedOperation pop=getPackedOperation(i);\n    final CombinedOperation cop=new CombinedOperation();\n    cop.setEditOperation(pop.getEditOperation());\n    if (pop.getEditOperation().equals(EditOperation.op_deletion) || pop.getEditOperation().equals(EditOperation.op_substitution)) {\n      cop.setLetter(pop.getLetter());\n      cop.setCount(1);\n    }\n else {\n      cop.setCount(0);\n      while (true) {\n        cop.incrementCount(pop.getCount());\n        i++;\n        if (i == size())         break;\n        pop=getPackedOperation(i);\n        if (cop.getEditOperation() != pop.getEditOperation())         break;\n      }\n      i--;\n    }\n    list.add(cop);\n  }\n  return list.toArray(new CombinedOperation[list.size()]);\n}\n", "nl": "gather all edits into combined operations"}
{"code": "@Override protected RemoteOperationResult run(OwnCloudClient client){\n  RemoteOperationResult result=null;\n  mFileToRemove=getStorageManager().getFileByPath(mRemotePath);\n  boolean localRemovalFailed=false;\n  if (!mOnlyLocalCopy) {\n    RemoveRemoteFileOperation operation=new RemoveRemoteFileOperation(mRemotePath);\n    result=operation.execute(client);\n    if (result.isSuccess() || result.getCode() == ResultCode.FILE_NOT_FOUND) {\n      localRemovalFailed=!(getStorageManager().removeFile(mFileToRemove,true,true));\n    }\n  }\n else {\n    localRemovalFailed=!(getStorageManager().removeFile(mFileToRemove,false,true));\n    if (!localRemovalFailed) {\n      result=new RemoteOperationResult(ResultCode.OK);\n    }\n  }\n  if (localRemovalFailed) {\n    result=new RemoteOperationResult(ResultCode.LOCAL_STORAGE_NOT_REMOVED);\n  }\n  return result;\n}\n", "nl": "Performs the remove operation"}
{"code": "public Boolean createStock(EntityManager em,String productId){\n  Boolean status=true;\n  Stock stock=null;\n  try {\n    if (!em.getTransaction().isActive()) {\n      em.getTransaction().begin();\n    }\n    stock=new Stock();\n    stock.setProductId(productId);\n    stock.setQuantity(BigDecimal.valueOf(10));\n    stock.setLotSize(BigDecimal.valueOf(15));\n    stock.setMinStock(BigDecimal.valueOf(5));\n    em.persist(stock);\n    em.getTransaction().commit();\n  }\n catch (  Exception e) {\n    status=false;\n    logger.error(\"Error occured during creation of Stock. Detailed info: \" + e);\n  }\n  return status;\n}\n", "nl": "Helper method to create Stock"}
{"code": "private boolean isPathRestricted(HttpServletRequest oCntxt) throws ODataException {\n  boolean status;\n  String path=oCntxt.getRequestURI().toString();\n  if ((path.contains(\"/SalesOrderHeaders\") || path.contains(\"/Customers\") || path.contains(\"/SalesOrderItems\")) && (oCntxt.getMethod().equals(\"GET\") || oCntxt.getMethod().equals(\"DELETE\"))) {\n    status=true;\n  }\n else   if (path.contains(\"/PurchaseOrderHeaders\") || path.contains(\"/PurchaseOrderItems\") || path.contains(\"/Suppliers\")|| path.contains(\"/Stocks\")) {\n    status=true;\n  }\n else   if ((path.contains(\"/Products\") || path.contains(\"/ProductCategories\")) && (oCntxt.getMethod().equals(\"POST\") || oCntxt.getMethod().equals(\"PUT\") || oCntxt.getMethod().equals(\"DELETE\"))) {\n    status=true;\n  }\n else   if ((path.contains(\"/ConfirmSalesOrder\") || path.contains(\"/CancelSalesOrder\"))) {\n    status=true;\n  }\n else {\n    status=false;\n  }\n  return status;\n}\n", "nl": "Checks if triggered path is restricted for anonymous users"}
{"code": "private void bigWigToScores(BBFileReader reader){\n  List<ScreenWiggleLocusInfo> screenWigLocInfoList=new ArrayList<ScreenWiggleLocusInfo>();\n  for (int i=0; i < getGc().getUserWindowSize(); i++) {\n    screenWigLocInfoList.add(new ScreenWiggleLocusInfo());\n  }\n  BigWigIterator iter=reader.getBigWigIterator(getGc().getChrom(),getGc().getFrom(),getGc().getChrom(),getGc().getTo(),false);\n  while (iter.hasNext()) {\n    WigItem bw=iter.next();\n    for (int i=bw.getStartBase(); i <= bw.getEndBase(); i++) {\n      int idx=Utils.getIndexOfclosestValue(i,getGc().getMapping());\n      screenWigLocInfoList.get(idx).increment(bw.getWigValue());\n    }\n  }\n  ArrayList<Double> screenScores=new ArrayList<Double>();\n  for (  ScreenWiggleLocusInfo x : screenWigLocInfoList) {\n    screenScores.add((double)x.getMeanScore());\n  }\n  this.setScreenScores(screenScores);\n}\n", "nl": "Populate object using bigWig data"}
{"code": "public static String underlinesToCamelCase(String string){\n  StringBuilder sb=new StringBuilder(string.length());\n  int n=string.length();\n  int i=0;\n  boolean upcaseNext=true;\n  for (; i < n; i++) {\n    char c=string.charAt(i);\n    if (c == '_') {\n      upcaseNext=true;\n    }\n else {\n      if (upcaseNext) {\n        c=Character.toUpperCase(c);\n      }\n      upcaseNext=false;\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}\n", "nl": "Converts an underlined_word into a CamelCase word"}
{"code": "private void writeDictionaryMetadataFile() throws IOException {\n  int min_surrogate_key=0;\n  int max_surrogate_key=0;\n  if (null != chunkMetaObjectForLastSegmentEntry) {\n    if (0 == totalRecordCount) {\n      min_surrogate_key=chunkMetaObjectForLastSegmentEntry.getMax_surrogate_key();\n    }\n else {\n      min_surrogate_key=chunkMetaObjectForLastSegmentEntry.getMax_surrogate_key() + 1;\n    }\n    max_surrogate_key=chunkMetaObjectForLastSegmentEntry.getMax_surrogate_key() + totalRecordCount;\n  }\n else {\n    if (totalRecordCount > 0) {\n      min_surrogate_key=1;\n    }\n    max_surrogate_key=totalRecordCount;\n  }\n  ColumnDictionaryChunkMeta dictionaryChunkMeta=new ColumnDictionaryChunkMeta(min_surrogate_key,max_surrogate_key,chunk_start_offset,chunk_end_offset,chunk_count);\n  openThriftWriter(this.dictionaryMetaFilePath);\n  writeThriftObject(dictionaryChunkMeta);\n  closeThriftWriter();\n  LOGGER.info(\"Dictionary metadata file written successfully for column \" + this.columnIdentifier + \" at path \"+ this.dictionaryMetaFilePath);\n}\n", "nl": "This method will write the dictionary metadata file for a given column"}
{"code": "public static String checkAndAppendHDFSUrl(String filePath){\n  String currentPath=filePath;\n  if (null != filePath && filePath.length() != 0 && FileFactory.getFileType(filePath) != FileFactory.FileType.HDFS && FileFactory.getFileType(filePath) != FileFactory.FileType.VIEWFS) {\n    String baseDFSUrl=CarbonProperties.getInstance().getProperty(CarbonCommonConstants.CARBON_DDL_BASE_HDFS_URL);\n    if (null != baseDFSUrl) {\n      String dfsUrl=conf.get(FS_DEFAULT_FS);\n      if (null != dfsUrl && (dfsUrl.startsWith(HDFS_PREFIX) || dfsUrl.startsWith(VIEWFS_PREFIX))) {\n        baseDFSUrl=dfsUrl + baseDFSUrl;\n      }\n      if (baseDFSUrl.endsWith(\"/\")) {\n        baseDFSUrl=baseDFSUrl.substring(0,baseDFSUrl.length() - 1);\n      }\n      if (!filePath.startsWith(\"/\")) {\n        filePath=\"/\" + filePath;\n      }\n      currentPath=baseDFSUrl + filePath;\n    }\n  }\n  return currentPath;\n}\n", "nl": "Append HDFS Base Url for show create & load data sql"}
{"code": "private void editConflictsExternal(IFile resource,IFile conflictOldFile,IFile conflictWorkingFile,IFile conflictNewFile,String mergeProgramLocation,String mergeProgramParameters) throws CoreException, InvocationTargetException, InterruptedException {\n  try {\n    if (mergeProgramLocation.equals(\"\")) {\n      throw new SVNException(Policy.bind(\"EditConflictsAction.noMergeProgramConfigured\"));\n    }\n    File mergeProgramFile=new File(mergeProgramLocation);\n    if (!mergeProgramFile.exists()) {\n      throw new SVNException(Policy.bind(\"EditConflictsAction.mergeProgramDoesNotExist\"));\n    }\n    Command command=new Command(mergeProgramLocation);\n    String[] parameters=mergeProgramParameters.split(\" \");\n    for (int i=0; i < parameters.length; i++) {\n      parameters[i]=replaceParameter(parameters[i],\"${theirs}\",conflictNewFile.getLocation().toFile().getAbsolutePath());\n      parameters[i]=replaceParameter(parameters[i],\"${yours}\",conflictWorkingFile.getLocation().toFile().getAbsolutePath());\n      parameters[i]=replaceParameter(parameters[i],\"${base}\",conflictOldFile.getLocation().toFile().getAbsolutePath());\n      parameters[i]=replaceParameter(parameters[i],\"${merged}\",resource.getLocation().toFile().getAbsolutePath());\n    }\n    command.setParameters(parameters);\n    command.exec();\n    command.waitFor();\n    resource.refreshLocal(IResource.DEPTH_ZERO,null);\n  }\n catch (  IOException e) {\n    throw new SVNException(Policy.bind(\"EditConflictsAction.1\") + e.getMessage(),e);\n  }\n}\n", "nl": "edit the conflicts using an external merger"}
{"code": "private boolean parseOptions() throws IOException {\n  boolean valid;\n  if (hasOption(LOCALPROPFILE)) {\n    SystemConfiguration.loadPropsFromFile(new File(getOptionValue(LOCALPROPFILE)));\n  }\n else   if (hasOption(HDFSPROPDIR)) {\n    FileSystem fs=FileSystem.get(new Configuration());\n    SystemConfiguration.loadPropsFromHDFSDir(getOptionValue(HDFSPROPDIR),fs);\n  }\n else   if (hasOption(HDFSPROPFILE)) {\n    FileSystem fs=FileSystem.get(new Configuration());\n    SystemConfiguration.loadPropsFromFile(getOptionValue(HDFSPROPFILE),fs);\n  }\n else {\n    for (    String prop : ResponderProps.PROPSLIST) {\n      if (hasOption(prop)) {\n        SystemConfiguration.setProperty(prop,getOptionValue(prop));\n      }\n    }\n  }\n  valid=ResponderProps.validateResponderProperties();\n  return valid;\n}\n", "nl": "Method to parse and validate the options provided"}
{"code": "public static Locale parseLocale(String localeString){\n  if (UtilValidate.isEmpty(localeString)) {\n    return null;\n  }\n  Locale locale=null;\n  if (localeString.length() == 2) {\n    locale=new Locale(localeString);\n  }\n else   if (localeString.length() == 5) {\n    String language=localeString.substring(0,2);\n    String country=localeString.substring(3,5);\n    locale=new Locale(language,country);\n  }\n else   if (localeString.length() > 6) {\n    String language=localeString.substring(0,2);\n    String country=localeString.substring(3,5);\n    String extension=localeString.substring(6);\n    locale=new Locale(language,country,extension);\n  }\n else {\n    Debug.logWarning(\"Do not know what to do with the localeString [\" + localeString + \"], should be length 2, 5, or greater than 6, returning null\",module);\n  }\n  return locale;\n}\n", "nl": "Parse a locale string Locale object"}
{"code": "public static Converter<String,?> determinePrimitiveConverter(Type type){\n  if (String.class.equals(type)) {\n    return StringConverter.INSTANCE;\n  }\n else   if (Boolean.class.equals(type) || boolean.class.equals(type)) {\n    return BooleanConverter.INSTANCE;\n  }\n else   if (Integer.class.equals(type) || int.class.equals(type)) {\n    return Ints.stringConverter();\n  }\n else   if (Long.class.equals(type) || long.class.equals(type)) {\n    return Longs.stringConverter();\n  }\n else   if (Short.class.equals(type) || short.class.equals(type)) {\n    return Shorts.stringConverter();\n  }\n else   if (Float.class.equals(type) || float.class.equals(type)) {\n    return Floats.stringConverter();\n  }\n else   if (Double.class.equals(type) || double.class.equals(type)) {\n    return Doubles.stringConverter();\n  }\n  return null;\n}\n", "nl": "Determine the primitive type's converter"}
{"code": "public boolean has(String key,String value){\n  if (key == null) {\n    throw new NullPointerException(\"key\");\n  }\n  if (value == null) {\n    throw new NullPointerException(\"value\");\n  }\nsynchronized (contexts) {\n    for (    Map.Entry<String,String> e : contexts) {\n      if (!e.getKey().equalsIgnoreCase(key)) {\n        continue;\n      }\n      if (!e.getValue().equals(value)) {\n        continue;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Check if thr set contains a given key mapped to a given value"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  final Set<String> previousSelection=ProjectManager.getPreviouslySelectedNodeLabels();\n  viewer.getSelectedBlock().clear();\n  if (previousSelection.size() > 0) {\n    final Alignment alignment=viewer.getAlignment();\n    for (int row=0; row < alignment.getNumberOfSequences(); row++) {\n      Lane lane=alignment.getLane(row);\n      if (previousSelection.contains(Basic.getFirstWord(lane.getName()))) {\n        int firstJump=alignment.getGapColumnContractor().getTotalJumpBeforeLayoutColumn(lane.getFirstNonGapPosition());\n        int firstCol=lane.getFirstNonGapPosition() - firstJump;\n        int lastCol=lane.getLastNonGapPosition() - firstJump - 1;\n        row=alignment.getRowCompressor().getRow(row);\n        viewer.getSelectedBlock().select(row,firstCol,row,lastCol,alignment.isTranslate());\n        System.err.println(\"Found: \" + lane.getName());\n        executeImmediately(\"zoom axis=both what=selection;\");\n        return;\n      }\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public ResponsePacket writeRequestPacket(RequestPacket packet) throws SQLException {\n  long start=System.currentTimeMillis();\n  boolean useRouter=false;\n  while (true) {\n    if (!useRouter) {\n      try {\n        return writeRequestPacketInternal(packet);\n      }\n catch (      RemoteException re) {\n        sleep(1000);\n        if (System.currentTimeMillis() - start > EXECUTE_RETRY_TIMEOUT) {\n          useRouter=true;\n        }\n      }\n    }\n else {\n      reinitialize();\n      start=System.currentTimeMillis();\n      useRouter=false;\n    }\n  }\n}\n", "nl": "This is the methods that writes the RequestPacket into the socket"}
{"code": "BitMatrix buildFunctionPattern(){\n  int dimension=getDimensionForVersion();\n  BitMatrix bitMatrix=new BitMatrix(dimension);\n  bitMatrix.setRegion(0,0,9,9);\n  bitMatrix.setRegion(dimension - 8,0,8,9);\n  bitMatrix.setRegion(0,dimension - 8,9,8);\n  int max=alignmentPatternCenters.length;\n  for (int x=0; x < max; x++) {\n    int i=alignmentPatternCenters[x] - 2;\n    for (int y=0; y < max; y++) {\n      if ((x == 0 && (y == 0 || y == max - 1)) || (x == max - 1 && y == 0)) {\n        continue;\n      }\n      bitMatrix.setRegion(alignmentPatternCenters[y] - 2,i,5,5);\n    }\n  }\n  bitMatrix.setRegion(6,9,1,dimension - 17);\n  bitMatrix.setRegion(9,6,dimension - 17,1);\n  if (versionNumber > 6) {\n    bitMatrix.setRegion(dimension - 11,0,3,6);\n    bitMatrix.setRegion(0,dimension - 11,6,3);\n  }\n  return bitMatrix;\n}\n", "nl": "See ISO 18004:2006 Annex E"}
{"code": "public static String convertObjectToString(Object obj) throws IOException {\n  ByteArrayOutputStream baos=null;\n  GZIPOutputStream gos=null;\n  ObjectOutputStream oos=null;\n  try {\n    baos=new ByteArrayOutputStream();\n    gos=new GZIPOutputStream(baos);\n    oos=new ObjectOutputStream(gos);\n    oos.writeObject(obj);\n  }\n  finally {\n    try {\n      if (oos != null) {\n        oos.close();\n      }\n      if (gos != null) {\n        gos.close();\n      }\n      if (baos != null) {\n        baos.close();\n      }\n    }\n catch (    IOException e) {\n      LOG.error(e);\n    }\n  }\n  return new String(Base64.encodeBase64(baos.toByteArray()),CarbonCommonConstants.DEFAULT_CHARSET);\n}\n", "nl": "Convert object to Base64 String"}
{"code": "public static boolean bboxIsValid(String bbox){\n  if (bbox == null || bbox.trim().isEmpty()) {\n    return false;\n  }\n  Matcher matcher=BBOX_PATTERN.matcher(bbox);\n  if (!matcher.matches()) {\n    return false;\n  }\n  double minLng=Double.parseDouble(matcher.group(1));\n  double minLat=Double.parseDouble(matcher.group(4));\n  double maxLng=Double.parseDouble(matcher.group(7));\n  double maxLat=Double.parseDouble(matcher.group(10));\n  if (minLng < -180d || minLng > 180d || maxLng < -180d || maxLng > 180d) {\n    return false;\n  }\n  if (minLat < -90d || minLat > 90d || maxLat < -90d || maxLat > 90d) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Validates whether a bbox string is valid and on the format: <code>min longitude, min latitude, max longitude, max latitude</code>"}
{"code": "private Map<String,Pair<Type,RoleType>> computeVarTypeRoleMap(){\n  Map<String,Pair<Type,RoleType>> roleVarTypeMap=new HashMap<>();\n  if (getParentQuery() == null)   return roleVarTypeMap;\n  MindmapsGraph graph=getParentQuery().getGraph().orElse(null);\n  Type relType=getType();\n  Set<String> vars=getVarNames();\n  Map<String,Type> varTypeMap=getParentQuery().getVarTypeMap();\n  for (  String var : vars) {\n    Type type=varTypeMap.get(var);\n    String roleTypeId=\"\";\n    for (    VarAdmin.Casting c : castings) {\n      if (c.getRolePlayer().getName().equals(var))       roleTypeId=c.getRoleType().flatMap(null).orElse(\"\");\n    }\n    if (!roleTypeId.isEmpty())     roleVarTypeMap.put(var,new Pair<>(type,graph.getRoleType(roleTypeId)));\n else {\n      if (type != null) {\n        Set<RoleType> cRoles=getCompatibleRoleTypes(type,relType);\n        if (cRoles.size() == 1)         roleVarTypeMap.put(var,new Pair<>(type,cRoles.iterator().next()));\n else         roleVarTypeMap.put(var,new Pair<>(type,null));\n      }\n    }\n  }\n  return roleVarTypeMap;\n}\n", "nl": "Attempts to infer the implicit roleTypes of vars in a relAtom"}
{"code": "public static void expandID(String numberString,WordRelation wordRelation,Item tokenItem){\n  int numberDigits=numberString.length();\n  if ((numberDigits == 4) && (numberString.charAt(2) == '0') && (numberString.charAt(3) == '0')) {\n    if (numberString.charAt(1) == '0') {\n      expandNumber(numberString,wordRelation,tokenItem);\n    }\n else {\n      expandNumber(numberString.substring(0,2),wordRelation,tokenItem);\n      wordRelation.addWord(tokenItem,\"hundred\");\n    }\n  }\n else   if ((numberDigits == 2) && (numberString.charAt(0) == '0')) {\n    wordRelation.addWord(tokenItem,\"oh\");\n    expandDigits(numberString.substring(1,2),wordRelation,tokenItem);\n  }\n else   if ((numberDigits == 4 && numberString.charAt(1) == '0') || numberDigits < 3) {\n    expandNumber(numberString,wordRelation,tokenItem);\n  }\n else   if (numberDigits % 2 == 1) {\n    String firstDigit=digit2num[numberString.charAt(0) - '0'];\n    wordRelation.addWord(tokenItem,firstDigit);\n    expandID(numberString.substring(1,numberDigits),wordRelation,tokenItem);\n  }\n else {\n    expandNumber(numberString.substring(0,2),wordRelation,tokenItem);\n    expandID(numberString.substring(2,numberDigits),wordRelation,tokenItem);\n  }\n}\n", "nl": "Expands the given number string as pairs as in years or IDs"}
{"code": "public boolean contains(){\n  int next=0;\n  final int size=fValues.size();\n  LOOP:   for (int i=0; i < size; i=next) {\n    next=i + fFieldCount;\n    for (int j=0; j < fFieldCount; j++) {\n      Object value1=fLocalValues[j];\n      Object value2=fValues.elementAt(i);\n      short valueType1=fLocalValueTypes[j];\n      short valueType2=getValueTypeAt(i);\n      if (value1 == null || value2 == null || valueType1 != valueType2 || !(value1.equals(value2))) {\n        continue LOOP;\n      }\n else       if (valueType1 == XSConstants.LIST_DT || valueType1 == XSConstants.LISTOFUNION_DT) {\n        ShortList list1=fLocalItemValueTypes[j];\n        ShortList list2=getItemValueTypeAt(i);\n        if (list1 == null || list2 == null || !list1.equals(list2))         continue LOOP;\n      }\n      i++;\n    }\n    return true;\n  }\n  return false;\n}\n", "nl": "Returns true if this value store contains the locally scoped value stores"}
{"code": "TxnManagerTransaction(TransactionManager mgr,LogManager logmgr,long id,TaskManager threadpool,WakeupManager wm,TxnSettler settler,Uuid uuid,long lease,boolean persistent,Object externalXid,ConcurrentMap<String,IDirectSpaceProxy> proxiesMap){\n  if (logmgr == null)   throw new IllegalArgumentException(\"TxnManagerTransaction: \" + \"log manager must be non-null\");\n  if (mgr == null)   throw new IllegalArgumentException(\"TxnManagerTransaction: \" + \"transaction manager must be non-null\");\n  if (threadpool == null)   throw new IllegalArgumentException(\"TxnManagerTransaction: \" + \"threadpool must be non-null\");\n  if (wm == null)   throw new IllegalArgumentException(\"TxnManagerTransaction: \" + \"wakeup manager must be non-null\");\n  if (settler == null)   throw new IllegalArgumentException(\"TxnManagerTransaction: \" + \"settler must be non-null\");\n  if (uuid == null)   throw new IllegalArgumentException(\"TxnManagerTransaction: \" + \"uuid must be non-null\");\n  this.threadpool=threadpool;\n  this.wm=wm;\n  this.logmgr=logmgr;\n  if (externalXid != null) {\n    _externalXid=externalXid;\n    str=new GSServerTransaction(mgr,externalXid,lease);\n    str.id=id;\n  }\n else {\n    _externalXid=null;\n    str=new ServerTransaction(mgr,id,lease);\n  }\n  this.settler=settler;\n  this.uuid=uuid;\n  _persistent=persistent;\n  _proxiesMap=proxiesMap;\n  finer_op_logger=operationsLogger.isLoggable(Level.FINER);\n  finest_tr_logger=transactionsLogger.isLoggable(Level.FINEST);\n}\n", "nl": "Constructs a <code>TxnManagerTransaction</code>"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(getSyntax());\n  AlignmentViewer viewer=(AlignmentViewer)getViewer();\n  String fastA=viewer.getAlignmentViewerPanel().getSelectedAlignment();\n  if (fastA != null) {\n    StringWriter w=new StringWriter();\n    BufferedReader r=new BufferedReader(new StringReader(fastA));\n    String aLine;\n    while ((aLine=r.readLine()) != null) {\n      aLine=aLine.trim();\n      if (aLine.startsWith(\">\"))       w.write(aLine + \"\\n\");\n else {\n        for (int i=0; i < aLine.length() - 2; i+=3) {\n          w.write(SequenceUtils.getAminoAcid(aLine.charAt(i),aLine.charAt(i + 1),aLine.charAt(i + 2)));\n        }\n        w.write(\"\\n\");\n      }\n    }\n    System.out.println(w.toString());\n    NotificationsInSwing.showInformation(viewer.getFrame(),w.toString());\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "@Override protected String doInBackground(Void... params){\n  try {\n    String res=launchPing(urlToPing);\n    mTraceRouteResult.append(res);\n    publishProgress(res);\n    TraceRouteContainer trace;\n    if (res.contains(UNREACHABLE_PING) && !res.contains(EXCEED_PING)) {\n      trace=new TraceRouteContainer(\"\",parseIpFromPing(res),elapsedTime,false);\n    }\n else {\n      trace=new TraceRouteContainer(\"\",parseIpFromPing(res),ttl == maxTtl ? Float.parseFloat(parseTimeFromPing(res)) : elapsedTime,true);\n      InetAddress inetAddr=InetAddress.getByName(trace.getIp());\n      Log.e(\"TAG\",\"getIP is \" + trace.getIp());\n      String hostname=inetAddr.getHostName();\n      String canonicalHostname=inetAddr.getCanonicalHostName();\n      trace.setHostname(hostname);\n      traces.add(trace);\n    }\n    return res;\n  }\n catch (  final Exception e) {\n    e.printStackTrace();\n  }\n  return \"\";\n}\n", "nl": "Launches the ping, launches InetAddress to retrieve url if there is one, store trace"}
{"code": "private void drawLineProgress(Canvas canvas){\n  float unitDegrees=(float)(2.0f * Math.PI / mLineCount);\n  float outerCircleRadius=mRadius;\n  float interCircleRadius=mRadius - mLineWidth;\n  int progressLineCount=(int)((float)getProgress() / (float)getMax() * mLineCount);\n  for (int i=0; i < mLineCount; i++) {\n    float rotateDegrees=i * unitDegrees;\n    float startX=mCenterX + (float)Math.sin(rotateDegrees) * interCircleRadius;\n    float startY=mCenterX - (float)Math.cos(rotateDegrees) * interCircleRadius;\n    float stopX=mCenterX + (float)Math.sin(rotateDegrees) * outerCircleRadius;\n    float stopY=mCenterX - (float)Math.cos(rotateDegrees) * outerCircleRadius;\n    if (i < progressLineCount) {\n      canvas.drawLine(startX,startY,stopX,stopY,mProgressPaint);\n    }\n else {\n      canvas.drawLine(startX,startY,stopX,stopY,mProgressBackgroundPaint);\n    }\n  }\n}\n", "nl": "In the center of the drawing area as a reference point , rotate the canvas"}
{"code": "public void initHMMDataForHMMModel(String voiceName) throws IOException, MaryConfigurationException {\n  PropertiesAccessor p=MaryConfig.getVoiceConfig(voiceName).getPropertiesAccessor(true);\n  String prefix=\"voice.\" + voiceName;\n  treeDurStream=p.getStream(prefix + \".Ftd\");\n  pdfDurStream=p.getStream(prefix + \".Fmd\");\n  treeLf0Stream=p.getStream(prefix + \".Ftf\");\n  pdfLf0Stream=p.getStream(prefix + \".Fmf\");\n  useGV=p.getBoolean(prefix + \".useGV\");\n  if (useGV) {\n    useContextDependentGV=p.getBoolean(prefix + \".useContextDependentGV\",useContextDependentGV);\n    if (p.getProperty(prefix + \".gvMethod\") != null) {\n      String sval=p.getProperty(prefix + \".gvMethod\");\n      setGvMethod(sval);\n    }\n    maxLf0GvIter=p.getInteger(prefix + \".maxLf0GvIter\",maxLf0GvIter);\n    gvWeightLf0=p.getDouble(prefix + \".gvWeightLf0\",gvWeightLf0);\n    pdfLf0GVStream=p.getStream(prefix + \".Fgvf\");\n    maxLf0GvIter=p.getInteger(prefix + \".maxLf0GvIter\",maxLf0GvIter);\n  }\n  InputStream feaStream=p.getStream(prefix + \".FeaFile\");\n  feaDef=FeatureUtils.readFeatureDefinition(feaStream);\n  InputStream trickyPhonesStream=p.getStream(prefix + \".trickyPhonesFile\");\n  trickyPhones=new PhoneTranslator(trickyPhonesStream);\n  Log.i(Mary.LOG,\"Loading Tree Set in CARTs:\");\n  cart.loadTreeSet(this,feaDef,trickyPhones);\n  Log.i(Mary.LOG,\"Loading GV Model Set:\");\n  gv.loadGVModelSet(this,feaDef);\n}\n", "nl": "Reads from configuration file tree and pdf data for duration and f0 this method is used by HMMModel"}
{"code": "public static boolean writeToFile(StringBuffer content,File file,boolean append){\n  OutputStreamWriter fw=null;\n  try {\n    fw=new OutputStreamWriter(new FileOutputStream(file,append),\"UTF-8\");\n    Writer bw=new BufferedWriter(fw);\n    bw.write(content.toString());\n    bw.flush();\n    bw.close();\n  }\n catch (  IOException ex) {\n    Logger.getLogger(FileUtility.class.getName()).log(Level.SEVERE,null,ex);\n    return false;\n  }\n finally {\n    try {\n      fw.close();\n    }\n catch (    IOException ex) {\n      Logger.getLogger(FileUtility.class.getName()).log(Level.SEVERE,null,ex);\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Write a content to a file"}
{"code": "private static void copyItemInfo(Item sourceItem,Item newItem){\n  newItem.setOptionalSocket(sourceItem.getOptionalSocket());\n  newItem.setItemCreator(sourceItem.getItemCreator());\n  if (sourceItem.hasManaStones()) {\n    for (    ManaStone manaStone : sourceItem.getItemStones()) {\n      ItemSocketService.addManaStone(newItem,manaStone.getItemId());\n    }\n  }\n  if (sourceItem.getGodStone() != null) {\n    newItem.addGodStone(sourceItem.getGodStone().getItemId());\n  }\n  if (sourceItem.getEnchantLevel() > 0) {\n    newItem.setEnchantLevel(sourceItem.getEnchantLevel());\n  }\n  if (sourceItem.isSoulBound()) {\n    newItem.setSoulBound(true);\n  }\n  newItem.setBonusNumber(sourceItem.getBonusNumber());\n  newItem.setRandomStats(sourceItem.getRandomStats());\n  newItem.setRandomCount(sourceItem.getRandomCount());\n  newItem.setIdianStone(sourceItem.getIdianStone());\n  newItem.setItemColor(sourceItem.getItemColor());\n  newItem.setItemSkinTemplate(sourceItem.getItemSkinTemplate());\n}\n", "nl": "Copy some item values like item stones and enchant level"}
{"code": "public static List<MySQLRepBean> loadMySQLRepBean(String datasourceuri){\n  List<MySQLRepBean> list=new LinkedList<MySQLRepBean>();\n  try {\n    NodeList nodeList=loadXmlDoc(datasourceuri).getElementsByTagName(\"mysql-replica\");\n    for (int i=0; i < nodeList.getLength(); i++) {\n      Node curRepNode=nodeList.item(i);\n      NamedNodeMap map=curRepNode.getAttributes();\n      String name=getAttribute(map,\"name\",null);\n      int type=getIntAttribute(map,\"type\",0);\n      int switchType=getIntAttribute(map,\"switch-type\",0);\n      MySQLRepBean repBean=new MySQLRepBean(name,type);\n      repBean.setSwitchType(switchType);\n      List<Node> mysqlNodes=getChildNodes(curRepNode,\"mysql\");\n      List<MySQLBean> allMysqls=mysqlNodes.stream().map(null).collect(Collectors.toList());\n      repBean.setMysqls(allMysqls);\n      list.add(repBean);\n    }\n  }\n catch (  Exception e) {\n    LOGGER.warn(\"loadMySQLRepBean err \" + e);\n  }\n  return list;\n}\n", "nl": "load datasource file"}
{"code": "public static boolean hasPhoneNumber(ContentResolver resolver,long contactID){\n  Cursor phoneCursor;\n  String[] selectionArgs={String.valueOf(contactID)};\n  Uri contentUri=CommonDataKinds.Phone.CONTENT_URI;\n  phoneCursor=resolver.query(contentUri,DataTypeQuery.PROJECTION,DataTypeQuery.SELECTION,selectionArgs,DataTypeQuery.SORTORDER + \" LIMIT 1\");\n  if (phoneCursor == null) {\n    return false;\n  }\n  try {\n    return phoneCursor.getCount() > 0;\n  }\n catch (  Exception e) {\n    ErrorTracker.track(e);\n  }\n finally {\n    if (!phoneCursor.isClosed()) {\n      phoneCursor.close();\n    }\n  }\n  return false;\n}\n", "nl": "Returns whether the contact with the particular contactID has at least one phone number"}
{"code": "private byte[] encryptModulus(BigInteger modulus){\n  byte[] encryptedModulus=modulus.toByteArray();\n  if ((encryptedModulus.length == 0x81) && (encryptedModulus[0] == 0x00)) {\n    byte[] temp=new byte[0x80];\n    System.arraycopy(encryptedModulus,1,temp,0,0x80);\n    encryptedModulus=temp;\n  }\n  for (int i=0; i < 4; i++) {\n    byte temp=encryptedModulus[i];\n    encryptedModulus[i]=encryptedModulus[0x4d + i];\n    encryptedModulus[0x4d + i]=temp;\n  }\n  for (int i=0; i < 0x40; i++) {\n    encryptedModulus[i]=(byte)(encryptedModulus[i] ^ encryptedModulus[0x40 + i]);\n  }\n  for (int i=0; i < 4; i++) {\n    encryptedModulus[0x0d + i]=(byte)(encryptedModulus[0x0d + i] ^ encryptedModulus[0x34 + i]);\n  }\n  for (int i=0; i < 0x40; i++) {\n    encryptedModulus[0x40 + i]=(byte)(encryptedModulus[0x40 + i] ^ encryptedModulus[i]);\n  }\n  return encryptedModulus;\n}\n", "nl": "Encrypt RSA modulus N"}
{"code": "public static String shouldCreateChatlog(String message,String user,String serverIp){\n  if (!SERVER_ADDRESS.matcher(serverIp).matches()) {\n    return null;\n  }\n  Matcher chatMatcher=CHAT_FORMAT.matcher(message);\n  if (!chatMatcher.matches()) {\n    return null;\n  }\n  String sender=chatMatcher.group(1);\n  if (sender.equals(user)) {\n    return null;\n  }\n  String chatMessage=chatMatcher.group(2);\n  for (  String badWord : RewiMod.getInstance().getBlacklistedWords()) {\n    if (chatMessage.contains(badWord)) {\n      return sender;\n    }\n  }\n  return null;\n}\n", "nl": "Determines if a chatlog should be created or not"}
{"code": "private final void reapReachedMarkers(){\n  if (!_cacheManager.requiresEvictionReplicationProtection())   return;\n  int reapCount=0;\n  try {\n    long currentTime=SystemTime.timeMillis();\n    long expirationTime=currentTime - LM_CHECK_TIME_MARKERS_REPOSITORY_DEFAULT;\n    if (_force || _lastReapedMarkersRepository < expirationTime)     _lastReapedMarkersRepository=currentTime;\n else     return;\n    reapCount=_cacheManager.getEvictionReplicationsMarkersRepository().reapUnused();\n  }\n catch (  Exception ex) {\n    if (_logger.isLoggable(Level.SEVERE)) {\n      _logger.log(Level.SEVERE,this.getName() + \" - caught exception while reaping reached markers \",ex);\n    }\n  }\n  if (reapCount > 0 && _logger.isLoggable(Level.FINE)) {\n    _logger.fine(this.getName() + \" - Reaped reached markers. [Reaped: \" + reapCount+ \", Remaining:\"+ _cacheManager.getEvictionReplicationsMarkersRepository().size()+ \"]\");\n  }\n}\n", "nl": "Clean reached markers if markers repository is activated"}
{"code": "private void exportToSLD(){\n  SLDWriterInterface sldWriter=SLDWriterFactory.createWriter(SLDOutputFormatEnum.SLD);\n  for (  SLDDataInterface sldData : sldDataList) {\n    StyledLayerDescriptor sld=SLDUtils.createSLDFromString(sldData);\n    String layerName=sldData.getLayerNameWithOutSuffix();\n    if (sld != null) {\n      String sldString=sldWriter.encodeSLD(sldData.getResourceLocator(),sld);\n      String sldFilename=layerName + ExternalFilenames.addFileExtensionSeparator(SLDEditorFile.getSLDFileExtension());\n      String destinationFolder=sldData.getSLDFile().getParent();\n      File fileToSave=new File(destinationFolder,sldFilename);\n      if (fileToSave.exists()) {\n        ConsoleManager.getInstance().error(this,Localisation.getField(YSLDTool.class,\"YSLDTool.destinationAlreadyExists\") + \" \" + sldFilename);\n      }\n else {\n        ConsoleManager.getInstance().information(this,Localisation.getField(YSLDTool.class,\"YSLDTool.exportToSLDMsg\") + \" \" + sldFilename);\n        BufferedWriter out;\n        try {\n          out=new BufferedWriter(new FileWriter(fileToSave));\n          out.write(sldString);\n          out.close();\n        }\n catch (        IOException e) {\n          ConsoleManager.getInstance().exception(this,e);\n        }\n      }\n    }\n  }\n}\n", "nl": "Export to SLD"}
{"code": "@VisibleForTesting static SkinLayoutDefinition loadFromTokens(Iterator<String> tokens){\n  String key;\n  String value;\n  SkinLayoutDefinition definition=new SkinLayoutDefinition();\n  while (tokens.hasNext()) {\n    key=tokens.next();\n    if (key.equals(\"}\")) {\n      break;\n    }\n else {\n      value=tokens.next();\n      if (value.equals(\"{\")) {\n        definition.myChildren.put(key,loadFromTokens(tokens));\n      }\n else {\n        definition.myProperties.put(key,value);\n      }\n    }\n  }\n  return definition;\n}\n", "nl": "Populate myProperties and myChildren from the token stream"}
{"code": "public static void removeAllMEGANData(String fileName) throws IOException {\n  final DAAHeader header=new DAAHeader(fileName);\n  header.load();\n  long newFileSize=-1l;\n  for (int i=0; i < header.getBlockTypeRankArrayLength(); i++) {\n    BlockType type=header.getBlockType(i);\n    if (type != BlockType.empty) {\n      if (type.toString().startsWith(\"megan\")) {\n        if (newFileSize == -1l)         newFileSize=header.getLocationOfBlockInFile(i);\n        header.setBlockTypeRank(i,BlockType.rank(BlockType.empty));\n        header.setBlockSize(i,0l);\n      }\n    }\n    if (newFileSize != -1) {\n      try (RandomAccessFile raf=new RandomAccessFile(fileName,\"rw\")){\n        raf.setLength(newFileSize);\n      }\n     }\n    if (newFileSize != -1 || header.getReserved3() > 0) {\n      header.setReserved3(0);\n      header.save();\n    }\n  }\n}\n", "nl": "remove all data added by MEGAN"}
{"code": "public static Map<String,Object> entitySortTest(DispatchContext dctx,Map<String,?> context){\n  Delegator delegator=dctx.getDelegator();\n  Set<ModelEntity> set=new TreeSet<ModelEntity>();\n  set.add(delegator.getModelEntity(\"Person\"));\n  set.add(delegator.getModelEntity(\"PartyRole\"));\n  set.add(delegator.getModelEntity(\"Party\"));\n  set.add(delegator.getModelEntity(\"ContactMech\"));\n  set.add(delegator.getModelEntity(\"PartyContactMech\"));\n  set.add(delegator.getModelEntity(\"OrderHeader\"));\n  set.add(delegator.getModelEntity(\"OrderItem\"));\n  set.add(delegator.getModelEntity(\"OrderContactMech\"));\n  set.add(delegator.getModelEntity(\"OrderRole\"));\n  set.add(delegator.getModelEntity(\"Product\"));\n  set.add(delegator.getModelEntity(\"RoleType\"));\n  for (  ModelEntity modelEntity : set) {\n    Debug.logInfo(modelEntity.getEntityName(),module);\n  }\n  return ServiceUtil.returnSuccess();\n}\n", "nl": "Test entity sorting"}
{"code": "public void registerInterface(Class<? extends PluginLoader> loader) throws IllegalArgumentException {\n  PluginLoader instance;\n  if (PluginLoader.class.isAssignableFrom(loader)) {\n    Constructor<? extends PluginLoader> constructor;\n    try {\n      constructor=loader.getConstructor(Server.class);\n      instance=constructor.newInstance(server);\n    }\n catch (    NoSuchMethodException ex) {\n      String className=loader.getName();\n      throw new IllegalArgumentException(String.format(\"Class %s does not have a public %s(Server) constructor\",className,className),ex);\n    }\ncatch (    Exception ex) {\n      throw new IllegalArgumentException(String.format(\"Unexpected exception %s while attempting to construct a new instance of %s\",ex.getClass().getName(),loader.getName()),ex);\n    }\n  }\n else {\n    throw new IllegalArgumentException(String.format(\"Class %s does not implement interface PluginLoader\",loader.getName()));\n  }\n  Pattern[] patterns=instance.getPluginFileFilters();\nsynchronized (this) {\n    for (    Pattern pattern : patterns) {\n      fileAssociations.put(pattern,instance);\n    }\n  }\n}\n", "nl": "Registers the specified plugin loader"}
{"code": "@deprecated public static int[] codePoints(CharSequence s){\n  int[] result=new int[s.length()];\n  int j=0;\n  for (int i=0; i < s.length(); i++) {\n    char cp=s.charAt(i);\n    if ((cp >= 56320) && (cp <= 57343) && (i != 0)) {\n      char last=(char)result[(j - 1)];\n      if ((last >= 55296) && (last <= 56319)) {\n        result[(j - 1)]=Character.toCodePoint(last,cp);\n        continue;\n      }\n    }\n    result[(j++)]=cp;\n  }\n  if (j == result.length) {\n    return result;\n  }\n  int[] shortResult=new int[j];\n  System.arraycopy(result,0,shortResult,0,j);\n  return shortResult;\n}\n", "nl": "/*    "}
{"code": "public static int exportAll(IConnector connector,String fileName,ProgressListener progressListener) throws IOException {\n  int total=0;\n  try {\n    progressListener.setTasks(\"Export\",\"Writing all reads\");\n    try (BufferedWriter w=new BufferedWriter(new FileWriter(fileName))){\n      IReadBlockIterator it=connector.getAllReadsIterator(0,10000,true,false);\n      progressListener.setMaximum(it.getMaximumProgress());\n      progressListener.setProgress(0);\n      while (it.hasNext()) {\n        total++;\n        write(it.next(),w);\n        progressListener.setProgress(it.getProgress());\n      }\n    }\n   }\n catch (  CanceledException ex) {\n    System.err.println(\"USER CANCELED\");\n  }\n  return total;\n}\n", "nl": "export all matches in file"}
{"code": "@Path(path=\"go\",login=true) public boolean go(){\n  Session s=this.getSession();\n  if (s.has(\"uri\")) {\n    String uri=(String)s.get(\"uri\");\n    log.debug(\"redirecting:\" + uri);\n    if (uri.endsWith(\"/index\")) {\n      uri=uri.substring(0,uri.length() - 6);\n    }\n    if (X.isEmpty(uri)) {\n      this.redirect(\"/\");\n    }\n else {\n      this.redirect(uri);\n    }\n    s.remove(\"uri\").store();\n    return true;\n  }\n  this.redirect(\"/\");\n  return false;\n}\n", "nl": "redirect the web to right site"}
{"code": "public static MapWritable jsonStringToMapWritable(String jsonString){\n  MapWritable value=new MapWritable();\n  JSONParser jsonParser=new JSONParser();\n  try {\n    JSONObject jsonObj=(JSONObject)jsonParser.parse(jsonString);\n    for (    Object key : jsonObj.keySet()) {\n      Text mapKey=new Text(key.toString());\n      Text mapValue=new Text();\n      if (jsonObj.get(key) != null) {\n        mapValue.set(jsonObj.get(key).toString());\n      }\n      value.put(mapKey,mapValue);\n    }\n  }\n catch (  ParseException e) {\n    logger.warn(\"Could not json-decode string: \" + jsonString,e);\n  }\ncatch (  NumberFormatException e) {\n    logger.warn(\"Could not parse field into number: \" + jsonString,e);\n  }\n  return value;\n}\n", "nl": "Method to take an input json string and output a MapWritable with arrays as JSON formatted String objects"}
{"code": "@Deprecated public void initialiseVerticalStepperForm(String[] stepsTitles,int buttonBackgroundColor,int buttonTextColor,int buttonPressedBackgroundColor,int buttonPressedTextColor,int stepNumberBackgroundColor,int stepNumberTextColor,VerticalStepperForm verticalStepperForm,Activity activity){\n  this.alphaOfDisabledElements=0.25f;\n  this.buttonBackgroundColor=buttonBackgroundColor;\n  this.buttonTextColor=buttonTextColor;\n  this.buttonPressedBackgroundColor=buttonPressedBackgroundColor;\n  this.buttonPressedTextColor=buttonPressedTextColor;\n  this.stepNumberBackgroundColor=stepNumberBackgroundColor;\n  this.stepTitleTextColor=Color.rgb(33,33,33);\n  this.stepSubtitleTextColor=Color.rgb(162,162,162);\n  this.stepNumberTextColor=stepNumberTextColor;\n  this.errorMessageTextColor=Color.rgb(175,18,18);\n  this.displayBottomNavigation=true;\n  this.materialDesignInDisabledSteps=false;\n  this.hideKeyboard=true;\n  this.showVerticalLineWhenStepsAreCollapsed=false;\n  this.verticalStepperFormImplementation=verticalStepperForm;\n  this.activity=activity;\n  initStepperForm(stepsTitles,null);\n}\n", "nl": "Set up and initialize the form"}
{"code": "private void updateTitle(){\n  if (menuDone != null && menuCamera != null) {\n    if (isDisplayingFolderView()) {\n      actionBar.setTitle(folderTitle);\n      menuDone.setVisible(false);\n    }\n else {\n      if (selectedImages.size() == 0) {\n        actionBar.setTitle(imageTitle);\n        if (menuDone != null)         menuDone.setVisible(false);\n      }\n else {\n        if (mode == ImagePickerActivity.MODE_MULTIPLE) {\n          if (limit == Constants.MAX_LIMIT)           actionBar.setTitle(String.format(getString(R.string.selected),selectedImages.size()));\n else           actionBar.setTitle(String.format(getString(R.string.selected_with_limit),selectedImages.size(),limit));\n        }\n        if (menuDone != null)         menuDone.setVisible(true);\n      }\n    }\n  }\n}\n", "nl": "Update activity title If we're displaying folder, set folder title If we're displaying images, show number of selected images"}
{"code": "public static ValueCompressonHolder.UnCompressValue unCompressNone(DataType compDataType,DataType actualDataType){\n  if (actualDataType == DataType.DATA_BIGINT) {\n    return new UnCompressDefaultLong();\n  }\n else {\nswitch (compDataType) {\ncase DATA_BYTE:\n      return new UnCompressNoneByte();\ncase DATA_SHORT:\n    return new UnCompressNoneShort();\ncase DATA_INT:\n  return new UnCompressNoneInt();\ncase DATA_LONG:\nreturn new UnCompressNoneLong();\ncase DATA_FLOAT:\nreturn new UnCompressNoneFloat();\ndefault :\nreturn new UnCompressNoneDefault();\n}\n}\n}\n", "nl": "uncompress data for example: int -> double"}
{"code": "public void zoomOut() throws IOException {\n  int zoom=1;\n  int range=this.to - this.from + 1;\n  if (range % 2 == 1) {\n    range--;\n  }\n  int midpoint=this.getMidpoint();\n  long zoomTo=midpoint + ((long)range * (long)zoom);\n  if (zoomTo >= Integer.MAX_VALUE) {\n    System.err.println(\"Invalid 'to' coordinate to fetch \" + zoomTo + \" (integer overflow?)\");\n    zoomTo=Integer.MAX_VALUE;\n  }\n  this.to=(int)zoomTo;\n  this.from=midpoint - (range * zoom);\n  this.from=(this.from <= 0) ? 1 : this.from;\n  if (this.samSeqDict != null && this.samSeqDict.size() > 0) {\n    if (this.samSeqDict.getSequence(this.chrom).getSequenceLength() > 0) {\n      this.to=(this.to > this.samSeqDict.getSequence(this.chrom).getSequenceLength()) ? this.samSeqDict.getSequence(this.chrom).getSequenceLength() : this.to;\n    }\n  }\n  this.setRefSeq();\n}\n", "nl": "Rescale coords to extend them as in zooming-in/-out"}
{"code": "private void readFromVersion1Stream(StatusFromBytesStream dis) throws IOException {\n  String urlCopiedFromString=dis.readUTF();\n  if (urlCopiedFromString.equals(\"\")) {\n    urlCopiedFrom=null;\n  }\n else {\n    urlCopiedFrom=url;\n  }\n  file=new File(dis.readUTF());\n  pathConflictOld=dis.readUTF();\n  if (pathConflictOld.equals(\"\"))   pathConflictOld=null;\n  pathConflictNew=dis.readUTF();\n  if (pathConflictNew.equals(\"\"))   pathConflictNew=null;\n  pathConflictWorking=dis.readUTF();\n  if (pathConflictWorking.equals(\"\"))   pathConflictWorking=null;\n  lockOwner=null;\n  lockCreationDate=0L;\n  lockComment=null;\n  readOnly=false;\n}\n", "nl": "Just for backwards compatibility with workspaces stored with previous version"}
{"code": "private static double[] computeSimpsonReciprocal(ClassificationViewer viewer,ProgressListener progressListener) throws IOException, CanceledException {\n  progressListener.setMaximum(2 * viewer.getSelectedNodes().size());\n  progressListener.setProgress(0);\n  int numberOfDatasets=viewer.getDocument().getNumberOfSamples();\n  double[] total=new double[numberOfDatasets];\n  for (  Node v : viewer.getSelectedNodes()) {\n    int[] summarized=viewer.getNodeData(v).getSummarized();\n    for (int i=0; i < summarized.length; i++)     total[i]+=summarized[i];\n    progressListener.incrementProgress();\n  }\n  double[] result=new double[numberOfDatasets];\n  for (  Node v : viewer.getSelectedNodes()) {\n    int[] summarized=viewer.getNodeData(v).getSummarized();\n    for (int i=0; i < summarized.length; i++) {\n      double p=summarized[i] / total[i];\n      result[i]+=p * p;\n    }\n    progressListener.incrementProgress();\n  }\n  for (int i=0; i < result.length; i++)   result[i]=result[i] > 0 ? 1.0 / result[i] : 0;\n  return result;\n}\n", "nl": "compute the Shannon-Weaver diversity index in bits"}
{"code": "public static List<String> parseStringGroup(final String string,final String regex,final String firstRegex,final String firstRegexReplace,final int lastRegexStringLength){\n  List<String> list=null;\n  if (string != null) {\n    list=new ArrayList<String>();\n    int lastRegexLength=lastRegexStringLength < 0 ? 0 : lastRegexStringLength;\n    Pattern pattern=Pattern.compile(regex);\n    Matcher matcher=pattern.matcher(string);\n    String group=null;\n    int start=0;\n    while (matcher.find(start)) {\n      start=matcher.end();\n      group=matcher.group();\n      group=group.replaceFirst(firstRegex,firstRegexReplace);\n      group=group.substring(0,group.length() - lastRegexLength);\n      list.add(group);\n    }\n  }\n  return list;\n}\n", "nl": "<p> Method: check the string match the regex or not and return the match field value like {xxxx} can find xxxx </p>"}
{"code": "private void initializeReader() throws IOException {\n  close();\n  String path=this.csvParserVo.getBlockDetailsList().get(blockCounter).getFilePath();\n  FileType fileType=FileFactory.getFileType(path);\n  if (path.endsWith(\".gz\") || path.endsWith(\".bz2\")) {\n    DataInputStream dataInputStream=FileFactory.getDataInputStream(path,fileType,bufferSize);\n    inputStreamReader=new BufferedReader(new InputStreamReader(dataInputStream));\n  }\n else {\n    long startOffset=this.csvParserVo.getBlockDetailsList().get(blockCounter).getBlockOffset();\n    long blockLength=this.csvParserVo.getBlockDetailsList().get(blockCounter).getBlockLength();\n    long endOffset=blockLength + startOffset;\n    DataInputStream dataInputStream=FileFactory.getDataInputStream(path,fileType,bufferSize,startOffset);\n    if (startOffset != 0) {\n      LineReader lineReader=new LineReader(dataInputStream,1);\n      startOffset+=lineReader.readLine(new Text(),0);\n    }\n    inputStreamReader=new BufferedReader(new InputStreamReader(new BoundedDataStream(dataInputStream,endOffset - startOffset)));\n  }\n}\n", "nl": "Below method will be used to initialize the reader"}
{"code": "private static void inferConstraints(WidgetContainer base){\n  if (base == null) {\n    return;\n  }\n  if (base instanceof ConstraintWidgetContainer && ((ConstraintWidgetContainer)base).handlesInternalConstraints()) {\n    return;\n  }\n  int preX=base.getX();\n  int preY=base.getY();\n  base.setX(0);\n  base.setY(0);\n  for (  ConstraintWidget constraintWidget : base.getChildren()) {\n    if (constraintWidget instanceof ConstraintWidgetContainer) {\n      ConstraintWidgetContainer container=(ConstraintWidgetContainer)constraintWidget;\n      if (!container.getChildren().isEmpty()) {\n        inferConstraints(container);\n      }\n    }\n  }\n  ArrayList<ConstraintWidget> list=new ArrayList<>(base.getChildren());\n  list.add(0,base);\n  ConstraintWidget[] widgets=list.toArray(new ConstraintWidget[list.size()]);\n  ScoutWidget.computeConstraints(ScoutWidget.create(widgets));\n  base.setX(preX);\n  base.setY(preY);\n}\n", "nl": "Recursive decent of widget tree inferring constraints on ConstraintWidgetContainer"}
{"code": "@deprecated public StringBuffer format(Object obj,StringBuffer toAppendTo,FieldPosition pos){\n  TimeZone tz=null;\n  long date=System.currentTimeMillis();\n  if ((obj instanceof TimeZone)) {\n    tz=(TimeZone)obj;\n  }\n else   if ((obj instanceof Calendar)) {\n    tz=((Calendar)obj).getTimeZone();\n    date=((Calendar)obj).getTimeInMillis();\n  }\n else {\n    throw new IllegalArgumentException(\"Cannot format given Object (\" + obj.getClass().getName() + \") as a time zone\");\n  }\n  assert (tz != null);\n  String result=formatOffsetLocalizedGMT(tz.getOffset(date));\n  toAppendTo.append(result);\n  if ((pos.getFieldAttribute() == DateFormat.Field.TIME_ZONE) || (pos.getField() == 17)) {\n    pos.setBeginIndex(0);\n    pos.setEndIndex(result.length());\n  }\n  return toAppendTo;\n}\n", "nl": "/*     "}
{"code": "public void read(IInputReader reader) throws IOException {\n  final int magicNumber=reader.readInt();\n  if (magicNumber != RMA6File.MAGIC_NUMBER) {\n    throw new IOException(\"Not an RMA file\");\n  }\n  final int version=reader.readInt();\n  if (version != RMA6File.VERSION) {\n    throw new IOException(\"Not an RMA \" + RMA6File.VERSION + \" file\");\n  }\n  int minorVersion=reader.readInt();\n  creator=reader.readString();\n  creationDate=reader.readLong();\n  blastMode=BlastMode.valueOf(reader.readString());\n  pairedReads=(reader.read() == 1);\n  matchClassNames=new String[reader.readInt()];\n  for (int i=0; i < matchClassNames.length; i++) {\n    matchClassNames[i]=reader.readString();\n  }\n}\n", "nl": "read the header"}
{"code": "public static int tick2index(Track track,long tick){\n  int ret=0;\n  if (tick > 0) {\n    int low=0;\n    int high=track.size() - 1;\n    while (low < high) {\n      ret=(low + high) >> 1;\n      long t=track.get(ret).getTick();\n      if (t == tick) {\n        break;\n      }\n else       if (t < tick) {\n        if (low == high - 1) {\n          ret++;\n          break;\n        }\n        low=ret;\n      }\n else {\n        high=ret;\n      }\n    }\n  }\n  return ret;\n}\n", "nl": "Binary search for the event indexes of the track"}
{"code": "protected int findClosest(int c){\n  if (colorTab == null)   return -1;\n  int r=(c >> 16) & 0xff;\n  int g=(c >> 8) & 0xff;\n  int b=(c >> 0) & 0xff;\n  int minpos=0;\n  int dmin=256 * 256 * 256;\n  int len=colorTab.length;\n  for (int i=0; i < len; ) {\n    int dr=r - (colorTab[i++] & 0xff);\n    int dg=g - (colorTab[i++] & 0xff);\n    int db=b - (colorTab[i] & 0xff);\n    int d=dr * dr + dg * dg + db * db;\n    int index=i / 3;\n    if (usedEntry[index] && (d < dmin)) {\n      dmin=d;\n      minpos=index;\n    }\n    i++;\n  }\n  return minpos;\n}\n", "nl": "Returns index of palette color closest to c"}
{"code": "public void checkFileOkToRead() throws IOException {\n  if (fileType == Type.MEGAN_SERVER_FILE)   return;\n  File file=new File(fileName);\n  if (!file.canRead())   throw new IOException(\"File not readable: \" + fileName);\nswitch (fileType) {\ncase RMA1_FILE:\n{\n      throw new IOException(\"RMA version 1 not supported: \" + fileName);\n    }\ncase RMA2_FILE:\n{\n    int version=RMA2File.getRMAVersion(file);\n    if (version != 2)     throw new IOException(\"RMA version (\" + version + \") not supported: \"+ fileName);\n    if (!file.canWrite())     setReadOnly(true);\n    return;\n  }\ncase RMA3_FILE:\ncase RMA6_FILE:\ncase DAA_FILE:\ncase MEGAN_SUMMARY_FILE:\nif (!file.canWrite()) setReadOnly(true);\nreturn;\ndefault :\nthrow new IOException(\"File has unknown type: \" + fileName);\n}\n}\n", "nl": "is the set file ok to read?"}
{"code": "public static void loadPlatform() throws ConfigurationException, IOException {\n  SystemConfig sysConfig=SystemConfig.getInstance();\n  Properties addSysProps=sysConfig.getSystemProperties();\n  URL[] platformJARs=sysConfig.getPlatformJars();\n  if (platformJARs.length == 0)   throw new RuntimeException(\"No platformJARs have been defined\");\n  CommonClassLoader commonCL=CommonClassLoader.getInstance();\n  commonCL.addCommonJARs(platformJARs);\n  addSysProps=sysConfig.getSystemProperties();\n  if (logger.isLoggable(Level.FINE)) {\n    StringBuilder buff=new StringBuilder();\n    for (Enumeration<?> en=addSysProps.propertyNames(); en.hasMoreElements(); ) {\n      String name=(String)en.nextElement();\n      String value=addSysProps.getProperty(name);\n      buff.append(\"    \").append(name).append(\"=\").append(value);\n      buff.append(\"\\n\");\n    }\n    logger.fine(\"Configured System Properties {\\n\" + buff.toString() + \"}\");\n  }\n  Properties sysProps=System.getProperties();\n  sysProps.putAll(addSysProps);\n  System.setProperties(sysProps);\n  logger.finest(\"Full list of System Properties {\\n\" + System.getProperties() + \"}\");\n}\n", "nl": "Load the platformJARs and initialize any configured system properties"}
{"code": "private String downloadUrl(String strUrl) throws IOException {\n  String data=\"\";\n  InputStream iStream=null;\n  HttpURLConnection urlConnection=null;\n  try {\n    URL url=new URL(strUrl);\n    urlConnection=(HttpURLConnection)url.openConnection();\n    urlConnection.connect();\n    iStream=urlConnection.getInputStream();\n    BufferedReader br=new BufferedReader(new InputStreamReader(iStream));\n    StringBuffer sb=new StringBuffer();\n    String line=\"\";\n    while ((line=br.readLine()) != null) {\n      sb.append(line);\n    }\n    data=sb.toString();\n    br.close();\n  }\n catch (  Exception e) {\n    Log.d(\"Exc. while down url\",e.toString());\n  }\n finally {\n    iStream.close();\n    urlConnection.disconnect();\n  }\n  return data;\n}\n", "nl": "A method to download json data from url"}
{"code": "public void limitTransAndScale(Matrix matrix,RectF content){\n  matrix.getValues(matrixBuffer);\n  float curTransX=matrixBuffer[Matrix.MTRANS_X];\n  float curScaleX=matrixBuffer[Matrix.MSCALE_X];\n  float curTransY=matrixBuffer[Matrix.MTRANS_Y];\n  float curScaleY=matrixBuffer[Matrix.MSCALE_Y];\n  mScaleX=Math.min(Math.max(mMinScaleX,curScaleX),mMaxScaleX);\n  mScaleY=Math.min(Math.max(mMinScaleY,curScaleY),mMaxScaleY);\n  float width=0f;\n  float height=0f;\n  if (content != null) {\n    width=content.width();\n    height=content.height();\n  }\n  float maxTransX=-width * (mScaleX - 1f);\n  mTransX=Math.min(Math.max(curTransX,maxTransX - mTransOffsetX),mTransOffsetX);\n  float maxTransY=height * (mScaleY - 1f);\n  mTransY=Math.max(Math.min(curTransY,maxTransY + mTransOffsetY),-mTransOffsetY);\n  matrixBuffer[Matrix.MTRANS_X]=mTransX;\n  matrixBuffer[Matrix.MSCALE_X]=mScaleX;\n  matrixBuffer[Matrix.MTRANS_Y]=mTransY;\n  matrixBuffer[Matrix.MSCALE_Y]=mScaleY;\n  matrix.setValues(matrixBuffer);\n}\n", "nl": "limits the maximum scale and X translation of the given matrix"}
{"code": "public Matrix times(Matrix B){\n  if (B.m != n) {\n    throw new IllegalArgumentException(\"Matrix inner dimensions must agree.\");\n  }\n  Matrix X=new Matrix(m,B.n);\n  double[][] C=X.getArray();\n  double[] Bcolj=new double[n];\n  for (int j=0; j < B.n; j++) {\n    for (int k=0; k < n; k++) {\n      Bcolj[k]=B.A[k][j];\n    }\n    for (int i=0; i < m; i++) {\n      double[] Arowi=A[i];\n      double s=0;\n      for (int k=0; k < n; k++) {\n        s+=Arowi[k] * Bcolj[k];\n      }\n      C[i][j]=s;\n    }\n  }\n  return X;\n}\n", "nl": "Linear algebraic matrix multiplication, A * B"}
{"code": "public static <K>BigDecimal addToBigDecimalInMap(Map<K,Object> theMap,K mapKey,BigDecimal addNumber){\n  Object currentNumberObj=theMap.get(mapKey);\n  BigDecimal currentNumber=null;\n  if (currentNumberObj == null) {\n    currentNumber=ZERO_BD;\n  }\n else   if (currentNumberObj instanceof BigDecimal) {\n    currentNumber=(BigDecimal)currentNumberObj;\n  }\n else   if (currentNumberObj instanceof Double) {\n    currentNumber=new BigDecimal(((Double)currentNumberObj).doubleValue());\n  }\n else   if (currentNumberObj instanceof Long) {\n    currentNumber=new BigDecimal(((Long)currentNumberObj).longValue());\n  }\n else {\n    throw new IllegalArgumentException(\"In addToBigDecimalInMap found a Map value of a type not supported: \" + currentNumberObj.getClass().getName());\n  }\n  if (addNumber == null || ZERO_BD.compareTo(addNumber) == 0) {\n    return currentNumber;\n  }\n  currentNumber=currentNumber.add(addNumber);\n  theMap.put(mapKey,currentNumber);\n  return currentNumber;\n}\n", "nl": "Assuming theMap not null; if null will throw a NullPointerException"}
{"code": "private void drawComponentBackground(@NotNull Graphics2D gc,@NotNull NlComponent component){\n  if (component.viewInfo != null) {\n    int x=getSwingX(myScreenView,component.x);\n    int y=getSwingY(myScreenView,component.y);\n    int w=getSwingDimension(myScreenView,component.w);\n    int h=getSwingDimension(myScreenView,component.h);\n    Graphics2D g=(Graphics2D)gc.create();\n    if (!component.isRoot()) {\n      g.setPaint(new LinearGradientPaint((float)x,(float)y,(float)(x + BACKGROUND_LINE_SPACE_PX),(float)(y + BACKGROUND_LINE_SPACE_PX),COMPONENT_BACKGROUND_GRADIENT_FRACTIONS,COMPONENT_BACKGROUND_GRADIENT_COLORS,MultipleGradientPaint.CycleMethod.REFLECT));\n      g.fillRect(x,y,w,h);\n    }\n    g.setColor(BLUEPRINT_FG_COLOR);\n    Stroke prevStroke=g.getStroke();\n    g.setStroke(BLUEPRINT_COMPONENT_STROKE);\n    g.drawRect(x,y,w,h);\n    g.setStroke(prevStroke);\n    g.dispose();\n  }\n}\n", "nl": "Utility function to draw a component's background"}
{"code": "public static Long parseDate(Object value){\n  if (value == null) {\n    return null;\n  }\n  String str=(String)value;\n  try {\n    return Instant.parse(str).toEpochMilli();\n  }\n catch (  DateTimeParseException e) {\n    if (str.length() == 0) {\n      return null;\n    }\n    SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss Z\");\n    try {\n      return sdf.parse(str).getTime();\n    }\n catch (    ParseException e1) {\n      throw new IllegalArgumentException(\"Invalid datetime '\" + str + \"'; \"+ e1.getMessage());\n    }\n  }\n}\n", "nl": "Convert a string to a Date object"}
{"code": "private int processData(){\n  int bytes=ringBuffer.read(buffer,bufferSize);\n  Log.d(TAG,\"Read size: \" + bytes);\n  if (bytes > 0) {\n    short[] innerBuf=new short[bytes / 2];\n    ByteBuffer.wrap(buffer).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer().get(innerBuf);\n    int encodedSize=SimpleLame.encode(innerBuf,innerBuf,bytes / 2,mp3Buffer);\n    if (encodedSize < 0) {\n      Log.e(TAG,\"Lame encoded size: \" + encodedSize);\n    }\n    try {\n      os.write(mp3Buffer,0,encodedSize);\n    }\n catch (    IOException e) {\n      Log.e(TAG,\"Unable to write to file\");\n    }\n    return bytes;\n  }\n  return 0;\n}\n", "nl": "Get data from ring buffer Encode it to mp3 frames using lame encoder"}
{"code": "@Override public boolean onTouch(final View v,final MotionEvent event){\n  if (!lollipopAndAbove()) switch (event.getAction()) {\ncase MotionEvent.ACTION_DOWN:\n    gradientDrawable=new GradientDrawable();\n  gradientDrawable.setShape(GradientDrawable.OVAL);\ngradientDrawable.setSize(mOriginalThumbHeight / 2,mOriginalThumbHeight / 2);\ngradientDrawable.setColor(mIsEnabled ? mThumbColor : Color.LTGRAY);\ngradientDrawable.setDither(true);\ngradientDrawable.setAlpha(mThumbAlpha);\nsetThumb(gradientDrawable);\nbreak;\ncase MotionEvent.ACTION_UP:\ngradientDrawable=new GradientDrawable();\ngradientDrawable.setShape(GradientDrawable.OVAL);\ngradientDrawable.setSize(mOriginalThumbHeight / 3,mOriginalThumbHeight / 3);\ngradientDrawable.setColor(mIsEnabled ? mThumbColor : Color.LTGRAY);\ngradientDrawable.setDither(true);\ngradientDrawable.setAlpha(mThumbAlpha);\nsetThumb(gradientDrawable);\nbreak;\n}\nreturn false;\n}\n", "nl": "Touch listener for changing Thumb Drawable"}
{"code": "private void write(Writer w,boolean useOriginal) throws IOException {\n  if (useOriginal) {\n    originalData.disabledSamples.addAll(disabledSamples);\n    originalData.write(w,false);\n    originalData.disabledSamples.clear();\n  }\n else {\n    writeHeader(w);\n    for (    String classification : classification2class2counts.keySet()) {\n      Map<Integer,Integer[]> class2counts=classification2class2counts.get(classification);\n      classification=ClassificationType.getShortName(classification);\n      for (      Integer classId : class2counts.keySet()) {\n        Integer[] counts=class2counts.get(classId);\n        if (counts != null) {\n          w.write(classification + \"\\t\" + classId);\n          int last=Math.min(counts.length,getNumberOfSamples()) - 1;\n          while (last > 0 && (counts[last] == null || counts[last] == 0))           last--;\n          for (int i=0; i <= last; i++) {\n            if (i < counts.length)             w.write(\"\\t\" + (counts[i] != null ? counts[i] : 0));\n          }\n          w.write(\"\\n\");\n        }\n      }\n    }\n    w.write(\"END_OF_DATA_TABLE\\n\");\n  }\n}\n", "nl": "write data to writer"}
{"code": "private Map<String,List<ChartObject>> convertResult(StatisticsDocumentHandler handler){\n  DecimalFormat formatter=new DecimalFormat(\"###.##\");\n  List<ChartObject> objects=handler.getResult();\n  if (objects.isEmpty()) {\n    return new HashMap<>();\n  }\n  Map<String,List<ChartObject>> result=new HashMap<>();\n  for (  ChartObject object : objects) {\n    Map<String,String> values=new HashMap<>();\n    double failed=Integer.parseInt(object.getValues().get(getFailedFieldName()));\n    double skipped=Integer.parseInt(object.getValues().get(getSkippedFieldName()));\n    double total=Integer.parseInt(object.getValues().get(getTotalFieldName()));\n    if (total > 0) {\n      double percent=(failed + skipped) / total * 100;\n      values.put(NOT_PASSED_PERCENT,formatter.format(percent));\n    }\n else {\n      values.put(NOT_PASSED_PERCENT,\"0\");\n    }\n    object.setValues(values);\n  }\n  result.put(\"result\",objects);\n  return result;\n}\n", "nl": "Convert database query result to chart data"}
{"code": "public static void streamContentToBrowser(HttpServletResponse response,byte[] bytes,String contentType,String fileName) throws IOException {\n  setResponseBrowserProxyNoCache(response);\n  response.setContentLength(bytes.length);\n  if (contentType != null) {\n    response.setContentType(contentType);\n  }\n  if (fileName != null) {\n    response.setHeader(\"Content-Disposition\",\"attachment;filename=\\\"\" + fileName + \"\\\"\");\n  }\n  OutputStream out=response.getOutputStream();\n  InputStream in=new ByteArrayInputStream(bytes);\n  try {\n    streamContent(out,in,bytes.length);\n  }\n catch (  IOException e) {\n    in.close();\n    out.close();\n    throw e;\n  }\n  in.close();\n  out.flush();\n  out.close();\n}\n", "nl": "Stream an array of bytes to the browser This method will close the ServletOutputStream when finished"}
{"code": "public void actionPerformed(ActionEvent ev){\n  File lastOpenFile=ProgramProperties.getFile(MeganProperties.MEGANFILE);\n  MeganAndRMAFileFilter meganAndRMAFileFilter=new MeganAndRMAFileFilter();\n  meganAndRMAFileFilter.setAllowGZipped(true);\n  meganAndRMAFileFilter.setAllowZipped(true);\n  meganAndRMAFileFilter.add(MeganizedDAAFileFilter.getInstance());\n  getDir().notifyLockInput();\n  Collection<File> files;\n  try {\n    files=ChooseFileDialog.chooseFilesToOpen(getViewer().getFrame(),lastOpenFile,meganAndRMAFileFilter,meganAndRMAFileFilter,ev,\"Open MEGAN file\");\n  }\n  finally {\n    getDir().notifyUnlockInput();\n  }\n  if (files != null && files.size() > 0) {\n    final StringBuilder buf=new StringBuilder();\n    for (    File file : files) {\n      if (file != null && file.exists() && file.canRead()) {\n        ProgramProperties.put(MeganProperties.MEGANFILE,file.getAbsolutePath());\n        buf.append(\"open file='\").append(file.getPath()).append(\"';\");\n      }\n    }\n    execute(buf.toString());\n  }\n}\n", "nl": "action to be performed"}
{"code": "private static double[] computeShannonWeaver(MainViewer mainViewer,ProgressListener progressListener) throws IOException, CanceledException {\n  progressListener.setMaximum(2 * mainViewer.getSelectedNodes().size());\n  progressListener.setProgress(0);\n  int numberOfDatasets=mainViewer.getDir().getDocument().getNumberOfSamples();\n  double[] total=new double[numberOfDatasets];\n  for (  Node v : mainViewer.getSelectedNodes()) {\n    int[] summarized=mainViewer.getNodeData(v).getSummarized();\n    for (int i=0; i < summarized.length; i++)     total[i]+=summarized[i];\n    progressListener.incrementProgress();\n  }\n  double[] result=new double[numberOfDatasets];\n  for (int i=0; i < result.length; i++)   result[0]=0d;\n  for (  Node v : mainViewer.getSelectedNodes()) {\n    int[] summarized=mainViewer.getNodeData(v).getSummarized();\n    for (int i=0; i < summarized.length; i++) {\n      if (summarized[i] > 0) {\n        double p=summarized[i] / total[i];\n        result[i]+=p * Math.log(p) / LOG2;\n      }\n    }\n    progressListener.incrementProgress();\n  }\n  for (int i=0; i < result.length; i++)   result[i]=-result[i];\n  return result;\n}\n", "nl": "compute the Shannon-Weaver diversity index in bits"}
{"code": "public void onBindViewHolderItemType(T holder,ItemIndex index,ItemType itemType){\nswitch (itemType) {\ncase LVL3_ITEM:\n    onBindLvl3Item(holder,index);\n  break;\ncase LVL2_ITEM:\nonBindLvl2Item(holder,index);\nbreak;\ncase LVL1_ITEM:\nonBindLvl1Item(holder,index);\nbreak;\ncase LVL0_ITEM:\nonBindLvl0Item(holder,index);\nbreak;\ncase LVL3_SECTION:\nonBindLvl3Section(holder,index);\nbreak;\ncase LVL2_SECTION:\nonBindLvl2Section(holder,index);\ncase LVL1_SECTION:\nonBindLvl1Section(holder,index);\n}\n}\n", "nl": "main onBind method controls all other methods do not overwrite unless necessary"}
{"code": "private void checkRecycledViewPool(int viewType){\n  try {\n    if (mViewTypes.size() > MAX_VIEWTYPE_ALLOW_CACHE)     mAllowCacheViewHolder=false;\n    if (mDownForBidCacheViewHolder)     if (getHostView() != null && getHostView().getInnerView() != null)     getHostView().getInnerView().getRecycledViewPool().setMaxRecycledViews(viewType,0);\n    if (!mDownForBidCacheViewHolder) {\n      if (!mAllowCacheViewHolder) {\n        if (getHostView() != null && getHostView().getInnerView() != null) {\n          for (int i=0; i < mViewTypes.size(); i++) {\n            getHostView().getInnerView().getRecycledViewPool().setMaxRecycledViews(mViewTypes.keyAt(i),0);\n          }\n          mDownForBidCacheViewHolder=true;\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    WXLogUtils.e(TAG,\"Clear recycledViewPool error!\");\n  }\n}\n", "nl": "Forbid ViewHolder cache if viewType > MAX_VIEWTYPE_ALLOW_CACHE"}
{"code": "public static Map deleteOrderItemShipGroup(DispatchContext ctx,Map context) throws GenericEntityException {\n  Delegator delegator=ctx.getDelegator();\n  Map<String,Object> result=new HashMap<String,Object>();\n  GenericValue orderItemShipGroup=(GenericValue)context.get(\"orderItemShipGroup\");\n  if (UtilValidate.isEmpty(orderItemShipGroup)) {\n    String orderId=(String)context.get(\"orderId\");\n    GenericValue orderHeader=EntityQuery.use(delegator).from(\"OrderHeader\").where(\"orderId\",orderId).queryOne();\n    String shipGroupSeqId=(String)context.get(\"shipGroupSeqId\");\n    if (UtilValidate.isNotEmpty(orderHeader) && UtilValidate.isNotEmpty(shipGroupSeqId)) {\n      orderItemShipGroup=EntityQuery.use(delegator).from(\"OrderItemShipGroup\").where(\"orderId\",orderId,\"shipGroupSeqId\",shipGroupSeqId).queryOne();\n      if (UtilValidate.isEmpty(orderItemShipGroup)) {\n        return ServiceUtil.returnError(\"OrderItemShipGroup Does Not Exist\");\n      }\n    }\n  }\n  if (UtilValidate.isNotEmpty(orderItemShipGroup)) {\n    orderItemShipGroup.remove();\n    result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_SUCCESS);\n  }\n  return result;\n}\n", "nl": "Remove an OrderItemShipGroup record"}
{"code": "public static void streamContentToBrowser(HttpServletResponse response,InputStream in,int length,String contentType,String fileName) throws IOException {\n  setResponseBrowserProxyNoCache(response);\n  response.setContentLength(length);\n  if (contentType != null) {\n    response.setContentType(contentType);\n  }\n  if (fileName != null) {\n    response.setHeader(\"Content-Disposition\",\"attachment;filename=\\\"\" + fileName + \"\\\"\");\n  }\n  OutputStream out=response.getOutputStream();\n  try {\n    streamContent(out,in,length);\n  }\n catch (  IOException e) {\n    out.close();\n    throw e;\n  }\n  out.flush();\n  out.close();\n}\n", "nl": "Streams content from InputStream to the ServletOutputStream This method will close the ServletOutputStream when finished This method does not close the InputSteam passed"}
{"code": "public android.os.IBinder onBind(android.content.Intent intent){\n  if (ScriptLoader.isCalledFromJRuby())   return null;\n  preOnBind(intent);\n  if (JRubyAdapter.isInitialized() && scriptInfo.isReadyToLoad()) {\n    ScriptLoader.loadScript(this);\n  }\n else {\n    return null;\n  }\n  String rubyClassName=scriptInfo.getRubyClassName();\n  if (rubyClassName == null)   return null;\n  if ((Boolean)JRubyAdapter.runScriptlet(rubyClassName + \".instance_methods(false).any?{|m| m.to_sym == :onBind}\")) {\n    return (android.os.IBinder)JRubyAdapter.runRubyMethod(android.os.IBinder.class,scriptInfo.getRubyInstance(),\"onBind\",intent);\n  }\n else {\n    if ((Boolean)JRubyAdapter.runScriptlet(rubyClassName + \".instance_methods(false).any?{|m| m.to_sym == :on_bind}\")) {\n      return (android.os.IBinder)JRubyAdapter.runRubyMethod(android.os.IBinder.class,scriptInfo.getRubyInstance(),\"on_bind\",intent);\n    }\n else {\n      if ((Boolean)JRubyAdapter.runScriptlet(rubyClassName + \".instance_methods(true).any?{|m| m.to_sym == :on_bind}\")) {\n        return (android.os.IBinder)JRubyAdapter.runRubyMethod(android.os.IBinder.class,scriptInfo.getRubyInstance(),\"on_bind\",intent);\n      }\n else {\n        return (android.os.IBinder)JRubyAdapter.runRubyMethod(android.os.IBinder.class,scriptInfo.getRubyInstance(),\"onBind\",intent);\n      }\n    }\n  }\n}\n", "nl": "Generated Methods"}
{"code": "public void close(){\n  logger.info(\"Closing monitor service.\");\n  if (null != dlClient) {\n    dlClient.close();\n  }\n  if (null != zkServerSets) {\n    for (    DLZkServerSet zkServerSet : zkServerSets) {\n      zkServerSet.close();\n    }\n  }\n  if (null != dlNamespace) {\n    dlNamespace.close();\n  }\n  executorService.shutdown();\n  try {\n    if (!executorService.awaitTermination(1,TimeUnit.MINUTES)) {\n      executorService.shutdownNow();\n    }\n  }\n catch (  InterruptedException e) {\n    logger.error(\"Interrupted on waiting shutting down monitor executor service : \",e);\n  }\n  if (null != statsProvider) {\n    statsProvider.stop();\n  }\n  keepAliveLatch.countDown();\n  logger.info(\"Closed monitor service.\");\n}\n", "nl": "Close the server"}
{"code": "public void start(){\n  if (isActive) {\n    return;\n  }\n  log.info(\"Starting up the default async job executor [{}].\",getClass().getName());\n  if (timerJobRunnable == null) {\n    timerJobRunnable=new AcquireTimerJobsRunnable(this,processEngineConfiguration.getJobManager());\n  }\n  if (resetExpiredJobsRunnable == null) {\n    resetExpiredJobsRunnable=new ResetExpiredJobsRunnable(this);\n  }\n  if (!isMessageQueueMode && asyncJobsDueRunnable == null) {\n    asyncJobsDueRunnable=new AcquireAsyncJobsDueRunnable(this);\n  }\n  if (!isMessageQueueMode) {\n    initAsyncJobExecutionThreadPool();\n    startJobAcquisitionThread();\n  }\n  startTimerAcquisitionThread();\n  startResetExpiredJobsThread();\n  isActive=true;\n  executeTemporaryJobs();\n}\n", "nl": "Starts the async executor"}
{"code": "@Deprecated public void initialiseVerticalStepperForm(String[] stepsTitles,int colorPrimary,int colorPrimaryDark,VerticalStepperForm verticalStepperForm,Activity activity){\n  this.alphaOfDisabledElements=0.25f;\n  this.buttonTextColor=Color.rgb(255,255,255);\n  this.buttonPressedTextColor=Color.rgb(255,255,255);\n  this.stepNumberTextColor=Color.rgb(255,255,255);\n  this.stepTitleTextColor=Color.rgb(33,33,33);\n  this.stepSubtitleTextColor=Color.rgb(162,162,162);\n  this.stepNumberBackgroundColor=colorPrimary;\n  this.buttonBackgroundColor=colorPrimary;\n  this.buttonPressedBackgroundColor=colorPrimaryDark;\n  this.errorMessageTextColor=Color.rgb(175,18,18);\n  this.displayBottomNavigation=true;\n  this.materialDesignInDisabledSteps=false;\n  this.hideKeyboard=true;\n  this.showVerticalLineWhenStepsAreCollapsed=false;\n  this.verticalStepperFormImplementation=verticalStepperForm;\n  this.activity=activity;\n  initStepperForm(stepsTitles,null);\n}\n", "nl": "Set up and initialize the form"}
{"code": "public void testDeployIntermediateVersionWithoutMessageStartEvent(){\n  String deploymentId1=deployStartMessageTestProcess();\n  assertEquals(1,getAllEventSubscriptions().size());\n  assertEquals(0,runtimeService.createProcessInstanceQuery().count());\n  runtimeService.startProcessInstanceByMessageAndTenantId(\"myStartMessage\",TENANT_ID);\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  assertEventSubscriptionsCount(1);\n  String deploymentId2=deployProcessWithoutEvents();\n  assertEquals(0,getAllEventSubscriptions().size());\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  try {\n    runtimeService.startProcessInstanceByMessageAndTenantId(\"myStartMessage\",TENANT_ID);\n    fail();\n  }\n catch (  Exception e) {\n  }\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  assertEventSubscriptionsCount(0);\n  String deploymentId3=deployStartMessageTestProcess();\n  assertEquals(1,getAllEventSubscriptions().size());\n  assertEquals(1,runtimeService.createProcessInstanceQuery().count());\n  runtimeService.startProcessInstanceByMessageAndTenantId(\"myStartMessage\",TENANT_ID);\n  assertEquals(2,runtimeService.createProcessInstanceQuery().count());\n  assertEventSubscriptionsCount(1);\n  List<EventSubscriptionEntity> eventSubscriptions=getAllEventSubscriptions();\n  assertEquals(repositoryService.createProcessDefinitionQuery().deploymentId(deploymentId3).singleResult().getId(),eventSubscriptions.get(0).getProcessDefinitionId());\n  cleanup(deploymentId1,deploymentId2,deploymentId3);\n}\n", "nl": "v1 -> has start message event v2 -> has no start message event v3 -> has start message event"}
{"code": "private void exportToYSLD(){\n  SLDWriterInterface ysldWriter=SLDWriterFactory.createWriter(SLDOutputFormatEnum.YSLD);\n  for (  SLDDataInterface sldData : sldDataList) {\n    StyledLayerDescriptor sld=SLDUtils.createSLDFromString(sldData);\n    String layerName=sldData.getLayerNameWithOutSuffix();\n    if (sld != null) {\n      String sldString=ysldWriter.encodeSLD(sldData.getResourceLocator(),sld);\n      String ysldFilename=layerName + \".\" + YSLDTool.YSLD_FILE_EXTENSION;\n      String destinationFolder=sldData.getSLDFile().getParent();\n      File fileToSave=new File(destinationFolder,ysldFilename);\n      if (fileToSave.exists()) {\n        ConsoleManager.getInstance().error(this,Localisation.getField(YSLDTool.class,\"YSLDTool.destinationAlreadyExists\") + \" \" + ysldFilename);\n      }\n else {\n        ConsoleManager.getInstance().information(this,Localisation.getField(YSLDTool.class,\"YSLDTool.exportToYSLDMsg\") + \" \" + ysldFilename);\n        BufferedWriter out;\n        try {\n          out=new BufferedWriter(new FileWriter(fileToSave));\n          out.write(sldString);\n          out.close();\n        }\n catch (        IOException e) {\n          ConsoleManager.getInstance().exception(this,e);\n        }\n      }\n    }\n  }\n}\n", "nl": "Export to YSLD"}
{"code": "public String createContainerName(String name){\n  boolean valid=false;\n  int counter=1;\n  while (!valid) {\n    String candidate=name + counter;\n    boolean exists=false;\n    for (    ConstraintWidget widget : mWidgets.values()) {\n      if (widget.getDebugName().equalsIgnoreCase(candidate)) {\n        exists=true;\n        break;\n      }\n    }\n    if (!exists) {\n      valid=true;\n      name=candidate;\n    }\n else {\n      counter++;\n    }\n  }\n  return name;\n}\n", "nl": "Utility function returning a new unique name for a container"}
{"code": "private Map<String,Integer> loadAssignmentFiles(String cName,String fileName){\n  final File file=new File(Basic.replaceFileSuffix(fileName,\".\" + cName.toLowerCase()));\n  if (file.exists() && file.canRead()) {\n    System.err.println(\"External assignment file for \" + cName + \" detected: \"+ fileName);\n    final Map<String,Integer> map=new HashMap<>();\n    try (final FileInputIterator it=new FileInputIterator(file,true)){\n      while (it.hasNext()) {\n        final String[] tokens=Basic.split(it.next(),'\\t');\n        if (tokens.length == 2 && Basic.isInteger(tokens[1])) {\n          map.put(tokens[0],Basic.parseInt(tokens[1]));\n        }\n      }\n    }\n catch (    IOException ex) {\n      System.err.println(ex.getMessage());\n    }\n    System.err.println(\"Count: \" + map.size());\n    if (map.size() > 0)     return map;\n  }\n  return null;\n}\n", "nl": "load all assignment files"}
{"code": "private static int parseInt(String value,int beginIndex,int endIndex) throws NumberFormatException {\n  if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\n    throw new NumberFormatException(value);\n  }\n  int i=beginIndex;\n  int result=0;\n  int digit;\n  if (i < endIndex) {\n    digit=Character.digit(value.charAt(i++),10);\n    if (digit < 0) {\n      throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex,endIndex));\n    }\n    result=-digit;\n  }\n  while (i < endIndex) {\n    digit=Character.digit(value.charAt(i++),10);\n    if (digit < 0) {\n      throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex,endIndex));\n    }\n    result*=10;\n    result-=digit;\n  }\n  return -result;\n}\n", "nl": "Parse an integer located between 2 given offsets in a string"}
{"code": "public static boolean checkPointWithMultiPolygon(double longitude,double latitude,String multiPolygonJson,FeatureType featureType){\n  try {\n    boolean contains=false;\n    GeometryJSON gtjson=new GeometryJSON();\n    Point point=getGeoJsonPoint(longitude,latitude);\n    if (point != null && point.isValid()) {\n      if (featureType == FeatureType.POLYGON) {\n        Polygon polygon=gtjson.readPolygon(new StringReader(\"{\\\"type\\\":\\\"Polygon\\\", \\\"coordinates\\\":\" + multiPolygonJson + \"}\"));\n        contains=polygon.contains(point);\n      }\n else       if (featureType == FeatureType.MULTI_POLYGON) {\n        MultiPolygon multiPolygon=gtjson.readMultiPolygon(new StringReader(\"{\\\"type\\\":\\\"MultiPolygon\\\", \\\"coordinates\\\":\" + multiPolygonJson + \"}\"));\n        contains=multiPolygon.contains(point);\n      }\n    }\n    return contains;\n  }\n catch (  Exception ex) {\n    return false;\n  }\n}\n", "nl": "Check if the point coordinate falls within the polygon/MultiPolygon Shape"}
{"code": "private void readSudoUserinformationFromFile(){\n  BufferedReader br;\n  try {\n    br=new BufferedReader(new FileReader(Settings.sServerInfo));\n    sSudoID=EncryptionManager.decrypt64bits(br.readLine());\n    sSudoPassword=EncryptionManager.decrypt64bits(br.readLine());\n    sEmailAddress=EncryptionManager.decrypt64bits(br.readLine());\n    isMakeSudoId=Boolean.parseBoolean(EncryptionManager.decrypt64bits(br.readLine()));\n    br.close();\n  }\n catch (  FileNotFoundException e) {\n    System.out.println(\"serverinfo.jrc do not exist\");\n  }\ncatch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  Exception e) {\n    e.printStackTrace();\n  }\n  System.out.println(\"file reading complete\");\n}\n", "nl": "read sudo user information - encrypted by using AES 64bits"}
{"code": "private void drawDrawable(Canvas canvas,Bitmap bitmap){\n  Paint paint=new Paint();\n  paint.setColor(0xffffffff);\n  paint.setAntiAlias(true);\n  PorterDuffXfermode xfermode=new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);\n  int saveFlags=Canvas.MATRIX_SAVE_FLAG | Canvas.CLIP_SAVE_FLAG | Canvas.HAS_ALPHA_LAYER_SAVE_FLAG| Canvas.FULL_COLOR_LAYER_SAVE_FLAG| Canvas.CLIP_TO_LAYER_SAVE_FLAG;\n  canvas.saveLayer(0,0,width,height,null,saveFlags);\n  if (shapeType == 1) {\n    canvas.drawCircle(width / 2,height / 2,width / 2 - 1,paint);\n  }\n else   if (shapeType == 2) {\n    RectF rectf=new RectF(1,1,getWidth() - 1,getHeight() - 1);\n    canvas.drawRoundRect(rectf,radius + 1,radius + 1,paint);\n  }\n  paint.setXfermode(xfermode);\n  float scaleWidth=((float)getWidth()) / bitmap.getWidth();\n  float scaleHeight=((float)getHeight()) / bitmap.getHeight();\n  Matrix matrix=new Matrix();\n  matrix.postScale(scaleWidth,scaleHeight);\n  bitmap=Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,true);\n  canvas.drawBitmap(bitmap,0,0,paint);\n  canvas.restore();\n}\n", "nl": "draw Rounded Rectangle"}
{"code": "private void processRequest(Map<String,Object> request){\n  Map<String,Object> config=new HashMap<>();\n  request.put(\"Config\",config);\n  config.put(\"Hostname\",request.remove(\"Hostname\"));\n  config.put(\"Cmd\",request.remove(\"Cmd\"));\n  config.put(\"Env\",request.remove(\"Env\"));\n  @SuppressWarnings(\"unchecked\") Map<String,Object> hostConfig=(Map<String,Object>)request.get(\"HostConfig\");\n  if (hostConfig == null) {\n    hostConfig=new HashMap<>();\n    request.put(\"HostConfig\",hostConfig);\n  }\n  Map<String,String> portMapping=new HashMap<>();\n  portMapping.put(\"HostIp\",\"0.0.0.0\");\n  portMapping.put(\"HostPort\",\"9999\");\n  List<Map<String,String>> portMappings=Collections.singletonList(portMapping);\n  Map<String,List<Map<String,String>>> allPortMappings=new HashMap<>();\n  allPortMappings.put(\"8080/tcp\",portMappings);\n  hostConfig.put(\"PortBindings\",allPortMappings);\n  Map<String,Object> networkSettings=new HashMap<>();\n  request.put(\"NetworkSettings\",networkSettings);\n  networkSettings.put(\"Ports\",allPortMappings);\n}\n", "nl": "Move request properties to the Config object before storing the state"}
{"code": "private int removeRowsById(String msgId){\n  int position=-1;\n  if (StringUtil.isNotBlank(msgId)) {\n    boolean find=false;\n    Iterator<Row> iterator=rows.iterator();\n    while (iterator.hasNext()) {\n      Row row=iterator.next();\n      if (msgId.equals(row.getMessage().get_id())) {\n        find=true;\n        position=rows.indexOf(row);\n        iterator.remove();\n      }\n      if (find && !msgId.equals(row.getMessage().get_id())) {\n        break;\n      }\n    }\n  }\n  return position;\n}\n", "nl": "remove rows by id & return the position"}
{"code": "public static StringBuilder readFile(String filePath,String charsetName){\n  File file=new File(filePath);\n  StringBuilder fileContent=new StringBuilder(\"\");\n  if (file == null || !file.isFile()) {\n    return null;\n  }\n  BufferedReader reader=null;\n  try {\n    InputStreamReader is=new InputStreamReader(new FileInputStream(file),charsetName);\n    reader=new BufferedReader(is);\n    String line=null;\n    while ((line=reader.readLine()) != null) {\n      if (!fileContent.toString().equals(\"\")) {\n        fileContent.append(\"\\r\\n\");\n      }\n      fileContent.append(line);\n    }\n    return fileContent;\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"IOException occurred. \",e);\n  }\n finally {\n    IOUtil.close(reader);\n  }\n}\n", "nl": "read file"}
{"code": "public boolean fieldsExistsInHost(){\n  Structure hostStructure=StructureFactory.getStructureByVelocityVarName(\"Host\");\n  List<Field> fieldsInStructure=FieldFactory.getFieldsByStructure(hostStructure.getInode());\n  for (  Field f : fieldsInStructure) {\n    if (Configuration.HOSTFIELDNAME_TWITTERCONSUMERKEY.equalsIgnoreCase(f.getFieldName())) {\n      fieldTwitterConsumerKeyExists=true;\n    }\n else     if (Configuration.HOSTFIELDNAME_TWITTERSECRETCONSUMERKEY.equalsIgnoreCase(f.getFieldName())) {\n      fieldTwitterSecretConsumerKeyExists=true;\n    }\n else     if (Configuration.HOSTFIELDNAME_TWITTERACCESSTOKEN.equalsIgnoreCase(f.getFieldName())) {\n      fieldTwitterAccessTokenExists=true;\n    }\n else     if (Configuration.HOSTFIELDNAME_TWITTERSECRETACCESSTOKEN.equalsIgnoreCase(f.getFieldName())) {\n      fieldTwitterSecretAccessTokenExists=true;\n    }\n else     if (Configuration.HOSTFIELDNAME_TWITTERLINEDIVIDER.equalsIgnoreCase(f.getFieldName())) {\n      fieldLinedividerTwitterConfigurationExists=true;\n    }\n  }\n  if (!fieldTwitterConsumerKeyExists || !fieldTwitterSecretConsumerKeyExists || !fieldTwitterAccessTokenExists|| !fieldTwitterSecretAccessTokenExists|| !fieldLinedividerTwitterConfigurationExists) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Check if all the required configuration fields already exists in the Host structure"}
{"code": "public static void mergeServiceDocuments(ServiceDocument copyTo,ServiceDocument copyFrom,BinaryOperator<Object> fieldMergeStrategy){\n  for (  Field field : copyFrom.getClass().getFields()) {\n    if (ServiceDocument.isBuiltInDocumentField(field.getName()) || Modifier.isStatic(field.getModifiers())) {\n      continue;\n    }\n    try {\n      Object value=field.get(copyFrom);\n      Object oldValue=field.get(copyTo);\n      field.set(copyTo,fieldMergeStrategy.apply(oldValue,value));\n    }\n catch (    IllegalArgumentException|IllegalAccessException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  long exp=copyFrom.documentExpirationTimeMicros;\n  if (exp != 0) {\n    copyTo.documentExpirationTimeMicros=exp < 0 ? 0 : exp;\n  }\n}\n", "nl": "Perform merge of ServiceDocuments using the given strategy"}
{"code": "public static RecvHeaderInfo recvHeader(InputStream in,byte expect_cmd,long expect_body_len) throws IOException {\n  byte[] header;\n  int bytes;\n  long pkg_len;\n  header=new byte[FDFS_PROTO_PKG_LEN_SIZE + 2];\n  if ((bytes=in.read(header)) != header.length) {\n    throw new IOException(\"recv package size \" + bytes + \" != \"+ header.length);\n  }\n  if (header[PROTO_HEADER_CMD_INDEX] != expect_cmd) {\n    throw new IOException(\"recv cmd: \" + header[PROTO_HEADER_CMD_INDEX] + \" is not correct, expect cmd: \"+ expect_cmd);\n  }\n  if (header[PROTO_HEADER_STATUS_INDEX] != 0) {\n    return new RecvHeaderInfo(header[PROTO_HEADER_STATUS_INDEX],0);\n  }\n  pkg_len=ProtoCommon.buff2long(header,0);\n  if (pkg_len < 0) {\n    throw new IOException(\"recv body length: \" + pkg_len + \" < 0!\");\n  }\n  if (expect_body_len >= 0 && pkg_len != expect_body_len) {\n    throw new IOException(\"recv body length: \" + pkg_len + \" is not correct, expect length: \"+ expect_body_len);\n  }\n  return new RecvHeaderInfo((byte)0,pkg_len);\n}\n", "nl": "receive pack header"}
{"code": "private void writeState(DataOutputStream dos) throws IOException {\n  dos.writeInt(REPOSITORIES_STATE_FILE_VERSION_3);\n  Collection<ISVNRepositoryLocation> repos=repositories.values();\n  dos.writeInt(repos.size());\n  for (  ISVNRepositoryLocation reposLocation : repos) {\n    SVNRepositoryLocation root=(SVNRepositoryLocation)reposLocation;\n    dos.writeUTF(root.getLocation());\n    if (root.getLabel() == null) {\n      dos.writeUTF(\"\");\n    }\n else {\n      dos.writeUTF(root.getLabel());\n    }\n    if (root.getRepositoryRoot() == null) {\n      dos.writeUTF(\"\");\n    }\n else {\n      dos.writeUTF(root.getRepositoryRoot().toString());\n    }\n  }\n  dos.flush();\n  dos.close();\n}\n", "nl": "write the state of the plugin ie the repositories locations"}
{"code": "private boolean parseOptions(){\n  boolean valid=true;\n  if (hasOption(LOCALPROPFILE)) {\n    SystemConfiguration.loadPropsFromFile(new File(getOptionValue(LOCALPROPFILE)));\n  }\n else {\n    for (    String prop : QuerierProps.PROPSLIST) {\n      if (hasOption(prop)) {\n        SystemConfiguration.setProperty(prop,getOptionValue(prop));\n      }\n    }\n  }\n  valid=QuerierProps.validateQuerierProperties();\n  if (valid) {\n    logger.info(\"loading schemas: dataSchemas = \" + SystemConfiguration.getProperty(\"data.schemas\") + \" querySchemas = \"+ SystemConfiguration.getProperty(\"query.schemas\"));\n    try {\n      DataSchemaLoader.initialize();\n      QuerySchemaLoader.initialize();\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n    }\n  }\n  return valid;\n}\n", "nl": "Method to parse and validate the options provided"}
{"code": "private long trySync(String oldLibrary,String newLibrary){\n  JSONObject request=new JSONObject();\n  try {\n    request.put(\"old_library\",oldLibrary);\n    request.put(\"new_library\",newLibrary);\n    request.put(\"favorites_only\",favoritesOnly);\n    JSONObject results=new JSONObject(httpClient.postRequest(syncEndpoint,Collections.<String,String>emptyMap(),request.toString()));\n    if (!results.getBoolean(\"success\")) {\n      throw new RuntimeException(\"Sync failed!\");\n    }\n    return results.getLong(\"task_id\");\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n    throw new RuntimeException(\"Exception making HTTP request!\");\n  }\ncatch (  JSONException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Start a sync"}
{"code": "public static void prepareMatrix(MatrixInterface adjMatrix){\n  if (adjMatrix instanceof SparseMatrix) {\n    prepareSparseMatrix((SparseMatrix)adjMatrix);\n  }\n else {\n    for (int i=0; i != adjMatrix.getRowsCount(); i++) {\n      double sum=0.0;\n      for (int j=0; j != adjMatrix.getColsCount(); j++) {\n        sum+=adjMatrix.get(i,j);\n      }\n      if (sum != 0.0) {\n        for (int j=0; j != adjMatrix.getColsCount(); j++)         adjMatrix.set(i,j,adjMatrix.get(i,j) / sum);\n      }\n else {\n        double tmp=1.0 / adjMatrix.getColsCount();\n        for (int j=0; j != adjMatrix.getColsCount(); j++) {\n          adjMatrix.set(i,j,tmp);\n        }\n      }\n    }\n    adjMatrix.inv();\n  }\n}\n", "nl": "Transfer the adjacency matrix into the form pagerank can use, that's normalization and transposition"}
{"code": "public void computeGapAreas(){\n  Rectangle gap=new Rectangle();\n  int area=0;\n  for (int i=0; i < mRectList.length; i++) {\n    Rectangle rectangleA=mRectList[i];\n    for (int j=i + 1; j < mRectList.length; j++) {\n      Rectangle rectangleB=mRectList[j];\n      boolean viable=calculateGap(rectangleA,rectangleB,gap);\n      if (viable) {\n        for (int k=0; k < mRectList.length; k++) {\n          if (k != j && k != i) {\n            if (gap.intersects(mRectList[k])) {\n              viable=false;\n              break;\n            }\n          }\n        }\n      }\n      if (viable) {\n        area+=gap.width * gap.height;\n      }\n    }\n  }\n  mGapArea=area;\n}\n", "nl": "compute the area of the gaps between rectangles in the list"}
{"code": "public static Object invokeMethod(Class<?> clazz,Object obj,String name,Class<?>[] parameterTypes,Object[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n  if (clazz == null || obj == null || name == null) {\n    throw new IllegalArgumentException(\"arguments cannot be null.\");\n  }\n  if (parameterTypes != null && args != null && parameterTypes.length > 0 && args.length > 0) {\n    if (parameterTypes.length == args.length) {\n      Method method=clazz.getDeclaredMethod(name,parameterTypes);\n      if (!method.isAccessible()) {\n        method.setAccessible(true);\n      }\n      return method.invoke(obj,args);\n    }\n  }\n else {\n    Method method=clazz.getDeclaredMethod(name);\n    if (!method.isAccessible()) {\n      method.setAccessible(true);\n    }\n    return method.invoke(obj);\n  }\n  return null;\n}\n", "nl": "invoke method with arguments"}
{"code": "public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"set nodeColor=\");\n  final Color color=np.getColor();\n  final java.util.List<String> samples=new LinkedList<>();\n  if (np.peekMatchIgnoreCase(\"sample=\")) {\n    np.matchIgnoreCase(\"sample=\");\n    while (!np.peekMatchIgnoreCase(\";\")) {\n      samples.add(np.getWordRespectCase());\n    }\n  }\n  np.matchIgnoreCase(\";\");\n  final Document doc=((Director)getDir()).getDocument();\n  if (samples.size() == 0)   samples.addAll(doc.getSampleSelection().getAll());\n  if (samples.size() > 0) {\n    for (    String sample : samples) {\n      doc.getSampleAttributeTable().putSampleColor(sample,color);\n    }\n    doc.setDirty(true);\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "private double[] readSPTKF0Data(String lf0SPTKFile) throws IOException {\n  if (!FileUtils.exists(lf0SPTKFile)) {\n    System.out.println(\"SPTK Pitch file not found: \" + lf0SPTKFile);\n    return null;\n  }\n  int numberOfFrames=getNumberOfFrames(lf0SPTKFile);\n  LEDataInputStream lf0Data=new LEDataInputStream(new BufferedInputStream(new FileInputStream(lf0SPTKFile)));\n  double[] f0Data=new double[numberOfFrames];\n  for (int i=0; i < numberOfFrames; i++) {\n    float f0Value=lf0Data.readFloat();\n    if (f0Value < 0) {\n      f0Data[i]=0.0f;\n    }\n else {\n      f0Data[i]=new Double(Math.exp(f0Value));\n    }\n  }\n  return f0Data;\n}\n", "nl": "convert a SPTK file into contour[]"}
{"code": "public void populateApiLevels(int apiLevel,@Nullable IAndroidTarget apiTarget,@NotNull ScopedStateStore state){\n  if (apiLevel >= 1) {\n    if (apiTarget == null) {\n      state.put(myBuildApiKey,Integer.toString(apiLevel));\n    }\n else     if (!apiTarget.isPlatform()) {\n      state.put(myBuildApiKey,AndroidTargetHash.getTargetHashString(apiTarget));\n    }\n else {\n      state.put(myBuildApiKey,TemplateMetadata.getBuildApiString(apiTarget.getVersion()));\n    }\n    state.put(myBuildApiLevelKey,apiLevel);\n    if (apiLevel >= SdkVersionInfo.HIGHEST_KNOWN_API || (apiTarget != null && apiTarget.getVersion().isPreview())) {\n      state.put(myTargetApiLevelKey,apiLevel);\n      if (apiTarget != null) {\n        state.put(myTargetApiStringKey,apiTarget.getVersion().getApiString());\n      }\n else {\n        state.put(myTargetApiStringKey,Integer.toString(apiLevel));\n      }\n    }\n else     if (ourHighestInstalledApiTarget != null) {\n      state.put(myTargetApiLevelKey,ourHighestInstalledApiTarget.getVersion().getApiLevel());\n      state.put(myTargetApiStringKey,ourHighestInstalledApiTarget.getVersion().getApiString());\n    }\n  }\n}\n", "nl": "Populate the api variables in the given state store"}
{"code": "public Builder cloneFrom(DisplayImageOptions options){\n  imageResOnLoading=options.imageResOnLoading;\n  imageResForEmptyUri=options.imageResForEmptyUri;\n  imageResOnFail=options.imageResOnFail;\n  imageOnLoading=options.imageOnLoading;\n  imageForEmptyUri=options.imageForEmptyUri;\n  imageOnFail=options.imageOnFail;\n  resetViewBeforeLoading=options.resetViewBeforeLoading;\n  cacheInMemory=options.cacheInMemory;\n  cacheOnDisk=options.cacheOnDisk;\n  imageScaleType=options.imageScaleType;\n  decodingOptions=options.decodingOptions;\n  delayBeforeLoading=options.delayBeforeLoading;\n  considerExifParams=options.considerExifParams;\n  extraForDownloader=options.extraForDownloader;\n  preProcessor=options.preProcessor;\n  postProcessor=options.postProcessor;\n  displayer=options.displayer;\n  handler=options.handler;\n  isSyncLoading=options.isSyncLoading;\n  return this;\n}\n", "nl": "Sets all options equal to incoming options"}
{"code": "public static String uri2FilePath(final Context context,final Uri uri){\n  if (null == uri)   return null;\n  final String scheme=uri.getScheme();\n  String data=null;\n  if (scheme == null)   data=uri.getPath();\n else   if (ContentResolver.SCHEME_FILE.equals(scheme)) {\n    data=uri.getPath();\n  }\n else   if (ContentResolver.SCHEME_CONTENT.equals(scheme)) {\n    Cursor cursor=context.getContentResolver().query(uri,new String[]{MediaStore.Images.ImageColumns.DATA},null,null,null);\n    if (null != cursor) {\n      if (cursor.moveToFirst()) {\n        int index=cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);\n        if (index > -1) {\n          data=cursor.getString(index);\n        }\n      }\n      cursor.close();\n    }\n  }\n  return data;\n}\n", "nl": "Try to return the absolute file path from the given Uri"}
{"code": "private int generateViewType(WXComponent component){\n  long id;\n  try {\n    id=Integer.parseInt(component.getDomObject().ref);\n    String type=component.getDomObject().attr.getScope();\n    if (!TextUtils.isEmpty(type)) {\n      if (mRefToViewType == null) {\n        mRefToViewType=new ArrayMap<>();\n      }\n      if (!mRefToViewType.containsKey(type)) {\n        mRefToViewType.put(type,id);\n      }\n      id=mRefToViewType.get(type);\n    }\n  }\n catch (  RuntimeException e) {\n    WXLogUtils.eTag(TAG,e);\n    id=RecyclerView.NO_ID;\n    WXLogUtils.e(TAG,\"getItemViewType: NO ID, this will crash the whole render system of WXListRecyclerView\");\n  }\n  return (int)id;\n}\n", "nl": "generate viewtype by component"}
{"code": "public synchronized Plugin loadPlugin(File file) throws InvalidPluginException, UnknownDependencyException {\n  Validate.notNull(file,\"File cannot be null\");\n  checkUpdate(file);\n  Set<Pattern> filters=fileAssociations.keySet();\n  Plugin result=null;\n  for (  Pattern filter : filters) {\n    String name=file.getName();\n    Matcher match=filter.matcher(name);\n    if (match.find()) {\n      PluginLoader loader=fileAssociations.get(filter);\n      result=loader.loadPlugin(file);\n    }\n  }\n  if (result != null) {\n    plugins.add(result);\n    lookupNames.put(result.getDescription().getName(),result);\n  }\n  return result;\n}\n", "nl": "Loads the plugin in the specified file <p> File must be valid according to the current enabled Plugin interfaces"}
{"code": "private URL[] doGetURLs(ClassLoader cl){\n  if (disableSmartGetUrl) {\n    return super.getURLs();\n  }\n  URL[] urls=null;\n  if (cl.equals(this)) {\n    urls=super.getURLs();\n  }\n else {\n    if (cl instanceof ServiceClassLoader) {\n      ServiceClassLoader scl=(ServiceClassLoader)cl;\n      urls=scl.getURLs();\n    }\n else {\n      urls=super.getURLs();\n    }\n  }\n  return (urls);\n}\n", "nl": "Get the URLs, ensuring when an Object is marshalled the annotation is correct"}
{"code": "public byte[] sign(final String text) throws DataSigningException {\n  try {\n    final Signature signature=Signature.getInstance(\"SHA256withRSA\");\n    signature.initSign(getPrivateKey());\n    signature.update(text.getBytes(\"UTF-8\"));\n    return signature.sign();\n  }\n catch (  final NoSuchAlgorithmException e) {\n    throw new DataSigningException(e);\n  }\ncatch (  final UnrecoverableKeyException e) {\n    throw new DataSigningException(e);\n  }\ncatch (  final InvalidKeyException e) {\n    throw new DataSigningException(e);\n  }\ncatch (  final SignatureException e) {\n    throw new DataSigningException(e);\n  }\ncatch (  final UnsupportedEncodingException e) {\n    throw new DataSigningException(e);\n  }\ncatch (  final KeyStoreException e) {\n    throw new DataSigningException(e);\n  }\n}\n", "nl": "Sign provided text with SHA256withRSA initialized by the private key"}
{"code": "public void openOtherProfile(@NonNull Activity activity,String memberId,DeepLinkListener callback){\n  this.deepLinkListener=callback;\n  LISession session=LISessionManager.getInstance(activity.getApplicationContext()).getSession();\n  if (!session.isValid()) {\n    callback.onDeepLinkError(new LIDeepLinkError(LIAppErrorCode.NOT_AUTHENTICATED,\"there is no access token\"));\n    return;\n  }\n  try {\n    if (!LIAppVersion.isLIAppCurrent(activity)) {\n      AppStore.goAppStore(activity,true);\n      return;\n    }\n    deepLinkToProfile(activity,memberId,session.getAccessToken());\n  }\n catch (  ActivityNotFoundException e) {\n    callback.onDeepLinkError(new LIDeepLinkError(LIAppErrorCode.LINKEDIN_APP_NOT_FOUND,\"LinkedIn app needs to be either installed or` updated\"));\n    deepLinkListener=null;\n  }\n}\n", "nl": "opens a view which shows the profile of the given member"}
{"code": "public static void removeMEGANClassificationData(DAAHeader header) throws IOException {\n  boolean hasMeganBlock=false;\n  long meganStart=header.getHeaderSize();\n  for (int i=0; i < header.getBlockTypeRankArrayLength(); i++) {\n    BlockType type=header.getBlockType(i);\n    if (type != BlockType.empty) {\n      if (type.toString().startsWith(\"megan\") && !type.equals(BlockType.megan_ref_annotations)) {\n        hasMeganBlock=true;\n        header.setBlockTypeRank(i,BlockType.rank(BlockType.empty));\n        header.setBlockSize(i,0l);\n      }\n else       meganStart+=header.getBlockSize(i);\n    }\n  }\n  if (hasMeganBlock) {\n    header.save();\n    try (RandomAccessFile raf=new RandomAccessFile(header.getFileName(),\"rw\")){\n      raf.setLength(meganStart);\n    }\n   }\n}\n", "nl": "remove all classification data added by MEGAN (leaves ref annotations)"}
{"code": "public void uncollapseSelectedNodes(boolean wholeSubtree){\n  final Set<Integer> ids=new HashSet<>();\n  for (Node v=getSelectedNodes().getFirstElement(); v != null; v=getSelectedNodes().getNextElement(v)) {\n    if (v.getOutDegree() == 0) {\n      Integer vid=(Integer)v.getInfo();\n      ids.add(vid);\n      if (!wholeSubtree)       setSelected(v,false);\n    }\n  }\n  final Set<Integer> seen=new HashSet<>();\n  for (  int id : ids) {\n    getCollapsedIds().remove(id);\n    Node vFull=classification.getFullTree().getANode(id);\n    if (!wholeSubtree) {\n      for (Iterator outEdgesFull=vFull.getOutEdges(); outEdgesFull.hasNext(); ) {\n        Edge eFull=(Edge)outEdgesFull.next();\n        Node wFull=eFull.getOpposite(vFull);\n        Integer wid=(Integer)wFull.getInfo();\n        getCollapsedIds().add(wid);\n      }\n    }\n else     uncollapseSelectedNodesRec(vFull,ids,seen);\n  }\n  updateTree();\n}\n", "nl": "uncollapse all selected nodes"}
{"code": "public Feedback(CharSequence id,Activity activity,App appInfo,CharSequence userComment,boolean includeScreenshot,Uri screenshotFileUri,File screenshotFile,boolean includeLogs,Uri logsFileUri,File logsFile){\n  this.id=id;\n  this.deviceInfo=new DeviceInfo(activity);\n  this.appInfo=appInfo;\n  this.userComment=userComment;\n  this.includeLogs=includeLogs;\n  if (this.includeLogs) {\n    this.logsFile=logsFile;\n    this.logsFileUri=logsFileUri;\n  }\n else {\n    this.logsFile=null;\n    this.logsFileUri=null;\n  }\n  this.includeScreenshot=includeScreenshot;\n  if (this.includeScreenshot) {\n    this.screenshotFile=screenshotFile;\n    this.screenshotFileUri=screenshotFileUri;\n  }\n else {\n    this.screenshotFileUri=null;\n    this.screenshotFile=null;\n  }\n}\n", "nl": "Construct an immutable feedback"}
{"code": "private void initial(){\n  int dayOfWeek=calendar.get(Calendar.DAY_OF_WEEK);\n  int monthStart=-1;\n  if (dayOfWeek >= 2 && dayOfWeek <= 7) {\n    monthStart=dayOfWeek - 2;\n  }\n else   if (dayOfWeek == 1) {\n    monthStart=6;\n  }\n  curStartIndex=monthStart;\n  date[monthStart]=1;\n  int daysOfMonth=daysOfCurrentMonth();\n  for (int i=1; i < daysOfMonth; i++) {\n    date[monthStart + i]=i + 1;\n  }\n  curEndIndex=monthStart + daysOfMonth;\n  if (calendar.get(Calendar.YEAR) == Calendar.getInstance().get(Calendar.YEAR) && calendar.get(Calendar.MONTH) == Calendar.getInstance().get(Calendar.MONTH)) {\n    todayIndex=Calendar.getInstance().get(Calendar.DAY_OF_MONTH) + monthStart - 1;\n  }\n else {\n    todayIndex=-1;\n  }\n}\n", "nl": "calculate the values of date[] and the legal range of index of date[]"}
{"code": "public DistributedTestCLI(String[] args){\n  cliOptions=createOptions();\n  try {\n    CommandLineParser parser=new GnuParser();\n    commandLine=parser.parse(cliOptions,args,true);\n    if (hasOption(\"h\")) {\n      printHelp();\n      System.exit(1);\n    }\n    if (!hasOption(\"j\")) {\n      logger.info(\"The full path of the jar file must be set with -j\");\n      System.exit(1);\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    System.exit(1);\n  }\n}\n", "nl": "Create and parse allowable options"}
{"code": "public static int apply(ViewerBase viewer,Writer writer,boolean showInternalLabels,boolean showUnassignedLabels,boolean simplify) throws IOException {\n  PhyloTree tree=viewer.getTree();\n  Node root=tree.getRoot();\n  if (root == null)   return 0;\n  NodeSet toUse=null;\n  if (viewer.getSelectedNodes().size() > 0) {\n    toUse=new NodeSet(tree);\n    visitNodesToUseRec(viewer,root,toUse);\n    while (!viewer.getSelected(root)) {\n      Node w=null;\n      for (Edge e=root.getFirstOutEdge(); e != null; e=root.getNextOutEdge(e)) {\n        if (toUse.contains(e.getTarget())) {\n          if (w == null)           w=e.getTarget();\n else {\n            w=null;\n            break;\n          }\n        }\n      }\n      if (w != null)       root=w;\n else       break;\n    }\n  }\n  int countNodes=writeAsTreeRec(viewer,toUse,root,writer,showInternalLabels,showUnassignedLabels,simplify,0);\n  writer.write(\";\\n\");\n  return countNodes;\n}\n", "nl": "export the tree"}
{"code": "public Matrix times(Matrix B){\n  if (B.m != n) {\n    throw new IllegalArgumentException(\"Matrix inner dimensions must agree.\");\n  }\n  Matrix X=new Matrix(m,B.n);\n  double[][] C=X.getArray();\n  double[] Bcolj=new double[n];\n  for (int j=0; j < B.n; j++) {\n    for (int k=0; k < n; k++) {\n      Bcolj[k]=B.A[k][j];\n    }\n    for (int i=0; i < m; i++) {\n      double[] Arowi=A[i];\n      double s=0;\n      for (int k=0; k < n; k++) {\n        s+=Arowi[k] * Bcolj[k];\n      }\n      C[i][j]=s;\n    }\n  }\n  return X;\n}\n", "nl": "Linear algebraic matrix multiplication, A * B"}
{"code": "private static long addStackableItem(Player player,ItemTemplate itemTemplate,long count,ItemUpdatePredicate predicate){\n  Storage inventory=player.getInventory();\n  Collection<Item> items=inventory.getItemsByItemId(itemTemplate.getTemplateId());\n  for (  Item item : items) {\n    if (count == 0) {\n      break;\n    }\n    count=inventory.increaseItemCount(item,count,predicate.getUpdateType(item,true));\n  }\n  if (itemTemplate.getCategory() == ItemCategory.SHARD) {\n    Equipment equipment=player.getEquipment();\n    items=equipment.getEquippedItemsByItemId(itemTemplate.getTemplateId());\n    for (    Item item : items) {\n      if (count == 0) {\n        break;\n      }\n      count=equipment.increaseEquippedItemCount(item,count);\n    }\n  }\n  while (!inventory.isFull(itemTemplate.getExtraInventoryId()) && count > 0) {\n    Item newItem=ItemFactory.newItem(itemTemplate.getTemplateId(),count);\n    count-=newItem.getItemCount();\n    inventory.add(newItem,predicate.getAddType());\n  }\n  return count;\n}\n", "nl": "Add stackable item to inventory"}
{"code": "private boolean registerNamespace(String namespace,boolean ensureOwned) throws PulsarServerException {\n  String myUrl=pulsar.getBrokerServiceUrl();\n  try {\n    NamespaceName nsname=new NamespaceName(namespace);\n    String otherUrl=null;\n    NamespaceBundle nsFullBundle=null;\n    nsFullBundle=bundleFactory.getFullBundle(nsname);\n    otherUrl=ownershipCache.getOrSetOwner(nsFullBundle).getNativeUrl();\n    if (myUrl.equals(otherUrl)) {\n      if (nsFullBundle != null) {\n        pulsar.loadNamespaceDestinations(nsFullBundle);\n      }\n      return true;\n    }\n    String msg=String.format(\"namespace already owned by other broker : ns=%s expected=%s actual=%s\",namespace,myUrl,otherUrl);\n    if (!ensureOwned) {\n      LOG.info(msg);\n      return false;\n    }\n    throw new IllegalStateException(msg);\n  }\n catch (  Exception e) {\n    LOG.error(e.getMessage(),e);\n    throw new PulsarServerException(e);\n  }\n}\n", "nl": "Tried to registers a namespace to this instance"}
{"code": "public Pair<Integer,Integer> writeOverlapGraph(Writer writer) throws IOException, CanceledException {\n  final NodeArray<String> names=new NodeArray<>(overlapGraph);\n  final NodeArray<String> sequences=new NodeArray<>(overlapGraph);\n  for (Node v=overlapGraph.getFirstNode(); v != null; v=v.getNext()) {\n    int i=(Integer)v.getInfo();\n    sequences.set(v,alignment.getLane(i).getBlock());\n    names.set(v,Basic.getFirstWord(alignment.getLane(i).getName()));\n  }\n  final Map<String,NodeArray<?>> label2nodes=new TreeMap<>();\n  label2nodes.put(\"label\",names);\n  label2nodes.put(\"sequence\",sequences);\n  final EdgeArray<Integer> overlap=new EdgeArray<>(overlapGraph);\n  for (Edge e=overlapGraph.getFirstEdge(); e != null; e=e.getNext()) {\n    overlap.set(e,(Integer)e.getInfo());\n  }\n  final Map<String,EdgeArray<?>> label2edges=new TreeMap<>();\n  label2edges.put(\"label\",null);\n  label2edges.put(\"overlap\",overlap);\n  overlapGraph.writeGML(writer,\"Overlap graph generated by MEGAN6\",true,alignment.getName(),1,label2nodes,label2edges);\n  return new Pair<>(overlapGraph.getNumberOfNodes(),overlapGraph.getNumberOfEdges());\n}\n", "nl": "write the overlap graph"}
{"code": "protected void drawHole(Canvas c){\n  if (mChart.isDrawHoleEnabled()) {\n    float radius=mChart.getRadius();\n    float holeRadius=radius * (mChart.getHoleRadius() / 100);\n    PointF center=mChart.getCenterCircleBox();\n    if (Color.alpha(mHolePaint.getColor()) > 0) {\n      mBitmapCanvas.drawCircle(center.x,center.y,holeRadius,mHolePaint);\n    }\n    if (Color.alpha(mTransparentCirclePaint.getColor()) > 0 && mChart.getTransparentCircleRadius() > mChart.getHoleRadius()) {\n      int alpha=mTransparentCirclePaint.getAlpha();\n      float secondHoleRadius=radius * (mChart.getTransparentCircleRadius() / 100);\n      mTransparentCirclePaint.setAlpha((int)((float)alpha * mAnimator.getPhaseX() * mAnimator.getPhaseY()));\n      mHoleCirclePath.reset();\n      mHoleCirclePath.addCircle(center.x,center.y,secondHoleRadius,Path.Direction.CW);\n      mHoleCirclePath.addCircle(center.x,center.y,holeRadius,Path.Direction.CCW);\n      mBitmapCanvas.drawPath(mHoleCirclePath,mTransparentCirclePaint);\n      mTransparentCirclePaint.setAlpha(alpha);\n    }\n  }\n}\n", "nl": "draws the hole in the center of the chart and the transparent circle / hole"}
{"code": "public static String parseColumnType(String typeName,int colSize,int scale){\n  typeName=typeName.toUpperCase();\n  if ((typeName.startsWith(\"INT\") || typeName.startsWith(\"SMALLINT\") || typeName.startsWith(\"TINYINT\")|| typeName.startsWith(\"INTEGER\")|| (typeName.startsWith(\"NUMBER\") && scale <= 0)) && colSize < 10) {\n    return iswrapper ? INT_WRAPPER : INT;\n  }\n else   if ((typeName.startsWith(\"BIGINT\") || typeName.startsWith(\"LONG\") || (typeName.startsWith(\"NUMBER\") && scale <= 0)|| typeName.startsWith(\"INT\")) && colSize >= 10) {\n    return iswrapper ? LONG_WRAPPER : LONG;\n  }\n else   if (typeName.startsWith(\"VARCHAR\")) {\n    return STRING;\n  }\n else   if ((typeName.startsWith(\"NUMBER\") || typeName.startsWith(\"DECIMAL\") || typeName.startsWith(\"NUMERIC\")|| typeName.startsWith(\"DOUBLE\")|| typeName.startsWith(\"FLOAT\")) && scale > 0) {\n    return DECIMAL;\n  }\n else   if (typeName.startsWith(\"TIMESTAMP\") || typeName.startsWith(\"DATETIME\")) {\n    return TIMESTAMP;\n  }\n else   if (typeName.startsWith(\"DATE\")) {\n    return DATE;\n  }\n else {\n    return STRING;\n  }\n}\n", "nl": "parse columnTypeName to corresponding java class"}
{"code": "public byte[] externalize(){\n  byte[] options=new byte[312];\n  options[0]=(byte)99;\n  options[1]=(byte)130;\n  options[2]=(byte)83;\n  options[3]=(byte)99;\n  int position=4;\n  Enumeration<DHCPOptionsEntry> e=this.optionsTable.elements();\n  while (e.hasMoreElements()) {\n    DHCPOptionsEntry entry=e.nextElement();\n    options[position++]=entry.code;\n    options[position++]=entry.length;\n    for (int i=0; i < entry.length; ++i) {\n      options[position++]=entry.content[i];\n    }\n  }\n  options[position]=(byte)255;\n  return options;\n}\n", "nl": "Converts a linked options list to a byte array"}
