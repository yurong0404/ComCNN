{"code": "private static void createOutputMap(Map<String,List<Distributable>> outputMap,int blocksPerNode,Set<Distributable> uniqueBlocks,Map<String,List<Distributable>> nodeAndBlockMapping,List<String> activeNodes){\n  ArrayList<NodeMultiBlockRelation> multiBlockRelations=new ArrayList<>(nodeAndBlockMapping.size());\n  for (  Map.Entry<String,List<Distributable>> entry : nodeAndBlockMapping.entrySet()) {\n    multiBlockRelations.add(new NodeMultiBlockRelation(entry.getKey(),entry.getValue()));\n  }\n  Collections.sort(multiBlockRelations);\n  for (  NodeMultiBlockRelation nodeMultiBlockRelation : multiBlockRelations) {\n    String nodeName=nodeMultiBlockRelation.getNode();\n    String activeExecutor=nodeName;\n    if (null != activeNodes) {\n      activeExecutor=getActiveExecutor(activeNodes,nodeName);\n      if (null == activeExecutor) {\n        continue;\n      }\n    }\n    int nodeCapacity=0;\n    for (    Distributable block : nodeMultiBlockRelation.getBlocks()) {\n      if (uniqueBlocks.contains(block)) {\n        if (null == outputMap.get(activeExecutor)) {\n          List<Distributable> list=new ArrayList<Distributable>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n          outputMap.put(activeExecutor,list);\n        }\n        if (nodeCapacity < blocksPerNode) {\n          List<Distributable> infos=outputMap.get(activeExecutor);\n          infos.add(block);\n          nodeCapacity++;\n          uniqueBlocks.remove(block);\n        }\n else {\n          break;\n        }\n      }\n    }\n  }\n}\n", "nl": "To create the final output of the Node and Data blocks"}
{"code": "static public ScoutCandidateGroup create(Rectangle group,ScoutWidget[] list,Rectangle[] rectList){\n  BitSet set=new BitSet();\n  int count=0;\n  int groupArea=group.width * group.height;\n  int widgetArea=0;\n  for (int i=1; i < list.length; i++) {\n    if (group.intersects(rectList[i]) && !group.contains(rectList[i])) {\n      return null;\n    }\n    if (group.contains(rectList[i])) {\n      set.set(i);\n      count++;\n      widgetArea+=rectList[i].height * rectList[i].width;\n    }\n  }\n  if (count < 4) {\n    return null;\n  }\n  if (widgetArea * 2 < groupArea) {\n    return null;\n  }\n  ScoutCandidateGroup c=new ScoutCandidateGroup();\n  c.mNorth=group.y;\n  c.mSouth=group.y + group.height;\n  c.mEast=group.x + group.width;\n  c.mWest=group.x;\n  c.mContainSet=set;\n  c.mCount=count;\n  c.mGroupArea=groupArea;\n  c.mWidgetArea=widgetArea;\n  c.mRect=new Rectangle(group);\n  c.mRectList=buildRectList(set,rectList);\n  return c;\n}\n", "nl": "Create a candidate for grouping based on a rectangle"}
{"code": "public void update(float deltaTime){\n  if (!isPaused && !defeated) {\n    timeTilVictory-=deltaTime;\n    currentDelay-=deltaTime;\n    if (timeTilVictory <= 0.0f) {\n      defeated=true;\n    }\n else     if (currentDelay <= this.min_delay && !playersWarned) {\n      turnOnTracks(chooseNextTrackCodeByPlayers());\n      playersWarned=true;\n    }\n else     if (currentDelay <= 1.0f && !trainsSummoned) {\n      callTrains(nextTrainCode);\n      trainsSummoned=true;\n    }\n else     if (currentDelay <= 0.0625f && !imminentDanger) {\n      turnOffAllTracks();\n      imminentDanger=true;\n    }\n else     if (currentDelay <= 0.0f) {\n      turnOffAllTracks();\n      playersWarned=false;\n      imminentDanger=false;\n      trainsSummoned=false;\n      activeDelays.remove();\n      currentDelay=activeDelays.peek();\n    }\n  }\n}\n", "nl": "Update function"}
{"code": "public List<Contentlet> executeSafe(){\n  Logger.debug(this,\"Executing query: \" + query.toString());\n  Logger.debug(this,\"Use Paging: \" + this.usePaging + \", Limit: \"+ this.limit+ \", Offset: \"+ this.offset+ \", Sort By: \"+ this.sortBy);\n  try {\n    if (this.usePaging) {\n      if (!exactFieldLimitations.isEmpty()) {\n        Logger.warn(this,\"Can't use exact matching in paginated search\");\n      }\n      PaginatedArrayList<Contentlet> contentlets=ContentUtils.pullPagenated(query.toString(),this.limit,this.offset,this.sortBy,APILocator.getUserAPI().getSystemUser(),null);\n      this.totalResults=contentlets.getTotalResults();\n      Logger.debug(this,\"Number Of Results: \" + contentlets.size() + \", Total Results: \"+ contentlets.getTotalResults());\n      return contentlets;\n    }\n else {\n      List<Contentlet> contentlets=APILocator.getContentletAPI().search(query.toString(),this.limit,this.offset,this.sortBy,APILocator.getUserAPI().getSystemUser(),false);\n      contentlets=removeNonExactMatches(contentlets);\n      if (Logger.isDebugEnabled(this.getClass())) {\n        if (contentlets == null) {\n          Logger.debug(this,\"Contentlets == null\");\n        }\n else {\n          Logger.debug(this,\"Number Of Results: \" + contentlets.size());\n        }\n      }\n      return contentlets;\n    }\n  }\n catch (  DotDataException|DotSecurityException e) {\n    Logger.warn(this,\"Exception while executing query\",e);\n  }\n  return new ArrayList<Contentlet>();\n}\n", "nl": "Executes the query"}
{"code": "@deprecated public static VersionInfo javaVersion(){\n  if (javaVersion == null) {\n    String s=System.getProperty(\"java.version\");\n    char[] chars=s.toCharArray();\n    int r=0;\n    int w=0;\n    int count=0;\n    boolean numeric=false;\n    while (r < chars.length) {\n      char c=chars[(r++)];\n      if ((c < '0') || (c > '9')) {\n        if (numeric) {\n          if (count == 3) {\n            break;\n          }\n          numeric=false;\n          chars[(w++)]='.';\n          count++;\n        }\n      }\n else {\n        numeric=true;\n        chars[(w++)]=c;\n      }\n    }\n    while ((w > 0) && (chars[(w - 1)] == '.')) {\n      w--;\n    }\n    String vs=new String(chars,0,w);\n    javaVersion=getInstance(vs);\n  }\n  return javaVersion;\n}\n", "nl": "/*    "}
{"code": "public CART[] load(int numStates,InputStream treeStream,InputStream pdfStream,PdfFileFormat fileFormat,FeatureDefinition featDefinition,PhoneTranslator phTranslator) throws IOException, MaryConfigurationException {\n  featDef=featDefinition;\n  int i, j, length, state;\n  BufferedReader s=null;\n  String line, aux;\n  phTrans=phTranslator;\n  CART treeSet[]=new CART[numStates];\n  for (i=0; i < numStates; i++)   treeSet[i]=new CART();\n  double pdf[][][][];\n  pdf=loadPdfs(numStates,pdfStream,fileFormat);\n  assert featDefinition != null : \"Feature Definition was not set\";\n  s=new BufferedReader(new InputStreamReader(treeStream,\"UTF-8\"));\n  while ((line=s.readLine()) != null) {\n    if (line.indexOf(\"QS\") < 0)     break;\n  }\n  while ((line=s.readLine()) != null) {\n    if (line.indexOf(\"{*}\") >= 0) {\n      aux=line.substring(line.indexOf(\"[\") + 1,line.indexOf(\"]\"));\n      state=Integer.parseInt(aux);\n      treeSet[state - 2].setRootNode(loadStateTree(s,pdf[state - 2]));\n      if (treeSet[state - 2].getRootNode() instanceof DecisionNode)       ((DecisionNode)treeSet[state - 2].getRootNode()).countData();\n      Log.d(Mary.LOG,\"load: CART[\" + (state - 2) + \"], total number of nodes in this CART: \"+ treeSet[state - 2].getNumNodes());\n    }\n  }\n  if (s != null)   s.close();\n  if (treeSet.length == 0) {\n    throw new IOException(\"LoadTreeSet: error no trees loaded\");\n  }\n  return treeSet;\n}\n", "nl": "Load the cart from the given file"}
{"code": "public void draw(Node v,boolean selected){\n  final NodeView nv=viewer.getNV(v);\n  final NodeData data=(NodeData)v.getData();\n  if (selected)   hilite(v);\n  if ((!drawLeavesOnly || v.getOutDegree() == 0) && scaleBy != ScaleBy.None && nv.getShape() != NodeView.NONE_NODE) {\nswitch (style) {\ncase HeatMap:\n      drawAsHeatMap(v,nv,data);\n    break;\ncase BarChart:\n  drawAsBarChart(v,nv,data);\nbreak;\ncase PieChart:\ndrawAsCircle(v,nv,data);\ndrawAsPieChart(v,nv,data);\nbreak;\ncase CoxComb:\ndrawAsCoxComb(v,nv,data);\nbreak;\ndefault :\ncase Circle:\ndrawAsCircle(v,nv,data);\nbreak;\n}\n}\n else {\nnv.setShape(NodeView.NONE_NODE);\n}\n}\n", "nl": "draw the node"}
{"code": "public int compute(String line){\n  this.line=line;\n  int count=0;\n  if (attemptFirstWord) {\n    int a=0;\n    while (a < line.length()) {\n      if (line.charAt(a) == '>' || Character.isWhitespace(line.charAt(a)))       a++;\n else       break;\n    }\n    int b=a + 1;\n    while (b < line.length()) {\n      int ch=line.charAt(b);\n      if (Character.isLetterOrDigit(ch) || ch == ':' || ch == '_')       b++;\n else       break;\n    }\n    if (b - a > 4) {\n      pairs[count][0]=a;\n      pairs[count++][1]=b;\n    }\n  }\n  if (idTags.length > 0) {\n    for (    String tag : idTags) {\n      int b;\n      for (int a=line.indexOf(tag); a != -1; a=line.indexOf(tag,b + 1)) {\n        a+=tag.length();\n        b=a + 1;\n        while (b < line.length() && (Character.isLetterOrDigit(line.charAt(b)) || line.charAt(b) == '_'))         b++;\n        if (b > a) {\n          if (count == pairs.length)           pairs=MultiWords.grow(pairs);\n          pairs[count][0]=a;\n          pairs[count++][1]=b;\n        }\n      }\n    }\n  }\n  return count;\n}\n", "nl": "compute all accessions that follow any one of the tags"}
{"code": "private void updateStatus(){\n  conflicts=null;\n  if (resource == null) {\n    statusLabel.setText(\"\");\n    return;\n  }\n  try {\n    LocalResourceStatus status=resource.getStatus();\n    if (!resource.isManaged()) {\n      statusLabel.setText(Policy.bind(\"SvnPropertiesView.resourceNotManaged\"));\n    }\n else     if (status.getPropStatus().equals(SVNStatusKind.MODIFIED)) {\n      statusLabel.setText(Policy.bind(\"SvnPropertiesView.somePropertiesModified\"));\n    }\n else     if (status.getPropStatus().equals(SVNStatusKind.NORMAL)) {\n      statusLabel.setText(Policy.bind(\"SvnPropertiesView.noPropertiesModified\"));\n    }\n else     if (status.getPropStatus().equals(SVNStatusKind.CONFLICTED)) {\n      statusLabel.setText(Policy.bind(\"SvnPropertiesView.conflictOnProperties\"));\n      try {\n        conflicts=PropertyConflict.getPropertyConflicts(resource);\n      }\n catch (      Exception e) {\n      }\n    }\n else {\n      statusLabel.setText(\"\");\n    }\n  }\n catch (  SVNException e) {\n    statusLabel.setText(Policy.bind(\"SvnPropertiesView.errorGettingStatus\"));\n  }\n}\n", "nl": "update the status text"}
{"code": "long parseDir(String line,String path) throws IOException {\n  int bytesStart=0;\n  int bytesEnd=0;\n  int j=line.length() - 1;\n  innerLoop1:   while (j >= 0) {\n    char c=line.charAt(j);\n    if (Character.isDigit(c)) {\n      bytesEnd=j + 1;\n      break innerLoop1;\n    }\n    j--;\n  }\n  innerLoop2:   while (j >= 0) {\n    char c=line.charAt(j);\n    if (!Character.isDigit(c) && c != ',' && c != '.') {\n      bytesStart=j + 1;\n      break innerLoop2;\n    }\n    j--;\n  }\n  if (j < 0) {\n    throw new IOException(\"Command line 'dir /-c' did not return valid info \" + \"for path '\" + path + \"'\");\n  }\n  StringBuilder buf=new StringBuilder(line.substring(bytesStart,bytesEnd));\n  for (int k=0; k < buf.length(); k++) {\n    if (buf.charAt(k) == ',' || buf.charAt(k) == '.') {\n      buf.deleteCharAt(k--);\n    }\n  }\n  return parseBytes(buf.toString(),path);\n}\n", "nl": "Parses the Windows dir response last line"}
{"code": "public void parseBuffer(ByteInputBuffer buffer,InputReaderLittleEndian refIns) throws IOException {\n  subjectId=buffer.readIntLittleEndian();\n  int flag=buffer.read();\n  score=buffer.readPacked(flag & 3);\n  queryBegin=buffer.readPacked((flag >>> 2) & 3);\n  subjectBegin=buffer.readPacked((flag >>> 4) & 3);\n  transcript.read(buffer);\n  if (refIns != null)   subjectName=daaHeader.getReference(subjectId,refIns);\n else   subjectName=\"unknown\".getBytes();\n  totalSubjectLen=daaHeader.getRefLength(subjectId);\nswitch (daaHeader.getAlignMode()) {\ncase blastx:\n{\n      frame=(flag & (1 << 6)) == 0 ? queryBegin % 3 : 3 + (queryRecord.getSourceSequence().length - 1 - queryBegin) % 3;\n      translatedQueryBegin=getQueryTranslatedBegin(queryBegin,frame,queryRecord.getSourceSequence().length,true);\n      break;\n    }\ncase blastp:\n{\n    frame=0;\n    translatedQueryBegin=queryBegin;\n    break;\n  }\ndefault :\ncase blastn:\n{\n  frame=(flag & (1 << 6)) == 0 ? 0 : 1;\n  translatedQueryBegin=getQueryTranslatedBegin(queryBegin,frame,queryRecord.getSourceSequence().length);\n}\n}\nparseTranscript(transcript);\n}\n", "nl": "parse from buffer"}
{"code": "@Override public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (obj == null) {\n    return false;\n  }\n  if (!(obj instanceof AbsoluteTableIdentifier)) {\n    return false;\n  }\n  AbsoluteTableIdentifier other=(AbsoluteTableIdentifier)obj;\n  if (carbonTableIdentifier == null) {\n    if (other.carbonTableIdentifier != null) {\n      return false;\n    }\n  }\n else   if (!carbonTableIdentifier.equals(other.carbonTableIdentifier)) {\n    return false;\n  }\n  if (storePath == null) {\n    if (other.storePath != null) {\n      return false;\n    }\n  }\n else   if (!storePath.equals(other.storePath)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "to check this class is equal to other object passed"}
{"code": "public static void readFromFile(File file,Function<String,Boolean> lineProcessing){\n  FileInputStream fr=null;\n  try {\n    fr=new FileInputStream(file);\n    InputStreamReader char_input=new InputStreamReader(fr,Charset.forName(\"UTF-8\").newDecoder());\n    BufferedReader br=new BufferedReader(char_input);\n    while (true) {\n      String in=br.readLine();\n      if (in == null) {\n        break;\n      }\n      if (!lineProcessing.apply(in)) {\n        break;\n      }\n    }\n    br.close();\n  }\n catch (  IOException e) {\n    Logger.getLogger(FileUtility.class.getName()).log(Level.SEVERE,\"IOException while reading file\",e);\n  }\n finally {\n    try {\n      fr.close();\n    }\n catch (    IOException e) {\n      Logger.getLogger(FileUtility.class.getName()).log(Level.SEVERE,\"IOException while closing file reader\",e);\n    }\n  }\n}\n", "nl": "Read a plain text file and process it line by line"}
{"code": "@Override public void renderAxisLabels(Canvas c){\n  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;\n  float[] positions=getTransformedPositions();\n  mAxisLabelPaint.setTypeface(mYAxis.getTypeface());\n  mAxisLabelPaint.setTextSize(mYAxis.getTextSize());\n  mAxisLabelPaint.setColor(mYAxis.getTextColor());\n  float xoffset=mYAxis.getXOffset();\n  float yoffset=Utils.calcTextHeight(mAxisLabelPaint,\"A\") / 2.5f + mYAxis.getYOffset();\n  AxisDependency dependency=mYAxis.getAxisDependency();\n  YAxisLabelPosition labelPosition=mYAxis.getLabelPosition();\n  float xPos=0f;\n  if (dependency == AxisDependency.LEFT) {\n    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {\n      mAxisLabelPaint.setTextAlign(Align.LEFT);\n      xPos=mViewPortHandler.offsetLeft() - xoffset;\n    }\n else {\n      mAxisLabelPaint.setTextAlign(Align.LEFT);\n      xPos=mViewPortHandler.offsetLeft() + xoffset;\n    }\n  }\n else {\n    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {\n      mAxisLabelPaint.setTextAlign(Align.LEFT);\n      xPos=mViewPortHandler.contentRight() + xoffset;\n    }\n else {\n      mAxisLabelPaint.setTextAlign(Align.LEFT);\n      xPos=mViewPortHandler.contentRight() - xoffset;\n    }\n  }\n  drawYLabels(c,xPos,positions,yoffset);\n}\n", "nl": "draws the y-axis labels to the screen"}
{"code": "public void createNetwork(int[] cycle0,Taxa taxa,SplitSystem splits,PhyloTreeView view) throws Exception {\n  ntax=taxa.getBits().cardinality();\n  PhyloTree graph=(PhyloTree)view.getGraph();\n  graph.clear();\n  int[] cycle=normalizeCycle(cycle0);\n  for (int i=1; i <= ntax; i++)   graph.setTaxon2Cycle(cycle[i],i);\n  initGraph(taxa,splits,cycle,graph);\n  List<Integer> interiorSplits=getInteriorSplitsOrdered(taxa,splits);\n  BitSet usedSplits=new BitSet();\n{\n    for (    Integer s : interiorSplits) {\n      wrapSplit(taxa,splits,s,cycle,graph);\n      usedSplits.set(s,true);\n    }\n  }\n  removeTemporaryTrivialEdges(graph);\n  assignAnglesToEdges(splits,cycle,graph,new HashSet());\n  assignAnglesToEdges(splits,cycle,graph,new HashSet());\n  if (graph.getNumberOfNodes() > 0 && graph.getNumberOfEdges() > 0) {\n    Node v=graph.getTaxon2Node(1);\n    Edge e=graph.getFirstAdjacentEdge(v);\n    double angle=Math.PI + graph.getAngle(e);\n    for (e=graph.getFirstEdge(); e != null; e=graph.getNextEdge(e)) {\n      graph.setAngle(e,graph.getAngle(e) - angle);\n    }\n    assignCoordinatesToNodes(optionUseWeights,view);\n  }\n else   assignCoordinatesToNodes(optionUseWeights,view);\n  view.resetViews();\n}\n", "nl": "computes the graph and graph view"}
{"code": "public ConstraintAnchor findAnchor(float x,float y,boolean checkGuidelines,boolean mousePress,ViewTransform viewTransform){\n  ConnectionCandidate candidate=new ConnectionCandidate();\n  float dist=(ConnectionDraw.CONNECTION_ANCHOR_SIZE + ConnectionDraw.CONNECTION_ANCHOR_SIZE) / viewTransform.getScale();\n  candidate.distance=ConnectionDraw.CONNECTION_ANCHOR_SIZE * ConnectionDraw.CONNECTION_ANCHOR_SIZE;\n  for (  Selection.Element element : mSelection.getElements()) {\n    ConstraintWidget widget=element.widget;\n    if (!checkGuidelines && (widget instanceof Guideline)) {\n      continue;\n    }\n    WidgetCompanion companion=(WidgetCompanion)widget.getCompanionWidget();\n    WidgetInteractionTargets widgetInteraction=companion.getWidgetInteractionTargets();\n    widgetInteraction.updatePosition(viewTransform);\n    widgetInteraction.findClosestConnection(viewTransform,x,y,candidate,mousePress);\n  }\n  float slope=(dist * dist);\n  if (candidate.anchorTarget != null && candidate.distance < slope) {\n    candidate.distance=0;\n  }\n else {\n    candidate.anchorTarget=null;\n  }\n  for (  ConstraintWidget widget : mWidgets.values()) {\n    if (!checkGuidelines && (widget instanceof Guideline)) {\n      continue;\n    }\n    WidgetCompanion companion=(WidgetCompanion)widget.getCompanionWidget();\n    WidgetDecorator decorator=companion.getWidgetDecorator(WidgetDecorator.BLUEPRINT_STYLE);\n    if (!decorator.isVisible()) {\n      continue;\n    }\n    WidgetInteractionTargets widgetInteraction=companion.getWidgetInteractionTargets();\n    widgetInteraction.updatePosition(viewTransform);\n    widgetInteraction.findClosestConnection(viewTransform,x,y,candidate,mousePress);\n  }\n  return candidate.anchorTarget;\n}\n", "nl": "Find which ConstraintAnchor is close to the (x, y) coordinates"}
{"code": "private void updateThemes(){\n  ImmutableList<String> editableThemes=ThemeEditorUtils.getModuleThemeQualifiedNamesList(myContext.getCurrentContextModule());\n  ImmutableList.Builder<String> availableThemesListBuilder=ImmutableList.builder();\n  ImmutableList.Builder<String> disabledThemesListBuilder=ImmutableList.builder();\n  ThemeResolver themeResolver=myContext.getThemeResolver();\n  for (  String themeName : editableThemes) {\n    if (themeResolver.getTheme(themeName) != null) {\n      availableThemesListBuilder.add(themeName);\n    }\n else {\n      disabledThemesListBuilder.add(themeName);\n    }\n  }\n  myAvailableProjectThemes=availableThemesListBuilder.build();\n  ImmutableList<String> disabledProjectThemes=disabledThemesListBuilder.build();\n  String selectedItem=getSelectedItem();\n  if (selectedItem == null) {\n    if (myDefaultThemeName != null && (editableThemes.contains(myDefaultThemeName) || themeResolver.getTheme(myDefaultThemeName) != null)) {\n      selectedItem=myDefaultThemeName;\n    }\n else     if (!editableThemes.isEmpty()) {\n      selectedItem=editableThemes.get(0);\n    }\n else     if (!myDefaultThemeNames.isEmpty()) {\n      selectedItem=myDefaultThemeNames.get(0);\n    }\n  }\n  myEditOptions.clear();\n  buildEditOptionsList(selectedItem);\n  myAllItems=new SeparatedList(mySeparator,group(myAvailableProjectThemes),group(disabledProjectThemes),group(myDefaultThemeNames,SHOW_ALL_THEMES),group(myEditOptions));\n  setSelectedItem(selectedItem);\n}\n", "nl": "Updates the themes list reloading all the themes from the resolver"}
{"code": "private boolean deleteStorage(TrackerServer trackerServer,String groupName,String storageIpAddr) throws IOException {\n  byte[] header;\n  byte[] bGroupName;\n  byte[] bs;\n  int len;\n  Socket trackerSocket;\n  trackerSocket=trackerServer.getSocket();\n  OutputStream out=trackerSocket.getOutputStream();\n  bs=groupName.getBytes(ClientGlobal.g_charset);\n  bGroupName=new byte[ProtoCommon.FDFS_GROUP_NAME_MAX_LEN];\n  if (bs.length <= ProtoCommon.FDFS_GROUP_NAME_MAX_LEN) {\n    len=bs.length;\n  }\n else {\n    len=ProtoCommon.FDFS_GROUP_NAME_MAX_LEN;\n  }\n  Arrays.fill(bGroupName,(byte)0);\n  System.arraycopy(bs,0,bGroupName,0,len);\n  int ipAddrLen;\n  byte[] bIpAddr=storageIpAddr.getBytes(ClientGlobal.g_charset);\n  if (bIpAddr.length < ProtoCommon.FDFS_IPADDR_SIZE) {\n    ipAddrLen=bIpAddr.length;\n  }\n else {\n    ipAddrLen=ProtoCommon.FDFS_IPADDR_SIZE - 1;\n  }\n  header=ProtoCommon.packHeader(ProtoCommon.TRACKER_PROTO_CMD_SERVER_DELETE_STORAGE,ProtoCommon.FDFS_GROUP_NAME_MAX_LEN + ipAddrLen,(byte)0);\n  byte[] wholePkg=new byte[header.length + bGroupName.length + ipAddrLen];\n  System.arraycopy(header,0,wholePkg,0,header.length);\n  System.arraycopy(bGroupName,0,wholePkg,header.length,bGroupName.length);\n  System.arraycopy(bIpAddr,0,wholePkg,header.length + bGroupName.length,ipAddrLen);\n  out.write(wholePkg);\n  ProtoCommon.RecvPackageInfo pkgInfo=ProtoCommon.recvPackage(trackerSocket.getInputStream(),ProtoCommon.TRACKER_PROTO_CMD_RESP,0);\n  this.errno=pkgInfo.errno;\n  return pkgInfo.errno == 0;\n}\n", "nl": "delete a storage server from the tracker server"}
{"code": "int big5_probability(byte[] rawtext){\n  int i, rawtextlen=0;\n  int dbchars=1, bfchars=1;\n  float rangeval=0, freqval=0;\n  long bffreq=0, totalfreq=1;\n  int row, column;\n  rawtextlen=rawtext.length;\n  for (i=0; i < rawtextlen - 1; i++) {\n    if (rawtext[i] >= 0) {\n    }\n else {\n      dbchars++;\n      if ((byte)0xA1 <= rawtext[i] && rawtext[i] <= (byte)0xF9 && (((byte)0x40 <= rawtext[i + 1] && rawtext[i + 1] <= (byte)0x7E) || ((byte)0xA1 <= rawtext[i + 1] && rawtext[i + 1] <= (byte)0xFE))) {\n        bfchars++;\n        totalfreq+=500;\n        row=rawtext[i] + 256 - 0xA1;\n        if (0x40 <= rawtext[i + 1] && rawtext[i + 1] <= 0x7E) {\n          column=rawtext[i + 1] - 0x40;\n        }\n else {\n          column=rawtext[i + 1] + 256 - 0x61;\n        }\n        if (Big5Freq[row][column] != 0) {\n          bffreq+=Big5Freq[row][column];\n        }\n else         if (3 <= row && row <= 37) {\n          bffreq+=200;\n        }\n      }\n      i++;\n    }\n  }\n  rangeval=50 * ((float)bfchars / (float)dbchars);\n  freqval=50 * ((float)bffreq / (float)totalfreq);\n  return (int)(rangeval + freqval);\n}\n", "nl": "Function: big5_probability Argument: byte array Returns : number from 0 to 100 representing probability text in array uses Big5 encoding"}
{"code": "public static void streamContent(OutputStream out,InputStream in,int length) throws IOException {\n  int bufferSize=512;\n  if (out == null) {\n    throw new IOException(\"Attempt to write to null output stream\");\n  }\n  if (in == null) {\n    throw new IOException(\"Attempt to read from null input stream\");\n  }\n  if (length == 0) {\n    throw new IOException(\"Attempt to write 0 bytes of content to output stream\");\n  }\n  BufferedOutputStream bos=new BufferedOutputStream(out,bufferSize);\n  BufferedInputStream bis=new BufferedInputStream(in,bufferSize);\n  byte[] buffer=new byte[length];\n  int read=0;\n  try {\n    while ((read=bis.read(buffer,0,buffer.length)) != -1) {\n      bos.write(buffer,0,read);\n    }\n  }\n catch (  IOException e) {\n    Debug.logError(e,\"Problem reading/writing buffers\",module);\n    bis.close();\n    bos.close();\n    throw e;\n  }\n finally {\n    if (bis != null) {\n      bis.close();\n    }\n    if (bos != null) {\n      bos.flush();\n      bos.close();\n    }\n  }\n}\n", "nl": "Stream binary content from InputStream to OutputStream This method does not close the streams passed"}
{"code": "public static String decrypt64bits(String encryptedData){\n  Key key;\n  Cipher c;\n  boolean ischeck=true;\n  byte[] decValue=null;\n  while (ischeck) {\n    key=generateKey64bits();\n    try {\n      c=Cipher.getInstance(Settings.ALGO);\n      c.init(Cipher.DECRYPT_MODE,key);\n      byte[] decordedValue=DatatypeConverter.parseBase64Binary(encryptedData);\n      decValue=c.doFinal(decordedValue);\n      String decryptedValue=new String(decValue);\n      return decryptedValue;\n    }\n catch (    NoSuchAlgorithmException|NoSuchPaddingException e) {\n      e.printStackTrace();\n    }\ncatch (    InvalidKeyException e) {\n      e.printStackTrace();\n    }\ncatch (    IllegalBlockSizeException e) {\n      ischeck=false;\n    }\ncatch (    BadPaddingException e) {\n      e.printStackTrace();\n    }\n  }\n  return \"/&\" + Settings._ERROR_PACKET + \"/&@\";\n}\n", "nl": "this method change the message encrypt String to normal String using 64bits AES if decpytion fail then returnERROR_PACKET(-1)"}
{"code": "public void copyPluginSoLib(Context context,String dexPath,String nativeLibDir){\n  String cpuName=getCpuName();\n  String cpuArchitect=getCpuArch(cpuName);\n  sNativeLibDir=nativeLibDir;\n  Log.d(TAG,\"cpuArchitect: \" + cpuArchitect);\n  long start=System.currentTimeMillis();\n  try {\n    ZipFile zipFile=new ZipFile(dexPath);\n    Enumeration<? extends ZipEntry> entries=zipFile.entries();\n    while (entries.hasMoreElements()) {\n      ZipEntry zipEntry=(ZipEntry)entries.nextElement();\n      if (zipEntry.isDirectory()) {\n        continue;\n      }\n      String zipEntryName=zipEntry.getName();\n      if (zipEntryName.endsWith(\".so\") && zipEntryName.contains(cpuArchitect)) {\n        final long lastModify=zipEntry.getTime();\n        if (lastModify == DLConfigs.getSoLastModifiedTime(context,zipEntryName)) {\n          Log.d(TAG,\"skip copying, the so lib is exist and not change: \" + zipEntryName);\n          continue;\n        }\n        mSoExecutor.execute(new CopySoTask(context,zipFile,zipEntry,lastModify));\n      }\n    }\n    zipFile.close();\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n  long end=System.currentTimeMillis();\n  Log.d(TAG,\"### copy so time : \" + (end - start) + \" ms\");\n}\n", "nl": "copy so lib to specify directory(/data/data/host_pack_name/pluginlib)"}
{"code": "private BTreeNode findFirstLeafNode(IndexKey key,BTreeNode node){\n  int childNodeIndex;\n  int low=0;\n  int high=node.nodeSize() - 1;\n  int mid=0;\n  int compareRes=-1;\n  IndexKey[] nodeKeys=node.getNodeKeys();\n  while (low <= high) {\n    mid=(low + high) >>> 1;\n    compareRes=compareIndexes(key,nodeKeys[mid]);\n    if (compareRes < 0) {\n      high=mid - 1;\n    }\n else     if (compareRes > 0) {\n      low=mid + 1;\n    }\n else {\n      int currentPos=mid;\n      while (currentPos - 1 >= 0 && compareIndexes(key,nodeKeys[currentPos - 1]) == 0) {\n        currentPos--;\n      }\n      mid=currentPos;\n      break;\n    }\n  }\n  if (compareRes < 0) {\n    if (mid > 0) {\n      mid--;\n    }\n    childNodeIndex=mid;\n  }\n else {\n    childNodeIndex=mid;\n  }\n  node=node.getChild(childNodeIndex);\n  return node;\n}\n", "nl": "Binary search used to get the first tentative block of the btree based on search key"}
{"code": "public static StringBuffer readFromStream(InputStream inputStream){\n  StringBuffer output=new StringBuffer();\n  if (inputStream == null) {\n    return output;\n  }\n  InputStreamReader char_input=new InputStreamReader(inputStream,Charset.forName(\"UTF-8\").newDecoder());\n  BufferedReader br=new BufferedReader(char_input);\n  try {\n    while (true) {\n      String in=br.readLine();\n      if (in == null) {\n        break;\n      }\n      output.append(in).append(\"\\n\");\n    }\n    return output;\n  }\n catch (  IOException e) {\n    Logger.getLogger(FileUtility.class.getName()).log(Level.SEVERE,null,e);\n  }\n finally {\n    try {\n      char_input.close();\n    }\n catch (    IOException e) {\n      Logger.getLogger(FileUtility.class.getName()).log(Level.SEVERE,null,e);\n    }\n    try {\n      br.close();\n    }\n catch (    IOException e) {\n      Logger.getLogger(FileUtility.class.getName()).log(Level.SEVERE,null,e);\n    }\n  }\n  return output;\n}\n", "nl": "Read plain text data from an InputStream"}
{"code": "public Node load(String fileName,FeatureDefinition featDefinition,String[] dummy) throws IOException, MaryConfigurationException {\n  cleadReader();\n  DataInput raf=new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)));\n  MaryHeader maryHeader=new MaryHeader(raf);\n  if (!maryHeader.hasCurrentVersion()) {\n    throw new IOException(\"Wrong version of database file\");\n  }\n  if (maryHeader.getType() != MaryHeader.CARTS) {\n    throw new IOException(\"No CARTs file\");\n  }\n  int numNodes=raf.readInt();\n  raf.readUTF();\n  featDef=featDefinition;\n  openBrackets=0;\n  try {\n    while (true) {\n      int length=raf.readInt();\n      char[] cartChars=new char[length];\n      for (int i=0; i < length; i++) {\n        cartChars[i]=raf.readChar();\n      }\n      String cart=new String(cartChars);\n      parseAndAdd(cart);\n    }\n  }\n catch (  EOFException eof) {\n  }\n  if (openBrackets != 0) {\n    throw new IOException(\"Error loading CART: bracket mismatch: \" + openBrackets);\n  }\n  if (rootNode instanceof DecisionNode)   ((DecisionNode)rootNode).countData();\n  return rootNode;\n}\n", "nl": "Load the cart from the given file"}
{"code": "static Class findProviderClass(String className,ClassLoader cl,boolean doFallback) throws ClassNotFoundException, ConfigurationError {\n  SecurityManager security=System.getSecurityManager();\n  if (security != null) {\n    final int lastDot=className.lastIndexOf(\".\");\n    String packageName=className;\n    if (lastDot != -1)     packageName=className.substring(0,lastDot);\n    security.checkPackageAccess(packageName);\n  }\n  Class providerClass;\n  if (cl == null) {\n    providerClass=Class.forName(className);\n  }\n else {\n    try {\n      providerClass=cl.loadClass(className);\n    }\n catch (    ClassNotFoundException x) {\n      if (doFallback) {\n        ClassLoader current=ObjectFactory.class.getClassLoader();\n        if (current == null) {\n          providerClass=Class.forName(className);\n        }\n else         if (cl != current) {\n          cl=current;\n          providerClass=cl.loadClass(className);\n        }\n else {\n          throw x;\n        }\n      }\n else {\n        throw x;\n      }\n    }\n  }\n  return providerClass;\n}\n", "nl": "Find a Class using the specified ClassLoader"}
{"code": "static Class findProviderClass(String className,ClassLoader cl,boolean doFallback) throws ClassNotFoundException, ConfigurationError {\n  SecurityManager security=System.getSecurityManager();\n  if (security != null) {\n    final int lastDot=className.lastIndexOf(\".\");\n    String packageName=className;\n    if (lastDot != -1)     packageName=className.substring(0,lastDot);\n    security.checkPackageAccess(packageName);\n  }\n  Class providerClass;\n  if (cl == null) {\n    providerClass=Class.forName(className);\n  }\n else {\n    try {\n      providerClass=cl.loadClass(className);\n    }\n catch (    ClassNotFoundException x) {\n      if (doFallback) {\n        ClassLoader current=ObjectFactory.class.getClassLoader();\n        if (current == null) {\n          providerClass=Class.forName(className);\n        }\n else         if (cl != current) {\n          cl=current;\n          providerClass=cl.loadClass(className);\n        }\n else {\n          throw x;\n        }\n      }\n else {\n        throw x;\n      }\n    }\n  }\n  return providerClass;\n}\n", "nl": "Find a Class using the specified ClassLoader"}
{"code": "protected void splitLU(RealMatrix lu,double[][] lowerData,double[][] upperData){\n  if (!lu.isSquare()) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.NON_SQUARE_MATRIX,lu.getRowDimension(),lu.getColumnDimension());\n  }\n  if (lowerData.length != lowerData[0].length) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,lowerData.length,lowerData[0].length);\n  }\n  if (upperData.length != upperData[0].length) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,upperData.length,upperData[0].length);\n  }\n  if (lowerData.length != upperData.length) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,lowerData.length,upperData.length);\n  }\n  if (lowerData.length != lu.getRowDimension()) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,lowerData.length,lu.getRowDimension());\n  }\n  int n=lu.getRowDimension();\n  for (int i=0; i < n; i++) {\n    for (int j=0; j < n; j++) {\n      if (j < i) {\n        lowerData[i][j]=lu.getEntry(i,j);\n        upperData[i][j]=0d;\n      }\n else       if (i == j) {\n        lowerData[i][j]=1d;\n        upperData[i][j]=lu.getEntry(i,j);\n      }\n else {\n        lowerData[i][j]=0d;\n        upperData[i][j]=lu.getEntry(i,j);\n      }\n    }\n  }\n}\n", "nl": "extracts the l  and u matrices from compact lu representation"}
{"code": "public static boolean loadTinkerResources(Context context,boolean tinkerLoadVerifyFlag,String directory,Intent intentResult){\n  if (resPatchInfo == null || resPatchInfo.resArscMd5 == null) {\n    return true;\n  }\n  String resourceString=directory + \"/\" + RESOURCE_PATH+ \"/\"+ RESOURCE_FILE;\n  File resourceFile=new File(resourceString);\n  long start=System.currentTimeMillis();\n  if (tinkerLoadVerifyFlag) {\n    if (!SharePatchFileUtil.checkResourceArscMd5(resourceFile,resPatchInfo.resArscMd5)) {\n      Log.e(TAG,\"Failed to load resource file, path: \" + resourceFile.getPath() + \", expect md5: \"+ resPatchInfo.resArscMd5);\n      ShareIntentUtil.setIntentReturnCode(intentResult,ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH);\n      return false;\n    }\n    Log.i(TAG,\"verify resource file:\" + resourceFile.getPath() + \" md5, use time: \"+ (System.currentTimeMillis() - start));\n  }\n  try {\n    TinkerResourcePatcher.monkeyPatchExistingResources(context,resourceString);\n    Log.i(TAG,\"monkeyPatchExistingResources resource file:\" + resourceString + \", use time: \"+ (System.currentTimeMillis() - start));\n  }\n catch (  Throwable e) {\n    Log.e(TAG,\"install resources failed\");\n    try {\n      SystemClassLoaderAdder.uninstallPatchDex(context.getClassLoader());\n    }\n catch (    Throwable throwable) {\n      Log.e(TAG,\"uninstallPatchDex failed\",e);\n    }\n    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION,e);\n    ShareIntentUtil.setIntentReturnCode(intentResult,ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION);\n    return false;\n  }\n  return true;\n}\n", "nl": "Load tinker resources"}
{"code": "private boolean hasSideEffectsOrReadsThis(SootMethod method,Set<SootMethod> runList){\n  if (!method.hasActiveBody())   return false;\n  Boolean hasSideEffects=methodSideEffects.get(method);\n  if (hasSideEffects != null)   return hasSideEffects;\n  if (!runList.add(method))   return false;\n  if (methodIsAndroidStub(method)) {\n    methodSideEffects.put(method,false);\n    return false;\n  }\n  Local thisLocal=method.isStatic() ? null : method.getActiveBody().getThisLocal();\n  for (  Unit u : method.getActiveBody().getUnits()) {\n    if (u instanceof AssignStmt) {\n      AssignStmt assign=(AssignStmt)u;\n      if (assign.getLeftOp() instanceof FieldRef || assign.getLeftOp() instanceof ArrayRef) {\n        methodSideEffects.put(method,true);\n        return true;\n      }\n    }\n    Stmt s=(Stmt)u;\n    if (thisLocal != null)     for (    ValueBox vb : s.getUseBoxes())     if (vb.getValue() == thisLocal)     return true;\n    if (s.containsInvokeExpr()) {\n      for (Iterator<Edge> edgeIt=Scene.v().getCallGraph().edgesOutOf(u); edgeIt.hasNext(); ) {\n        Edge e=edgeIt.next();\n        if (hasSideEffectsOrReadsThis(e.getTgt().method(),runList))         return true;\n      }\n    }\n  }\n  methodSideEffects.put(method,false);\n  return false;\n}\n", "nl": "Checks whether the given method or one of its transitive callees has side-effects or calls a sink method"}
{"code": "public static ChatComponentText chatComponentFromLegacyText(String message){\n  ChatComponentText base;\n  String[] parts=message.split(Character.toString(LegacyFormat.MARK));\n  if (parts.length == 1)   return new ChatComponentText(message);\n  base=new ChatComponentText(parts[0]);\n  ChatStyle chatStyle=new ChatStyle();\n  for (int i=1; i < parts.length; i++) {\n    String current=parts[i];\n    char code=current.charAt(0);\n    String text=current.substring(1);\n    if (code >= '0' && code <= '9' || code >= 'a' && code <= 'f' || code == 'r') {\n      chatStyle=new ChatStyle();\n      chatStyle.setColor(formattingMap.get(code));\n    }\n else {\n      chatStyle=chatStyle.createDeepCopy();\nswitch (code) {\ncase 'k':\n        chatStyle.setObfuscated(true);\n      break;\ncase 'l':\n    chatStyle.setBold(true);\n  break;\ncase 'm':\nchatStyle.setStrikethrough(true);\nbreak;\ncase 'n':\nchatStyle.setUnderlined(true);\nbreak;\ncase 'o':\nchatStyle.setItalic(true);\nbreak;\n}\n}\nbase.appendSibling(new ChatComponentText(text).setChatStyle(chatStyle));\n}\nreturn base;\n}\n", "nl": "Parses a legacy text"}
{"code": "static Class findProviderClass(String className,ClassLoader cl,boolean doFallback) throws ClassNotFoundException, ConfigurationError {\n  SecurityManager security=System.getSecurityManager();\n  if (security != null) {\n    final int lastDot=className.lastIndexOf(\".\");\n    String packageName=className;\n    if (lastDot != -1)     packageName=className.substring(0,lastDot);\n    security.checkPackageAccess(packageName);\n  }\n  Class providerClass;\n  if (cl == null) {\n    providerClass=Class.forName(className);\n  }\n else {\n    try {\n      providerClass=cl.loadClass(className);\n    }\n catch (    ClassNotFoundException x) {\n      if (doFallback) {\n        ClassLoader current=ObjectFactory.class.getClassLoader();\n        if (current == null) {\n          providerClass=Class.forName(className);\n        }\n else         if (cl != current) {\n          cl=current;\n          providerClass=cl.loadClass(className);\n        }\n else {\n          throw x;\n        }\n      }\n else {\n        throw x;\n      }\n    }\n  }\n  return providerClass;\n}\n", "nl": "Find a Class using the specified ClassLoader"}
{"code": "protected void readChangeLogVersionNode(XmlPullParser parser,ChangeLog changeLog) throws Exception {\n  if (parser == null)   return;\n  parser.require(XmlPullParser.START_TAG,null,TAG_CHANGELOGVERSION);\n  String versionName=parser.getAttributeValue(null,ATTRIBUTE_VERSIONNAME);\n  String versionCodeStr=parser.getAttributeValue(null,ATTRIBUTE_VERSIONCODE);\n  int versionCode=0;\n  if (versionCodeStr != null) {\n    try {\n      versionCode=Integer.parseInt(versionCodeStr);\n    }\n catch (    NumberFormatException ne) {\n      Log.w(TAG,\"Error while parsing versionCode.It must be a numeric value. Check you file.\");\n    }\n  }\n  String changeDate=parser.getAttributeValue(null,ATTRIBUTE_CHANGEDATE);\n  if (versionName == null)   throw new ChangeLogException(\"VersionName required in changeLogVersion node\");\n  ChangeLogRowHeader row=new ChangeLogRowHeader();\n  row.setVersionName(versionName);\n  row.setChangeDate(changeDate);\n  changeLog.addRow(row);\n  while (parser.next() != XmlPullParser.END_TAG) {\n    if (parser.getEventType() != XmlPullParser.START_TAG) {\n      continue;\n    }\n    String tag=parser.getName();\n    if (mChangeLogTags.contains(tag)) {\n      readChangeLogRowNode(parser,changeLog,versionName,versionCode);\n    }\n  }\n}\n", "nl": "Parse changeLogVersion node"}
{"code": "public static boolean addSmiles(Context context,Spannable spannable){\n  boolean hasChanges=false;\n  for (  Entry<Pattern,Object> entry : emoticons.entrySet()) {\n    Matcher matcher=entry.getKey().matcher(spannable);\n    while (matcher.find()) {\n      boolean set=true;\n      for (      ImageSpan span : spannable.getSpans(matcher.start(),matcher.end(),ImageSpan.class))       if (spannable.getSpanStart(span) >= matcher.start() && spannable.getSpanEnd(span) <= matcher.end())       spannable.removeSpan(span);\n else {\n        set=false;\n        break;\n      }\n      if (set) {\n        hasChanges=true;\n        Object value=entry.getValue();\n        if (value instanceof String && !((String)value).startsWith(\"http\")) {\n          File file=new File((String)value);\n          if (!file.exists() || file.isDirectory()) {\n            return false;\n          }\n          spannable.setSpan(new ImageSpan(context,Uri.fromFile(file)),matcher.start(),matcher.end(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        }\n else {\n          spannable.setSpan(new ImageSpan(context,(Integer)value),matcher.start(),matcher.end(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        }\n      }\n    }\n  }\n  return hasChanges;\n}\n", "nl": "replace existing spannable with smiles"}
{"code": "public static List<BigInteger> partitionDataElement(QuerySchema qSchema,JSONObject jsonData,boolean embedSelector) throws PIRException {\n  List<BigInteger> parts=new ArrayList<>();\n  DataSchema dSchema=DataSchemaRegistry.get(qSchema.getDataSchemaName());\n  if (embedSelector) {\n    String selectorFieldName=qSchema.getSelectorName();\n    String type=dSchema.getElementType(selectorFieldName);\n    String selector=getSelectorByQueryTypeJSON(qSchema,jsonData);\n    parts.addAll(embeddedSelectorToPartitions(selector,type,dSchema.getPartitionerForElement(selectorFieldName)));\n    logger.debug(\"Added embedded selector for selector = \" + selector + \" type = \"+ type+ \" parts.size() = \"+ parts.size());\n  }\n  List<String> dataFieldsToExtract=qSchema.getElementNames();\n  for (  String fieldName : dataFieldsToExtract) {\n    Object dataElement=null;\n    if (jsonData.containsKey(fieldName)) {\n      dataElement=jsonData.get(fieldName);\n    }\n    if (dSchema.isArrayElement(fieldName)) {\n      List<String> elementArray;\n      if (dataElement == null) {\n        elementArray=Collections.singletonList(\"0\");\n      }\n else {\n        elementArray=StringUtils.jsonArrayStringToArrayList(dataElement.toString());\n      }\n      logger.debug(\"Adding parts for fieldName = \" + fieldName + \" type = \"+ dSchema.getElementType(fieldName)+ \" jsonData = \"+ dataElement);\n      parts.addAll(dSchema.getPartitionerForElement(fieldName).arrayToPartitions(elementArray,dSchema.getElementType(fieldName)));\n    }\n else {\n      if (dataElement == null) {\n        dataElement=\"0\";\n      }\n      logger.debug(\"Adding parts for fieldName = \" + fieldName + \" type = \"+ dSchema.getElementType(fieldName)+ \" jsonData = \"+ dataElement);\n      parts.addAll(dSchema.getPartitionerForElement(fieldName).toPartitions(dataElement.toString(),dSchema.getElementType(fieldName)));\n    }\n  }\n  logger.debug(\"parts.size() = \" + parts.size());\n  return parts;\n}\n", "nl": "Method to convert the given data element given by the JSONObject data element into the extracted BigInteger partitions based upon the given queryType"}
{"code": "@Override public void execute(JobExecutionContext context) throws JobExecutionException {\n  if (isEnabled() == false) {\n    return;\n  }\n  if (Singleton.getBackgroundJobsEnabled() == false) {\n    return;\n  }\n  Thread.currentThread().setPriority(Thread.MIN_PRIORITY);\n  while (CodeIndexer.shouldPauseAdding()) {\n    Singleton.getLogger().info(\"Pausing parser.\");\n    return;\n  }\n  UniqueRepoQueue repoQueue=this.getNextQueuedRepo();\n  RepoResult repoResult=repoQueue.poll();\n  AbstractMap<String,Integer> runningIndexRepoJobs=Singleton.getRunningIndexRepoJobs();\n  if (repoResult != null && !runningIndexRepoJobs.containsKey(repoResult.getName())) {\n    Singleton.getLogger().info(\"File Indexer Indexing \" + repoResult.getName());\n    try {\n      runningIndexRepoJobs.put(repoResult.getName(),(int)(System.currentTimeMillis() / 1000));\n      JobDataMap data=context.getJobDetail().getJobDataMap();\n      String repoName=repoResult.getName();\n      this.repoName=repoName;\n      String repoRemoteLocation=repoResult.getUrl();\n      String repoLocations=data.get(\"REPOLOCATIONS\").toString();\n      this.LOWMEMORY=Boolean.parseBoolean(data.get(\"LOWMEMORY\").toString());\n      Path docDir=Paths.get(repoRemoteLocation);\n      this.indexDocsByPath(docDir,repoName,repoLocations,repoRemoteLocation,true);\n    }\n  finally {\n      runningIndexRepoJobs.remove(repoResult.getName());\n    }\n  }\n}\n", "nl": "The main method used for finding jobs to index and actually doing the work"}
{"code": "private void postRecoveryActions(ISpaceSynchronizeReplicaState recoveryState) throws Exception {\n  changeSpaceState(ISpaceState.STARTING,true,true);\n  if (recoveryState != null) {\n    int replicationSynchronizationTimeout=5 * 60;\n    try {\n      long syncStartTime=SystemTime.timeMillis();\n      ISpaceSynchronizeResult synchronizeResult=recoveryState.waitForSynchronizeCompletion(replicationSynchronizationTimeout,TimeUnit.SECONDS);\n      if (synchronizeResult != null) {\n        if (synchronizeResult.isFailed()) {\n          if (_logger.isLoggable(Level.WARNING))           _logger.warning(\"Synchronization failed: \" + synchronizeResult.getFailureReason());\n          throw synchronizeResult.getFailureReason();\n        }\n        if (getEngine().getReplicationNode() != null && getEngine().getReplicationNode().getDirectPesistencySyncHandler() != null) {\n          getEngine().getReplicationNode().getDirectPesistencySyncHandler().afterRecovery();\n          getEngine().getReplicationNode().setDirectPersistencyBackupSyncIteratorHandler(null);\n        }\n        if (getDirectPersistencyRecoveryHelper() != null && isBackup()) {\n          getDirectPersistencyRecoveryHelper().setPendingBackupRecovery(false);\n        }\n        if (_logger.isLoggable(Level.INFO)) {\n          long duration=SystemTime.timeMillis() - syncStartTime;\n          _logger.info(\"Synchronization completed [duration=\" + JSpaceUtilities.formatMillis(duration) + \"]\");\n        }\n      }\n    }\n catch (    TimeoutException e) {\n      if (getEngine().getCacheManager().isOffHeapCachePolicy()) {\n        if (_logger.isLoggable(Level.SEVERE))         _logger.severe(\"Timeout occurred [\" + replicationSynchronizationTimeout + \" seconds] while waiting for replication to synchronize. Will shut down space since blobstore inconsistent space can't be started.\");\n        throw e;\n      }\n      if (_logger.isLoggable(Level.WARNING))       _logger.warning(\"Timeout occurred [\" + replicationSynchronizationTimeout + \" seconds] while waiting for replication to synchronize. Starting the space without complete synchronization.\");\n    }\ncatch (    Exception e) {\n      changeSpaceState(ISpaceState.STARTING,true,false);\n      throw e;\n    }\n  }\n}\n", "nl": "Perform any actions that need to be executed after space recovery and before it is started"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"load taxonomyFile=\");\n  String treeFile=np.getWordFileNamePunctuation();\n  String mapFile=null;\n  if (np.peekMatchAnyTokenIgnoreCase(\"mapFile\")) {\n    np.matchIgnoreCase(\"mapFile=\");\n    mapFile=np.getWordFileNamePunctuation();\n  }\n  np.matchIgnoreCase(\";\");\n  if (mapFile == null)   mapFile=Basic.replaceFileSuffix(treeFile,\".map\");\n  Classification classification=ClassificationManager.load(Classification.Taxonomy,treeFile,mapFile,getDoc().getProgressListener());\n  Node v=classification.getFullTree().getRoot();\n  if (v != null && (Integer)v.getInfo() == 0) {\n    v.setInfo(1);\n    classification.getFullTree().addId2Node(0,null);\n    classification.getFullTree().addId2Node(1,v);\n    classification.getIdMapper().getName2IdMap().put(\"Root\",1);\n  }\n  Collection<Pair<String,String>> mappingFixes=new LinkedList<>();\n  mappingFixes=ProgramProperties.get(MeganProperties.TAXON_MAPPING_CHANGES,mappingFixes);\n  for (  Pair<String,String> pair : mappingFixes) {\n    String taxonName=pair.getFirst();\n    int taxId=Integer.parseInt(pair.getSecond());\n    System.err.println(\"Changing taxon mapping of '\" + taxonName + \"' from \"+ TaxonomyData.getName2IdMap().get(taxonName)+ \" to \"+ taxId);\n    TaxonomyData.getName2IdMap().put(taxonName,taxId);\n    classification.getIdMapper().getName2IdMap().put(taxonName,taxId);\n    classification.getId2Rank().put(taxId,0);\n  }\n  ProgramProperties.put(MeganProperties.TAXONOMYFILE,treeFile);\n  Document.loadVersionInfo(\"Taxonomy\",treeFile);\n}\n", "nl": "parses the given command and executes it"}
{"code": "private String shortDescription(){\n  StringBuilder buffer=new StringBuilder();\n  if (refName.length() > 0)   buffer.append(String.format(\">%s\\n\",Basic.fold(refName,ALIGNMENT_FOLD)));\n{\n    if (optionalFields.get(\"ZL\") != null)     buffer.append(String.format(\"\\tLength = %s\\n\\n\",optionalFields.get(\"ZL\").toString()));\n else     buffer.append(\"\\n\");\n  }\n{\n    boolean hasFirst=false;\n    boolean hasSecond=false;\n    if (optionalFields.get(\"AS\") != null && optionalFields.get(\"AS\") instanceof Integer) {\n      buffer.append(String.format(\" Score = %d\",getBitScore()));\n      if (optionalFields.get(\"ZR\") != null && optionalFields.get(\"ZR\") instanceof Integer) {\n        buffer.append(String.format(\" bits (%d)\",getRawScore()));\n      }\n      hasFirst=true;\n    }\n    if (optionalFields.get(\"ZE\") != null && optionalFields.get(\"ZE\") instanceof Float) {\n      if (hasFirst)       buffer.append(\",\");\n      if (getExpected() == 0)       buffer.append(\" Expect = 0\");\n else       buffer.append(String.format(\" Expect = %.1g\",getExpected()));\n      hasSecond=true;\n    }\n    if (hasFirst || hasSecond)     buffer.append(\"\\n\");\n  }\n{\n    if (optionalFields.get(\"AL\") != null)     buffer.append(optionalFields.get(\"AL\").toString()).append(\"\\n\");\n  }\n  return buffer.toString();\n}\n", "nl": "gets a short description of a match This is used for BlastTab and similar incomplete formats"}
{"code": "public String authorizeConsumerRequestToken(String url) throws Exception {\n  WebTarget target=ClientBuilder.newClient().target(url);\n  Invocation.Builder builder=target.request();\n  builder.header(\"Accept\",\"application/xml\");\n  String base64Credentials=new String(Base64.encodeBytes(\"admin:admin\".getBytes()));\n  builder.header(\"Authorization\",\"Basic \" + base64Credentials);\n  Response response=null;\n  try {\n    response=builder.get();\n    if (200 != response.getStatus()) {\n      throw new RuntimeException(\"No authorization request data is available\");\n    }\n    String body=response.readEntity(String.class);\n    String consumerId=evaluateBody(new ByteArrayInputStream(body.getBytes()),\"/ns:tokenAuthorizationRequest/ns:consumerId/text()\");\n    String consumerName=evaluateBody(new ByteArrayInputStream(body.getBytes()),\"/ns:tokenAuthorizationRequest/ns:consumerName/text()\");\n    String requestScope=evaluateBody(new ByteArrayInputStream(body.getBytes()),\"/ns:tokenAuthorizationRequest/ns:scopes/text()\");\n    String requestPermission=evaluateBody(new ByteArrayInputStream(body.getBytes()),\"/ns:tokenAuthorizationRequest/ns:permissions/text()\");\n    String message=\"Authorize \" + (\"\".equals(consumerName) ? consumerId : consumerName) + System.getProperty(\"line.separator\")+ \" to access \"+ (\"\".equals(requestScope) ? \"your resources\" : requestScope)+ (requestPermission == null ? \"\" : (System.getProperty(\"line.separator\") + \" and grant the following permissions : \\\"\" + requestPermission+ \"\\\"\"))+ \" (yes/no) ?\";\n    String decision=JOptionPane.showInputDialog(message);\n    if (decision == null || !\"yes\".equalsIgnoreCase(decision)) {\n      decision=\"no\";\n    }\n    String replyTo=evaluateBody(new ByteArrayInputStream(body.getBytes()),\"/ns:tokenAuthorizationRequest/@replyTo\");\n    replyTo+=\"&xoauth_end_user_decision=\" + decision.toLowerCase();\n    return confirmAuthorization(replyTo);\n  }\n  finally {\n    response.close();\n  }\n}\n", "nl": "End user follows the redirection by going to the authorizationURI  provided by a 3rd party consumer"}
{"code": "private void updateButtons(){\n  List<ButtonData> buttonDatas=allAngleExpandableButton.buttonDatas;\n  int mainButtonRadius=allAngleExpandableButton.mainButtonSizePx / 2;\n  int subButtonRadius=allAngleExpandableButton.subButtonSizePx / 2;\n  Matrix matrix=matrixArray[0];\n  matrix.reset();\n  matrix.postRotate(allAngleExpandableButton.mainButtonRotateDegree * allAngleExpandableButton.rotateProgress,allAngleExpandableButton.rawButtonRectF.centerX(),allAngleExpandableButton.rawButtonRectF.centerY());\n  for (int i=1; i < buttonDatas.size(); i++) {\n    matrix=matrixArray[i];\n    ButtonData buttonData=buttonDatas.get(i);\n    matrix.reset();\n    if (allAngleExpandableButton.expanded) {\n      ExpandMoveCoordinate coordinate=expandDesCoordinateMap.get(buttonData);\n      float dx=allAngleExpandableButton.expandProgress * (coordinate.moveX);\n      float dy=allAngleExpandableButton.expandProgress * (-coordinate.moveY);\n      matrix.postTranslate(dx,dy);\n    }\n else {\n      int radius=mainButtonRadius + subButtonRadius + allAngleExpandableButton.buttonGapPx;\n      float moveX;\n      float moveY;\n      ExpandMoveCoordinate coordinate=expandDesCoordinateMap.get(buttonData);\n      if (coordinate == null) {\n        moveX=allAngleExpandableButton.angleCalculator.getMoveX(radius,i);\n        moveY=allAngleExpandableButton.angleCalculator.getMoveY(radius,i);\n        coordinate=new ExpandMoveCoordinate(moveX,moveY);\n        expandDesCoordinateMap.put(buttonData,coordinate);\n      }\n else {\n        moveX=coordinate.moveX;\n        moveY=coordinate.moveY;\n      }\n      float dx=allAngleExpandableButton.expandProgress * (moveX);\n      float dy=allAngleExpandableButton.expandProgress * (-moveY);\n      matrix.postTranslate(dx,dy);\n    }\n  }\n}\n", "nl": "called before draw an expand/collapse frame"}
{"code": "public void cloneCharacter(int taskId,int targetAccountId,String name,String account,byte[] db){\n  if (!PlayerService.isFreeName(name)) {\n    if (PlayerTransferConfig.BLOCK_SAMENAME) {\n      LoginServer.getInstance().sendPacket(new SM_PTRANSFER_CONTROL(SM_PTRANSFER_CONTROL.ERROR,taskId,\"Name is already in use\"));\n      return;\n    }\n    log.info(\"Name is already in use `\" + name + \"`\");\n    textLog.info(\"taskId:\" + taskId + \"; [CloneCharacter:!isFreeName]\");\n    String newName=name + PlayerTransferConfig.NAME_PREFIX;\n    int i=0;\n    while (!PlayerService.isFreeName(newName)) {\n      newName=name + PlayerTransferConfig.NAME_PREFIX + i;\n    }\n    name=newName;\n  }\n  if (AccountService.loadAccount(targetAccountId).size() >= GSConfig.CHARACTER_LIMIT_COUNT) {\n    LoginServer.getInstance().sendPacket(new SM_PTRANSFER_CONTROL(SM_PTRANSFER_CONTROL.ERROR,taskId,\"No free character slots\"));\n    return;\n  }\n  CMT_CHARACTER_INFORMATION acp=new CMT_CHARACTER_INFORMATION(0,State.CONNECTED);\n  acp.setBuffer(ByteBuffer.wrap(db).order(ByteOrder.LITTLE_ENDIAN));\n  Player cha=acp.readInfo(name,targetAccountId,account,rsList,textLog);\n  if (cha == null) {\n    log.error(\"clone failed #\" + taskId + \" `\"+ name+ \"`\");\n    LoginServer.getInstance().sendPacket(new SM_PTRANSFER_CONTROL(SM_PTRANSFER_CONTROL.ERROR,taskId,\"unexpected sql error while creating a clone\"));\n  }\n else {\n    DAOManager.getDAO(PlayerDAO.class).setPlayerLastTransferTime(cha.getObjectId(),System.currentTimeMillis());\n    LoginServer.getInstance().sendPacket(new SM_PTRANSFER_CONTROL(SM_PTRANSFER_CONTROL.OK,taskId));\n    log.info(\"clone successful #\" + taskId + \" `\"+ name+ \"`\");\n    textLog.info(\"taskId:\" + taskId + \"; [CloneCharacter:Done]\");\n  }\n}\n", "nl": "sent from login to target server with character information from source server"}
{"code": "private static boolean versionGreaterThan(GradleVersion v,int major,int minor,int micro,int beta,int alpha){\n  if (v == null) {\n    return true;\n  }\n  if (v.getMajor() != major) {\n    return v.getMajor() > major;\n  }\n  if (v.getMinor() != minor) {\n    return (v.getMinor() > minor);\n  }\n  if (v.getMicro() != micro) {\n    return (v.getMicro() > micro);\n  }\n  if (alpha > 0) {\n    if (\"alpha\".equals(v.getPreviewType())) {\n      return (v.getPreview() > alpha);\n    }\n else {\n      return true;\n    }\n  }\n  if (beta > 0) {\n    if (\"beta\".equals(v.getPreviewType())) {\n      return (v.getPreview() > beta);\n    }\n else {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Are we past a version used to implement a conditional change for other releases results when alpha and beta both > 0 is undefined"}
{"code": "public static int export(String classification,Collection<Integer> classIds,IConnector connector,String fileName,ProgressListener progressListener) throws IOException, CanceledException {\n  int total=0;\n  try {\n    progressListener.setTasks(\"Export\",\"Writing selected reads\");\n    try (BufferedWriter w=new BufferedWriter(new FileWriter(fileName))){\n      int maxProgress=100000 * classIds.size();\n      int currentProgress;\n      progressListener.setMaximum(maxProgress);\n      progressListener.setProgress(0);\n      int countClassIds=0;\n      for (      Integer classId : classIds) {\n        countClassIds++;\n        currentProgress=100000 * countClassIds;\n        IReadBlockIterator it=connector.getReadsIterator(classification,classId,0,10000,true,false);\n        long progressIncrement=100000 / (it.getMaximumProgress() + 1);\n        while (it.hasNext()) {\n          total++;\n          write(it.next(),w);\n          progressListener.setProgress(currentProgress);\n          currentProgress+=progressIncrement;\n        }\n      }\n    }\n   }\n catch (  CanceledException ex) {\n    System.err.println(\"USER CANCELED\");\n  }\n  return total;\n}\n", "nl": "export all reads for given set of classids in the given classification"}
{"code": "public static boolean addSmiles(Context context,Spannable spannable){\n  boolean hasChanges=false;\n  for (  Entry<Pattern,Object> entry : emoticons.entrySet()) {\n    Matcher matcher=entry.getKey().matcher(spannable);\n    while (matcher.find()) {\n      boolean set=true;\n      for (      ImageSpan span : spannable.getSpans(matcher.start(),matcher.end(),ImageSpan.class))       if (spannable.getSpanStart(span) >= matcher.start() && spannable.getSpanEnd(span) <= matcher.end())       spannable.removeSpan(span);\n else {\n        set=false;\n        break;\n      }\n      if (set) {\n        hasChanges=true;\n        Object value=entry.getValue();\n        if (value instanceof String && !((String)value).startsWith(\"http\")) {\n          File file=new File((String)value);\n          if (!file.exists() || file.isDirectory()) {\n            return false;\n          }\n          spannable.setSpan(new ImageSpan(context,Uri.fromFile(file)),matcher.start(),matcher.end(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        }\n else {\n          spannable.setSpan(new ImageSpan(context,(Integer)value),matcher.start(),matcher.end(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        }\n      }\n    }\n  }\n  return hasChanges;\n}\n", "nl": "replace existing spannable with smiles"}
{"code": "void handleEOD(EncoderContext context,StringBuilder buffer){\n  int unwritten=(buffer.length() / 3) * 2;\n  int rest=buffer.length() % 3;\n  int curCodewordCount=context.getCodewordCount() + unwritten;\n  context.updateSymbolInfo(curCodewordCount);\n  int available=context.getSymbolInfo().getDataCapacity() - curCodewordCount;\n  if (rest == 2) {\n    buffer.append('\\0');\n    while (buffer.length() >= 3) {\n      writeNextTriplet(context,buffer);\n    }\n    if (context.hasMoreCharacters()) {\n      context.writeCodeword(HighLevelEncoder.C40_UNLATCH);\n    }\n  }\n else   if (available == 1 && rest == 1) {\n    while (buffer.length() >= 3) {\n      writeNextTriplet(context,buffer);\n    }\n    if (context.hasMoreCharacters()) {\n      context.writeCodeword(HighLevelEncoder.C40_UNLATCH);\n    }\n    context.pos--;\n  }\n else   if (rest == 0) {\n    while (buffer.length() >= 3) {\n      writeNextTriplet(context,buffer);\n    }\n    if (available > 0 || context.hasMoreCharacters()) {\n      context.writeCodeword(HighLevelEncoder.C40_UNLATCH);\n    }\n  }\n else {\n    throw new IllegalStateException(\"Unexpected case. Please report!\");\n  }\n  context.signalEncoderChange(HighLevelEncoder.ASCII_ENCODATION);\n}\n", "nl": "Handle \"end of data\" situations"}
{"code": "private static WidgetDecorator createDecorator(NlComponent component,ConstraintWidget widget){\n  WidgetDecorator decorator=null;\n  if (component.getTagName().equalsIgnoreCase(SdkConstants.TEXT_VIEW)) {\n    decorator=new TextWidget(widget,ConstraintUtilities.getResolvedText(component));\n  }\n else   if (component.getTagName().equalsIgnoreCase(SdkConstants.BUTTON)) {\n    decorator=new ButtonWidget(widget,ConstraintUtilities.getResolvedText(component));\n  }\n else   if (component.getTagName().equalsIgnoreCase(SdkConstants.RADIO_BUTTON)) {\n    decorator=new RadiobuttonWidget(widget,ConstraintUtilities.getResolvedText(component));\n  }\n else   if (component.getTagName().equalsIgnoreCase(SdkConstants.CHECK_BOX)) {\n    decorator=new CheckboxWidget(widget,ConstraintUtilities.getResolvedText(component));\n  }\n else   if (component.getTagName().equalsIgnoreCase(SdkConstants.SWITCH)) {\n    decorator=new SwitchWidget(widget,ConstraintUtilities.getResolvedText(component));\n  }\n else   if (component.getTagName().equalsIgnoreCase(SdkConstants.IMAGE_VIEW)) {\n    decorator=new ImageViewWidget(widget);\n  }\n else   if (component.getTagName().equalsIgnoreCase(SdkConstants.WEB_VIEW)) {\n    decorator=new WebViewWidget(widget);\n  }\n else   if (component.getTagName().equalsIgnoreCase(SdkConstants.EDIT_TEXT)) {\n    decorator=new TextWidget(widget,ConstraintUtilities.getResolvedText(component));\n  }\n  if (decorator == null) {\n    decorator=new WidgetDecorator(widget);\n  }\n  return decorator;\n}\n", "nl": "Return a new instance of WidgetDecorator given a component and its ConstraintWidget"}
{"code": "public static boolean batch(WebSocketImpl ws,ByteChannel sockchannel) throws IOException {\n  ByteBuffer buffer=ws.outQueue.peek();\n  WrappedByteChannel c=null;\n  if (buffer == null) {\n    if (sockchannel instanceof WrappedByteChannel) {\n      c=(WrappedByteChannel)sockchannel;\n      if (c.isNeedWrite()) {\n        c.writeMore();\n      }\n    }\n  }\n else {\n    do {\n      sockchannel.write(buffer);\n      if (buffer.remaining() > 0) {\n        return false;\n      }\n else {\n        ws.outQueue.poll();\n        buffer=ws.outQueue.peek();\n      }\n    }\n while (buffer != null);\n  }\n  if (ws != null && ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER) {\nsynchronized (ws) {\n      ws.closeConnection();\n    }\n  }\n  return c != null ? !((WrappedByteChannel)sockchannel).isNeedWrite() : true;\n}\n", "nl": "Returns whether the whole outQueue has been flushed"}
{"code": "public void close() throws GenericDataSourceException {\n  if (_manualTX) {\n    if (Debug.verboseOn())     Debug.logVerbose(\"SQLProcessor:close() calling commit : _manualTX=\" + _manualTX,module);\n    commit();\n  }\n  _sql=null;\n  if (_rs != null) {\n    try {\n      _rs.close();\n      if (Debug.verboseOn())       Debug.logVerbose(\"SQLProcessor:close() result close : _manualTX=\" + _manualTX,module);\n    }\n catch (    SQLException sqle) {\n      Debug.logWarning(sqle.getMessage(),module);\n    }\n    _rs=null;\n  }\n  if (_ps != null) {\n    try {\n      _ps.close();\n      if (Debug.verboseOn())       Debug.logVerbose(\"SQLProcessor:close() preparedStatement close : _manualTX=\" + _manualTX,module);\n    }\n catch (    SQLException sqle) {\n      Debug.logWarning(sqle.getMessage(),module);\n    }\n    _ps=null;\n  }\n  if ((_connection != null) && _bDeleteConnection) {\n    try {\n      _connection.close();\n      if (Debug.verboseOn())       Debug.logVerbose(\"SQLProcessor:close() connection close : _manualTX=\" + _manualTX,module);\n    }\n catch (    SQLException sqle) {\n      Debug.logWarning(sqle.getMessage(),module);\n    }\n    _connection=null;\n  }\n}\n", "nl": "Commit if required and remove all allocated resources"}
{"code": "@Override public final boolean equals(final Object copy){\n  boolean result=copy != null && copy instanceof HardwareAddress && this.getClass().equals(copy.getClass());\n  if (result) {\n    Field[] fields=this.getClass().getDeclaredFields();\n    for (    Field field : fields) {\n      if (!Modifier.isFinal(field.getModifiers()) && !Modifier.isStatic(field.getModifiers()) && !Modifier.isTransient(field.getModifiers())) {\n        try {\n          if ((field.get(this) != null && field.get(copy) == null) || (field.get(this) == null && field.get(copy) != null)) {\n            result=false;\n          }\n else           if (field.get(this) != null && field.get(copy) != null) {\n            if (field.getType().isArray()) {\n              if (Object[].class.isAssignableFrom(field.getType())) {\n                result=Arrays.equals((Object[])field.get(this),(Object[])field.get(copy));\n              }\n else {\n                result=ArrayUtils.isEquals(field.get(this),field.get(copy));\n              }\n            }\n else {\n              result=field.get(this).equals(field.get(copy));\n            }\n          }\n        }\n catch (        Exception e) {\n          result=false;\n        }\n      }\n      if (!result)       break;\n    }\n  }\n  return result;\n}\n", "nl": "The two addresses are considered equals if they're of the same type and all their non-static attributes are equal"}
{"code": "public static long count(String table,String where,Object[] args){\n  TimeStamp t=TimeStamp.create();\n  StringBuilder sum=new StringBuilder();\n  sum.append(\"select count(*) t from \").append(table);\n  if (where != null) {\n    sum.append(\" where \").append(where);\n  }\n  Connection c=null;\n  PreparedStatement p=null;\n  ResultSet r=null;\n  try {\n    c=getConnection();\n    if (c == null)     return 0;\n    p=c.prepareStatement(sum.toString());\n    int order=1;\n    if (args != null) {\n      for (int i=0; i < args.length; i++) {\n        Object o=args[i];\n        setParameter(p,order++,o);\n      }\n    }\n    r=p.executeQuery();\n    if (r.next()) {\n      return r.getInt(\"t\");\n    }\n  }\n catch (  Exception e) {\n    if (log.isErrorEnabled())     log.error(sum.toString() + toString(args),e);\n  }\n finally {\n    close(r,p,c);\n    if (t.past() > 2 && sqllog.isDebugEnabled()) {\n      sqllog.debug(\"cost:\" + t.past() + \"ms, sql=[\"+ sum+ \"]; [\"+ sum+ \"]\");\n    }\n  }\n  return 0;\n}\n", "nl": "count the data"}
{"code": "private void synchronizeCache(final Set<Long> pTagIds) throws CacheSynchronizationException {\n  try {\n    if (!liveCache.isEmpty()) {\n      final Set<Long> unsynchronizedTagIds;\n      if (pTagIds == null || jmsConnectionDown || heartbeatExpired) {\n        unsynchronizedTagIds=new HashSet<Long>(liveCache.keySet());\n      }\n else {\n        unsynchronizedTagIds=new HashSet<Long>(pTagIds);\n      }\n      unsynchronizedTagIds.removeAll(synchronizeTags(unsynchronizedTagIds));\n      for (      Long tagId : unsynchronizedTagIds) {\n        final ClientDataTagImpl liveTag=liveCache.get(tagId);\n        if (liveTag.getDataTagQuality().isExistingTag()) {\n          if (jmsProxy.isRegisteredListener(liveTag)) {\n            try {\n              jmsProxy.unregisterUpdateListener(liveTag);\n            }\n catch (            Exception e) {\n              LOG.warn(\"synchronizeCache() - Could not unregister tag \" + tagId + \" from JmsProxy. Reason: \"+ e.getMessage());\n            }\n          }\n          supervisionManager.removeSupervisionListener(liveTag);\n          final ClientDataTagImpl unkownTag=new ClientDataTagImpl(tagId,true);\n          unkownTag.addUpdateListeners(liveTag.getUpdateListeners());\n          liveCache.put(tagId,unkownTag);\n        }\n      }\n    }\n    jmsConnectionDown=false;\n    heartbeatExpired=false;\n  }\n catch (  Exception e) {\n    throw new CacheSynchronizationException(\"Could not refresh tags in the live cache.\",e);\n  }\n}\n", "nl": "Inner method which synchronizes the live cache with the C2MON server"}
{"code": "public static String[] splitWithoutEscaped(String str,char separatorChar,boolean retainEmpty){\n  int len=str.length();\n  if (len == 0) {\n    return new String[0];\n  }\n  List<String> list=new ArrayList<String>();\n  int i=0;\n  int start=0;\n  boolean match=false;\n  while (i < len) {\n    if (str.charAt(i) == '\\\\') {\n      match=true;\n      i+=2;\n    }\n else     if (str.charAt(i) == separatorChar) {\n      if (retainEmpty || match) {\n        list.add(str.substring(start,i));\n        match=false;\n      }\n      start=++i;\n    }\n else {\n      match=true;\n      i++;\n    }\n  }\n  if (retainEmpty || match) {\n    list.add(str.substring(start,i));\n  }\n  return list.toArray(new String[list.size()]);\n}\n", "nl": "does not take into account escaped separators"}
{"code": "public static String completeAssignment(HttpServletRequest request,HttpServletResponse response){\n  LocalDispatcher dispatcher=(LocalDispatcher)request.getAttribute(\"dispatcher\");\n  GenericValue userLogin=(GenericValue)request.getSession().getAttribute(\"userLogin\");\n  Map<String,Object> parameterMap=UtilHttp.getParameterMap(request);\n  String workEffortId=(String)parameterMap.remove(\"workEffortId\");\n  String partyId=(String)parameterMap.remove(\"partyId\");\n  String roleTypeId=(String)parameterMap.remove(\"roleTypeId\");\n  String fromDateStr=(String)parameterMap.remove(\"fromDate\");\n  java.sql.Timestamp fromDate=null;\n  Locale locale=UtilHttp.getLocale(request);\n  try {\n    fromDate=(java.sql.Timestamp)ObjectType.simpleTypeConvert(fromDateStr,\"java.sql.Timestamp\",null,null);\n  }\n catch (  GeneralException e) {\n    request.setAttribute(\"_ERROR_MESSAGE_\",UtilProperties.getMessage(resource_error,\"OrderInvalidDateFormatForFromDate\",locale));\n    return \"error\";\n  }\n  Map<String,Object> result=null;\n  try {\n    Map<String,? extends Object> context=UtilMisc.toMap(\"workEffortId\",workEffortId,\"partyId\",partyId,\"roleTypeId\",roleTypeId,\"fromDate\",fromDate,\"result\",parameterMap,\"userLogin\",userLogin);\n    result=dispatcher.runSync(\"wfCompleteAssignment\",context);\n    if (result.containsKey(ModelService.RESPOND_ERROR)) {\n      request.setAttribute(\"_ERROR_MESSAGE_\",result.get(ModelService.ERROR_MESSAGE));\n      return \"error\";\n    }\n  }\n catch (  GenericServiceException e) {\n    request.setAttribute(\"_ERROR_MESSAGE_\",UtilProperties.getMessage(resource_error,\"OrderProblemsInvokingTheCompleteAssignmentService\",locale));\n    return \"error\";\n  }\n  return \"success\";\n}\n", "nl": "Complete assignment event"}
{"code": "@Override public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (obj == null) {\n    return false;\n  }\n  if (!(obj instanceof BlockInfo)) {\n    return false;\n  }\n  BlockInfo other=(BlockInfo)obj;\n  if (!info.getSegmentId().equals(other.info.getSegmentId())) {\n    return false;\n  }\n  if (info.getBlockOffset() != other.info.getBlockOffset()) {\n    return false;\n  }\n  if (info.getBlockLength() != info.getBlockLength()) {\n    return false;\n  }\n  if (info.getFilePath() == null && other.info.getFilePath() != null) {\n    return false;\n  }\n else   if (info.getFilePath() != null && other.info.getFilePath() == null) {\n    return false;\n  }\n else   if (!info.getFilePath().equals(other.info.getFilePath())) {\n    return false;\n  }\n  return true;\n}\n", "nl": "To check the equality"}
{"code": "static Class findProviderClass(String className,ClassLoader cl,boolean doFallback) throws ClassNotFoundException, ConfigurationError {\n  SecurityManager security=System.getSecurityManager();\n  if (security != null) {\n    final int lastDot=className.lastIndexOf(\".\");\n    String packageName=className;\n    if (lastDot != -1)     packageName=className.substring(0,lastDot);\n    security.checkPackageAccess(packageName);\n  }\n  Class providerClass;\n  if (cl == null) {\n    providerClass=Class.forName(className);\n  }\n else {\n    try {\n      providerClass=cl.loadClass(className);\n    }\n catch (    ClassNotFoundException x) {\n      if (doFallback) {\n        ClassLoader current=ObjectFactory.class.getClassLoader();\n        if (current == null) {\n          providerClass=Class.forName(className);\n        }\n else         if (cl != current) {\n          cl=current;\n          providerClass=cl.loadClass(className);\n        }\n else {\n          throw x;\n        }\n      }\n else {\n        throw x;\n      }\n    }\n  }\n  return providerClass;\n}\n", "nl": "Find a Class using the specified ClassLoader"}
{"code": "public static boolean checkURLforSpiders(HttpServletRequest request){\n  boolean result=false;\n  String spiderRequest=(String)request.getAttribute(\"_REQUEST_FROM_SPIDER_\");\n  if (UtilValidate.isNotEmpty(spiderRequest)) {\n    if (\"Y\".equals(spiderRequest)) {\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n else {\n    String initialUserAgent=request.getHeader(\"User-Agent\") != null ? request.getHeader(\"User-Agent\") : \"\";\n    List<String> spiderList=StringUtil.split(UtilProperties.getPropertyValue(\"url\",\"link.remove_lsessionid.user_agent_list\"),\",\");\n    if (UtilValidate.isNotEmpty(spiderList)) {\n      for (      String spiderNameElement : spiderList) {\n        Pattern pattern=null;\n        try {\n          pattern=PatternFactory.createOrGetPerl5CompiledPattern(spiderNameElement,false);\n        }\n catch (        MalformedPatternException e) {\n          Debug.logError(e,module);\n        }\n        PatternMatcher matcher=new Perl5Matcher();\n        if (matcher.contains(initialUserAgent,pattern)) {\n          request.setAttribute(\"_REQUEST_FROM_SPIDER_\",\"Y\");\n          result=true;\n          break;\n        }\n      }\n    }\n  }\n  if (!result) {\n    request.setAttribute(\"_REQUEST_FROM_SPIDER_\",\"N\");\n  }\n  return result;\n}\n", "nl": "checks, if the current request comes from a searchbot"}
{"code": "public static void saveToSdCard(List<Entry> entries,String path){\n  File sdcard=Environment.getExternalStorageDirectory();\n  File saved=new File(sdcard,path);\n  if (!saved.exists()) {\n    try {\n      saved.createNewFile();\n    }\n catch (    IOException e) {\n      Log.e(LOG,e.toString());\n    }\n  }\n  BufferedWriter buf=null;\n  try {\n    buf=new BufferedWriter(new FileWriter(saved,true));\n    for (    Entry e : entries) {\n      buf.append(e.getVal() + \"#\" + e.getXIndex());\n      buf.newLine();\n    }\n  }\n catch (  IOException e) {\n    Log.e(LOG,e.toString());\n  }\n finally {\n    if (buf != null)     try {\n      buf.close();\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "nl": "Saves an Array of Entries to the specified location on the sdcard"}
{"code": "public static void searchInScope(PsiElement originalElement,Processor<BuildElement> processor){\n  boolean topLevelScope=true;\n  PsiElement element=originalElement;\n  while (!(element instanceof PsiFileSystemItem)) {\n    PsiElement parent=element.getParent();\n    if (parent instanceof BuildFile) {\n      if (!((BuildFile)parent).searchSymbolsInScope(processor,topLevelScope ? element : null)) {\n        return;\n      }\n    }\n else     if (parent instanceof FunctionStatement) {\n      topLevelScope=false;\n      for (      Parameter param : ((FunctionStatement)parent).getParameters()) {\n        if (!processor.process(param)) {\n          return;\n        }\n      }\n    }\n else     if (parent instanceof ForStatement) {\n      for (      Expression expr : ((ForStatement)parent).getForLoopVariables()) {\n        if (expr instanceof TargetExpression && !processor.process(expr)) {\n          return;\n        }\n      }\n    }\n else     if (parent instanceof StatementList) {\n      if (!visitChildAssignmentStatements((BuildElement)parent,(Processor)processor)) {\n        return;\n      }\n    }\n    element=parent;\n  }\n}\n", "nl": "Walks up PSI tree of local file, checking PsiNamedElements"}
{"code": "public void pasteClipboardByAttribute(String attribute) throws IOException {\n  final Clipboard clipboard=Clipboard.getSystemClipboard();\n  Set<Pair<Integer,Integer>> selectedPairs=getSelectedPairs();\n  if (selectedPairs.size() > 0) {\n    BitSet rows=getSelectedSampleIndices();\n    String contents=clipboard.getString().trim().replaceAll(\"\\r\\n\",\"\\n\").replaceAll(\"\\r\",\"\\n\");\n    String[] lines=contents.split(\"\\n\");\n    if (lines.length > 0) {\n      final int guideCol=dataGrid.findColumn(attribute);\n      final Map<String,String> attributeValue2Line=new HashMap<>();\n      int inputLineNumber=0;\n      String[] toPaste=new String[getNumberOfSelectedSamples()];\n      int expandedLineNumber=0;\n      for (int row=rows.nextSetBit(1); row != -1; row=rows.nextSetBit(row + 1)) {\n        String value=dataGrid.getValue(row,guideCol);\n        if (!attributeValue2Line.containsKey(value)) {\n          if (inputLineNumber == lines.length)           break;\n          toPaste[expandedLineNumber++]=lines[inputLineNumber];\n          attributeValue2Line.put(value,lines[inputLineNumber++]);\n        }\n else {\n          if (expandedLineNumber == toPaste.length)           break;\n          toPaste[expandedLineNumber++]=attributeValue2Line.get(value);\n        }\n      }\n      if (attributeValue2Line.size() != lines.length) {\n        throw new IOException(\"Mismatch between number of lines pasted (\" + lines.length + \") and number of attribute values (\"+ attributeValue2Line.size()+ \")\");\n      }\n      paste(toPaste);\n    }\n  }\n}\n", "nl": "pastes lines into table guided by an attribute"}
{"code": "public final String toString(){\n  StringBuffer str=new StringBuffer();\n  str.append(getTagId());\n  str.append('\\t');\n  str.append(getTagName());\n  str.append('\\t');\n  if (getTagValue() != null) {\n    str.append(getTagValue());\n  }\n else {\n    str.append(\"null\");\n  }\n  str.append('\\t');\n  str.append(getTagValueDesc());\n  str.append('\\t');\n  str.append(getTagDataType());\n  str.append('\\t');\n  str.append(getSourceTimestamp());\n  str.append('\\t');\n  str.append(getDaqTimestamp());\n  str.append('\\t');\n  str.append(getServerTimestamp());\n  str.append('\\t');\n  str.append(getTagQualityCode());\n  str.append('\\t');\n  if ((getTagQualityDesc() != null) && (getTagQualityDesc().equals(\"\"))) {\n    str.append(\"null\");\n  }\n else {\n    str.append(getTagQualityDesc());\n  }\n  str.append('\\t');\n  str.append(getTagMode());\n  str.append('\\t');\n  str.append(getTagDir());\n  str.append('\\t');\n  str.append(new Timestamp(System.currentTimeMillis()));\n  return str.toString();\n}\n", "nl": "Converts a DataTagShortTermLog object into a string representation"}
{"code": "public int checkBookiesUp(int count,int timeout) throws Exception {\n  ZooKeeper zkc=connectZooKeeper(zkHost,zkPort,zkTimeoutSec);\n  try {\n    int mostRecentSize=0;\n    for (int i=0; i < timeout; i++) {\n      try {\n        List<String> children=zkc.getChildren(\"/ledgers/available\",false);\n        children.remove(\"readonly\");\n        mostRecentSize=children.size();\n        if ((mostRecentSize > count) || LOG.isDebugEnabled()) {\n          LOG.info(\"Found \" + mostRecentSize + \" bookies up, \"+ \"waiting for \"+ count);\n          if ((mostRecentSize > count) || LOG.isTraceEnabled()) {\n            for (            String child : children) {\n              LOG.info(\" server: \" + child);\n            }\n          }\n        }\n        if (mostRecentSize == count) {\n          break;\n        }\n      }\n catch (      KeeperException e) {\n      }\n      Thread.sleep(1000);\n    }\n    return mostRecentSize;\n  }\n  finally {\n    zkc.close();\n  }\n}\n", "nl": "Check that a number of bookies are available"}
{"code": "private void collectMethodsReturningClassType(TypeElement originalClass){\n  TypeElement clazz=originalClass;\n  while (clazz.getSuperclass().getKind() != TypeKind.NONE) {\n    for (    Element subElement : clazz.getEnclosedElements()) {\n      Set<Modifier> modifiers=subElement.getModifiers();\n      if (subElement.getKind() == ElementKind.METHOD && !modifiers.contains(Modifier.PRIVATE) && !modifiers.contains(Modifier.FINAL) && !modifiers.contains(Modifier.STATIC)) {\n        TypeMirror methodReturnType=((ExecutableType)subElement.asType()).getReturnType();\n        if (methodReturnType.equals(clazz.asType()) || typeUtils.isSubtype(clazz.asType(),methodReturnType)) {\n          List<? extends TypeMirror> params=((ExecutableType)subElement.asType()).getParameterTypes();\n          String methodName=subElement.getSimpleName().toString();\n          if (methodName.equals(RESET_METHOD) && params.isEmpty()) {\n            continue;\n          }\n          if (params.size() == 1) {\n            TypeMirror param=params.get(0);\n            ParameterSpec parameterSpec;\n            if (methodName.equals(LAYOUT_METHOD) && param.getKind() == TypeKind.INT) {\n              parameterSpec=ParameterSpec.builder(int.class,methodName).addAnnotation(LAYOUT_RES_ANNOTATION).build();\n            }\n else {\n              parameterSpec=ParameterSpec.builder(TypeName.get(param),methodName).build();\n            }\n            methodsReturningClassType.add(new MethodInfo(methodName,modifiers,Collections.singletonList(parameterSpec)));\n          }\n else {\n            methodsReturningClassType.add(new MethodInfo(methodName,modifiers,buildParamList(params)));\n          }\n        }\n      }\n    }\n    clazz=(TypeElement)typeUtils.asElement(clazz.getSuperclass());\n  }\n}\n", "nl": "Get information about methods returning class type of the original class so we can duplicate them in the generated class for chaining purposes"}
{"code": "public Matrix solve(Matrix B){\n  if (B.getRowDimension() != m) {\n    throw new IllegalArgumentException(\"Matrix row dimensions must agree.\");\n  }\n  if (!this.isNonsingular()) {\n    throw new RuntimeException(\"Matrix is singular.\");\n  }\n  int nx=B.getColumnDimension();\n  Matrix Xmat=B.getMatrix(piv,0,nx - 1);\n  double[][] X=Xmat.getArray();\n  for (int k=0; k < n; k++) {\n    for (int i=k + 1; i < n; i++) {\n      for (int j=0; j < nx; j++) {\n        X[i][j]-=X[k][j] * LU[i][k];\n      }\n    }\n  }\n  for (int k=n - 1; k >= 0; k--) {\n    for (int j=0; j < nx; j++) {\n      X[k][j]/=LU[k][k];\n    }\n    for (int i=0; i < k; i++) {\n      for (int j=0; j < nx; j++) {\n        X[i][j]-=X[k][j] * LU[i][k];\n      }\n    }\n  }\n  return Xmat;\n}\n", "nl": "Solve A*X = B"}
{"code": "private String computeConsensus(Map<String,String> globalAlignment,char unknownChar){\n  if (globalAlignment.size() > 0) {\n    String firstRow=globalAlignment.values().iterator().next();\n    StringBuilder buf=new StringBuilder();\n    Map<Character,Integer> char2count=new HashMap<>();\n    for (int i=0; i < firstRow.length(); i++) {\n      for (      String row : globalAlignment.values()) {\n        char ch=row.charAt(i);\n        if (Character.isLetter(ch)) {\n          Integer count=char2count.get(ch);\n          if (count == null)           char2count.put(ch,1);\n else           char2count.put(ch,count + 1);\n        }\n      }\n      char bestChar=unknownChar;\n      int bestCount=0;\n      for (      Character ch : char2count.keySet()) {\n        if (char2count.get(ch) > bestCount) {\n          bestChar=ch;\n          bestCount=char2count.get(ch);\n        }\n      }\n      buf.append(bestChar);\n      char2count.clear();\n    }\n    return buf.toString();\n  }\n else   return \"\";\n}\n", "nl": "computes the consensus for a set of reads or references"}
{"code": "public static boolean addSmiles(Context context,Spannable spannable){\n  boolean hasChanges=false;\n  for (  Entry<Pattern,Object> entry : emoticons.entrySet()) {\n    Matcher matcher=entry.getKey().matcher(spannable);\n    while (matcher.find()) {\n      boolean set=true;\n      for (      ImageSpan span : spannable.getSpans(matcher.start(),matcher.end(),ImageSpan.class))       if (spannable.getSpanStart(span) >= matcher.start() && spannable.getSpanEnd(span) <= matcher.end())       spannable.removeSpan(span);\n else {\n        set=false;\n        break;\n      }\n      if (set) {\n        hasChanges=true;\n        Object value=entry.getValue();\n        if (value instanceof String && !((String)value).startsWith(\"http\")) {\n          File file=new File((String)value);\n          if (!file.exists() || file.isDirectory()) {\n            return false;\n          }\n          spannable.setSpan(new ImageSpan(context,Uri.fromFile(file)),matcher.start(),matcher.end(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        }\n else {\n          spannable.setSpan(new ImageSpan(context,(Integer)value),matcher.start(),matcher.end(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        }\n      }\n    }\n  }\n  return hasChanges;\n}\n", "nl": "replace existing spannable with smiles"}
{"code": "public static ListOfLongs loadQueryLocations(DAAHeader daaHeader,String classificationName,Collection<Integer> classIds) throws IOException {\n  for (int i=0; i < daaHeader.getBlockTypeRankArrayLength() - 1; i++) {\n    final int j=i + 1;\n    if (daaHeader.getBlockType(i) == BlockType.megan_classification_key_block && daaHeader.getBlockType(j) == BlockType.megan_classification_dump_block) {\n      try (InputReaderLittleEndian insKey=new InputReaderLittleEndian(new FileRandomAccessReadOnlyAdapter(daaHeader.getFileName()))){\n        final long keyBase=daaHeader.computeBlockStart(i);\n        insKey.seek(keyBase);\n        final String cName=insKey.readNullTerminatedBytes();\n        if (cName.equals(classificationName)) {\n          final int numberOfClasses=insKey.readInt();\n          final ListOfLongs list=new ListOfLongs(100000);\n          try (InputReaderLittleEndian insDump=new InputReaderLittleEndian(new FileRandomAccessReadOnlyAdapter(daaHeader.getFileName()))){\n            final long dumpBase=daaHeader.computeBlockStart(j);\n            insDump.seek(dumpBase);\n            if (!insDump.readNullTerminatedBytes().equals(classificationName))             throw new IOException(\"Internal error: key-dump mismatch\");\n            for (int c=0; c < numberOfClasses; c++) {\n              int classId=insKey.readInt();\n              insKey.skip(4);\n              int size=insKey.readInt();\n              final long offset=insKey.readLong();\n              if (classIds.contains(classId)) {\n                insDump.seek(dumpBase + offset);\n                for (int n=0; n < size; n++) {\n                  list.add(insDump.readLong());\n                }\n              }\n            }\n          }\n           return list;\n        }\n      }\n     }\n  }\n  return null;\n}\n", "nl": "load all query locations for a given classification and class ids"}
{"code": "@Override public AudioInputStream synthesizeUsingImposedF0(int sourceIndex,int targetIndex,AudioFileFormat aft) throws SynthesisException {\n  if (!f0ContourImposeSupport) {\n    throw new SynthesisException(\"Mary configuration of this voice doesn't support intonation contour imposition\");\n  }\n  int numberOfUnits=unitFileReader.getNumberOfUnits();\n  if (sourceIndex >= numberOfUnits || targetIndex >= numberOfUnits) {\n    throw new IllegalArgumentException(\"sourceIndex(\" + sourceIndex + \") and targetIndex(\"+ targetIndex+ \") are should be less than number of available units (\"+ numberOfUnits+ \")\");\n  }\n  if (sourceIndex == targetIndex) {\n    return reSynthesize(sourceIndex,aft);\n  }\n  double[] sourceF0=this.vIntonationReader.getContour(sourceIndex);\n  double[] targetF0coeffs=this.vIntonationReader.getIntonationCoeffs(targetIndex);\n  double[] sourceF0coeffs=this.vIntonationReader.getIntonationCoeffs(sourceIndex);\n  if (targetF0coeffs == null || sourceF0coeffs == null) {\n    return reSynthesize(sourceIndex,aft);\n  }\n  if (targetF0coeffs.length == 0 || sourceF0coeffs.length == 0) {\n    return reSynthesize(sourceIndex,aft);\n  }\n  double[] targetF0=Polynomial.generatePolynomialValues(targetF0coeffs,sourceF0.length,0,1);\n  sourceF0=Polynomial.generatePolynomialValues(sourceF0coeffs,sourceF0.length,0,1);\n  assert targetF0.length == sourceF0.length;\n  double[] tScalesArray=new double[sourceF0.length];\n  double[] pScalesArray=new double[sourceF0.length];\n  for (int i=0; i < targetF0.length; i++) {\n    pScalesArray[i]=(float)(targetF0[i] / sourceF0[i]);\n    tScalesArray[i]=(float)(1.0);\n  }\n  return synthesizeUsingF0Modification(sourceIndex,pScalesArray,tScalesArray,aft);\n}\n", "nl": "Impose target intonation contour on given vocalization using HNM technology"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  ChartViewer viewer=(ChartViewer)getViewer();\n  np.matchIgnoreCase(\"hide what=\");\n  final String what=np.getWordMatchesIgnoringCase(\"all none selected unselected\");\n  final LabelsJList list;\n  if (np.peekMatchIgnoreCase(\"target=\")) {\n    np.matchIgnoreCase(\"target=\");\n    list=viewer.getLabelsJList(np.getWordMatchesIgnoringCase(\"series classes attributes\"));\n  }\n else {\n    list=viewer.getActiveLabelsJList();\n  }\n  np.matchIgnoreCase(\";\");\n  if (what.equalsIgnoreCase(\"none\")) {\n    list.enableLabels(list.getAllLabels());\n  }\n else   if (what.equalsIgnoreCase(\"selected\")) {\n    list.disableLabels(list.getSelectedLabels());\n  }\n else   if (what.equalsIgnoreCase(\"unselected\")) {\n    final Set<String> labels=new HashSet<>();\n    labels.addAll(list.getAllLabels());\n    labels.removeAll(list.getSelectedLabels());\n    list.disableLabels(labels);\n  }\n else {\n    list.disableLabels(list.getAllLabels());\n  }\n  if (list.getName().equalsIgnoreCase(\"series\"))   viewer.getChartData().setEnabledSeries(list.getEnabledLabels());\n}\n", "nl": "parses the given command and executes it"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  final ClusterViewer viewer=getViewer();\n  int maxPC=viewer.getPcoaTab().getPCoA().getNumberOfPositiveEigenValues();\n  np.matchIgnoreCase(\"set pc1=\");\n  int pc1=np.getInt(1,maxPC);\n  np.matchIgnoreCase(\"pc2=\");\n  int pc2=np.getInt(1,maxPC);\n  int pc3=Math.max(pc1,pc2) + 1;\n  if (np.peekMatchIgnoreCase(\";\")) {\n    viewer.getPcoaTab().set3dMode(false);\n  }\n else {\n    np.matchIgnoreCase(\"pc3=\");\n    pc3=np.getInt(1,maxPC);\n    viewer.getPcoaTab().set3dMode(true);\n  }\n  np.matchIgnoreCase(\";\");\n  if (pc1 == pc2)   throw new IOException(\"pc1==pc2\");\n  if (pc1 == pc3)   throw new IOException(\"pc1==pc3\");\n  if (pc2 == pc3)   throw new IOException(\"pc2==pc3\");\n{\n    viewer.getPcoaTab().setFirstPC(pc1 - 1);\n    viewer.getPcoaTab().setSecondPC(pc2 - 1);\n    viewer.getPcoaTab().setThirdPC(pc3 - 1);\n    final Taxa taxa=new Taxa();\n    java.util.List<String> pids=((Director)getDir()).getDocument().getSampleNames();\n    for (    String name : pids) {\n      taxa.add(name);\n    }\n    viewer.getPcoaTab().setData(taxa,null);\n    viewer.updateConvexHulls=true;\n    viewer.addFormatting(viewer.getPcoaTab().getGraphView());\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public static <T>int linearSearch(List<? extends T> list,Comparator<T> comparator,T key,int initialGuess){\n  int guess=initialGuess;\n  if (guess >= list.size()) {\n    guess=list.size() - 1;\n  }\n  int comparison=comparator.compare(list.get(guess),key);\n  if (comparison == 0) {\n    return guess;\n  }\n  if (comparison < 0) {\n    guess++;\n    while (guess < list.size()) {\n      comparison=comparator.compare(list.get(guess),key);\n      if (comparison == 0) {\n        return guess;\n      }\n      if (comparison > 0) {\n        return -(guess + 1);\n      }\n      guess++;\n    }\n    return -(list.size() + 1);\n  }\n else {\n    guess--;\n    while (guess >= 0) {\n      comparison=comparator.compare(list.get(guess),key);\n      if (comparison == 0) {\n        return guess;\n      }\n      if (comparison < 0) {\n        return -(guess + 2);\n      }\n      guess--;\n    }\n    return -1;\n  }\n}\n", "nl": "Performs a linear search in a sorted list for key, starting at initialGuess"}
{"code": "public void process(Document doc){\n  TreeWalker tw=DomUtils.createTreeWalker(doc,MaryXML.PROSODY);\n  Element e=null;\n  while ((e=(Element)tw.nextNode()) != null) {\n    Log.d(Mary.LOG,\"Found prosody element around '\" + DomUtils.getPlainTextBelow(e) + \"'\");\n    boolean hasRateAttribute=e.hasAttribute(\"rate\");\n    boolean hasContourAttribute=e.hasAttribute(\"contour\");\n    boolean hasPitchAttribute=e.hasAttribute(\"pitch\");\n    NodeList nl=e.getElementsByTagName(\"ph\");\n    if (nl.getLength() == 0) {\n      continue;\n    }\n    if (hasRateAttribute) {\n      applySpeechRateSpecifications(nl,e.getAttribute(\"rate\"));\n    }\n    if (hasPitchAttribute || hasContourAttribute) {\n      double[] f0Contour=getF0Contour(nl);\n      double[] coeffs=Polynomial.fitPolynomial(f0Contour,1);\n      double[] baseF0Contour=Polynomial.generatePolynomialValues(coeffs,F0CONTOUR_LENGTH,0,1);\n      double[] diffF0Contour=new double[F0CONTOUR_LENGTH];\n      for (int i=0; i < f0Contour.length; i++) {\n        diffF0Contour[i]=f0Contour[i] - baseF0Contour[i];\n      }\n      if (hasPitchAttribute) {\n        baseF0Contour=applyPitchSpecifications(nl,baseF0Contour,e.getAttribute(\"pitch\"));\n      }\n      if (hasContourAttribute) {\n        baseF0Contour=applyContourSpecifications(nl,baseF0Contour,e.getAttribute(\"contour\"));\n      }\n      for (int i=0; i < f0Contour.length; i++) {\n        f0Contour[i]=diffF0Contour[i] + baseF0Contour[i];\n      }\n      setModifiedContour(nl,f0Contour);\n    }\n  }\n}\n", "nl": "A method to modify prosody modifications"}
{"code": "private AudioInputStream synthesizeUsingF0Modification(int backchannelNumber,float[] pScalesArray,float[] pScalesTimes,float[] tScalesArray,float[] tScalesTimes,AudioFileFormat aft) throws SynthesisException {\n  if (backchannelNumber > vHNMFeaturesReader.getNumberOfUnits()) {\n    throw new IllegalArgumentException(\"requesting unit should not be more than number of units\");\n  }\n  if (!f0ContourImposeSupport) {\n    throw new SynthesisException(\"Mary configuration of this voice doesn't support intonation contour imposition\");\n  }\n  BasicProsodyModifierParams pmodParams=new BasicProsodyModifierParams(tScalesArray,tScalesTimes,pScalesArray,pScalesTimes);\n  HntmSpeechSignal hnmSignal=vHNMFeaturesReader.getHntmSpeechSignal(backchannelNumber);\n  HntmSynthesizer hs=new HntmSynthesizer();\n  HntmSynthesizedSignal xhat=hs.synthesize(hnmSignal,null,null,pmodParams,null,analysisParams,synthesisParams);\n  AudioFormat af;\n  if (aft == null) {\n    float sampleRate=16000.0F;\n    int sampleSizeInBits=16;\n    int channels=1;\n    boolean signed=true;\n    boolean bigEndian=false;\n    af=new AudioFormat(sampleRate,sampleSizeInBits,channels,signed,bigEndian);\n  }\n else {\n    af=aft.getFormat();\n  }\n  double[] audio_double=xhat.output;\n  double MaxSample=MathUtils.getAbsMax(audio_double);\n  for (int i=0; i < audio_double.length; i++) {\n    audio_double[i]=0.3 * (audio_double[i] / MaxSample);\n  }\n  DDSAudioInputStream oais=new DDSAudioInputStream(new BufferedDoubleDataSource(audio_double),af);\n  return oais;\n}\n", "nl": "modify intonation contour using HNM technology"}
{"code": "private boolean validateEquippedArmor(Item item,boolean validateOnly){\n  ArmorType armorType=item.getItemTemplate().getArmorType();\n  if (armorType == null) {\n    return true;\n  }\n  if (armorType == ArmorType.ARROW) {\n    return false;\n  }\n  int[] requiredSkills=armorType.getRequiredSkills();\n  if (!checkAvailableEquipSkills(requiredSkills)) {\n    return false;\n  }\n  ItemSlot slotToCheck1=ItemSlot.MAIN_HAND;\n  ItemSlot slotToCheck2=ItemSlot.SUB_HAND;\n  if ((item.getEquipmentSlot() & ItemSlot.MAIN_OFF_OR_SUB_OFF.getSlotIdMask()) != 0) {\n    slotToCheck1=ItemSlot.MAIN_OFF_HAND;\n    slotToCheck2=ItemSlot.SUB_OFF_HAND;\n  }\n  Item itemInMainHand=equipment.get(slotToCheck1.getSlotIdMask());\n  if (itemInMainHand != null && armorType == ArmorType.SHIELD && itemInMainHand.getItemTemplate().isTwoHandWeapon()) {\n    if (validateOnly) {\n      if (owner.getInventory().isFull()) {\n        return false;\n      }\n      markedFreeSlots.add(slotToCheck1.getSlotIdMask());\n      markedFreeSlots.add(slotToCheck2.getSlotIdMask());\n    }\n else {\n      unEquip(slotToCheck1.getSlotIdMask() | slotToCheck2.getSlotIdMask());\n    }\n  }\n  return true;\n}\n", "nl": "Used during equip process and analyzes equipped slots"}
{"code": "private void close(Collection<WatchedObject> bucket,SocketAddress serverAddress,Exception e,long originalInvocationVersion) throws IOException {\n  for (  WatchedObject watched : bucket) {\n    long currentWatchedInvocationVersion=watched.getVersion();\n    if (!RequestResponseTimeoutObserver.DISABLE_RESPONSE_WATCH && currentWatchedInvocationVersion > originalInvocationVersion) {\n      if (_logger.isLoggable(Level.FINER)) {\n        _logger.log(Level.FINER,\"Not closing invalid connection as current invocation version does not match\" + \" original invocation version. [original version=\" + originalInvocationVersion + \", current version=\"+ currentWatchedInvocationVersion+ \"original message [\"+ getInvalidConnectionMessage(serverAddress,watched.getSocket(),watched)+ \"[\"+ e+ \"]]\");\n      }\n      continue;\n    }\n    try {\n      watched.stopWatch();\n      watched.setException(e);\n      Level closeConnectionLoggingLevel=getCloseConnectionLoggingLevel();\n      if (_logger.isLoggable(closeConnectionLoggingLevel)) {\n        String invalidConnectionMessage=getInvalidConnectionMessage(serverAddress,watched.getSocket(),watched);\n        _logger.log(closeConnectionLoggingLevel,invalidConnectionMessage + \"[\" + e+ \"]\",e);\n      }\n      if (watched.getSocket().isBlocking()) {\n        watched.getSocket().close();\n      }\n else {\n        AsyncContext context=((CPeer)watched.getClient()).getAsyncContext();\n        if (context != null) {\n          context.setSelectionKey(null);\n          context.close(new ClosedChannelException());\n        }\n      }\n    }\n catch (    Exception ex) {\n      if (_logger.isLoggable(Level.FINE)) {\n        _logger.log(Level.FINE,getFailureToCloseInvalidConnectionMessage(serverAddress,watched.getSocket()),ex);\n      }\n    }\n  }\n}\n", "nl": "Close client socket"}
{"code": "public static String substituteParams(String sql,List<Integer> paramOrder) throws IOException {\n  if (sql.indexOf(\"?\") == -1)   return sql;\n  paramOrder.clear();\n  StreamTokenizer tok=new StreamTokenizer(new StringReader(sql));\n  tok.resetSyntax();\n  tok.quoteChar('\\'');\n  tok.wordChars('0','9');\n  tok.wordChars('?','?');\n  StringBuilder buf=new StringBuilder(sql.length());\n  for (int ttype; (ttype=tok.nextToken()) != StreamTokenizer.TT_EOF; ) {\nswitch (ttype) {\ncase StreamTokenizer.TT_WORD:\n      if (tok.sval.startsWith(\"?\")) {\n        buf.append(\"?\");\n        String pIndex=tok.sval.substring(1);\n        if (pIndex.length() > 0) {\n          paramOrder.add(Integer.valueOf(pIndex));\n        }\n else {\n          paramOrder.add(paramOrder.size() + 1);\n        }\n      }\n else       buf.append(tok.sval);\n    break;\ncase '\\'':\n  buf.append('\\'');\nif (tok.sval != null) {\n  buf.append(tok.sval);\n  buf.append('\\'');\n}\nbreak;\ndefault :\nbuf.append((char)ttype);\n}\n}\nreturn buf.toString();\n}\n", "nl": "Utility method to substitute '?num' for parameters in the given SQL statement, and fill-in the order of the parameter tokens"}
{"code": "public static String deflate(String previous,String current){\n  if (previous == null)   return current;\n  StringBuilder buf=new StringBuilder();\n  int start1=0;\n  int start2=0;\n  while (start1 < previous.length() && start2 < current.length()) {\n    int end1=start1;\n    int end2=start2;\n    while (end1 <= previous.length() && end2 <= current.length()) {\n      int c1=(end1 < previous.length() ? previous.charAt(end1) : '\\t');\n      int c2=(end2 < current.length() ? current.charAt(end2) : '\\t');\n      if (c1 == c2) {\n        if (c1 == '\\t') {\n          buf.append(\"&\");\n          break;\n        }\n else {\n          end1++;\n          end2++;\n        }\n      }\n else {\n        while (end1 < previous.length() && previous.charAt(end1) != '\\t') {\n          end1++;\n        }\n        while (end2 < current.length() && current.charAt(end2) != '\\t') {\n          end2++;\n        }\n        for (int i=start2; i < end2; i++)         buf.append(current.charAt(i));\n        break;\n      }\n    }\n    start1=end1 + 1;\n    start2=end2 + 1;\n    if (start2 < current.length())     buf.append(\"\\t\");\n  }\n  return buf.toString();\n}\n", "nl": "deflate current SAM line by replacing all fields that equalOverShorterOfBoth previous line by an ampersand"}
{"code": "private double computeOneFrameDistance(double[] l1,double[] l2,boolean isBark,double upperFreqInHz){\n  int maxInd1=MathUtils.getLargestIndexSmallerThan(l1,upperFreqInHz);\n  int maxInd2=MathUtils.getLargestIndexSmallerThan(l2,upperFreqInHz);\n  int maxInd=Math.min(maxInd1,maxInd2);\n  double[] tmp1;\n  double[] tmp2;\n  if (maxInd + 1 == l1.length) {\n    tmp1=l1;\n  }\n else {\n    tmp1=new double[maxInd + 1];\n    System.arraycopy(l1,0,tmp1,0,maxInd + 1);\n  }\n  if (maxInd + 1 == l2.length) {\n    tmp2=l2;\n  }\n else {\n    tmp2=new double[maxInd + 1];\n    System.arraycopy(l2,0,tmp2,0,maxInd + 1);\n  }\n  double distance;\n  if (!isBark) {\n    distance=SignalProcUtils.getRmsDistance(tmp1,tmp2);\n  }\n else {\n    distance=SignalProcUtils.getRmsDistance(SignalProcUtils.freq2bark(tmp1),SignalProcUtils.freq2bark(tmp2));\n  }\n  return distance;\n}\n", "nl": "Compute the distance between two LSF frames"}
{"code": "public void disableAllChecks(){\n  super.reset();\n  setLeadingWS(false);\n  setTrailingWS(false);\n  setEmptyTarget(false);\n  setEmptySource(false);\n  setTargetSameAsSource(false);\n  setTargetSameAsSourceForSameLanguage(false);\n  setTargetSameAsSourceWithCodes(false);\n  setCodeDifference(false);\n  setGuessOpenClose(false);\n  setCheckXliffSchema(false);\n  setCheckPatterns(false);\n  setCheckWithLT(false);\n  setTranslateLTMsg(false);\n  setLtBilingualMode(false);\n  setDoubledWord(false);\n  setCorruptedCharacters(false);\n  setCheckMaxCharLength(false);\n  setCheckMinCharLength(false);\n  setCheckStorageSize(false);\n  setCheckAbsoluteMaxCharLength(false);\n  setCheckAllowedCharacters(false);\n  setCheckCharacters(false);\n  setCheckTerms(false);\n  setStringMode(false);\n  setBetweenCodes(false);\n  setCheckBlacklist(false);\n}\n", "nl": "Disables all checks done by the Quality Checker"}
{"code": "public void applyEffect(){\n  if (isFearEffect()) {\n    if (getEffected().isInState(CreatureState.GLIDING)) {\n      if (getEffected() instanceof Player) {\n        if (!((Player)getEffected()).isInFlyingMode()) {\n          ((Player)getEffected()).getFlyController().onStopGliding(true);\n          return;\n        }\n      }\n    }\n  }\n  if (effectHate != 0) {\n    if (getEffected() instanceof Npc && !isDelayedDamage() && !isPetOrder()&& !isSummoning()) {\n      getEffected().getAggroList().addHate(effector,1);\n    }\n    effector.getController().broadcastHate(effectHate);\n  }\n  if (skillTemplate.getEffects() == null || successEffects.isEmpty()) {\n    return;\n  }\n  for (  EffectTemplate template : successEffects.values()) {\n    if (getEffected() != null) {\n      if (getEffected().getLifeStats().isAlreadyDead() && !skillTemplate.hasResurrectEffect()) {\n        continue;\n      }\n    }\n    template.applyEffect(this);\n    template.startSubEffect(this);\n  }\n}\n", "nl": "Apply all effect templates"}
{"code": "private Slot insertSlotAt(final int position,@NonNull final Slot slot){\n  if (position < 0 || size < position) {\n    throw new IndexOutOfBoundsException(\"New slot position should be inside the mask. Or on the tail (position = size)\");\n  }\n  final Slot toInsert=new Slot(slot);\n  Slot currentSlot=getSlot(position);\n  Slot leftNeighbour;\n  Slot rightNeighbour=null;\n  if (currentSlot == null) {\n    leftNeighbour=lastSlot;\n  }\n else {\n    leftNeighbour=currentSlot.getPrevSlot();\n    rightNeighbour=currentSlot;\n  }\n  toInsert.setNextSlot(rightNeighbour);\n  toInsert.setPrevSlot(leftNeighbour);\n  if (rightNeighbour != null) {\n    rightNeighbour.setPrevSlot(toInsert);\n  }\n  if (leftNeighbour != null) {\n    leftNeighbour.setNextSlot(toInsert);\n  }\n  if (position == 0) {\n    firstSlot=toInsert;\n  }\n else   if (position == size) {\n    lastSlot=toInsert;\n  }\n  size++;\n  return toInsert;\n}\n", "nl": "Inserts a slot on a specified position"}
{"code": "public static Map<String,Object> cleanSyncRemoveInfo(DispatchContext dctx,Map<String,? extends Object> context){\n  Debug.logInfo(\"Running cleanSyncRemoveInfo\",module);\n  Delegator delegator=dctx.getDelegator();\n  Locale locale=(Locale)context.get(\"locale\");\n  try {\n    double keepRemoveInfoHours=24;\n    List<GenericValue> entitySyncRemoveList=EntityQuery.use(delegator).from(\"EntitySync\").queryList();\n    for (    GenericValue entitySyncRemove : entitySyncRemoveList) {\n      Double curKrih=entitySyncRemove.getDouble(\"keepRemoveInfoHours\");\n      if (curKrih != null) {\n        double curKrihVal=curKrih.doubleValue();\n        if (curKrihVal > keepRemoveInfoHours) {\n          keepRemoveInfoHours=curKrihVal;\n        }\n      }\n    }\n    int keepSeconds=(int)Math.floor(keepRemoveInfoHours * 3600);\n    Calendar nowCal=Calendar.getInstance();\n    nowCal.setTimeInMillis(System.currentTimeMillis());\n    nowCal.add(Calendar.SECOND,-keepSeconds);\n    Timestamp keepAfterStamp=new Timestamp(nowCal.getTimeInMillis());\n    int numRemoved=delegator.removeByCondition(\"EntitySyncRemove\",EntityCondition.makeCondition(ModelEntity.STAMP_TX_FIELD,EntityOperator.LESS_THAN,keepAfterStamp));\n    Debug.logInfo(\"In cleanSyncRemoveInfo removed [\" + numRemoved + \"] values with TX timestamp before [\"+ keepAfterStamp+ \"]\",module);\n    return ServiceUtil.returnSuccess();\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,\"Error cleaning out EntitySyncRemove info: \" + e.toString(),module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"EntityExtErrorCleaningEntitySyncRemove\",UtilMisc.toMap(\"errorString\",e.toString()),locale));\n  }\n}\n", "nl": "Clean EntitySyncRemove Info"}
{"code": "public void computeAttributes2Taxa2Values(Map<String,Map<String,Number>> taxa2dataset2value,Map<String,Map<String,Number>> attribute2taxa2value){\n  attribute2taxa2value.clear();\n  for (  String attribute : attribute2kind2taxaNames.keySet()) {\n    Map<String,ArrayList<String>> kind2taxaNames=attribute2kind2taxaNames.get(attribute);\n    for (    String kind : kind2taxaNames.keySet()) {\n      String attributeKindPair=attribute + \":\" + kind;\n      List<String> taxonNames=kind2taxaNames.get(kind);\n      for (      String taxonName : taxonNames) {\n        Map<String,Number> dataset2value=taxa2dataset2value.get(taxonName);\n        if (dataset2value != null) {\n          int sum=0;\n          for (          String dataset : dataset2value.keySet()) {\n            if (dataset2value.get(dataset) != null)             sum+=dataset2value.get(dataset).intValue();\n          }\n          if (sum > 0) {\n            Map<String,Number> taxa2value;\n            if (attribute2taxa2value.get(attributeKindPair) != null) {\n              taxa2value=attribute2taxa2value.get(attributeKindPair);\n            }\n else {\n              taxa2value=new TreeMap<>();\n              attribute2taxa2value.put(attributeKindPair,taxa2value);\n            }\n            taxa2value.put(taxonName,sum);\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "give an attribute 2 series 2 values mapping for taxa, computes one for microbial attributes tree window"}
{"code": "private void paste(String[] lines){\n  if (lines.length > 0) {\n    Set<Pair<Integer,Integer>> selectedPairs=getSelectedPairs();\n    if (selectedPairs.size() > 0) {\n      BitSet rows=getSelectedSampleIndices();\n      BitSet cols=getSelectedAttributesIndices();\n      int row=rows.nextSetBit(1);\n      for (      String line : lines) {\n        int col=cols.nextSetBit(1);\n        String[] values=line.trim().split(\"\\t\");\n        for (        String value : values) {\n          value=value.trim();\n          while (col != -1 && !selectedPairs.contains(new Pair<>(row,col)))           col=cols.nextSetBit(col + 1);\n          if (col != -1) {\n            final SpreadsheetCell cell=getSpreadsheetView().getGrid().getRows().get(row).get(col);\n            boolean succeed=cell.getCellType().match(value);\n            if (succeed) {\n              getSpreadsheetView().getGrid().setCellValue(cell.getRow(),cell.getColumn(),cell.getCellType().convertValue(value));\n            }\n            col=cols.nextSetBit(col + 1);\n          }\n else           break;\n        }\n        row=rows.nextSetBit(row + 1);\n        if (row == -1)         break;\n      }\n    }\n  }\n}\n", "nl": "pastes lines into table"}
{"code": "private void calcAngles(){\n  int entryCount=mData.getEntryCount();\n  if (mDrawAngles.length != entryCount) {\n    mDrawAngles=new float[entryCount];\n  }\n else {\n    for (int i=0; i < entryCount; i++) {\n      mDrawAngles[i]=0;\n    }\n  }\n  if (mAbsoluteAngles.length != entryCount) {\n    mAbsoluteAngles=new float[entryCount];\n  }\n else {\n    for (int i=0; i < entryCount; i++) {\n      mAbsoluteAngles[i]=0;\n    }\n  }\n  float yValueSum=mData.getYValueSum();\n  List<IPieDataSet> dataSets=mData.getDataSets();\n  int cnt=0;\n  for (int i=0; i < mData.getDataSetCount(); i++) {\n    IPieDataSet set=dataSets.get(i);\n    for (int j=0; j < set.getEntryCount(); j++) {\n      mDrawAngles[cnt]=calcAngle(Math.abs(set.getEntryForIndex(j).getY()),yValueSum);\n      if (cnt == 0) {\n        mAbsoluteAngles[cnt]=mDrawAngles[cnt];\n      }\n else {\n        mAbsoluteAngles[cnt]=mAbsoluteAngles[cnt - 1] + mDrawAngles[cnt];\n      }\n      cnt++;\n    }\n  }\n}\n", "nl": "calculates the needed angles for the chart slices"}
{"code": "private static String locate(File baseDir,String fileName){\n  if (baseDir == null)   throw new IllegalArgumentException(\"baseDir is null\");\n  if (fileName == null)   throw new IllegalArgumentException(\"subDirName is null\");\n  String foundFile=null;\n  File[] files=BootIOUtils.listFiles(baseDir);\n  List<File> dirList=new ArrayList<File>();\n  for (  File file1 : files) {\n    if (file1.getName().equals(fileName)) {\n      try {\n        foundFile=file1.getCanonicalPath();\n      }\n catch (      IOException e) {\n        e.printStackTrace();\n      }\n      break;\n    }\n else {\n      if (file1.isDirectory() && file1.canRead())       dirList.add(file1);\n    }\n  }\n  if (foundFile == null) {\n    File[] dirs=dirList.toArray(new File[dirList.size()]);\n    for (    File dir : dirs) {\n      String file=locate(dir,fileName);\n      if (file != null) {\n        foundFile=file;\n        break;\n      }\n    }\n  }\n  return (foundFile);\n}\n", "nl": "Locate a file using the starting base directory, traversing down the directory tree as sub-directories are encountered"}
{"code": "@Override public String doRender(Object o){\n  if (o != null) {\n    if (o instanceof Alarm) {\n      Alarm alarm=(Alarm)o;\n      StringBuffer str=new StringBuffer();\n      str.append(alarm.getId());\n      str.append('\\t');\n      str.append(alarm.getTagId());\n      str.append('\\t');\n      str.append(alarm.getTimestamp());\n      str.append('\\t');\n      str.append(alarm.getFaultFamily());\n      str.append('\\t');\n      str.append(alarm.getFaultMember());\n      str.append('\\t');\n      str.append(alarm.getFaultCode());\n      str.append('\\t');\n      str.append(alarm.getState());\n      if (alarm.getInfo() != null) {\n        str.append('\\t');\n        str.append(alarm.getInfo());\n      }\n      return str.toString();\n    }\n else {\n      return o.toString();\n    }\n  }\n else {\n    return null;\n  }\n}\n", "nl": "Implementation of the ObjectRenderer interface"}
{"code": "public static boolean checkComplete(String directory,ShareSecurityCheck securityCheck,Intent intentResult){\n  String meta=securityCheck.getMetaContentMap().get(SO_MEAT_FILE);\n  if (meta == null) {\n    return true;\n  }\n  ArrayList<ShareBsDiffPatchInfo> libraryList=new ArrayList<>();\n  ShareBsDiffPatchInfo.parseDiffPatchInfo(meta,libraryList);\n  if (libraryList.isEmpty()) {\n    return true;\n  }\n  String libraryPath=directory + \"/\" + SO_PATH+ \"/\";\n  HashMap<String,String> libs=new HashMap<>();\n  for (  ShareBsDiffPatchInfo info : libraryList) {\n    if (!ShareBsDiffPatchInfo.checkDiffPatchInfo(info)) {\n      intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK,ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED);\n      ShareIntentUtil.setIntentReturnCode(intentResult,ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);\n      return false;\n    }\n    String middle=info.path + \"/\" + info.name;\n    libs.put(middle,info.md5);\n  }\n  File libraryDir=new File(libraryPath);\n  if (!libraryDir.exists() || !libraryDir.isDirectory()) {\n    ShareIntentUtil.setIntentReturnCode(intentResult,ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST);\n    return false;\n  }\n  for (  String relative : libs.keySet()) {\n    File libFile=new File(libraryPath + relative);\n    if (!libFile.exists()) {\n      ShareIntentUtil.setIntentReturnCode(intentResult,ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST);\n      intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_LIB_PATH,libFile.getAbsolutePath());\n      return false;\n    }\n  }\n  intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_LIBS_PATH,libs);\n  return true;\n}\n", "nl": "all the library files in meta file exist? fast check, only check whether exist"}
{"code": "public void loadFile(IName2IdMap label2id,String fileName,ProgressListener progressListener) throws IOException, CanceledException {\n  System.err.println(\"Loading map from file: \" + fileName);\n  FileInputIterator it=new FileInputIterator(new InputStreamReader(ResourceManager.getFileAsStream(fileName)),fileName);\n  it.setSkipCommentLines(true);\n  it.setSkipEmptyLines(true);\n  progressListener.setProgress(0);\n  progressListener.setMaximum(it.getMaximumProgress());\n  try {\n    while (it.hasNext()) {\n      String aLine=it.next();\n      String[] tokens=aLine.split(\"\\t\");\n      if (tokens.length >= 2) {\n        final Integer id;\n        if (Basic.isInteger(tokens[1])) {\n          id=Basic.parseInt(tokens[1]);\n        }\n else {\n          id=label2id.get(tokens[1]);\n        }\n        if (id != 0)         put(tokens[0],id);\n else         System.err.println(\"Line \" + it.getLineNumber() + \": invalid id: \"+ tokens[1]);\n      }\n else {\n        throw new IOException(\"Loading synonyms-to-id file, line: \" + it.getLineNumber() + \": expected two entries separated by a tab,  got: <\"+ aLine+ \">\");\n      }\n      progressListener.setProgress(it.getProgress());\n    }\n  }\n  finally {\n    it.close();\n    System.err.println(\"Lines loaded: \" + size());\n  }\n}\n", "nl": "load a file of synonyms"}
{"code": "private static void addGradleLibraryProjects(@NonNull LintClient client,@Nullable List<VirtualFile> files,@NonNull Map<AndroidLibrary,Project> libraryMap,@NonNull List<Project> projects,@NonNull AndroidFacet facet,@NonNull AndroidGradleModel androidGradleModel,@NonNull LintModuleProject project,@NonNull Map<Project,Module> projectMap,@NonNull List<Project> dependencies){\n  Collection<AndroidLibrary> libraries=androidGradleModel.getSelectedMainCompileDependencies().getLibraries();\n  for (  AndroidLibrary library : libraries) {\n    Project p=libraryMap.get(library);\n    if (p == null) {\n      File dir=library.getFolder();\n      p=new LintGradleLibraryProject(client,dir,dir,library);\n      libraryMap.put(library,p);\n      projectMap.put(p,facet.getModule());\n      projects.add(p);\n      if (files != null) {\n        VirtualFile libraryDir=LocalFileSystem.getInstance().findFileByIoFile(dir);\n        if (libraryDir != null) {\n          ListIterator<VirtualFile> iterator=files.listIterator();\n          while (iterator.hasNext()) {\n            VirtualFile file=iterator.next();\n            if (VfsUtilCore.isAncestor(libraryDir,file,false)) {\n              project.addFile(VfsUtilCore.virtualToIoFile(file));\n              iterator.remove();\n            }\n          }\n        }\n        if (files.isEmpty()) {\n          files=null;\n        }\n      }\n    }\n    dependencies.add(p);\n  }\n}\n", "nl": "Adds any gradle library projects to the dependency list"}
{"code": "@Override public void renderAxisLabels(Canvas c){\n  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;\n  float[] positions=new float[mYAxis.mEntryCount * 2];\n  for (int i=0; i < positions.length; i+=2) {\n    positions[i + 1]=mYAxis.mEntries[i / 2];\n  }\n  mTrans.pointValuesToPixel(positions);\n  mAxisLabelPaint.setTypeface(mYAxis.getTypeface());\n  mAxisLabelPaint.setTextSize(mYAxis.getTextSize());\n  mAxisLabelPaint.setColor(mYAxis.getTextColor());\n  float xoffset=mYAxis.getXOffset();\n  float yoffset=Utils.calcTextHeight(mAxisLabelPaint,\"A\") / 2.5f + mYAxis.getYOffset();\n  AxisDependency dependency=mYAxis.getAxisDependency();\n  YAxisLabelPosition labelPosition=mYAxis.getLabelPosition();\n  float xPos;\n  if (dependency == AxisDependency.LEFT) {\n    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {\n      mAxisLabelPaint.setTextAlign(Align.RIGHT);\n      xPos=mViewPortHandler.offsetLeft() - xoffset;\n    }\n else {\n      mAxisLabelPaint.setTextAlign(Align.LEFT);\n      xPos=mViewPortHandler.offsetLeft() + xoffset;\n    }\n  }\n else {\n    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {\n      mAxisLabelPaint.setTextAlign(Align.LEFT);\n      xPos=mViewPortHandler.contentRight() + xoffset;\n    }\n else {\n      mAxisLabelPaint.setTextAlign(Align.RIGHT);\n      xPos=mViewPortHandler.contentRight() - xoffset;\n    }\n  }\n  drawYLabels(c,xPos,positions,yoffset);\n}\n", "nl": "draws the y-axis labels to the screen"}
{"code": "public static void launchProc(String cmdLine,String task,String baseName){\n  Process proc=null;\n  String line=null;\n  try {\n    proc=Runtime.getRuntime().exec(cmdLine);\n    InputStream procStdOut=proc.getInputStream();\n    InputStream procStdErr=proc.getErrorStream();\n    StreamLogger stdOutLogger=new StreamLogger(procStdOut,System.out);\n    StreamLogger stdErrLogger=new StreamLogger(procStdErr,System.err);\n    stdOutLogger.start();\n    stdErrLogger.start();\n    try {\n      stdOutLogger.join();\n      stdErrLogger.join();\n    }\n catch (    InterruptedException e) {\n      e.printStackTrace();\n    }\n    proc.waitFor();\n    if (proc.exitValue() != 0) {\n      throw new RuntimeException(task + \" computation failed on file [\" + baseName+ \"]!\\n\"+ \"Command line was: [\"+ cmdLine+ \"].\");\n    }\n  }\n catch (  IOException e) {\n    throw new RuntimeException(task + \" computation provoked an IOException on file [\" + baseName+ \"].\",e);\n  }\ncatch (  InterruptedException e) {\n    throw new RuntimeException(task + \" computation interrupted on file [\" + baseName+ \"].\",e);\n  }\n}\n", "nl": "A general process launcher for the various tasks"}
{"code": "private void loadHeaderAndData(DataInputStream dis){\n  try {\n    if (!General.readWord(dis).equals(\"EST_File\") || !General.readWord(dis).equals(\"Track\")) {\n      throw new Error(\"The given data input stream is not an EST Track file.\");\n    }\n    String token=General.readWord(dis);\n    while (!token.equals(\"EST_Header_End\")) {\n      if (token.equals(\"DataType\")) {\n        isBinary=General.readWord(dis).equals(\"binary\");\n      }\n else       if (token.equals(\"ByteOrder\")) {\n        isBigEndian=General.readWord(dis).equals(\"10\");\n      }\n else       if (token.equals(\"NumFrames\")) {\n        numFrames=Integer.parseInt(General.readWord(dis));\n      }\n else       if (token.equals(\"NumChannels\")) {\n        numChannels=Integer.parseInt(General.readWord(dis));\n      }\n      token=General.readWord(dis);\n    }\n    times=new float[numFrames];\n    frames=new float[numFrames][numChannels];\n    if (isBinary) {\n      loadBinaryData(dis);\n    }\n else {\n      loadTextData(dis);\n    }\n  }\n catch (  IOException ioe) {\n    throw new Error(\"IO Exception while parsing EST Track file: \" + ioe.getMessage());\n  }\n}\n", "nl": "Parse the EST header and load the track data"}
{"code": "public void unLock(File targetFile){\n  File lockFile=new File(targetFile.getParentFile().getAbsolutePath().concat(\"/lock\"));\n  if (!lockFile.exists()) {\n    return;\n  }\n  if (this.mRefCountMap.containsKey(lockFile.getAbsolutePath())) {\n    FileLockCount fileLockCount=this.mRefCountMap.get(lockFile.getAbsolutePath());\n    if (fileLockCount != null) {\n      java.nio.channels.FileLock fileLock=fileLockCount.mFileLock;\n      RandomAccessFile randomAccessFile=fileLockCount.fOs;\n      FileChannel fileChannel=fileLockCount.fChannel;\n      try {\n        if (RefCntDec(lockFile.getAbsolutePath()) <= 0) {\n          if (fileLock != null && fileLock.isValid()) {\n            fileLock.release();\n          }\n          if (randomAccessFile != null) {\n            randomAccessFile.close();\n          }\n          if (fileChannel != null) {\n            fileChannel.close();\n          }\n        }\n      }\n catch (      IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}\n", "nl": "unlock odex file"}
{"code": "protected synchronized void beforeSpaceModeChange(SpaceMode newMode){\n  if (_logger.isLoggable(Level.FINER))   _logger.finer(\"Invoking beforeSpaceModeChange event, new mode \" + newMode);\n  Queue<ISpaceModeListener> remoteListeners=new LinkedList<ISpaceModeListener>();\n  for (Iterator<ISpaceModeListener> iter=_primarySpaceModeListeners.iterator(); iter.hasNext(); ) {\n    ISpaceModeListener listener=iter.next();\n    try {\n      SpaceInitializationIndicator.setInitializer();\n      if (LRMIUtilities.isRemoteProxy(listener)) {\n        if (_logger.isLoggable(Level.FINEST))         _logger.finest(\"located remote listener for beforeSpaceModeChange, adding to asynchronous dispatch queue [\" + listener.toString() + \"]\");\n        remoteListeners.add(listener);\n        continue;\n      }\n      listener.beforeSpaceModeChange(newMode);\n    }\n catch (    DirectPersistencyRecoveryException dpe) {\n      if (_logger.isLoggable(Level.SEVERE)) {\n        _logger.log(Level.SEVERE,dpe.getMessage());\n      }\n      throw dpe;\n    }\ncatch (    Exception rex) {\n      if (_logger.isLoggable(Level.FINE)) {\n        _logger.log(Level.FINE,\"Failed to invoke method ISpaceModeListener.beforeSpaceModeChange(...) implemented by listener [\" + listener + \"]. Action Taken: Unregistered listener\",rex);\n      }\n      _primarySpaceModeListeners.removeListener(listener);\n    }\n finally {\n      SpaceInitializationIndicator.unsetInitializer();\n    }\n  }\n  if (remoteListeners.size() > 0)   dispatchBeforeEventToRemoteListeners(remoteListeners,newMode);\n  if (_logger.isLoggable(Level.FINEST))   _logger.finest(\"completed invoking synchronous beforeSpaceModeChange event with mode \" + newMode);\n}\n", "nl": "Notify the listeners about the event"}
{"code": "public void calcMinMax(){\n  if (mDataSets == null)   return;\n  mYMax=-Float.MAX_VALUE;\n  mYMin=Float.MAX_VALUE;\n  mXMax=-Float.MAX_VALUE;\n  mXMin=Float.MAX_VALUE;\n  for (int i=0, size=mDataSets.size(); i < size; i++) {\n    T set=mDataSets.get(i);\n    calcMinMax(set);\n  }\n  mLeftAxisMax=-Float.MAX_VALUE;\n  mLeftAxisMin=Float.MAX_VALUE;\n  mRightAxisMax=-Float.MAX_VALUE;\n  mRightAxisMin=Float.MAX_VALUE;\n  T firstLeft=getFirstLeft(mDataSets);\n  if (firstLeft != null) {\n    mLeftAxisMax=firstLeft.getYMax();\n    mLeftAxisMin=firstLeft.getYMin();\n    for (int i=0; i < mDataSets.size(); i++) {\n      T dataSet=mDataSets.get(i);\n      if (dataSet.getAxisDependency() == AxisDependency.LEFT) {\n        if (dataSet.getYMin() < mLeftAxisMin)         mLeftAxisMin=dataSet.getYMin();\n        if (dataSet.getYMax() > mLeftAxisMax)         mLeftAxisMax=dataSet.getYMax();\n      }\n    }\n  }\n  T firstRight=getFirstRight(mDataSets);\n  if (firstRight != null) {\n    mRightAxisMax=firstRight.getYMax();\n    mRightAxisMin=firstRight.getYMin();\n    for (int i=0; i < mDataSets.size(); i++) {\n      T dataSet=mDataSets.get(i);\n      if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {\n        if (dataSet.getYMin() < mRightAxisMin)         mRightAxisMin=dataSet.getYMin();\n        if (dataSet.getYMax() > mRightAxisMax)         mRightAxisMax=dataSet.getYMax();\n      }\n    }\n  }\n}\n", "nl": "calc minimum and maximum values (both x and y) over all DataSets"}
{"code": "private void initData(){\n  revision=SVNRevision.SVN_INVALID_REVNUM;\n  SyncInfoTree syncInfoTree=getSyncInfoSet();\n  SyncInfo[] syncInfos=syncInfoTree.getSyncInfos();\n  if (syncInfos.length > 0) {\n    SyncInfo syncInfo=syncInfos[0];\n    if (syncInfo instanceof SVNStatusSyncInfo) {\n      SVNStatusSyncInfo svnSyncInfo=(SVNStatusSyncInfo)syncInfo;\n      RemoteResourceStatus remoteResourceStatus=svnSyncInfo.getRemoteResourceStatus();\n      if (remoteResourceStatus != null) {\n        SVNRevision.Number revnum=remoteResourceStatus.getLastChangedRevision();\n        if (revnum != null)         revision=revnum.getNumber();\n else         revision=SVNRevision.INVALID_REVISION.getNumber();\n        author=remoteResourceStatus.getLastCommitAuthor();\n        if ((author == null) || (author.length() == 0)) {\n          author=Policy.bind(\"SynchronizeView.noAuthor\");\n        }\n        date=remoteResourceStatus.getLastChangedDate();\n        comment=fetchComment(svnSyncInfo);\n      }\n else {\n        revision=SVNRevision.INVALID_REVISION.getNumber();\n        author=Policy.bind(\"SynchronizeView.noAuthor\");\n        comment=\"\";\n        date=null;\n      }\n    }\n  }\n}\n", "nl": "Initialize the data of this checked in change set"}
{"code": "public static void main(String[] args) throws Throwable {\n  if (args.length != 1) {\n    if (_logger.isLoggable(Level.INFO)) {\n      _logger.info(\"Usage: QueryProcessor <property file>\");\n    }\n    System.exit(-1);\n  }\n  Properties config=new Properties();\n  FileInputStream fileIn=new FileInputStream(args[0]);\n  config.load(fileIn);\n  fileIn.close();\n  QueryProcessorConfiguration qpConfig=new QueryProcessorConfiguration(null,config);\n  IJSpace space=(IJSpace)SpaceFinder.find(qpConfig.getSpaceURL());\n  IRemoteSpace remoteSpace=((IDirectSpaceProxy)space).getRemoteJSpace();\n  QueryProcessor qp=(QueryProcessor)QueryProcessorFactory.newInstance(space,remoteSpace,config);\n  try {\n    int listenPort=qpConfig.getListenPort();\n    Registry registry=LocateRegistry.createRegistry(listenPort);\n    qp.initStub();\n    registry.bind(IQueryProcessor.QP_LOOKUP_NAME,qp._stub);\n    _logger.info(\"QueryProcessor started on port:\" + listenPort);\n  }\n catch (  Throwable e) {\n    qp.close();\n    throw e;\n  }\n  Object keepAlive=new Object();\nsynchronized (keepAlive) {\n    try {\n      keepAlive.wait();\n    }\n catch (    InterruptedException e) {\n    }\n  }\n}\n", "nl": "Run standalone QP"}
{"code": "public boolean addIfDoesNotOverlap(Pair<Rectangle2D,T> pair){\n  if (previousHit != null && pair.get1().intersects(previousHit))   return false;\n  if (data.size() == data.capacity())   data.ensureCapacity(data.size() + 1);\n  int which=data.size();\n  data.add(pair);\n  currentComparison=which;\n  BitSet startingX=getAll(sortedByMinX.headSet(which));\n  andAll(sortedByMaxX.tailSet(which),startingX);\n  boolean ok=(startingX.cardinality() == 0);\n  if (!ok) {\n    andAll(sortedByMinY.headSet(which),startingX);\n    ok=(startingX.cardinality() == 0);\n    if (!ok) {\n      andAll(sortedByMaxY.tailSet(which),startingX);\n      ok=(startingX.cardinality() == 0);\n    }\n  }\n  currentComparison=-1;\n  if (!ok) {\n    int id=startingX.nextSetBit(0);\n    previousHit=data.get(id).get1();\n    data.remove(which);\n    return false;\n  }\n else {\n    sortedByMaxX.add(which);\n    sortedByMinX.add(which);\n    sortedByMaxY.add(which);\n    sortedByMinY.add(which);\n    if (data.size() == 0)     bbox.setRect(pair.get1());\n else     bbox.add(pair.get1());\n    return true;\n  }\n}\n", "nl": "if rectangle does not overlap any rectangle already contained, then add it"}
{"code": "private synchronized void loadRuleProperties(){\n  try {\n    if (regex != null || urlRegexp != null || invalidRule) {\n      return;\n    }\n    String urlRuleText=getRuleText();\n    if (StringUtils.startsWith(urlRuleText,MASK_WHITE_LIST)) {\n      urlRuleText=urlRuleText.substring(MASK_WHITE_LIST.length());\n    }\n    int optionsIndex=StringUtils.lastIndexOf(urlRuleText,OPTIONS_DELIMITER);\n    if (optionsIndex > -1) {\n      String optionsBase=urlRuleText;\n      urlRuleText=urlRuleText.substring(0,optionsIndex);\n      String options=optionsBase.substring(optionsIndex + 1);\n      loadOptions(options);\n    }\n    urlRuleText=toPunycode(urlRuleText);\n    boolean regexRule=urlRuleText.startsWith(MASK_REGEX_RULE) && urlRuleText.endsWith(MASK_REGEX_RULE);\n    if (regexRule) {\n      regex=urlRuleText.substring(MASK_REGEX_RULE.length(),urlRuleText.length() - MASK_REGEX_RULE.length());\n      Pattern pattern=getUrlRegexp();\n      if (pattern == null) {\n        throw new IllegalArgumentException(\"ruleText\");\n      }\n    }\n else {\n      regex=createRegexFromRule(urlRuleText);\n    }\n  }\n catch (  Exception ex) {\n    LoggerFactory.getLogger(this.getClass()).warn(\"Invalid filter rule: {}\\r\\n\",getRuleText(),ex);\n    invalidRule=true;\n  }\n}\n", "nl": "Loads rule properties lazily"}
{"code": "private void executeEvent(){\n  if (!noParamMap.isEmpty()) {\n    for (    Object object : noParamMap.keySet()) {\n      try {\n        noParamMap.get(object).invoke(object,(Object[])null);\n      }\n catch (      IllegalAccessException e) {\n        e.printStackTrace();\n      }\ncatch (      InvocationTargetException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n  if (!hasParamMap.isEmpty()) {\n    for (    Object object : hasParamMap.keySet()) {\n      try {\n        for (        Method m : hasParamMap.get(object).keySet()) {\n          m.invoke(object,hasParamMap.get(object).get(m));\n        }\n      }\n catch (      IllegalAccessException e) {\n        e.printStackTrace();\n      }\ncatch (      InvocationTargetException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}\n", "nl": "executeEvent() method will invoke through invoke sendMessage() method"}
{"code": "public static String format(String refAllele,String altAllele,boolean noFormat){\n  String text=\"\";\n  if (refAllele.length() == 1 && altAllele.length() == 1) {\n    text=altAllele;\n  }\n else   if (refAllele.length() == 1 && altAllele.length() > 1) {\n    text=\"I\";\n  }\n else   if (refAllele.length() > 1 && altAllele.length() == 1) {\n    text=\"D\";\n  }\n  if (noFormat) {\n    return text;\n  }\n  String formattedText=\"\";\n  for (int i=0; i < text.length(); i++) {\n    char base=text.charAt(i);\n    if (base == 'A' || base == 'a') {\n      formattedText+=\"\\033[107;34m\" + base + \"\\033[0m\";\n    }\n else     if (base == 'C' || base == 'c') {\n      formattedText+=\"\\033[107;31m\" + base + \"\\033[0m\";\n    }\n else     if (base == 'G' || base == 'g') {\n      formattedText+=\"\\033[107;32m\" + base + \"\\033[0m\";\n    }\n else     if (base == 'T' || base == 't') {\n      formattedText+=\"\\033[107;33m\" + base + \"\\033[0m\";\n    }\n else {\n      formattedText+=base;\n    }\n  }\n  return formattedText;\n}\n", "nl": "Format alternative allele for text printing"}
{"code": "private void checkTheTicTacTocGameWin(int x,int y,int tag){\n  int _x=0;\n  int _y=0;\n  for (int i=x, j=y; ; i--, j--) {\n    _x=i;\n    _y=j;\n    if (i <= 0)     break;\n    if (j <= 0)     break;\n  }\n  for (int i=_y, j=_x; ; i++, j++) {\n    subCheckTheTicTacTocWin(tag,i,j);\n    if (i >= 8)     break;\n    if (j >= 11)     break;\n  }\n  _counter=0;\n  _x=x;\n  _y=0;\n  for (int i=_y, j=_x; i < 9; i++)   subCheckTheTicTacTocWin(tag,i,j);\n  _counter=0;\n  _x=0;\n  _y=y;\n  for (int i=_y, j=_x; j < 12; j++)   subCheckTheTicTacTocWin(tag,i,j);\n  _counter=0;\n  for (int i=x, j=y; ; i--, j++) {\n    _x=i;\n    _y=j;\n    if (i <= 0)     break;\n    if (j >= 8)     break;\n  }\n  for (int i=_y, j=_x; ; i--, j++) {\n    subCheckTheTicTacTocWin(tag,i,j);\n    if (i <= 0)     break;\n    if (j >= 11)     break;\n  }\n}\n", "nl": "check the game win detection or defeat check"}
{"code": "private void parseTranscript(PackedTranscript transcript){\n  translatedQueryLen=0;\n  subjectLen=0;\n  len=0;\n  identities=0;\n  mismatches=0;\n  gapOpenings=0;\n  int d=0;\n  for (  CombinedOperation op : transcript.gather()) {\n    int count=op.getCount();\n    len+=count;\nswitch (op.getEditOperation()) {\ncase op_match:\n      identities+=count;\n    translatedQueryLen+=count;\n  subjectLen+=count;\nd=0;\nbreak;\ncase op_substitution:\nmismatches+=count;\ntranslatedQueryLen+=count;\nsubjectLen+=count;\nd=0;\nbreak;\ncase op_insertion:\ntranslatedQueryLen+=count;\n++gapOpenings;\nd=0;\nbreak;\ncase op_deletion:\nsubjectLen+=count;\nif (d == 0) ++gapOpenings;\nd+=count;\n}\n}\n}\n", "nl": "parse the transcript"}
{"code": "static public ResolveType resolveThrownExceptions(@NotNull final Method method,@NotNull HashSet<PhpClass> declaredExceptions){\n  PhpPsiElement previous=method.getPrevPsiSibling();\n  if (!(previous instanceof PhpDocCommentImpl)) {\n    return ResolveType.NOT_RESOLVED;\n  }\n  Collection<PhpDocReturnTag> returns=PsiTreeUtil.findChildrenOfType(previous,PhpDocReturnTag.class);\n  if (returns.size() > 0) {\n    for (    PhpDocReturnTag returnOrThrow : returns) {\n      if (returnOrThrow.getName().equals(\"@throws\")) {\n        Collection<PhpDocTypeImpl> exceptions=PsiTreeUtil.findChildrenOfType(returnOrThrow,PhpDocTypeImpl.class);\n        if (exceptions.size() > 0) {\n          for (          PhpDocTypeImpl type : exceptions) {\n            PsiElement typeResolved=type.resolve();\n            if (typeResolved instanceof PhpClass) {\n              declaredExceptions.add((PhpClass)typeResolved);\n            }\n          }\n          exceptions.clear();\n        }\n      }\n    }\n    returns.clear();\n  }\n  Collection<PhpDocTagImpl> tags=PsiTreeUtil.findChildrenOfType(previous,PhpDocTagImpl.class);\n  if (tags.size() > 0) {\n    for (    PhpDocTagImpl tag : tags) {\n      if (tag.getName().toLowerCase().equals(\"@inheritdoc\")) {\n        resolveInheritDoc(method,declaredExceptions);\n        return ResolveType.RESOLVED_INHERIT_DOC;\n      }\n    }\n    tags.clear();\n  }\n  return ResolveType.RESOLVED;\n}\n", "nl": "Return false if doc-block is not defined"}
{"code": "public List<GenericValue> makeAllOrderItemSurveyResponses(){\n  List<GenericValue> allInfos=new LinkedList<GenericValue>();\n  for (  ShoppingCartItem item : this) {\n    List<String> responses=UtilGenerics.checkList(item.getAttribute(\"surveyResponses\"));\n    GenericValue response=null;\n    if (responses != null) {\n      for (      String responseId : responses) {\n        try {\n          response=this.getDelegator().findOne(\"SurveyResponse\",UtilMisc.toMap(\"surveyResponseId\",responseId),false);\n        }\n catch (        GenericEntityException e) {\n          Debug.logError(e,\"Unable to obtain SurveyResponse record for ID : \" + responseId,module);\n        }\n      }\n    }\n else {\n      String surveyResponseId=(String)item.getAttribute(\"surveyResponseId\");\n      try {\n        response=this.getDelegator().findOne(\"SurveyResponse\",UtilMisc.toMap(\"surveyResponseId\",surveyResponseId),false);\n      }\n catch (      GenericEntityException e) {\n        Debug.logError(e,\"Unable to obtain SurveyResponse record for ID : \" + surveyResponseId,module);\n      }\n    }\n    if (response != null) {\n      response.set(\"orderItemSeqId\",item.getOrderItemSeqId());\n      allInfos.add(response);\n    }\n  }\n  return allInfos;\n}\n", "nl": "make a list of SurveyResponse object to update with order information set"}
{"code": "public static Map<String,Object> sendMailFromUrl(DispatchContext ctx,Map<String,? extends Object> rcontext){\n  Map<String,Object> sendMailContext=UtilMisc.makeMapWritable(rcontext);\n  String bodyUrl=(String)sendMailContext.remove(\"bodyUrl\");\n  Map<String,Object> bodyUrlParameters=UtilGenerics.checkMap(sendMailContext.remove(\"bodyUrlParameters\"));\n  Locale locale=(Locale)rcontext.get(\"locale\");\n  LocalDispatcher dispatcher=ctx.getDispatcher();\n  URL url=null;\n  try {\n    url=new URL(bodyUrl);\n  }\n catch (  MalformedURLException e) {\n    Debug.logWarning(e,module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendMalformedUrl\",UtilMisc.toMap(\"bodyUrl\",bodyUrl,\"errorString\",e.toString()),locale));\n  }\n  HttpClient httpClient=new HttpClient(url,bodyUrlParameters);\n  String body=null;\n  try {\n    body=httpClient.post();\n  }\n catch (  HttpClientException e) {\n    Debug.logWarning(e,module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendGettingError\",UtilMisc.toMap(\"errorString\",e.toString()),locale));\n  }\n  sendMailContext.put(\"body\",body);\n  Map<String,Object> sendMailResult;\n  try {\n    sendMailResult=dispatcher.runSync(\"sendMail\",sendMailContext);\n  }\n catch (  GenericServiceException e) {\n    Debug.logError(e,module);\n    return ServiceUtil.returnError(e.getMessage());\n  }\n  return sendMailResult;\n}\n", "nl": "JavaMail Service that gets body content from a URL"}
{"code": "private static void computeCorrelationMatrix(int rank,double[][] vectors,Distances distances){\n  double[] mean=new double[rank];\n  for (  double[] row : vectors) {\n    for (int col=0; col < rank; col++) {\n      mean[col]+=row[col];\n    }\n  }\n  for (int col=0; col < rank; col++) {\n    mean[col]/=vectors.length;\n  }\n  double[] stddev=new double[rank];\n  for (  double[] row : vectors) {\n    for (int col=0; col < rank; col++) {\n      stddev[col]+=(row[col] - mean[col]) * (row[col] - mean[col]);\n    }\n  }\n  for (int col=0; col < rank; col++) {\n    stddev[col]=Math.sqrt(stddev[col] / vectors.length);\n  }\n  for (int di=0; di < rank; di++) {\n    distances.set(di + 1,di + 1,0);\n    for (int dj=di + 1; dj < rank; dj++) {\n      double cor=0;\n      for (      double[] row : vectors) {\n        cor+=(row[di] - mean[di]) * (row[dj] - mean[dj]) / (stddev[di] * stddev[dj]);\n      }\n      cor/=vectors.length;\n      distances.set(di + 1,dj + 1,cor);\n    }\n  }\n}\n", "nl": "computes the pearson distances"}
{"code": "@Override public void updateClassifications(String[] names,List<UpdateItem> updateItemList,ProgressListener progressListener) throws IOException, CanceledException {\n  final UpdateItemList updateItems=(UpdateItemList)updateItemList;\n  final int numClassifications=names.length;\n  long maxProgress=0;\n  for (int i=0; i < numClassifications; i++) {\n    maxProgress+=updateItems.getClassIds(i).size();\n  }\n  progressListener.setMaximum(maxProgress);\n  RMA3FileModifier rma3FileModifier=new RMA3FileModifier(fileName);\n  rma3FileModifier.startModification();\n  for (int i=0; i < numClassifications; i++) {\n    if (Basic.toString(ClassificationType.values(),\" \").contains(names[i])) {\n      ClassificationType classificationType=ClassificationType.valueOf(names[i]);\n      final Map<Integer,ListOfLongs> classId2Locations=new HashMap<>();\n      for (      Integer classId : updateItems.getClassIds(i)) {\n        int weightedSize=updateItems.getSize(i,classId);\n        final ListOfLongs positions=new ListOfLongs();\n        classId2Locations.put(classId,positions);\n        if (weightedSize > 0) {\n          for (UpdateItem item=updateItems.getFirst(i,classId); item != null; item=updateItems.getUpdateItem(item.getNextInClassification(i))) {\n            positions.add(item.getReadUId());\n          }\n        }\n        progressListener.incrementProgress();\n      }\n      rma3FileModifier.updateClassification(classificationType,classId2Locations);\n    }\n else     System.err.println(\"Unsupported classification type: \" + names[i]);\n  }\n  rma3FileModifier.finishModification();\n}\n", "nl": "rescan classifications after running the data processor"}
{"code": "public void requestDropList(Player player,int npcId){\n  DropNpc dropNpc=DropRegistrationService.getInstance().getDropRegistrationMap().get(npcId);\n  if (player == null || dropNpc == null) {\n    return;\n  }\n  if (!dropNpc.containsKey(player.getObjectId()) && !dropNpc.isFreeForAll()) {\n    PacketSendUtility.sendPacket(player,SM_SYSTEM_MESSAGE.STR_LOOT_NO_RIGHT);\n    return;\n  }\n  if (dropNpc.isBeingLooted()) {\n    PacketSendUtility.sendPacket(player,SM_SYSTEM_MESSAGE.STR_LOOT_FAIL_ONLOOTING);\n    return;\n  }\n  dropNpc.setBeingLooted(player);\n  VisibleObject visObj=World.getInstance().findVisibleObject(npcId);\n  if (visObj instanceof Npc) {\n    Npc npc=((Npc)visObj);\n    ScheduledFuture<?> decayTask=(ScheduledFuture<?>)npc.getController().cancelTask(TaskId.DECAY);\n    if (decayTask != null) {\n      long reamingDecayTime=decayTask.getDelay(TimeUnit.MILLISECONDS);\n      dropNpc.setReamingDecayTime(reamingDecayTime);\n    }\n  }\n  Set<DropItem> dropItems=DropRegistrationService.getInstance().getCurrentDropMap().get(npcId);\n  if (dropItems == null) {\n    dropItems=Collections.emptySet();\n  }\n  PacketSendUtility.sendPacket(player,new SM_LOOT_ITEMLIST(npcId,dropItems,player));\n  PacketSendUtility.sendPacket(player,new SM_LOOT_STATUS(npcId,2));\n  player.unsetState(CreatureState.ACTIVE);\n  player.setState(CreatureState.LOOTING);\n  player.setLootingNpcOid(npcId);\n  PacketSendUtility.broadcastPacket(player,new SM_EMOTION(player,EmotionType.START_LOOT,0,npcId),true);\n}\n", "nl": "When player clicks on dead NPC to request drop list"}
{"code": "public Matrix solve(Matrix B){\n  if (B.getRowDimension() != m) {\n    throw new IllegalArgumentException(\"Matrix row dimensions must agree.\");\n  }\n  if (!this.isFullRank()) {\n    throw new RuntimeException(\"Matrix is rank deficient.\");\n  }\n  int nx=B.getColumnDimension();\n  double[][] X=B.getArrayCopy();\n  for (int k=0; k < n; k++) {\n    for (int j=0; j < nx; j++) {\n      double s=0.0;\n      for (int i=k; i < m; i++) {\n        s+=QR[i][k] * X[i][j];\n      }\n      s=-s / QR[k][k];\n      for (int i=k; i < m; i++) {\n        X[i][j]+=s * QR[i][k];\n      }\n    }\n  }\n  for (int k=n - 1; k >= 0; k--) {\n    for (int j=0; j < nx; j++) {\n      X[k][j]/=Rdiag[k];\n    }\n    for (int i=0; i < k; i++) {\n      for (int j=0; j < nx; j++) {\n        X[i][j]-=X[k][j] * QR[i][k];\n      }\n    }\n  }\n  return (new Matrix(X,n,nx).getMatrix(0,n - 1,0,nx - 1));\n}\n", "nl": "Least squares solution of A*X = B"}
{"code": "public static boolean isLocalStore(int bc){\nswitch (bc) {\ncase ByteCode.ISTORE:\ncase ByteCode.FSTORE:\ncase ByteCode.ASTORE:\ncase ByteCode.LSTORE:\ncase ByteCode.DSTORE:\ncase ByteCode.ISTORE_0:\ncase ByteCode.ISTORE_1:\ncase ByteCode.ISTORE_2:\ncase ByteCode.ISTORE_3:\ncase ByteCode.FSTORE_0:\ncase ByteCode.FSTORE_1:\ncase ByteCode.FSTORE_2:\ncase ByteCode.FSTORE_3:\ncase ByteCode.ASTORE_0:\ncase ByteCode.ASTORE_1:\ncase ByteCode.ASTORE_2:\ncase ByteCode.ASTORE_3:\ncase ByteCode.LSTORE_0:\ncase ByteCode.LSTORE_1:\ncase ByteCode.LSTORE_2:\ncase ByteCode.LSTORE_3:\ncase ByteCode.DSTORE_0:\ncase ByteCode.DSTORE_1:\ncase ByteCode.DSTORE_2:\ncase ByteCode.DSTORE_3:\n    return true;\ndefault :\n  return false;\n}\n}\n", "nl": "Returns true if the bytecode is a local store"}
{"code": "public void testGenerateAltQueriesFuzz(){\n  Random rand=new Random();\n  SearchcodeLib scl=new SearchcodeLib();\n  for (int i=0; i < 10; i++) {\n    StringBuilder bf=new StringBuilder();\n    for (int j=0; j < 5; j++) {\n      if (j % 2 == 0) {\n        bf.append(RandomStringUtils.randomAscii(rand.nextInt(10) + 1) + \" \");\n      }\n else {\n        bf.append(RandomStringUtils.randomAlphabetic(rand.nextInt(10) + 1) + \" \");\n      }\n      Singleton.getSpellingCorrector().putWord(RandomStringUtils.randomAlphabetic(rand.nextInt(10) + 1));\nswitch (rand.nextInt(5)) {\ncase 1:\n        bf.append(\" AND \");\n      break;\ncase 2:\n    bf.append(\" OR \");\n  break;\ncase 3:\nbf.append(\" NOT \");\nbreak;\ncase 4:\nbf.append(RandomStringUtils.randomAlphabetic(rand.nextInt(10) + 1));\nbreak;\ndefault :\nbreak;\n}\n}\nscl.generateAltQueries(bf.toString());\n}\n}\n", "nl": "Fuzzy testing of the generate alt queries where we try random things to see if we can introduce an eception"}
{"code": "public List<String> listACL(int from,int to){\n  AmazonEC2 client=null;\n  try {\n    client=getEc2Client();\n    List<String> ipPermissions=new ArrayList<String>();\n    if (this.insEnvIdentity.isClassic()) {\n      DescribeSecurityGroupsRequest req=new DescribeSecurityGroupsRequest().withGroupNames(Arrays.asList(config.getACLGroupName()));\n      DescribeSecurityGroupsResult result=client.describeSecurityGroups(req);\n      for (      SecurityGroup group : result.getSecurityGroups())       for (      IpPermission perm : group.getIpPermissions())       if (perm.getFromPort() == from && perm.getToPort() == to)       ipPermissions.addAll(perm.getIpRanges());\n      logger.info(\"Fetch current permissions for classic env of running instance\");\n    }\n else {\n      Filter nameFilter=new Filter().withName(\"group-name\").withValues(config.getACLGroupName());\n      String vpcid=config.getVpcId();\n      if (vpcid == null || vpcid.isEmpty()) {\n        throw new IllegalStateException(\"vpcid is null even though instance is running in vpc.\");\n      }\n      Filter vpcFilter=new Filter().withName(\"vpc-id\").withValues(vpcid);\n      DescribeSecurityGroupsRequest req=new DescribeSecurityGroupsRequest().withFilters(nameFilter,vpcFilter);\n      DescribeSecurityGroupsResult result=client.describeSecurityGroups(req);\n      for (      SecurityGroup group : result.getSecurityGroups())       for (      IpPermission perm : group.getIpPermissions())       if (perm.getFromPort() == from && perm.getToPort() == to)       ipPermissions.addAll(perm.getIpRanges());\n      logger.info(\"Fetch current permissions for vpc env of running instance\");\n    }\n    return ipPermissions;\n  }\n  finally {\n    if (client != null)     client.shutdown();\n  }\n}\n", "nl": "List SG ACL's"}
{"code": "private void populateMethylLocus(){\n  if (this.refBase != 'C' && this.refBase != 'G') {\n    cntM=null;\n    cntU=null;\n    return;\n  }\n  for (  RecordAndOffset recOff : this.locus.getRecordAndPositions()) {\n    boolean readIsTopStrand=!(new ReadFromTopStrandFilter(true)).filterOut(recOff.getRecord());\n    char readBase=Character.toUpperCase((char)recOff.getReadBase());\n    if (this.refBase == 'C') {\n      if (readIsTopStrand) {\n        if (readBase == 'C') {\n          cntM++;\n        }\n else         if (readBase == 'T') {\n          cntU++;\n        }\n      }\n    }\n else     if (this.refBase == 'G') {\n      if (!readIsTopStrand) {\n        if (readBase == 'G') {\n          cntM++;\n        }\n else         if (readBase == 'A') {\n          cntU++;\n        }\n      }\n    }\n else {\n      System.err.println(\"Unexpected strand or base!\");\n      System.exit(1);\n    }\n  }\n}\n", "nl": "Fill up fields cntM, cntU etc"}
{"code": "public final List readLines(final int numOfLines,final IFallback fallbackObj) throws DataFallbackException {\n  int readlines=0;\n  List objects=new ArrayList();\n  String line=null;\n  IFallback obj;\n  boolean moreLines=true;\n  try {\n    while (moreLines && readlines < numOfLines) {\n      line=getInput().readLine();\n      if (line == null) {\n        moreLines=false;\n      }\n else {\n        try {\n          obj=fallbackObj.getObject(line);\n          objects.add(obj);\n        }\n catch (        DataFallbackException e) {\n          LOG.error(\"readLines() - \" + e.getMessage() + \"\"+ line);\n          objects.add(null);\n        }\n        readlines++;\n      }\n    }\n  }\n catch (  IOException e) {\n    throw new DataFallbackException(e.getMessage());\n  }\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"readLines() - \" + objects.size() + \" lines has been read from the log file\");\n  }\n  return objects;\n}\n", "nl": "It reads a list of objects from a fallback file"}
{"code": "static void commitGuideline(NlModel model,@NotNull AttributesTransaction component,@NotNull Guideline guideline){\n  int behaviour=guideline.getRelativeBehaviour();\n  WidgetCompanion companion=(WidgetCompanion)guideline.getCompanionWidget();\n  component.setAttribute(SdkConstants.SHERPA_URI,SdkConstants.LAYOUT_CONSTRAINT_GUIDE_BEGIN,null);\n  component.setAttribute(SdkConstants.SHERPA_URI,SdkConstants.LAYOUT_CONSTRAINT_GUIDE_END,null);\n  component.setAttribute(SdkConstants.SHERPA_URI,SdkConstants.LAYOUT_CONSTRAINT_GUIDE_PERCENT,null);\n  component.setAttribute(SdkConstants.SHERPA_URI,SdkConstants.LAYOUT_CONSTRAINT_DEPRECATED_GUIDE_PERCENT,null);\n  String previousValue=companion.getWidgetProperties().getGuidelineAttribute();\n  if (previousValue != null && !previousValue.startsWith(\"@\")) {\n    previousValue=null;\n  }\n  String value=previousValue;\n  if (behaviour == Guideline.RELATIVE_PERCENT) {\n    boolean useFloat=useGuidelineFloat(model);\n    if (value == null) {\n      float percent=guideline.getRelativePercent();\n      if (useFloat) {\n        value=String.valueOf(percent);\n      }\n else {\n        value=String.valueOf((int)(percent * 100));\n      }\n    }\n    String percentAttribute=useFloat ? SdkConstants.LAYOUT_CONSTRAINT_GUIDE_PERCENT : SdkConstants.LAYOUT_CONSTRAINT_DEPRECATED_GUIDE_PERCENT;\n    component.setAttribute(SdkConstants.SHERPA_URI,percentAttribute,value);\n  }\n else   if (behaviour == Guideline.RELATIVE_BEGIN) {\n    if (value == null) {\n      value=String.format(SdkConstants.VALUE_N_DP,guideline.getRelativeBegin());\n    }\n    component.setAttribute(SdkConstants.SHERPA_URI,SdkConstants.LAYOUT_CONSTRAINT_GUIDE_BEGIN,value);\n  }\n else   if (behaviour == Guideline.RELATIVE_END) {\n    if (value == null) {\n      value=String.format(SdkConstants.VALUE_N_DP,guideline.getRelativeEnd());\n    }\n    component.setAttribute(SdkConstants.SHERPA_URI,SdkConstants.LAYOUT_CONSTRAINT_GUIDE_END,value);\n  }\n}\n", "nl": "Update the component with the values from a Guideline widget"}
{"code": "public static void sellStoreItem(Player seller,Player buyer,TradeList tradeList){\n  if (!validateParticipants(seller,buyer))   return;\n  PrivateStore store=seller.getStore();\n  tradeList=loadObjIds(seller,tradeList);\n  if (tradeList == null)   return;\n  Storage inventory=buyer.getInventory();\n  int freeSlots=inventory.getLimit() - inventory.getItemsWithKinah().size() + 1;\n  if (freeSlots < tradeList.size()) {\n    return;\n  }\n  long price=getTotalPrice(store,tradeList);\n  if (price < 0)   return;\n  if (buyer.getInventory().getKinah() >= price) {\n    for (    TradeItem tradeItem : tradeList.getTradeItems()) {\n      Item item=getItemByObjId(seller,tradeItem.getItemId());\n      if (item != null) {\n        TradePSItem storeItem=store.getTradeItemByObjId(tradeItem.getItemId());\n        if (item.getItemCount() < tradeItem.getCount()) {\n          PacketSendUtility.sendMessage(buyer,\"You cannot buy more than player can sell.\");\n          return;\n        }\n        decreaseItemFromPlayer(seller,item,tradeItem);\n        ItemService.addItem(buyer,item.getItemId(),tradeItem.getCount(),item);\n        if (storeItem.getCount() == tradeItem.getCount()) {\n          store.removeItem(storeItem.getItemObjId());\n        }\n        log.info(\"[PRIVATE STORE] > [Seller: \" + seller.getName() + \"] sold [Item: \"+ item.getItemId()+ \"][Amount: \"+ item.getItemCount()+ \"] to [Buyer: \"+ buyer.getName()+ \"] for [Price: \"+ price+ \"]\");\n      }\n    }\n    decreaseKinahAmount(buyer,price);\n    increaseKinahAmount(seller,price);\n    if (store.getSoldItems().size() == 0) {\n      closePrivateStore(seller);\n    }\n  }\n}\n", "nl": "This method will move the item to the new player and move kinah to item owner"}
{"code": "public static Table readTable(String path) throws IOException {\n  ExecutorService executorService=Executors.newFixedThreadPool(READER_POOL_SIZE);\n  CompletionService readerCompletionService=new ExecutorCompletionService<>(executorService);\n  TableMetadata tableMetadata=readTableMetadata(path + separator() + \"Metadata.json\");\n  List<ColumnMetadata> columnMetadata=tableMetadata.getColumnMetadataList();\n  Table table=Table.create(tableMetadata);\n  ConcurrentLinkedQueue<Column> columnList=new ConcurrentLinkedQueue<>();\n  Map<String,Column> columns=new HashMap<>();\n  try {\n    for (    ColumnMetadata column : columnMetadata) {\n      readerCompletionService.submit(null);\n    }\n    for (int i=0; i < columnMetadata.size(); i++) {\n      Future future=readerCompletionService.take();\n      future.get();\n    }\n    for (    Column c : columnList) {\n      columns.put(c.id(),c);\n    }\n    for (    ColumnMetadata metadata : columnMetadata) {\n      String id=metadata.getId();\n      table.addColumn(columns.get(id));\n    }\n  }\n catch (  InterruptedException|ExecutionException e) {\n    throw new RuntimeException(e);\n  }\n  executorService.shutdown();\n  return table;\n}\n", "nl": "Reads a tablesaw table into memory"}
{"code": "@Override public void renderAxisLabels(Canvas c){\n  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;\n  float[] positions=getTransformedPositions();\n  mAxisLabelPaint.setTypeface(mYAxis.getTypeface());\n  mAxisLabelPaint.setTextSize(mYAxis.getTextSize());\n  mAxisLabelPaint.setColor(mYAxis.getTextColor());\n  mAxisLabelPaint.setTextAlign(Align.CENTER);\n  float baseYOffset=Utils.dp2px(2.5f);\n  float textHeight=Utils.calcTextHeight(mAxisLabelPaint,\"Q\");\n  AxisDependency dependency=mYAxis.getAxisDependency();\n  YAxisLabelPosition labelPosition=mYAxis.getLabelPosition();\n  float yPos=0f;\n  if (dependency == AxisDependency.LEFT) {\n    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {\n      yPos=mViewPortHandler.contentTop() - baseYOffset;\n    }\n else {\n      yPos=mViewPortHandler.contentTop() - baseYOffset;\n    }\n  }\n else {\n    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {\n      yPos=mViewPortHandler.contentBottom() + textHeight + baseYOffset;\n    }\n else {\n      yPos=mViewPortHandler.contentBottom() + textHeight + baseYOffset;\n    }\n  }\n  drawYLabels(c,yPos,positions,mYAxis.getYOffset());\n}\n", "nl": "draws the y-axis labels to the screen"}
{"code": "private Double readDoubleNumberFromExpression(String expression) throws ParsingException {\n  Character c=expression.charAt(expressionIterator);\n  Double number=getDoubleDigit(c);\n  while (++expressionIterator < expression.length()) {\n    c=expression.charAt(expressionIterator);\n    if (!Character.isDigit(c)) {\n      break;\n    }\n    number*=10;\n    number+=getDoubleDigit(c);\n  }\n  if (c == '.') {\n    if (++expressionIterator == expression.length()) {\n      throw new ParsingException(ILLEGAL_POSITION_IN_EXPRESSION + c);\n    }\n    c=expression.charAt(expressionIterator);\n    double placeFactor=10;\n    number+=getDoubleDigit(c) / placeFactor;\n    if (!Character.isDigit(c)) {\n      throw new ParsingException(ILLEGAL_POSITION_IN_EXPRESSION + c);\n    }\n    while (++expressionIterator < expression.length()) {\n      c=expression.charAt(expressionIterator);\n      if (!Character.isDigit(c)) {\n        break;\n      }\n      placeFactor*=10;\n      number+=getDoubleDigit(c) / placeFactor;\n    }\n  }\n  --expressionIterator;\n  return number;\n}\n", "nl": "Read a double number from the expressionIterator position in expression"}
{"code": "public String checkIfUserPresent(String userName) throws UnsupportedEncodingException, ParserConfigurationException, IOException, SAXException, DASTProxyException, XPathExpressionException {\n  LOGGER.debug(\"Inside checkIfUserPresent....1\");\n  final XPathFactory factory=XPathFactory.newInstance();\n  final XPath xpath=factory.newXPath();\n  xpath.setNamespaceContext(_nsContext);\n  Document response=null;\n  try {\n    response=sendRESTRequestToASE(AppScanConstants.APPSCAN_USERS_FOLDER_LIST_RELATIVE_URL,\"\");\n    LOGGER.debug(\"Inside checkIfUserPresent....2...response=\" + response);\n  }\n catch (  ConnectException ce) {\n    LOGGER.error(\"Could not find the user with userId=\" + userName + \" in the Backend.\");\n    LOGGER.error(ce);\n    return null;\n  }\n  LOGGER.debug(\"Check if user exists in the system. \");\n  checkForError(response,null);\n  LOGGER.debug(\"Inside checkIfUserPresent....2.1\");\n  if (userName.contains(\"CORP\\\\\")) {\n    userName=userName.substring(userName.indexOf(\"\\\\\") + 1);\n  }\n  LOGGER.debug(\"Inside checkIfUserPresent....3\");\n  String userId=(String)xpath.evaluate(\"//ase:folder[ase:contact='\" + userName + \"']/ase:id/text()\",response,XPathConstants.STRING);\n  LOGGER.debug(\"Inside checkIfUserPresent....4...userId=\" + userId);\n  if (AppScanUtils.isNotNull(userId)) {\n    return userId;\n  }\n else {\n    return null;\n  }\n}\n", "nl": "Check if user folder is present"}
{"code": "public static int download(String url,File f){\n  log.debug(\"url=\\\"\" + url + \"\\\"\");\n  String[] ss=url.split(\" \");\n  url=ss[ss.length - 1];\n  DefaultHttpClient client=getClient(url);\n  if (client != null) {\n    HttpGet get=null;\n    try {\n      get=new HttpGet(url);\n      if (!get.containsHeader(\"User-Agent\")) {\n        get.addHeader(\"User-Agent\",UA);\n      }\n      log.debug(\"get url=\" + url);\n      HttpResponse resp=client.execute(get);\n      if (resp.getStatusLine().getStatusCode() == 200) {\n        HttpEntity e=resp.getEntity();\n        InputStream in=e.getContent();\n        f.getParentFile().mkdirs();\n        FileOutputStream out=new FileOutputStream(f);\n        return IOUtil.copy(in,out);\n      }\n      return 0;\n    }\n catch (    Exception e) {\n      log.error(\"\\\"\" + url + \"\\\"\",e);\n    }\n finally {\n      if (get != null)       get.abort();\n    }\n  }\n  return 0;\n}\n", "nl": "download the file in the url to f"}
{"code": "public Matrix solve(Matrix B){\n  if (B.getRowDimension() != m) {\n    throw new IllegalArgumentException(\"Matrix row dimensions must agree.\");\n  }\n  if (!this.isNonsingular()) {\n    throw new RuntimeException(\"Matrix is singular.\");\n  }\n  int nx=B.getColumnDimension();\n  Matrix Xmat=B.getMatrix(piv,0,nx - 1);\n  double[][] X=Xmat.getArray();\n  for (int k=0; k < n; k++) {\n    for (int i=k + 1; i < n; i++) {\n      for (int j=0; j < nx; j++) {\n        X[i][j]-=X[k][j] * LU[i][k];\n      }\n    }\n  }\n  for (int k=n - 1; k >= 0; k--) {\n    for (int j=0; j < nx; j++) {\n      X[k][j]/=LU[k][k];\n    }\n    for (int i=0; i < k; i++) {\n      for (int j=0; j < nx; j++) {\n        X[i][j]-=X[k][j] * LU[i][k];\n      }\n    }\n  }\n  return Xmat;\n}\n", "nl": "Solve A*X = B"}
{"code": "private void createFieldDecl(polyglot.ast.FieldDecl field){\n  int modifiers=Util.getModifier(field.fieldInstance().flags());\n  String name=field.fieldInstance().name();\n  soot.Type sootType=Util.getSootType(field.fieldInstance().type());\n  soot.SootField sootField=new soot.SootField(name,sootType,modifiers);\n  sootClass.addField(sootField);\n  if (field.fieldInstance().flags().isStatic()) {\n    if (field.init() != null) {\n      if (field.flags().isFinal() && (field.type().type().isPrimitive() || (field.type().type().toString().equals(\"java.lang.String\"))) && field.fieldInstance().isConstant()) {\n        addConstValTag(field,sootField);\n      }\n else {\n        if (staticFieldInits == null) {\n          staticFieldInits=new ArrayList<FieldDecl>();\n        }\n        staticFieldInits.add(field);\n      }\n    }\n  }\n else {\n    if (field.init() != null) {\n      if (fieldInits == null) {\n        fieldInits=new ArrayList<FieldDecl>();\n      }\n      fieldInits.add(field);\n    }\n  }\n  Util.addLnPosTags(sootField,field.position());\n}\n", "nl": "Field Declaration Creation"}
{"code": "void handleEOD(EncoderContext context,StringBuilder buffer){\n  int unwritten=(buffer.length() / 3) * 2;\n  int rest=buffer.length() % 3;\n  int curCodewordCount=context.getCodewordCount() + unwritten;\n  context.updateSymbolInfo(curCodewordCount);\n  int available=context.getSymbolInfo().getDataCapacity() - curCodewordCount;\n  if (rest == 2) {\n    buffer.append('\\0');\n    while (buffer.length() >= 3) {\n      writeNextTriplet(context,buffer);\n    }\n    if (context.hasMoreCharacters()) {\n      context.writeCodeword(HighLevelEncoder.C40_UNLATCH);\n    }\n  }\n else   if (available == 1 && rest == 1) {\n    while (buffer.length() >= 3) {\n      writeNextTriplet(context,buffer);\n    }\n    if (context.hasMoreCharacters()) {\n      context.writeCodeword(HighLevelEncoder.C40_UNLATCH);\n    }\n    context.pos--;\n  }\n else   if (rest == 0) {\n    while (buffer.length() >= 3) {\n      writeNextTriplet(context,buffer);\n    }\n    if (available > 0 || context.hasMoreCharacters()) {\n      context.writeCodeword(HighLevelEncoder.C40_UNLATCH);\n    }\n  }\n else {\n    throw new IllegalStateException(\"Unexpected case. Please report!\");\n  }\n  context.signalEncoderChange(HighLevelEncoder.ASCII_ENCODATION);\n}\n", "nl": "Handle \"end of data\" situations"}
{"code": "@Override public void updateClassifications(String[] cNames,List<UpdateItem> updateItemList,ProgressListener progressListener) throws IOException, CanceledException {\n  final UpdateItemList updateItems=(UpdateItemList)updateItemList;\n  long maxProgress=0;\n  for (int i=0; i < cNames.length; i++) {\n    maxProgress+=updateItems.getClassIds(i).size();\n  }\n  progressListener.setMaximum(maxProgress);\n  final Map<Integer,ListOfLongs>[] fName2ClassId2Location=new HashMap[cNames.length];\n  final Map<Integer,Integer>[] fName2ClassId2Weight=new HashMap[cNames.length];\n  for (int i=0; i < cNames.length; i++) {\n    fName2ClassId2Location[i]=new HashMap<>(10000);\n    fName2ClassId2Weight[i]=new HashMap<>(10000);\n  }\n  for (int i=0; i < cNames.length; i++) {\n    final Map<Integer,ListOfLongs> classId2Location=fName2ClassId2Location[i];\n    final Map<Integer,Integer> classId2weight=fName2ClassId2Weight[i];\n    for (    Integer classId : updateItems.getClassIds(i)) {\n      int weightedSize=updateItems.getSize(i,classId);\n      final ListOfLongs positions=new ListOfLongs();\n      classId2Location.put(classId,positions);\n      classId2weight.put(classId,weightedSize);\n      if (weightedSize > 0) {\n        for (UpdateItem item=updateItems.getFirst(i,classId); item != null; item=updateItems.getUpdateItem(item.getNextInClassification(i))) {\n          positions.add(item.getReadUId());\n        }\n      }\n      progressListener.incrementProgress();\n    }\n  }\n  try (RMA6FileModifier rma6Modifier=new RMA6FileModifier(fileName)){\n    rma6Modifier.updateClassifications(cNames,fName2ClassId2Location,fName2ClassId2Weight);\n  }\n }\n", "nl": "rescan classifications after running the data processor"}
{"code": "private void receivedTraffic(String json,AirMapTraffic.TrafficType trafficType){\n  List<AirMapTraffic> updated=new ArrayList<>();\n  List<AirMapTraffic> added=new ArrayList<>();\n  JSONArray trafficJsonArray;\n  try {\n    trafficJsonArray=new JSONObject(json).getJSONArray(\"traffic\");\n  }\n catch (  JSONException e) {\n    e.printStackTrace();\n    AirMapLog.e(\"TrafficService\",e.getMessage());\n    return;\n  }\n  for (int i=0; i < trafficJsonArray.length(); i++) {\n    AirMapTraffic temp=new AirMapTraffic(trafficJsonArray.optJSONObject(i));\n    temp.setTrafficType(trafficType);\n    Coordinate projected=projectedCoordinate(temp);\n    temp.setCoordinate(projected);\n    int index=allTraffic.indexOf(temp);\n    if (index != -1) {\n      allTraffic.set(index,temp);\n      updated.add(temp);\n    }\n else {\n      allTraffic.add(temp);\n      added.add(temp);\n    }\n  }\n  notifyUpdated(updated);\n  notifyAdded(added);\n}\n", "nl": "Called when a traffic alert is received"}
{"code": "public void updateClustering(String[] labels,Table<String,String,Float> matrix){\n  if (!inUpdate) {\n    try {\n      inUpdate=true;\n      labelOrder.clear();\n      treeView.getGraph().clear();\n      previousRectangle=null;\n      if (labels.length > 0) {\n        final Taxa taxa=new Taxa();\n        for (        String label : labels)         taxa.add(label);\n        if (labels.length == 1) {\n          final Node root=treeView.getPhyloTree().newNode();\n          treeView.getPhyloTree().setRoot(root);\n          treeView.setLabel(root,labels[0]);\n          labelOrder.addAll(getLabelOrder(treeView));\n        }\n else {\n          final Distances distances=new Distances(taxa.size());\n          for (int i=0; i < labels.length; i++) {\n            final float[] iValues=getValuesRow(labels[i],matrix);\n            for (int j=i + 1; j < labels.length; j++) {\n              final float[] jValues=getValuesRow(labels[j],matrix);\n              distances.set(i + 1,j + 1,computeCorrelationDistances(iValues.length,iValues,jValues));\n            }\n          }\n          UPGMA.apply(taxa,distances,treeView);\n          flipCoordinates(treeView,rootSide);\n          labelOrder.addAll(getLabelOrder(treeView));\n        }\n      }\n    }\n  finally {\n      inUpdate=false;\n    }\n  }\n}\n", "nl": "update clustering"}
{"code": "public static boolean batch(WebSocketImpl ws,ByteChannel sockchannel) throws IOException {\n  ByteBuffer buffer=ws.outQueue.peek();\n  WrappedByteChannel c=null;\n  if (buffer == null) {\n    if (sockchannel instanceof WrappedByteChannel) {\n      c=(WrappedByteChannel)sockchannel;\n      if (c.isNeedWrite()) {\n        c.writeMore();\n      }\n    }\n  }\n else {\n    do {\n      sockchannel.write(buffer);\n      if (buffer.remaining() > 0) {\n        return false;\n      }\n else {\n        ws.outQueue.poll();\n        buffer=ws.outQueue.peek();\n      }\n    }\n while (buffer != null);\n  }\n  if (ws != null && ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER) {\nsynchronized (ws) {\n      ws.closeConnection();\n    }\n  }\n  return c != null ? !((WrappedByteChannel)sockchannel).isNeedWrite() : true;\n}\n", "nl": "Returns whether the whole outQueue has been flushed"}
{"code": "private void writeSortIndexFile(List<String> data,String columnId) throws IOException {\n  ColumnIdentifier columnIdentifier=new ColumnIdentifier(columnId,null,null);\n  Map<String,Integer> dataToSurrogateKeyMap=new HashMap<>(data.size());\n  int surrogateKey=0;\n  List<Integer> invertedIndexList=new ArrayList<>(data.size());\n  for (int i=0; i < data.size(); i++) {\n    dataToSurrogateKeyMap.put(data.get(i),++surrogateKey);\n  }\n  List<String> sortedKeyList=new ArrayList<>(dataToSurrogateKeyMap.keySet());\n  Collections.sort(sortedKeyList);\n  List<Integer> sortedIndexList=new ArrayList<>(data.size());\n  int[] invertedIndexArray=new int[sortedKeyList.size()];\n  for (int i=0; i < sortedKeyList.size(); i++) {\n    Integer key=dataToSurrogateKeyMap.get(sortedKeyList.get(i));\n    sortedIndexList.add(key);\n    invertedIndexArray[--key]=i + 1;\n  }\n  for (int i=0; i < invertedIndexArray.length; i++) {\n    invertedIndexList.add(invertedIndexArray[i]);\n  }\n  CarbonDictionarySortIndexWriter dictionarySortIndexWriter=new CarbonDictionarySortIndexWriterImpl(carbonTableIdentifier,columnIdentifier,carbonStorePath);\n  try {\n    dictionarySortIndexWriter.writeSortIndex(sortedIndexList);\n    dictionarySortIndexWriter.writeInvertedSortIndex(invertedIndexList);\n  }\n  finally {\n    dictionarySortIndexWriter.close();\n  }\n}\n", "nl": "This method will prepare the sort index data from the given data and write it to a sort index file"}
{"code": "private void applySpeechRateSpecifications(NodeList nl,String rateAttribute){\n  if (\"\".equals(rateAttribute)) {\n    return;\n  }\n  boolean hasLabel=rateAttribute.equals(\"x-slow\") || rateAttribute.equals(\"slow\") || rateAttribute.equals(\"medium\")|| rateAttribute.equals(\"fast\")|| rateAttribute.equals(\"x-fast\")|| rateAttribute.equals(\"default\");\n  if (hasLabel) {\n    rateAttribute=rateLabels2RelativeValues(rateAttribute);\n  }\n  if (!(rateAttribute.startsWith(\"+\") || rateAttribute.startsWith(\"-\")) && rateAttribute.endsWith(\"%\")) {\n    double absolutePercentage=new Double(rateAttribute.substring(0,rateAttribute.length() - 1)).doubleValue();\n    if (absolutePercentage == 100) {\n      return;\n    }\n else {\n      rateAttribute=df.format(absolutePercentage / 100);\n    }\n  }\n  boolean hasPositiveInteger=!rateAttribute.endsWith(\"%\") && (!rateAttribute.startsWith(\"+\") || !rateAttribute.startsWith(\"-\"));\n  if (hasPositiveInteger) {\n    rateAttribute=positiveInteger2RelativeValues(rateAttribute);\n  }\n  Pattern p=Pattern.compile(\"[+|-][0-9]+(.[0-9]+)?[%]?\");\n  Matcher m=p.matcher(rateAttribute);\n  if (m.find()) {\n    double percentage=new Double(rateAttribute.substring(1,rateAttribute.length() - 1)).doubleValue();\n    if (rateAttribute.startsWith(\"+\")) {\n      modifySpeechRate(nl,percentage,true);\n    }\n else {\n      modifySpeechRate(nl,percentage,false);\n    }\n  }\n}\n", "nl": "To apply 'rate' specifications to NodeList (with only 'ph' elements)"}
{"code": "public void update(){\n  clear();\n  final String[] columnNames=new String[classificationViewer.getNumberOfDatasets() + 1];\n  columnNames[0]=classificationViewer.getClassName();\n  for (int i=1; i <= classificationViewer.getNumberOfDatasets(); i++) {\n    columnNames[i]=\"Reads [\" + i + \"]\";\n  }\n  model.setColumnIdentifiers(columnNames);\n  for (int i=0; i < getColumnCount(); i++) {\n    TableColumn col=getColumnModel().getColumn(i);\n    col.setCellRenderer(cellRenderer);\n  }\n  if (classificationViewer.getTree().getRoot() != null) {\n    buildHeatMapRec(classificationViewer.getTree().getRoot(),new HashSet<Integer>());\n  }\n  int[] maxCounts=new int[classificationViewer.getNumberOfDatasets()];\n  for (Node v=classificationViewer.getTree().getFirstNode(); v != null; v=v.getNext()) {\n    if (v.getOutDegree() == 0) {\n      NodeData data=classificationViewer.getNodeData(v);\n      if (data != null) {\n        int[] summarized=data.getSummarized();\n        int top=Math.min(summarized.length,maxCounts.length);\n        for (int i=0; i < top; i++) {\n          maxCounts[i]=Math.max(maxCounts[i],summarized[i]);\n        }\n      }\n    }\n  }\n  cellRenderer.setMaxCounts(maxCounts);\n}\n", "nl": "rescan the heatmap"}
{"code": "@SuppressWarnings(\"unchecked\") public JavaRDD<MapWritable> readData() throws IOException, PIRException {\n  logger.info(\"Reading data \");\n  JavaRDD<MapWritable> jsonRDD;\n  Job job=Job.getInstance();\n  String baseQuery=SystemConfiguration.getProperty(\"pir.baseQuery\");\n  String jobName=\"pirSpark_base_\" + baseQuery + \"_\"+ System.currentTimeMillis();\n  job.setJobName(jobName);\n  job.getConfiguration().setBoolean(\"mapreduce.input.fileinputformat.input.dir.recursive\",true);\n  job.getConfiguration().set(\"query\",baseQuery);\n  logger.debug(\"queryType = \" + bVars.getQueryInfo().getQueryType());\n  logger.debug(\"QuerySchemaLoader.getSchemaNames().size() = \" + QuerySchemaRegistry.getNames().size());\n  for (  String name : QuerySchemaRegistry.getNames()) {\n    logger.debug(\"schemaName = \" + name);\n  }\n  job.getConfiguration().set(\"dataSchemaName\",qSchema.getDataSchemaName());\n  job.getConfiguration().set(\"data.schemas\",SystemConfiguration.getProperty(\"data.schemas\"));\n  String classString=SystemConfiguration.getProperty(\"pir.baseInputFormat\");\n  Class<? extends BaseInputFormat<Text,MapWritable>> inputClass;\n  try {\n    inputClass=(Class<? extends BaseInputFormat<Text,MapWritable>>)Class.forName(classString);\n  }\n catch (  ClassNotFoundException|ClassCastException e) {\n    throw new PIRException(classString + \" cannot be instantiated or does not extend BaseInputFormat\",e);\n  }\n  job.setInputFormatClass(inputClass);\n  FileInputFormat.setInputPaths(job,inputData);\n  jsonRDD=sc.newAPIHadoopRDD(job.getConfiguration(),inputClass,Text.class,MapWritable.class).values().coalesce(numDataPartitions);\n  if (qSchema.getFilter() != null) {\n    return jsonRDD.filter(new FilterData(accum,bVars));\n  }\n else {\n    logger.info(\"qSchema.getFilter() is null\");\n    return jsonRDD;\n  }\n}\n", "nl": "Method to read in the data from an allowed input format, filter, and return a RDD of MapWritable data elements"}
{"code": "private boolean mustUpdateCoordinates(){\n  boolean mustUpdate=(dataMatrix.size() == 0);\n  if (previousTranspose != isTranspose()) {\n    mustUpdate=true;\n  }\n  if (scalingType != ChartViewer.ScalingType.LINEAR)   return mustUpdate;\n  if (previousTranspose != isTranspose()) {\n    previousTranspose=isTranspose();\n    previousClusterSeries=false;\n    previousClusterClasses=false;\n  }\n{\n    final ArrayList<String> currentClasses=new ArrayList<>();\n    currentClasses.addAll(getChartData().getClassNames());\n    if (!previousClasses.equals(currentClasses)) {\n      mustUpdate=true;\n      previousClasses.clear();\n      previousClasses.addAll(currentClasses);\n    }\n  }\n{\n    final ArrayList<String> currentSamples=new ArrayList<>();\n    currentSamples.addAll(getChartData().getSeriesNames());\n    if (!previousSamples.equals(currentSamples)) {\n      mustUpdate=true;\n      previousSamples.clear();\n      previousSamples.addAll(currentSamples);\n    }\n  }\n{\n    if (!previousClusterClasses && viewer.getClassesList().isDoClustering() && !isTranspose())     mustUpdate=true;\n  }\n{\n    if (!previousClusterSeries && viewer.getSeriesList().isDoClustering() && isTranspose())     mustUpdate=true;\n  }\n  return mustUpdate;\n}\n", "nl": "do we need to recompute coordinates?"}
{"code": "public void update(){\n  enabled=true;\n  compressedRow2Reads.clear();\n  SortedSet<Pair<Integer,Integer>> sortedReads=new TreeSet<>();\n  int numberOfCompressedRows=0;\n  int[] ends=new int[alignment.getNumberOfSequences()];\n  for (int read=0; read < alignment.getNumberOfSequences(); read++) {\n    int start=alignment.getLane(read).getFirstNonGapPosition();\n    sortedReads.add(new Pair<>(start,read));\n  }\n  for (  Pair<Integer,Integer> pair : sortedReads) {\n    int read=pair.get2();\n    int start=alignment.getLane(read).getFirstNonGapPosition();\n    boolean done=false;\n    for (int row=0; !done && row < numberOfCompressedRows; row++) {\n      if (start > ends[row] + 10) {\n        compressedRow2Reads.get(row).add(read);\n        ends[row]=alignment.getLane(read).getLastNonGapPosition();\n        done=true;\n      }\n    }\n    if (!done) {\n      ends[numberOfCompressedRows]=alignment.getLane(read).getLastNonGapPosition();\n      List<Integer> reads=new LinkedList<>();\n      reads.add(read);\n      compressedRow2Reads.add(numberOfCompressedRows,reads);\n      numberOfCompressedRows++;\n    }\n  }\n}\n", "nl": "updates the row to compress row mapping"}
{"code": "private void _init(Configuration conf){\n  try {\n    if (this.id > 0) {\n      DefaultListener d=new DefaultListener();\n      d.upgrade(conf,this);\n    }\n    if (!X.isEmpty(listener)) {\n      String name=listener;\n      if (name != null) {\n        try {\n          Class<?> c=Class.forName(name,true,classLoader);\n          Object o=c.newInstance();\n          if (o instanceof IListener) {\n            log.info(\"initializing: \" + name);\n            IListener l=(IListener)o;\n            l.upgrade(conf,this);\n            l.onStart(conf,this);\n          }\n        }\n catch (        Throwable e) {\n          log.error(this.name + \", listener=\" + name,e);\n        }\n      }\n    }\n  }\n catch (  Throwable e) {\n    log.error(e.getMessage(),e);\n  }\n}\n", "nl": "invoke the life listener of the module"}
{"code": "public AbstractClientPacket handle(ChannelBuffer buf,ClientChannelHandler channelHandler){\n  byte opCode=buf.readByte();\n  State state=channelHandler.getState();\n  AbstractClientPacket clientPacket=null;\nswitch (state) {\ncase CONNECTED:\nswitch (opCode) {\ncase 0x30:\n      clientPacket=new CM_CHAT_INI(buf,channelHandler,chatService);\n    break;\ncase 0x05:\n  clientPacket=new CM_PLAYER_AUTH(buf,channelHandler,chatService);\nbreak;\ndefault :\n}\nbreak;\ncase AUTHED:\nswitch (opCode) {\ncase 0x10:\nclientPacket=new CM_CHANNEL_REQUEST(buf,channelHandler,chatService);\nbreak;\ncase 0x18:\nclientPacket=new CM_CHANNEL_MESSAGE(buf,channelHandler,broadcastService);\ndefault :\n}\nbreak;\n}\nreturn clientPacket;\n}\n", "nl": "Reads one packet from ChannelBuffer"}
{"code": "private static QuerySchema deserializeSchema(JsonObject querySchemaJson) throws JsonParseException {\n  long schemaVersion=querySchemaJson.get(\"querySchemaVersion\").getAsLong();\n  if (schemaVersion != QuerySchema.querySchemaSerialVersionUID) {\n    throw new JsonParseException(\"Attempt to deserialize unsupported query info version. Supported: \" + QueryInfo.queryInfoSerialVersionUID + \"; Received: \"+ schemaVersion);\n  }\n  String dataFilterName=querySchemaJson.get(\"filterTypeName\").getAsString();\n  Set<String> filteredElementNames;\n  try {\n    filteredElementNames=gson.fromJson(querySchemaJson.get(\"filteredElementNames\"),new TypeToken<Set<String>>(){\n    }\n.getType());\n  }\n catch (  Exception e) {\n    logger.warn(\"No filtered element names for Query Schema deserialization.\");\n    filteredElementNames=null;\n  }\n  DataFilter dataFilter;\n  try {\n    dataFilter=FilterFactory.getFilter(dataFilterName,filteredElementNames);\n  }\n catch (  IOException|PIRException e) {\n    logger.error(\"Error trying to create data filter from JSON.\",e);\n    throw new JsonParseException(e);\n  }\n  QuerySchema querySchema=new QuerySchema(querySchemaJson.get(\"schemaName\").getAsString(),querySchemaJson.get(\"dataSchemaName\").getAsString(),querySchemaJson.get(\"selectorName\").getAsString(),dataFilterName,dataFilter,querySchemaJson.get(\"dataElementSize\").getAsInt());\n  List<String> elementNames=gson.fromJson(querySchemaJson.get(\"elementNames\"),new TypeToken<List<String>>(){\n  }\n.getType());\n  querySchema.getElementNames().addAll(elementNames);\n  HashMap<String,String> additionalFields=gson.fromJson(querySchemaJson.get(\"additionalFields\"),new TypeToken<HashMap<String,String>>(){\n  }\n.getType());\n  querySchema.getAdditionalFields().putAll(additionalFields);\n  return querySchema;\n}\n", "nl": "Deserializes a QuerySchema JsonObject"}
{"code": "static Properties parseParameters(Element element){\n  Properties props=new Properties();\n  String name=null;\n  String value=null;\n  NodeList nList=element.getElementsByTagName(\"Parameter\");\n  if (nList.getLength() == 0)   nList=element.getElementsByTagName(\"parameter\");\n  for (int i=0; i < nList.getLength(); i++) {\n    Element parameterElement=(Element)nList.item(i);\n    NamedNodeMap nm=parameterElement.getAttributes();\n    Node node=nm.getNamedItem(\"Name\");\n    if (node == null)     node=nm.getNamedItem(\"name\");\n    name=node.getNodeValue();\n    String elementValue=getTextValue(parameterElement);\n    node=nm.getNamedItem(\"Value\");\n    if (node == null)     node=nm.getNamedItem(\"value\");\n    if (elementValue.length() > 0 && node != null)     throw new IllegalArgumentException(\"Declare either a Value \" + \"attribute or a <Parameter> \" + \"value, not both\");\n    if (node == null) {\n      if (elementValue.length() > 0) {\n        value=elementValue;\n      }\n else {\n        throw new IllegalArgumentException(\"You must declare a Value \" + \"attribute or a \" + \"<Parameter> value\");\n      }\n    }\n else {\n      value=node.getNodeValue();\n    }\n    props.put(name,value);\n  }\n  if (logger.isLoggable(Level.FINEST)) {\n    String tagName=element.getTagName();\n    if (element.getParentNode() != null && element.getParentNode() instanceof Element)     tagName=((Element)element.getParentNode()).getTagName() + \".\" + tagName;\n    logger.finest(\"Element [\" + tagName + \"], \"+ \"Parameters: \"+ props.toString());\n  }\n  return (props);\n}\n", "nl": "Parse the <Parameters> element"}
{"code": "static Class findProviderClass(String className,ClassLoader cl,boolean doFallback) throws ClassNotFoundException, ConfigurationError {\n  SecurityManager security=System.getSecurityManager();\n  if (security != null) {\n    final int lastDot=className.lastIndexOf(\".\");\n    String packageName=className;\n    if (lastDot != -1)     packageName=className.substring(0,lastDot);\n    security.checkPackageAccess(packageName);\n  }\n  Class providerClass;\n  if (cl == null) {\n    providerClass=Class.forName(className);\n  }\n else {\n    try {\n      providerClass=cl.loadClass(className);\n    }\n catch (    ClassNotFoundException x) {\n      if (doFallback) {\n        ClassLoader current=ObjectFactory.class.getClassLoader();\n        if (current == null) {\n          providerClass=Class.forName(className);\n        }\n else         if (cl != current) {\n          cl=current;\n          providerClass=cl.loadClass(className);\n        }\n else {\n          throw x;\n        }\n      }\n else {\n        throw x;\n      }\n    }\n  }\n  return providerClass;\n}\n", "nl": "Find a Class using the specified ClassLoader"}
{"code": "public Allophone(Element a,String[] featureNames){\n  name=a.getAttribute(\"ph\");\n  String vc;\n  String isTone;\n  if (name.equals(\"\"))   throw new IllegalArgumentException(\"Element must have a 'ph' attribute\");\n  if (a.getTagName().equals(\"consonant\")) {\n    vc=\"-\";\n    isTone=\"-\";\n  }\n else   if (a.getTagName().equals(\"vowel\")) {\n    vc=\"+\";\n    isTone=\"-\";\n  }\n else   if (a.getTagName().equals(\"silence\")) {\n    vc=\"0\";\n    isTone=\"-\";\n  }\n else   if (a.getTagName().equals(\"tone\")) {\n    vc=\"0\";\n    isTone=\"+\";\n  }\n else {\n    throw new IllegalArgumentException(\"Element must be one of <vowel>, <consonant> and <silence>, but is <\" + a.getTagName() + \">\");\n  }\n  Map<String,String> feats=new HashMap<String,String>();\n  feats.put(\"vc\",vc);\n  feats.put(\"isTone\",isTone);\n  for (  String f : featureNames) {\n    feats.put(f,getAttribute(a,f));\n  }\n  this.features=Collections.unmodifiableMap(feats);\n}\n", "nl": "Create a new Allophone object from the given XML Element"}
{"code": "public static void fileUnlock(ICarbonLock carbonLock,String locktype){\n  if (carbonLock.unlock()) {\n    if (locktype.equals(LockUsage.METADATA_LOCK)) {\n      LOGGER.info(\"Metadata lock has been successfully released\");\n    }\n else     if (locktype.equals(LockUsage.TABLE_STATUS_LOCK)) {\n      LOGGER.info(\"Table status lock has been successfully released\");\n    }\n else     if (locktype.equals(LockUsage.CLEAN_FILES_LOCK)) {\n      LOGGER.info(\"Clean files lock has been successfully released\");\n    }\n else     if (locktype.equals(LockUsage.DELETE_SEGMENT_LOCK)) {\n      LOGGER.info(\"Delete segments lock has been successfully released\");\n    }\n  }\n else {\n    if (locktype.equals(LockUsage.METADATA_LOCK)) {\n      LOGGER.error(\"Not able to release the metadata lock\");\n    }\n else     if (locktype.equals(LockUsage.TABLE_STATUS_LOCK)) {\n      LOGGER.error(\"Not able to release the table status lock\");\n    }\n else     if (locktype.equals(LockUsage.CLEAN_FILES_LOCK)) {\n      LOGGER.info(\"Not able to release the clean files lock\");\n    }\n else     if (locktype.equals(LockUsage.DELETE_SEGMENT_LOCK)) {\n      LOGGER.info(\"Not able to release the delete segments lock\");\n    }\n  }\n}\n", "nl": "unlocks given file"}
{"code": "public List login() throws Exception {\n  Map<String,String> map=new HashMap<String,String>();\n  map.put(\"formhash\",\"1d41a5ce\");\n  map.put(\"referer\",\"http,//www.hi-pda.com/forum/index.php\");\n  map.put(\"loginfield\",\"username\");\n  map.put(\"username\",\"\");\n  map.put(\"password\",\"\");\n  map.put(\"questionid\",\"0\");\n  map.put(\"answer\",\"\");\n  map.put(\"loginsubmit\",\"true\");\n  map.put(\"cookietime\",\"2592000\");\n  StringBuffer params=new StringBuffer();\n  Iterator it=map.entrySet().iterator();\n  while (it.hasNext()) {\n    Map.Entry element=(Map.Entry)it.next();\n    params.append(element.getKey());\n    params.append(\"=\");\n    params.append(element.getValue());\n    params.append(\"&\");\n  }\n  if (params.length() > 0) {\n    params.deleteCharAt(params.length() - 1);\n  }\n  URL hipdaURL=new URL(\"http://www.hi-pda.com/forum/logging.php?action=login&loginsubmit=yes&inajax=1\");\n  HttpURLConnection hipdaURLConnection=(HttpURLConnection)hipdaURL.openConnection();\n  hipdaURLConnection.setDoOutput(true);\n  hipdaURLConnection.setDoInput(true);\n  PrintWriter printWriter=new PrintWriter(hipdaURLConnection.getOutputStream());\n  printWriter.write(params.toString());\n  printWriter.flush();\n  List<String> cookielist=hipdaURLConnection.getHeaderFields().get(\"Set-Cookie\");\n  return cookielist;\n}\n", "nl": "Use this method to login and get cookies"}
{"code": "public boolean isAccepted(Question q){\n  if (excludeQuestions != null && excludeQuestions.contains(\";\" + q.getQuestionId() + \";\")) {\n    return false;\n  }\n  if (filterDupes) {\n    if (!q.isPossibleDuplicate()) {\n      return false;\n    }\n  }\n  if (closeVotes != null && closeVotes.isFilterActive()) {\n    if (!closeVotes.inRange(q.getCloseVoteCount())) {\n      return false;\n    }\n  }\n  if (scores != null && scores.isFilterActive()) {\n    if (!scores.inRange(q.getScore())) {\n      return false;\n    }\n  }\n  if (answerType != null) {\nswitch (answerType) {\ncase CLICK_FROM_ROOMBA:\n      return q.isAlmostRoomba();\ncase HAS_ANSWER:\n    return q.getAnswerCount() > 0;\ncase HAS_ACCEPTED_ANSWER:\n  return q.isAnswerAccepted();\ncase HAS_NO_ACCEPTED_ANSWER:\nreturn !q.isAnswerAccepted();\ncase HAS_NO_ANSWER:\nreturn q.getAnswerCount() <= 0;\ncase NO_ROOMBA:\nreturn !q.isRoomba();\ncase NO_FILTER:\nreturn true;\n}\n}\nreturn true;\n}\n", "nl": "Check if question is accpeted by filter Note: Day filter is already done on api call"}
{"code": "public static Map<String,Object> convertDocumentStreamToStream(DispatchContext dctx,Map<String,? extends Object> context){\n  XMultiComponentFactory xmulticomponentfactory=null;\n  String stringUrl=\"file:///\" + context.get(\"filenameFrom\");\n  String stringConvertedFile=\"file:///\" + context.get(\"filenameTo\");\n  String inputMimeType=(String)context.get(\"inputMimeType\");\n  String outputMimeType=(String)context.get(\"outputMimeType\");\n  String oooHost=(String)context.get(\"oooHost\");\n  String oooPort=(String)context.get(\"oooPort\");\n  try {\n    xmulticomponentfactory=OpenOfficeWorker.getRemoteServer(oooHost,oooPort);\n    File inputFile=new File(stringUrl);\n    long fileSize=inputFile.length();\n    FileInputStream fis=new FileInputStream(inputFile);\n    ByteArrayOutputStream baos=new ByteArrayOutputStream((int)fileSize);\n    int c;\n    while ((c=fis.read()) != -1) {\n      baos.write(c);\n    }\n    OpenOfficeByteArrayInputStream oobais=new OpenOfficeByteArrayInputStream(baos.toByteArray());\n    OpenOfficeByteArrayOutputStream oobaos=OpenOfficeWorker.convertOODocByteStreamToByteStream(xmulticomponentfactory,oobais,inputMimeType,outputMimeType);\n    FileOutputStream fos=new FileOutputStream(stringConvertedFile);\n    fos.write(oobaos.toByteArray());\n    fos.close();\n    fis.close();\n    oobais.close();\n    oobaos.close();\n    Map results=ServiceUtil.returnSuccess();\n    return results;\n  }\n catch (  IOException e) {\n    Debug.logError(e,\"Error in OpenOffice operation: \",module);\n    return ServiceUtil.returnError(e.toString());\n  }\ncatch (  Exception e) {\n    Debug.logError(e,\"Error in OpenOffice operation: \",module);\n    return ServiceUtil.returnError(e.toString());\n  }\n}\n", "nl": "Use OpenOffice to convert documents between types"}
{"code": "public boolean isValidLegionMemberEx(){\n  if (getObjectId() < 1) {\n    log.error(\"[LegionMemberEx] Player Object ID is empty.\");\n  }\n else   if (getName() == null) {\n    log.error(\"[LegionMemberEx] Player Name is empty.\" + getObjectId());\n  }\n else   if (getPlayerClass() == null) {\n    log.error(\"[LegionMemberEx] Player Class is empty.\" + getObjectId());\n  }\n else   if (getLevel() < 1) {\n    log.error(\"[LegionMemberEx] Player Level is empty.\" + getObjectId());\n  }\n else   if (getLastOnline() == 0) {\n    log.error(\"[LegionMemberEx] Last Online is empty.\" + getObjectId());\n  }\n else   if (getWorldId() < 1) {\n    log.error(\"[LegionMemberEx] World Id is empty.\" + getObjectId());\n  }\n else   if (getLegion() == null) {\n    log.error(\"[LegionMemberEx] Legion is empty.\" + getObjectId());\n  }\n else   if (getRank() == null) {\n    log.error(\"[LegionMemberEx] Rank is empty.\" + getObjectId());\n  }\n else   if (getNickname() == null) {\n    log.error(\"[LegionMemberEx] Nickname is empty.\" + getObjectId());\n  }\n else   if (getSelfIntro() == null) {\n    log.error(\"[LegionMemberEx] Self Intro is empty.\" + getObjectId());\n  }\n else {\n    return true;\n  }\n  return false;\n}\n", "nl": "Checks if a LegionMemberEx is valid or not"}
{"code": "private Map<RoleType,Pair<String,Type>> computeRoleVarTypeMap(){\n  Map<RoleType,Pair<String,Type>> roleVarTypeMap=new HashMap<>();\n  if (getParentQuery() == null)   return roleVarTypeMap;\n  MindmapsGraph graph=getParentQuery().getGraph().orElse(null);\n  Map<String,Type> varTypeMap=getParentQuery().getVarTypeMap();\n  Set<String> allocatedVars=new HashSet<>();\n  Set<RoleType> allocatedRoles=new HashSet<>();\n  castings.forEach(null);\n  RelationType relType=(RelationType)getType();\n  Set<String> varsToAllocate=getVarNames();\n  varsToAllocate.removeAll(allocatedVars);\n  for (  String var : varsToAllocate) {\n    Type type=varTypeMap.get(var);\n    if (type != null && relType != null) {\n      Set<RoleType> cRoles=getCompatibleRoleTypes(type,relType);\n      if (cRoles.size() == 1) {\n        RoleType role=cRoles.iterator().next();\n        roleVarTypeMap.put(role,new Pair<>(var,type));\n        allocatedVars.add(var);\n        allocatedRoles.add(role);\n      }\n    }\n  }\n  Collection<RoleType> rolesToAllocate=relType.hasRoles();\n  rolesToAllocate.removeAll(allocatedRoles);\n  varsToAllocate.removeAll(allocatedVars);\n  if (rolesToAllocate.size() == 1 && varsToAllocate.size() == 1) {\n    RoleType role=rolesToAllocate.iterator().next();\n    String var=varsToAllocate.iterator().next();\n    Type type=varTypeMap.get(var);\n    roleVarTypeMap.put(role,new Pair<>(var,type));\n  }\n  return roleVarTypeMap;\n}\n", "nl": "Attempts to infer the implicit roleTypes and matching types based on contents of the parent query"}
{"code": "private static void paintCycle(GuidelineHandler myState,NlGraphics g,List<Constraint> cycle){\n  assert cycle.size() > 0;\n  NlComponent from=cycle.get(0).from.node;\n  assert from != null;\n  Rectangle fromBounds=new Rectangle(from.x,from.y,from.w,from.h);\n  if (myState.myDraggedNodes.contains(from)) {\n    fromBounds=myState.myBounds;\n  }\n  Point fromCenter=center(fromBounds);\n  List<Point> points=new ArrayList<Point>();\n  points.add(fromCenter);\n  for (  Constraint constraint : cycle) {\n    assert constraint.from.node == from;\n    NlComponent to=constraint.to.node;\n    assert to != null;\n    Point toCenter=new Point(to.x + to.w / 2,to.y + to.h / 2);\n    points.add(toCenter);\n    boolean isDragged=myState.myDraggedNodes.contains(to);\n    if (isDragged) {\n      toCenter=center(myState.myBounds);\n      points.add(toCenter);\n    }\n    from=to;\n    fromCenter=toCenter;\n  }\n  points.add(fromCenter);\n  points.add(points.get(0));\n  g.useStyle(CYCLE);\n  for (int i=1, n=points.size(); i < n; i++) {\n    Point a=points.get(i - 1);\n    Point b=points.get(i);\n    g.drawLine(a.x,a.y,b.x,b.y);\n  }\n}\n", "nl": "Paints a constraint cycle"}
{"code": "public void load(Reader r0) throws IOException {\n  BufferedReader r=new BufferedReader(r0);\n  char[] mapPos2Char=null;\n  String aLine;\n  int cols=0;\n  while ((aLine=r.readLine()) != null) {\n    aLine=aLine.trim();\n    if (aLine.length() == 0 || aLine.startsWith(\"#\"))     continue;\n    if (mapPos2Char == null) {\n      String[] tokens=aLine.split(\" \");\n      cols=tokens.length;\n      if (tokens.length < 20)       throw new IOException(\"Expected >=20 tokens, got: \" + tokens.length + \" in line: \"+ aLine);\n      List<String> list=new LinkedList<>();\n      list.addAll(Arrays.asList(tokens));\n      int count=0;\n      mapPos2Char=new char[list.size()];\n      for (      String label : list) {\n        char c=Character.toUpperCase(label.charAt(0));\n        mapPos2Char[count++]=c;\n      }\n    }\n else {\n      String[] tokens=aLine.split(\" \");\n      if (tokens.length != cols + 1)       throw new IOException(\"Expected \" + (cols + 1) + \" tokens, got: \"+ tokens.length+ \" in line: \"+ aLine);\n      char c=Character.toUpperCase(tokens[0].charAt(0));\n      for (int i=1; i < tokens.length; i++) {\n        int value=Integer.parseInt(tokens[i]);\n        char d=mapPos2Char[i - 1];\n        matrix[c][d]=value;\n      }\n    }\n  }\n}\n", "nl": "load a matrix"}
{"code": "private void select(Rectangle rect,Rectangle selectionRect,int mouseClicks){\n  if (selectionRect == null || chartSelection == null || mouseClicks != 1)   return;\n  selectionGraphics.setSelectionRectangle(selectionRect);\n  selectionGraphics.getSelectedItems().clear();\n  doPaint(selectionGraphics,rect);\n  final Collection<Edge> hitEdges=selectionGraphics.getSelectedItems();\n  if (hitEdges.size() > 0) {\n    final Set<Node> seen=new HashSet<>();\n    final Stack<Node> stack=new Stack<>();\n    for (    Edge e : hitEdges) {\n      stack.add(e.getTarget());\n    }\n    while (stack.size() > 0) {\n      final Node v=stack.pop();\n      if (v.getOutDegree() == 0) {\n        if (type == TYPE.SERIES)         chartSelection.setSelectedSeries(treeView.getLabel(v),true);\n else         if (type == TYPE.CLASSES)         chartSelection.setSelectedClass(treeView.getLabel(v),true);\n else         if (type == TYPE.ATTRIBUTES)         chartSelection.setSelectedAttribute(treeView.getLabel(v),true);\n      }\n else {\n        for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n          if (!seen.contains(e.getTarget())) {\n            stack.push(e.getTarget());\n            seen.add(e.getTarget());\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "select series or classes"}
{"code": "public static void unZipFile(String zipFile,String outputFolder){\n  byte[] buffer=new byte[1024];\n  try {\n    File folder=new File(outputFolder);\n    if (!folder.exists()) {\n      folder.mkdir();\n    }\n    ZipInputStream zipInputStream=new ZipInputStream(new FileInputStream(zipFile));\n    ZipEntry zipEntry=zipInputStream.getNextEntry();\n    while (zipEntry != null) {\n      String fileName=zipEntry.getName();\n      File newFile=new File(FileUtility.joinPath(outputFolder,fileName));\n      System.out.println(\"file unzip : \" + newFile.getAbsoluteFile());\n      new File(newFile.getParent()).mkdirs();\n      FileOutputStream fileOutputStream=new FileOutputStream(newFile);\n      int length;\n      while ((length=zipInputStream.read(buffer)) > 0) {\n        fileOutputStream.write(buffer,0,length);\n      }\n      fileOutputStream.close();\n      zipEntry=zipInputStream.getNextEntry();\n    }\n    zipInputStream.closeEntry();\n    zipInputStream.close();\n  }\n catch (  IOException ex) {\n    LOGGER.log(Level.WARNING,\"Unable to unzip file\",ex);\n  }\n}\n", "nl": "Zip a file"}
{"code": "public void handleStep(final FieldODEStateInterpolator<T> interpolator,final boolean isLast) throws MathIllegalStateException {\n  if (last == null) {\n    first=interpolator.getPreviousState();\n    last=first;\n    forward=interpolator.isForward();\n    if (!forward) {\n      h=-h;\n    }\n  }\n  T nextTime=(mode == StepNormalizerMode.INCREMENT) ? last.getTime().add(h) : last.getTime().getField().getZero().add((FastMath.floor(last.getTime().getReal() / h) + 1) * h);\n  if (mode == StepNormalizerMode.MULTIPLES && Precision.equals(nextTime.getReal(),last.getTime().getReal(),1)) {\n    nextTime=nextTime.add(h);\n  }\n  boolean nextInStep=isNextInStep(nextTime,interpolator);\n  while (nextInStep) {\n    doNormalizedStep(false);\n    last=interpolator.getInterpolatedState(nextTime);\n    nextTime=nextTime.add(h);\n    nextInStep=isNextInStep(nextTime,interpolator);\n  }\n  if (isLast) {\n    final boolean addLast=bounds.lastIncluded() && last.getTime().getReal() != interpolator.getCurrentState().getTime().getReal();\n    doNormalizedStep(!addLast);\n    if (addLast) {\n      last=interpolator.getCurrentState();\n      doNormalizedStep(true);\n    }\n  }\n}\n", "nl": "Handle the last accepted step"}
{"code": "public static String readFile(File file,String charsetName){\n  StringBuilder fileContent=new StringBuilder(\"\");\n  if (file == null || !file.isFile()) {\n    return fileContent.toString();\n  }\n  BufferedReader reader=null;\n  try {\n    InputStreamReader is=new InputStreamReader(new FileInputStream(file),charsetName);\n    reader=new BufferedReader(is);\n    String line=null;\n    while ((line=reader.readLine()) != null) {\n      if (!fileContent.toString().equals(\"\")) {\n        fileContent.append(\"\\r\\n\");\n      }\n      fileContent.append(line);\n    }\n    reader.close();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"IOException occurred. \",e);\n  }\n finally {\n    if (reader != null) {\n      try {\n        reader.close();\n      }\n catch (      IOException e) {\n        throw new RuntimeException(\"IOException occurred. \",e);\n      }\n    }\n  }\n  return fileContent.toString();\n}\n", "nl": "read file"}
{"code": "static Class findProviderClass(String className,ClassLoader cl,boolean doFallback) throws ClassNotFoundException, ConfigurationError {\n  SecurityManager security=System.getSecurityManager();\n  if (security != null) {\n    final int lastDot=className.lastIndexOf(\".\");\n    String packageName=className;\n    if (lastDot != -1)     packageName=className.substring(0,lastDot);\n    security.checkPackageAccess(packageName);\n  }\n  Class providerClass;\n  if (cl == null) {\n    providerClass=Class.forName(className);\n  }\n else {\n    try {\n      providerClass=cl.loadClass(className);\n    }\n catch (    ClassNotFoundException x) {\n      if (doFallback) {\n        ClassLoader current=ObjectFactory.class.getClassLoader();\n        if (current == null) {\n          providerClass=Class.forName(className);\n        }\n else         if (cl != current) {\n          cl=current;\n          providerClass=cl.loadClass(className);\n        }\n else {\n          throw x;\n        }\n      }\n else {\n        throw x;\n      }\n    }\n  }\n  return providerClass;\n}\n", "nl": "Find a Class using the specified ClassLoader"}
{"code": "private void configureUI(){\n  if (mWidget == null) {\n    return;\n  }\n  int top=getMargin(ConstraintAnchor.Type.TOP);\n  int left=getMargin(ConstraintAnchor.Type.LEFT);\n  int right=getMargin(ConstraintAnchor.Type.RIGHT);\n  int bottom=getMargin(ConstraintAnchor.Type.BOTTOM);\n  boolean baseline=hasBaseline();\n  boolean showVerticalSlider=bottom != UNCONNECTED && top != UNCONNECTED;\n  boolean showHorizontalSlider=left != UNCONNECTED && right != UNCONNECTED;\n  if (showHorizontalSlider) {\n    float bias=mWidget.getHorizontalBiasPercent();\n    mHorizontalSlider.setValue((int)(bias * 100));\n  }\n  if (showVerticalSlider) {\n    float bias=mWidget.getVerticalBiasPercent();\n    mVerticalSlider.setValue(100 - (int)(bias * 100));\n  }\n  mVerticalSlider.setEnabled(showVerticalSlider);\n  mHorizontalSlider.setEnabled(showHorizontalSlider);\n  mHorizontalSlider.invalidate();\n  mVerticalSlider.invalidate();\n  mVerticalSlider.setToolTipText(showVerticalSlider ? VERTICAL_TOOL_TIP_TEXT : null);\n  mHorizontalSlider.setToolTipText(showHorizontalSlider ? HORIZONTAL_TOOL_TIP_TEXT : null);\n  int widthVal=convert(mWidget.getHorizontalDimensionBehaviour());\n  int heightValue=convert(mWidget.getVerticalDimensionBehaviour());\n  mMain.configureUi(bottom,top,left,right,baseline,widthVal,heightValue);\n}\n", "nl": "This loads the parameters form mWidget the ConstraintWidget"}
{"code": "protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  date.year=YEAR;\n  if (str.charAt(0) != '-' || str.charAt(1) != '-') {\n    throw new SchemaDateTimeException(\"Invalid format for gMonthDay: \" + str);\n  }\n  date.month=parseInt(str,2,4);\n  int start=4;\n  if (str.charAt(start++) != '-') {\n    throw new SchemaDateTimeException(\"Invalid format for gMonthDay: \" + str);\n  }\n  date.day=parseInt(str,start,start + 2);\n  if (MONTHDAY_SIZE < len) {\n    if (!isNextCharUTCSign(str,MONTHDAY_SIZE,len)) {\n      throw new SchemaDateTimeException(\"Error in month parsing:\" + str);\n    }\n else {\n      getTimeZone(str,date,MONTHDAY_SIZE,len);\n    }\n  }\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != 'Z') {\n    normalize(date);\n  }\n  date.position=1;\n  return date;\n}\n", "nl": "Parses, validates and computes normalized version of gMonthDay object"}
{"code": "private String parseIpFromPing(String ping){\n  String ip=\"\";\n  if (ping.contains(FROM_PING) || ping.contains(SMALL_FROM_PING)) {\n    int index=ping.indexOf(FROM_PING);\n    if (index == 0) {\n      index=ping.indexOf(SMALL_FROM_PING);\n    }\n    ip=ping.substring(index + 5);\n    if (ip.contains(PARENTHESE_OPEN_PING)) {\n      int indexOpen=ip.indexOf(PARENTHESE_OPEN_PING);\n      int indexClose=ip.indexOf(PARENTHESE_CLOSE_PING);\n      ip=ip.substring(indexOpen + 1,indexClose);\n    }\n else {\n      ip=ip.substring(0,ip.indexOf(\"\\n\"));\n      if (ip.contains(\":\")) {\n        index=ip.indexOf(\":\");\n      }\n else {\n        index=ip.indexOf(\" \");\n      }\n      ip=ip.substring(0,index);\n    }\n  }\n else {\n    int indexOpen=ping.indexOf(PARENTHESE_OPEN_PING);\n    int indexClose=ping.indexOf(PARENTHESE_CLOSE_PING);\n    ip=ping.substring(indexOpen + 1,indexClose);\n  }\n  return ip;\n}\n", "nl": "Gets the ip from the string returned by a ping"}
{"code": "private void hilite(Node v){\n  NodeView nv=viewer.getNV(v);\n  if (nv.getLocation() == null)   return;\n{\n    int scaledWidth;\n    int scaledHeight;\n    if (nv.getShape() == NodeView.NONE_NODE) {\n      scaledWidth=scaledHeight=2;\n    }\n else {\n      if (nv.getFixedSize()) {\n        scaledWidth=nv.getWidth();\n        scaledHeight=nv.getHeight();\n      }\n else {\n        scaledWidth=NodeView.computeScaledWidth(viewer.trans,nv.getWidth());\n        scaledHeight=NodeView.computeScaledHeight(viewer.trans,nv.getHeight());\n      }\n    }\n    Point apt=viewer.trans.w2d(nv.getLocation());\n    apt.x-=(scaledWidth >> 1);\n    apt.y-=(scaledHeight >> 1);\n    gc.setColor(ProgramProperties.SELECTION_COLOR);\n    Shape shape=new Rectangle(apt.x - 2,apt.y - 2,scaledWidth + 4,scaledHeight + 4);\n    gc.fill(shape);\n    gc.setColor(ProgramProperties.SELECTION_COLOR_DARKER);\n    final Stroke oldStroke=gc.getStroke();\n    gc.setStroke(NodeView.NORMAL_STROKE);\n    gc.draw(shape);\n    gc.setStroke(oldStroke);\n  }\n}\n", "nl": "hilite the node"}
{"code": "public static void rollback(Throwable causeThrowable) throws GenericTransactionException {\n  UserTransaction ut=TransactionFactoryLoader.getInstance().getUserTransaction();\n  if (ut != null) {\n    try {\n      int status=ut.getStatus();\n      Debug.logVerbose(\"Current status : \" + getTransactionStateString(status),module);\n      if (status != STATUS_NO_TRANSACTION) {\n        if (causeThrowable == null && Debug.infoOn()) {\n          Exception newE=new Exception(\"Stack Trace\");\n          Debug.logError(newE,\"[TransactionUtil.rollback]\",module);\n        }\n        clearTransactionStamps();\n        clearTransactionBeginStack();\n        clearSetRollbackOnlyCause();\n        ut.rollback();\n        Debug.logInfo(\"Transaction rolled back\",module);\n      }\n else {\n        Debug.logWarning(\"Transaction not rolled back, status is STATUS_NO_TRANSACTION\",module);\n      }\n    }\n catch (    IllegalStateException e) {\n      Throwable t=e.getCause() == null ? e : e.getCause();\n      throw new GenericTransactionException(\"Could not rollback transaction, IllegalStateException exception: \" + t.toString(),t);\n    }\ncatch (    SystemException e) {\n      Throwable t=e.getCause() == null ? e : e.getCause();\n      throw new GenericTransactionException(\"System error, could not rollback transaction: \" + t.toString(),t);\n    }\n  }\n else {\n    Debug.logInfo(\"No UserTransaction, transaction not rolled back\",module);\n  }\n}\n", "nl": "Rolls back transaction in the current thread IF transactions are available"}
{"code": "@Override protected void analyzeInteraction(){\n  int critVal=(int)(Rnd.get(55000) / (skillLvlDiff + 1));\n  if (critVal < CraftConfig.CRAFT_CHANCE_PURPLECRIT) {\n    critType=CraftCritType.PURPLE;\n    currentSuccessValue=maxSuccessValue;\n    return;\n  }\n else   if (critVal < CraftConfig.CRAFT_CHANCE_BLUECRIT) {\n    critType=CraftCritType.BLUE;\n  }\n else   if (critVal < CraftConfig.CRAFT_CHANCE_INSTANT) {\n    critType=CraftCritType.INSTANT;\n    currentSuccessValue=maxSuccessValue;\n    return;\n  }\n  if (CraftConfig.CRAFT_CHECKTASK) {\n    if (this.task == null) {\n      return;\n    }\n  }\n  double mod=Math.sqrt((double)skillLvlDiff / 450f) * 100f + Rnd.nextGaussian() * 10f;\n  mod-=(double)this.itemQuality.getQualityId();\n  if (mod < 0) {\n    currentFailureValue-=(int)mod;\n  }\n else {\n    currentSuccessValue+=(int)mod;\n  }\n  if (currentSuccessValue >= maxSuccessValue) {\n    currentSuccessValue=maxSuccessValue;\n  }\n else   if (currentFailureValue >= maxFailureValue) {\n    currentFailureValue=maxFailureValue;\n  }\n}\n", "nl": "Perform interaction calculation"}
{"code": "public static Schema fromStructType(StructType structType){\n  Schema.Builder builder=new Schema.Builder();\n  StructField[] fields=structType.fields();\n  String[] fieldNames=structType.fieldNames();\n  for (int i=0; i < fields.length; i++) {\n    String name=fields[i].dataType().typeName().toLowerCase();\nswitch (name) {\ncase \"double\":\n      builder.addColumnDouble(fieldNames[i]);\n    break;\ncase \"float\":\n  builder.addColumnFloat(fieldNames[i]);\nbreak;\ncase \"long\":\nbuilder.addColumnLong(fieldNames[i]);\nbreak;\ncase \"int\":\ncase \"integer\":\nbuilder.addColumnInteger(fieldNames[i]);\nbreak;\ncase \"string\":\nbuilder.addColumnString(fieldNames[i]);\nbreak;\ndefault :\nthrow new RuntimeException(\"Unknown type: \" + name);\n}\n}\nreturn builder.build();\n}\n", "nl": "Create a datavec schema from a struct type"}
{"code": "private static void visitSelectedLeavesRec(ClassificationViewer viewer,Node v,NodeSet selected,Vector<String> path,LinkedList<Map> rowList,LinkedList<int[]> dataList,ProgressListener progressListener) throws CanceledException {\n  if (v.getOutDegree() > 0 || selected.contains(v)) {\n    Integer classId=(Integer)v.getInfo();\n    String className=v == viewer.getTree().getRoot() ? \"Root\" : viewer.getClassification().getName2IdMap().get(classId);\n    path.addElement(className);\n    if (selected.contains(v)) {\n      NodeData data=viewer.getNodeData(v);\n      if (data != null) {\n        int[] values;\n        if (v.getOutDegree() == 0)         values=data.getSummarized();\n else         values=data.getAssigned();\n        Map rowItem=new StringMap();\n        rowItem.put(\"id\",\"\" + classId);\n        Map metadata=new StringMap();\n        ArrayList<String> classification=new ArrayList<>(path.size());\n        classification.addAll(path);\n        metadata.put(\"taxonomy\",classification);\n        rowItem.put(\"metadata\",metadata);\n        rowList.add(rowItem);\n        dataList.add(values);\n      }\n      progressListener.incrementProgress();\n    }\n    for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n      visitSelectedLeavesRec(viewer,e.getTarget(),selected,path,rowList,dataList,progressListener);\n    }\n    path.setSize(path.size() - 1);\n  }\n}\n", "nl": "recursively visit all the selected leaves"}
{"code": "public static void renameTableForDeletion(int partitionCount,String storePath,String databaseName,String tableName){\n  String tableNameWithPartition=\"\";\n  String databaseNameWithPartition=\"\";\n  String fullPath=\"\";\n  String newFilePath=\"\";\n  String newFileName=\"\";\n  Callable<Void> c=null;\n  long time=System.currentTimeMillis();\n  FileFactory.FileType fileType=null;\n  ExecutorService executorService=Executors.newFixedThreadPool(10);\n  for (int i=0; i < partitionCount; i++) {\n    databaseNameWithPartition=databaseName + '_' + i;\n    tableNameWithPartition=tableName + '_' + i;\n    newFileName=tableNameWithPartition + '_' + time;\n    fullPath=storePath + File.separator + databaseNameWithPartition+ File.separator+ tableNameWithPartition;\n    newFilePath=storePath + File.separator + databaseNameWithPartition+ File.separator+ newFileName;\n    fileType=FileFactory.getFileType(fullPath);\n    try {\n      if (FileFactory.isFileExist(fullPath,fileType)) {\n        CarbonFile file=FileFactory.getCarbonFile(fullPath,fileType);\n        boolean isRenameSuccessfull=file.renameTo(newFilePath);\n        if (!isRenameSuccessfull) {\n          LOGGER.error(\"Problem renaming the table :: \" + fullPath);\n          c=new DeleteFolderAndFiles(file);\n          executorService.submit(c);\n        }\n else {\n          c=new DeleteFolderAndFiles(FileFactory.getCarbonFile(newFilePath,fileType));\n          executorService.submit(c);\n        }\n      }\n    }\n catch (    IOException e) {\n      LOGGER.error(\"Problem renaming the table :: \" + fullPath);\n    }\n  }\n  executorService.shutdown();\n}\n", "nl": "This function will rename the table to be deleted"}
{"code": "@Override public void nextTuple(){\n  Message msg;\n  msg=failedMessages.peek();\n  if (msg != null) {\n    MessageRetries messageRetries=pendingMessageRetries.get(msg.getMessageId());\n    if (Backoff.shouldBackoff(messageRetries.getTimeStamp(),TimeUnit.NANOSECONDS,messageRetries.getNumRetries())) {\n      Utils.sleep(100);\n    }\n else {\n      LOG.info(\"[{}] Retrying failed message {}\",spoutId,msg.getMessageId());\n      failedMessages.remove();\n      mapToValueAndEmit(msg);\n    }\n    return;\n  }\n  if (consumer != null) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"[{}] Receiving the next message from pulsar consumer to emit to the collector\",spoutId);\n    }\n    try {\n      msg=consumer.receive(1,TimeUnit.SECONDS);\n      if (msg != null) {\n        ++messagesReceived;\n        messageSizeReceived+=msg.getData().length;\n      }\n      mapToValueAndEmit(msg);\n    }\n catch (    PulsarClientException e) {\n      LOG.error(\"[{}] Error receiving message from pulsar consumer\",spoutId,e);\n    }\n  }\n}\n", "nl": "Emits a tuple received from the Pulsar consumer unless there are any failed messages"}
{"code": "public static void appendCigar(String alignedQuery,String alignedReference,StringBuilder buffer){\n  char cigarState='M';\n  int count=0;\n  for (int i=0; i < alignedQuery.length(); i++) {\n    if (alignedQuery.charAt(i) == '-') {\n      if (cigarState == 'D') {\n        count++;\n      }\n else       if (count > 0) {\n        buffer.append(count).append(cigarState);\n        cigarState='D';\n        count=1;\n      }\n    }\n else     if (alignedReference.charAt(i) == '-') {\n      if (cigarState == 'I') {\n        count++;\n      }\n else       if (count > 0) {\n        buffer.append(count).append(cigarState);\n        cigarState='I';\n        count=1;\n      }\n    }\n else {\n      if (cigarState == 'M') {\n        count++;\n      }\n else       if (count > 0) {\n        buffer.append(count).append(cigarState);\n        cigarState='M';\n        count=1;\n      }\n    }\n  }\n  if (count > 0) {\n    buffer.append(count).append(cigarState);\n  }\n}\n", "nl": "append the cigar string"}
{"code": "@Override public void onRequestPermissionsResult(int requestCode,@NonNull String[] permissions,@NonNull int[] grantResults){\nswitch (requestCode) {\ncase Constants.PERMISSION_REQUEST_WRITE_EXTERNAL_STORAGE:\n{\n      if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n        Log.d(TAG,\"Write External permission granted\");\n        getData();\n        return;\n      }\n      Log.e(TAG,\"Permission not granted: results len = \" + grantResults.length + \" Result code = \"+ (grantResults.length > 0 ? grantResults[0] : \"(empty)\"));\n      finish();\n    }\ncase Constants.PERMISSION_REQUEST_CAMERA:\n{\n    if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n      Log.d(TAG,\"Camera permission granted\");\n      captureImage();\n      return;\n    }\n    Log.e(TAG,\"Permission not granted: results len = \" + grantResults.length + \" Result code = \"+ (grantResults.length > 0 ? grantResults[0] : \"(empty)\"));\n    break;\n  }\ndefault :\n{\n  Log.d(TAG,\"Got unexpected permission result: \" + requestCode);\n  super.onRequestPermissionsResult(requestCode,permissions,grantResults);\n  break;\n}\n}\n}\n", "nl": "Handle permission results"}
{"code": "public void attachPrevious(NlComponent previous,NlComponent node){\n  removeRelativeParams(node);\n  String id=previous.getId();\n  if (StringUtil.isEmpty(id)) {\n    return;\n  }\n  if (myCurrentTopMatch != null || myCurrentBottomMatch != null) {\n    node.setAttribute(ANDROID_URI,myCurrentTopMatch != null ? ATTR_LAYOUT_BELOW : ATTR_LAYOUT_ABOVE,id);\n    if (myCurrentLeftMatch != null) {\n      applyConstraint(node,myCurrentLeftMatch.getConstraint(true));\n      applyMargin(node,ATTR_LAYOUT_MARGIN_LEFT,myLeftMargin);\n    }\n else     if (myCurrentRightMatch != null) {\n      applyConstraint(node,myCurrentRightMatch.getConstraint(true));\n      applyMargin(node,ATTR_LAYOUT_MARGIN_RIGHT,myRightMargin);\n    }\n  }\n else   if (myCurrentLeftMatch != null || myCurrentRightMatch != null) {\n    node.setAttribute(ANDROID_URI,myCurrentLeftMatch != null ? ATTR_LAYOUT_TO_RIGHT_OF : ATTR_LAYOUT_TO_LEFT_OF,id);\n    if (myCurrentTopMatch != null) {\n      applyConstraint(node,myCurrentTopMatch.getConstraint(true));\n      applyMargin(node,ATTR_LAYOUT_MARGIN_TOP,getTopMarginDp());\n    }\n else     if (myCurrentBottomMatch != null) {\n      applyConstraint(node,myCurrentBottomMatch.getConstraint(true));\n      applyMargin(node,ATTR_LAYOUT_MARGIN_BOTTOM,getBottomMarginDp());\n    }\n  }\n}\n", "nl": "Attach the new child to the previous node"}
{"code": "public static void main(String[] args) throws IOException, DataFormatException {\n  Compressor compression=new Compressor();\n  BufferedReader r=new BufferedReader(new InputStreamReader(System.in));\n  System.out.print(\"> \");\n  System.out.flush();\n  String inputString=\"\";\n  String aLine;\n  while ((aLine=r.readLine()) != null) {\n    if (aLine.length() > 0) {\n      if (aLine.equals(\".\")) {\n        byte[] bytes=new byte[inputString.length() + 1000];\n        int numberOfBytes=compression.deflateString2ByteArray(inputString,bytes);\n        String outputString;\n        if (numberOfBytes < 0)         outputString=compression.inflateByteArray2String(-numberOfBytes,bytes);\n else         outputString=Compressor.convertUncompressedByteArray2String(numberOfBytes,bytes);\n        System.err.println(\"=<\" + outputString + \">\");\n        System.err.println(\"= \" + outputString);\n        System.err.println(\"uncompressed: \" + inputString.length());\n        System.err.println(\"compressed:   \" + numberOfBytes);\n        System.err.println(\"decompressed: \" + outputString.length());\n{\n          byte[] target=new byte[10 * bytes.length];\n          compression.inflateByteArray(-numberOfBytes,bytes,target);\n          System.err.println(\"decompressed bytes: \" + Basic.toString(target));\n        }\n        inputString=\"\";\n        System.out.print(\"> \");\n      }\n else {\n        inputString+=aLine + \"\\n\";\n        System.out.print(\"? \");\n      }\n      System.out.flush();\n    }\n  }\n}\n", "nl": "interactively test deflation and inflation"}
{"code": "public static void createCopyOfSubProcessExecutionForCompensation(ExecutionEntity subProcessExecution){\n  EventSubscriptionEntityManager eventSubscriptionEntityManager=Context.getCommandContext().getEventSubscriptionEntityManager();\n  List<EventSubscriptionEntity> eventSubscriptions=eventSubscriptionEntityManager.findEventSubscriptionsByExecutionAndType(subProcessExecution.getId(),\"compensate\");\n  List<CompensateEventSubscriptionEntity> compensateEventSubscriptions=new ArrayList<CompensateEventSubscriptionEntity>();\n  for (  EventSubscriptionEntity event : eventSubscriptions) {\n    if (event instanceof CompensateEventSubscriptionEntity) {\n      compensateEventSubscriptions.add((CompensateEventSubscriptionEntity)event);\n    }\n  }\n  if (CollectionUtil.isNotEmpty(compensateEventSubscriptions)) {\n    ExecutionEntity processInstanceExecutionEntity=subProcessExecution.getProcessInstance();\n    ExecutionEntity eventScopeExecution=Context.getCommandContext().getExecutionEntityManager().createChildExecution(processInstanceExecutionEntity);\n    eventScopeExecution.setActive(false);\n    eventScopeExecution.setEventScope(true);\n    eventScopeExecution.setCurrentFlowElement(subProcessExecution.getCurrentFlowElement());\n    Map<String,Object> variables=subProcessExecution.getVariablesLocal();\n    for (    Entry<String,Object> variable : variables.entrySet()) {\n      eventScopeExecution.setVariableLocal(variable.getKey(),variable.getValue());\n    }\n    for (    CompensateEventSubscriptionEntity eventSubscriptionEntity : compensateEventSubscriptions) {\n      eventSubscriptionEntityManager.delete(eventSubscriptionEntity);\n      CompensateEventSubscriptionEntity newSubscription=eventSubscriptionEntityManager.insertCompensationEvent(eventScopeExecution,eventSubscriptionEntity.getActivityId());\n      newSubscription.setConfiguration(eventSubscriptionEntity.getConfiguration());\n      newSubscription.setCreated(eventSubscriptionEntity.getCreated());\n    }\n    CompensateEventSubscriptionEntity eventSubscription=eventSubscriptionEntityManager.insertCompensationEvent(processInstanceExecutionEntity,eventScopeExecution.getCurrentFlowElement().getId());\n    eventSubscription.setConfiguration(eventScopeExecution.getId());\n  }\n}\n", "nl": "Creates a new event scope execution and moves existing event subscriptions to this new execution"}
{"code": "@deprecated public static int compare(CharSequence string,int codePoint){\n  if ((codePoint < 0) || (codePoint > 1114111)) {\n    throw new IllegalArgumentException();\n  }\n  int stringLength=string.length();\n  if (stringLength == 0) {\n    return -1;\n  }\n  char firstChar=string.charAt(0);\n  int offset=codePoint - 65536;\n  if (offset < 0) {\n    int result=firstChar - codePoint;\n    if (result != 0) {\n      return result;\n    }\n    return stringLength - 1;\n  }\n  char lead=(char)((offset >>> 10) + 55296);\n  int result=firstChar - lead;\n  if (result != 0) {\n    return result;\n  }\n  if (stringLength > 1) {\n    char trail=(char)((offset & 0x3FF) + 56320);\n    result=string.charAt(1) - trail;\n    if (result != 0) {\n      return result;\n    }\n  }\n  return stringLength - 2;\n}\n", "nl": "/*    "}
{"code": "@Override protected void analyzeInteraction(){\n  int critVal=(int)(Rnd.get(55000) / (skillLvlDiff + 1));\n  if (critVal < CraftConfig.CRAFT_CHANCE_BLUECRIT) {\n    critType=CraftCritType.BLUE;\n  }\n else   if ((critVal < CraftConfig.CRAFT_CHANCE_INSTANT) && (this.itemQuality.getQualityId() < ItemQuality.EPIC.getQualityId())) {\n    critType=CraftCritType.INSTANT;\n    currentSuccessValue=maxSuccessValue;\n    return;\n  }\n  if (CraftConfig.CRAFT_CHECKTASK) {\n    if (this.task == null) {\n      return;\n    }\n  }\n  double mod=Math.sqrt((double)skillLvlDiff / 450f) * 100f + Rnd.nextGaussian() * 10f;\n  mod-=(double)this.itemQuality.getQualityId() / 2;\n  if (mod < 0) {\n    currentFailureValue-=(int)mod;\n  }\n else {\n    currentSuccessValue+=(int)mod;\n  }\n  if (currentSuccessValue >= maxSuccessValue) {\n    currentSuccessValue=maxSuccessValue;\n  }\n else   if (currentFailureValue >= maxFailureValue) {\n    currentFailureValue=maxFailureValue;\n  }\n}\n", "nl": "Perform interaction calculation"}
{"code": "public byte[] generateMwk(byte[] desBytes){\n  if (debug) {\n    Debug.logInfo(\"DES Key : \" + StringUtil.toHexString(desBytes) + \" / \"+ desBytes.length,module);\n  }\n  SecretKeyFactory skf1=null;\n  SecretKey mwk=null;\n  try {\n    skf1=SecretKeyFactory.getInstance(\"DESede\");\n  }\n catch (  NoSuchAlgorithmException e) {\n    Debug.logError(e,module);\n  }\n  DESedeKeySpec desedeSpec2=null;\n  try {\n    desedeSpec2=new DESedeKeySpec(desBytes);\n  }\n catch (  InvalidKeyException e) {\n    Debug.logError(e,module);\n  }\n  if (skf1 != null && desedeSpec2 != null) {\n    try {\n      mwk=skf1.generateSecret(desedeSpec2);\n    }\n catch (    InvalidKeySpecException e) {\n      Debug.logError(e,module);\n    }\n  }\n  if (mwk != null) {\n    return generateMwk(mwk);\n  }\n else {\n    return null;\n  }\n}\n", "nl": "Generate a new MWK"}
{"code": "private static void createFile(String filePath,String text) throws Exception {\n  File dir=new File(filePath.substring(0,filePath.lastIndexOf(File.separator)));\n  File file=new File(filePath);\n  if (dir.exists()) {\n    dir.delete();\n  }\n  if (!dir.exists()) {\n    dir.mkdirs();\n  }\n  if (file.exists()) {\n    file.delete();\n  }\n  if (!file.exists()) {\n    file.createNewFile();\n  }\n else {\n    throw new Exception(\"file:[\" + filePath + \"] already exists and cannot delete!\");\n  }\n  FileOutputStream fileOutputStream=new FileOutputStream(file);\n  FileChannel channel=fileOutputStream.getChannel();\n  CharBuffer charBuffer=CharBuffer.allocate(text.length());\n  charBuffer.put(text);\n  charBuffer.flip();\n  Charset charset=Charset.defaultCharset();\n  ByteBuffer byteBuffer=charset.encode(charBuffer);\n  while (byteBuffer.hasRemaining()) {\n    channel.write(byteBuffer);\n  }\n  channel.close();\n  fileOutputStream.close();\n  logger.info(\"success generator file:-- \" + filePath);\n}\n", "nl": "create file here</p> try to delete dictory or file if exists"}
{"code": "public IQueryResultSet<IEntryPacket> groupBy(IQueryResultSet<IEntryPacket> entries,List<SelectColumn> groupColumns) throws SQLException {\n  IQueryResultSet<IEntryPacket> currGroup=null;\n  IEntryPacket currRow=null, prevRow=null;\n  int rc;\n  Comparator comparator=getGroupByComparator(entries,groupColumns);\n  Collections.sort((List<IEntryPacket>)entries,comparator);\n  Iterator<IEntryPacket> iter=entries.iterator();\n  ArrayList<IQueryResultSet<IEntryPacket>> groupList=new ArrayList<IQueryResultSet<IEntryPacket>>();\n  for (int i=0; i < entries.size(); i++) {\n    prevRow=currRow;\n    currRow=iter.next();\n    rc=comparator.compare(prevRow,currRow);\n    if (rc != 0) {\n      currGroup=entries.newResultSet();\n      groupList.add(currGroup);\n      currGroup.add(currRow);\n    }\n else {\n      currGroup.add(currRow);\n    }\n  }\n  IQueryResultSet<IEntryPacket> groupByResult=query.isConvertResultToArray() ? new ProjectedResultSet() : new ArrayListResult();\n  for (Iterator<IQueryResultSet<IEntryPacket>> iterator=groupList.iterator(); iterator.hasNext(); ) {\n    IQueryResultSet<IEntryPacket> group=iterator.next();\n    if (query.isConvertResultToArray())     groupByResult.add(aggregate(group));\n else     groupByResult.add(group.iterator().next());\n  }\n  return groupByResult;\n}\n", "nl": "Group the results according to the group by clause"}
{"code": "public void loadTreeSet(HMMData htsData,FeatureDefinition featureDef,PhoneTranslator trickyPhones) throws IOException, MaryConfigurationException {\n  PhoneTranslator phTranslator=trickyPhones;\n  HTSCARTReader htsReader=new HTSCARTReader();\n  if (htsData.getTreeDurStream() != null) {\n    Log.d(Mary.LOG,\"Loading duration tree...\");\n    durTree=htsReader.load(1,htsData.getTreeDurStream(),htsData.getPdfDurStream(),PdfFileFormat.dur,featureDef,phTranslator);\n    numStates=htsReader.getVectorSize();\n  }\n  if (htsData.getTreeLf0Stream() != null) {\n    Log.d(Mary.LOG,\"Loading log F0 tree...\");\n    lf0Tree=htsReader.load(numStates,htsData.getTreeLf0Stream(),htsData.getPdfLf0Stream(),PdfFileFormat.lf0,featureDef,phTranslator);\n    lf0Stream=htsReader.getVectorSize();\n  }\n  if (htsData.getTreeMgcStream() != null) {\n    Log.d(Mary.LOG,\"Loading mgc tree...\");\n    mgcTree=htsReader.load(numStates,htsData.getTreeMgcStream(),htsData.getPdfMgcStream(),PdfFileFormat.mgc,featureDef,phTranslator);\n    mcepVsize=htsReader.getVectorSize();\n  }\n  if (htsData.getTreeStrStream() != null) {\n    Log.d(Mary.LOG,\"Loading str tree...\");\n    strTree=htsReader.load(numStates,htsData.getTreeStrStream(),htsData.getPdfStrStream(),PdfFileFormat.str,featureDef,phTranslator);\n    strVsize=htsReader.getVectorSize();\n  }\n  if (htsData.getTreeMagStream() != null) {\n    Log.d(Mary.LOG,\"Loading mag tree...\");\n    magTree=htsReader.load(numStates,htsData.getTreeMagStream(),htsData.getPdfMagStream(),PdfFileFormat.mag,featureDef,phTranslator);\n    magVsize=htsReader.getVectorSize();\n  }\n}\n", "nl": "Loads all the CART trees"}
{"code": "private void updateStatus(){\n  conflicts=null;\n  if (resource == null && remoteResource == null) {\n    statusLabel.setText(\"\");\n    return;\n  }\n  if (resource != null) {\n    try {\n      LocalResourceStatus status=resource.getStatus();\n      if (!resource.isManaged()) {\n        statusLabel.setText(Policy.bind(\"SvnPropertiesView.resourceNotManaged\"));\n      }\n else       if (status.getPropStatus().equals(SVNStatusKind.MODIFIED)) {\n        statusLabel.setText(Policy.bind(\"SvnPropertiesView.somePropertiesModified\"));\n      }\n else       if (status.getPropStatus().equals(SVNStatusKind.NORMAL)) {\n        statusLabel.setText(Policy.bind(\"SvnPropertiesView.noPropertiesModified\"));\n      }\n else       if (status.getPropStatus().equals(SVNStatusKind.CONFLICTED)) {\n        statusLabel.setText(Policy.bind(\"SvnPropertiesView.conflictOnProperties\"));\n        try {\n          conflicts=PropertyConflict.getPropertyConflicts(resource);\n        }\n catch (        Exception e) {\n        }\n      }\n else {\n        statusLabel.setText(\"\");\n      }\n    }\n catch (    SVNException e) {\n      statusLabel.setText(Policy.bind(\"SvnPropertiesView.errorGettingStatus\"));\n    }\n  }\n}\n", "nl": "update the status text"}
{"code": "public static Map<String,Object> lookupRoutingTask(DispatchContext ctx,Map<String,? extends Object> context){\n  Delegator delegator=ctx.getDelegator();\n  Map<String,Object> result=FastMap.newInstance();\n  Locale locale=(Locale)context.get(\"locale\");\n  String workEffortName=(String)context.get(\"workEffortName\");\n  String fixedAssetId=(String)context.get(\"fixedAssetId\");\n  List<GenericValue> listRoutingTask=null;\n  List<EntityExpr> constraints=FastList.newInstance();\n  if (UtilValidate.isNotEmpty(workEffortName)) {\n    constraints.add(EntityCondition.makeCondition(\"workEffortName\",EntityOperator.GREATER_THAN_EQUAL_TO,workEffortName));\n  }\n  if (UtilValidate.isNotEmpty(fixedAssetId) && !\"ANY\".equals(fixedAssetId)) {\n    constraints.add(EntityCondition.makeCondition(\"fixedAssetId\",EntityOperator.EQUALS,fixedAssetId));\n  }\n  constraints.add(EntityCondition.makeCondition(\"currentStatusId\",EntityOperator.EQUALS,\"ROU_ACTIVE\"));\n  constraints.add(EntityCondition.makeCondition(\"workEffortTypeId\",EntityOperator.EQUALS,\"ROU_TASK\"));\n  try {\n    listRoutingTask=EntityQuery.use(delegator).from(\"WorkEffort\").where(constraints).orderBy(\"workEffortName\").queryList();\n  }\n catch (  GenericEntityException e) {\n    Debug.logWarning(e,module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"ManufacturingTechDataWorkEffortNotExist\",UtilMisc.toMap(\"errorString\",e.toString()),locale));\n  }\n  if (listRoutingTask == null) {\n    listRoutingTask=FastList.newInstance();\n  }\n  if (listRoutingTask.size() == 0) {\n  }\n  result.put(\"lookupResult\",listRoutingTask);\n  return result;\n}\n", "nl": "Used to retrieve some RoutingTasks (WorkEffort) selected by Name or MachineGroup ordered by Name"}
{"code": "private void performCrop(Uri picUri,int destType,Intent cameraIntent){\n  try {\n    Intent cropIntent=new Intent(\"com.android.camera.action.CROP\");\n    cropIntent.setDataAndType(picUri,\"image/*\");\n    cropIntent.putExtra(\"crop\",\"true\");\n    if (targetWidth > 0) {\n      cropIntent.putExtra(\"outputX\",targetWidth);\n    }\n    if (targetHeight > 0) {\n      cropIntent.putExtra(\"outputY\",targetHeight);\n    }\n    if (targetHeight > 0 && targetWidth > 0 && targetWidth == targetHeight) {\n      cropIntent.putExtra(\"aspectX\",1);\n      cropIntent.putExtra(\"aspectY\",1);\n    }\n    croppedUri=Uri.fromFile(createCaptureFile(this.encodingType,System.currentTimeMillis() + \"\"));\n    cropIntent.putExtra(\"output\",croppedUri);\n    if (this.cordova != null) {\n      this.cordova.startActivityForResult((CordovaPlugin)this,cropIntent,CROP_CAMERA + destType);\n    }\n  }\n catch (  ActivityNotFoundException anfe) {\n    Log.e(LOG_TAG,\"Crop operation not supported on this device\");\n    try {\n      processResultFromCamera(destType,cameraIntent);\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n      Log.e(LOG_TAG,\"Unable to write to file\");\n    }\n  }\n}\n", "nl": "Brings up the UI to perform crop on passed image URI"}
{"code": "public ResponsePacket executeOnSpace(ISpaceProxy space,Transaction txn) throws SQLException {\n  ResponsePacket response=new ResponsePacket();\n  try {\n    if (getSecurityInterceptor() != null) {\n      SpaceContext spaceContext=getSession().getConnectionContext().getSpaceContext();\n      SecurityContext securityContext=SpaceContextHelper.getSecurityContext(spaceContext);\n      getSecurityInterceptor().intercept(securityContext,SpacePrivilege.ALTER,tableName);\n    }\n    ExternalEntry template=new ExternalEntry(tableName,null,null);\n    template.setFieldsNames(_columnNames);\n    template.setFieldsTypes(_columnTypes);\n    template.setIndexIndicators(_indices);\n    template.setRoutingFieldName(_routingFieldName);\n    space.snapshot(template);\n    if (_logger.isLoggable(Level.FINE)) {\n      _logger.fine(\"Wrote a new table to space [\" + tableName + \"]\");\n    }\n    response.setIntResult(0);\n  }\n catch (  Exception e) {\n    if (_logger.isLoggable(Level.SEVERE)) {\n      _logger.log(Level.SEVERE,e.getMessage(),e);\n    }\n    SQLException se=new SQLException(\"Failed to create table [\" + tableName + \"]; Cause: \"+ e,\"GSP\",-106);\n    se.initCause(e);\n    throw se;\n  }\n  return response;\n}\n", "nl": "The main logic method, execute the query on the space by calling snapshot"}
{"code": "public static boolean loadLibraryFromTinker(Context context,String relativePath,String libname) throws UnsatisfiedLinkError {\n  final Tinker tinker=Tinker.with(context);\n  libname=libname.startsWith(\"lib\") ? libname : \"lib\" + libname;\n  libname=libname.endsWith(\".so\") ? libname : libname + \".so\";\n  String relativeLibPath=relativePath + \"/\" + libname;\n  if (tinker.isEnabledForNativeLib() && tinker.isTinkerLoaded()) {\n    TinkerLoadResult loadResult=tinker.getTinkerLoadResultIfPresent();\n    if (loadResult.libs != null) {\n      for (      String name : loadResult.libs.keySet()) {\n        if (name.equals(relativeLibPath)) {\n          String patchLibraryPath=loadResult.libraryDirectory + \"/\" + name;\n          File library=new File(patchLibraryPath);\n          if (library.exists()) {\n            boolean verifyMd5=tinker.isTinkerLoadVerify();\n            if (verifyMd5 && !SharePatchFileUtil.verifyFileMd5(library,loadResult.libs.get(name))) {\n              tinker.getLoadReporter().onLoadFileMd5Mismatch(library,ShareConstants.TYPE_LIBRARY);\n            }\n else {\n              System.load(patchLibraryPath);\n              TinkerLog.i(TAG,\"loadLibraryFromTinker success:\" + patchLibraryPath);\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n", "nl": "sample usage for native library"}
{"code": "public static Object ElementDefaultValidImmediate(XSTypeDefinition type,String value,ValidationContext context,ValidatedInfo vinfo){\n  XSSimpleType dv=null;\n  if (type.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {\n    dv=(XSSimpleType)type;\n  }\n else {\n    XSComplexTypeDecl ctype=(XSComplexTypeDecl)type;\n    if (ctype.fContentType == XSComplexTypeDefinition.CONTENTTYPE_SIMPLE) {\n      dv=ctype.fXSSimpleType;\n    }\n else     if (ctype.fContentType == XSComplexTypeDefinition.CONTENTTYPE_MIXED) {\n      if (!((XSParticleDecl)ctype.getParticle()).emptiable())       return null;\n    }\n else {\n      return null;\n    }\n  }\n  Object actualValue=null;\n  if (dv == null) {\n    dv=STRING_TYPE;\n  }\n  try {\n    actualValue=dv.validate(value,context,vinfo);\n    if (vinfo != null)     actualValue=dv.validate(vinfo.stringValue(),context,vinfo);\n  }\n catch (  InvalidDatatypeValueException ide) {\n    return null;\n  }\n  return actualValue;\n}\n", "nl": "check whether a value is a valid default for some type returns the compiled form of the value The parameter value could be either a String or a ValidatedInfo object"}
{"code": "protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  int start=0;\n  if (str.charAt(0) == '-') {\n    start=1;\n  }\n  int sign=findUTCSign(str,start,len);\n  final int length=((sign == -1) ? len : sign) - start;\n  if (length < 4) {\n    throw new RuntimeException(\"Year must have 'CCYY' format\");\n  }\n else   if (length > 4 && str.charAt(start) == '0') {\n    throw new RuntimeException(\"Leading zeros are required if the year value would otherwise have fewer than four digits; otherwise they are forbidden\");\n  }\n  if (sign == -1) {\n    date.year=parseIntYear(str,len);\n  }\n else {\n    date.year=parseIntYear(str,sign);\n    getTimeZone(str,date,sign,len);\n  }\n  date.month=MONTH;\n  date.day=1;\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != 'Z') {\n    normalize(date);\n  }\n  date.position=0;\n  return date;\n}\n", "nl": "Parses, validates and computes normalized version of gYear object"}
{"code": "private boolean mustUpdateCoordinates(){\n  boolean mustUpdate=(zScores.size() == 0);\n  if (previousTranspose != isTranspose()) {\n    mustUpdate=true;\n  }\n  if (!mustUpdate && scalingType == ChartViewer.ScalingType.ZSCORE && getChartData().getNumberOfClasses() > 0 && getChartData().getNumberOfSeries() > 0 && zScores.size() == 0) {\n    mustUpdate=true;\n  }\n  if (previousTranspose != isTranspose()) {\n    previousTranspose=isTranspose();\n    previousClusterSeries=false;\n    previousClusterClasses=false;\n  }\n  if (!mustUpdate && classNames != null) {\n    final ArrayList<String> currentClasses=new ArrayList<>(getChartData().getClassNames());\n    if (!previousClasses.equals(currentClasses)) {\n      mustUpdate=true;\n      previousClasses.clear();\n      previousClasses.addAll(currentClasses);\n    }\n  }\n  if (!mustUpdate && seriesNames != null) {\n    final ArrayList<String> currentSamples=new ArrayList<>(getChartData().getSeriesNames());\n    if (!previousSamples.equals(currentSamples)) {\n      mustUpdate=true;\n      previousSamples.clear();\n      previousSamples.addAll(currentSamples);\n    }\n  }\n  if (!mustUpdate) {\n    if (!previousClusterClasses && viewer.getClassesList().isDoClustering())     mustUpdate=true;\n  }\n  if (!mustUpdate) {\n    if (!previousClusterSeries && viewer.getSeriesList().isDoClustering())     mustUpdate=true;\n  }\n  return mustUpdate;\n}\n", "nl": "do we need to recompute coordinates?"}
{"code": "public Builder normalize(String column,Normalize type,DataAnalysis da){\n  ColumnAnalysis ca=da.getColumnAnalysis(column);\n  if (!(ca instanceof NumericalColumnAnalysis))   throw new IllegalStateException(\"Column \\\"\" + column + \"\\\" analysis is not numerical. \"+ \"Column is not numerical?\");\n  NumericalColumnAnalysis nca=(NumericalColumnAnalysis)ca;\n  double min=nca.getMinDouble();\n  double max=nca.getMaxDouble();\n  double mean=nca.getMean();\n  double sigma=nca.getSampleStdev();\nswitch (type) {\ncase MinMax:\n    return transform(new MinMaxNormalizer(column,min,max));\ncase MinMax2:\n  return transform(new MinMaxNormalizer(column,min,max,-1,1));\ncase Standardize:\nreturn transform(new StandardizeNormalizer(column,mean,sigma));\ncase SubtractMean:\nreturn transform(new SubtractMeanNormalizer(column,mean));\ncase Log2Mean:\nreturn transform(new Log2Normalizer(column,mean,min,0.5));\ncase Log2MeanExcludingMin:\nlong countMin=nca.getCountMinValue();\ndouble meanExMin;\nif (ca.getCountTotal() - countMin == 0) {\nif (ca.getCountTotal() == 0) {\nlog.warn(\"Normalizing with Log2MeanExcludingMin but 0 records present in analysis\");\n}\n else {\nlog.warn(\"Normalizing with Log2MeanExcludingMin but all records are the same value\");\n}\nmeanExMin=mean;\n}\n else {\nmeanExMin=(mean * ca.getCountTotal() - countMin * min) / (ca.getCountTotal() - countMin);\n}\nreturn transform(new Log2Normalizer(column,meanExMin,min,0.5));\ndefault :\nthrow new RuntimeException(\"Unknown/not implemented normalization type: \" + type);\n}\n}\n", "nl": "Normalize the specified column with a given type of normalization"}
{"code": "public static String mapToStr(Map<? extends Object,? extends Object> map){\n  if (map == null)   return null;\n  StringBuilder buf=new StringBuilder();\n  boolean first=true;\n  for (  Map.Entry<? extends Object,? extends Object> entry : map.entrySet()) {\n    Object key=entry.getKey();\n    Object value=entry.getValue();\n    if (!(key instanceof String) || !(value instanceof String))     continue;\n    String encodedName=null;\n    try {\n      encodedName=URLEncoder.encode((String)key,\"UTF-8\");\n    }\n catch (    UnsupportedEncodingException e) {\n      Debug.logError(e,module);\n    }\n    String encodedValue=null;\n    try {\n      encodedValue=URLEncoder.encode((String)value,\"UTF-8\");\n    }\n catch (    UnsupportedEncodingException e) {\n      Debug.logError(e,module);\n    }\n    if (first)     first=false;\n else     buf.append(\"|\");\n    buf.append(encodedName);\n    buf.append(\"=\");\n    buf.append(encodedValue);\n  }\n  return buf.toString();\n}\n", "nl": "Creates an encoded String from a Map of name/value pairs (MUST BE STRINGS!)"}
{"code": "private void processSplit(Node v,NodeArray node2taxa,int outGroupTaxonId,Split split,PhyloTree tree){\n  BitSet partB=split.getPartNotContainingTaxon(outGroupTaxonId);\n  double weight=split.getWeight();\n  boolean done=false;\n  while (!done) {\n    List edgesToPush=new LinkedList();\n    for (Edge f=v.getFirstOutEdge(); f != null; f=v.getNextOutEdge(f)) {\n      Node w=f.getTarget();\n      BitSet nodeSet=(BitSet)node2taxa.get(w);\n      if (nodeSet.intersects(partB))       edgesToPush.add(f);\n    }\n    if (edgesToPush.size() == 1) {\n      Edge f=(Edge)edgesToPush.get(0);\n      v=f.getTarget();\n    }\n else     if (edgesToPush.size() > 1) {\n      Node u=tree.newNode();\n      node2taxa.set(u,partB);\n      Edge h=tree.newEdge(v,u);\n      tree.setWeight(h,weight);\n      for (      Object anEdgesToPush1 : edgesToPush) {\n        Edge f=(Edge)anEdgesToPush1;\n        Node w=f.getTarget();\n        Edge g=tree.newEdge(u,w);\n        tree.setWeight(g,tree.getWeight(f));\n      }\n      for (      Object anEdgesToPush : edgesToPush) {\n        Edge f=(Edge)anEdgesToPush;\n        tree.deleteEdge(f);\n      }\n      done=true;\n    }\n else {\n      throw new RuntimeException(\"0 taxa in splitsToTreeRec\");\n    }\n  }\n}\n", "nl": "inserts a split into a tree"}
{"code": "public static boolean isItemRestrictedTo(Player player,Item item,byte storage){\n  StorageType type=StorageType.getStorageTypeById(storage);\nswitch (type) {\ncase REGULAR_WAREHOUSE:\n    if (!item.isStorableinWarehouse(player)) {\n      PacketSendUtility.sendPacket(player,new SM_SYSTEM_MESSAGE(1300418));\n      return true;\n    }\n  break;\ncase ACCOUNT_WAREHOUSE:\nif (!item.isStorableinAccWarehouse(player)) {\n  PacketSendUtility.sendPacket(player,new SM_SYSTEM_MESSAGE(1400356));\n  return true;\n}\nbreak;\ncase LEGION_WAREHOUSE:\nif (!item.isStorableinLegWarehouse(player) || !LegionConfig.LEGION_WAREHOUSE) {\nPacketSendUtility.sendPacket(player,new SM_SYSTEM_MESSAGE(1400355));\nreturn true;\n}\n else if (!player.isLegionMember() || !LegionService.getInstance().getLegionMember(player.getObjectId()).hasRights(LegionPermissionsMask.WH_DEPOSIT)) {\nPacketSendUtility.sendPacket(player,new SM_SYSTEM_MESSAGE(1300322));\nreturn true;\n}\nbreak;\ndefault :\nbreak;\n}\nreturn false;\n}\n", "nl": "Check if item can be moved to storage by player"}
{"code": "protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  date.year=YEAR;\n  date.day=DAY;\n  if (str.charAt(0) != '-' || str.charAt(1) != '-') {\n    throw new SchemaDateTimeException(\"Invalid format for gMonth: \" + str);\n  }\n  int stop=4;\n  date.month=parseInt(str,2,stop);\n  if (str.length() >= stop + 2 && str.charAt(stop) == '-' && str.charAt(stop + 1) == '-') {\n    stop+=2;\n  }\n  if (stop < len) {\n    if (!isNextCharUTCSign(str,stop,len)) {\n      throw new SchemaDateTimeException(\"Error in month parsing: \" + str);\n    }\n else {\n      getTimeZone(str,date,stop,len);\n    }\n  }\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != 'Z') {\n    normalize(date);\n  }\n  date.position=1;\n  return date;\n}\n", "nl": "Parses, validates and computes normalized version of gMonth object"}
{"code": "public static Pair<Double,Double> computeCGContentAndCoverage(Alignment alignment,ProgressListener progressListener) throws CanceledException {\n  if (progressListener != null) {\n    progressListener.setTasks(\"Computing CG content and coverage\",\"\");\n    progressListener.setMaximum(alignment.getNumberOfSequences());\n    progressListener.setProgress(0);\n  }\n  int cgCount=0;\n  int atCount=0;\n  int otherLetterCount=0;\n  int firstCol=Integer.MAX_VALUE;\n  int lastCol=0;\n  for (int row=0; row < alignment.getNumberOfSequences(); row++) {\n    Lane lane=alignment.getLane(row);\n    firstCol=Math.min(firstCol,lane.getFirstNonGapPosition());\n    lastCol=Math.max(lastCol,lane.getLastNonGapPosition());\n    String block=lane.getBlock();\n    for (int i=0; i < block.length(); i++) {\n      int ch=Character.toUpperCase(block.charAt(i));\n      if (ch == 'C' || ch == 'G') {\n        cgCount++;\n      }\n else       if (ch == 'A' || ch == 'T' || ch == 'U') {\n        atCount++;\n      }\n else       if (Character.isLetter(ch))       otherLetterCount++;\n    }\n    if (progressListener != null)     progressListener.incrementProgress();\n  }\n  double totalCount=cgCount + atCount + otherLetterCount;\n  double cgContent=100 * (totalCount > 0 ? (double)cgCount / totalCount : 0);\n  double totalLength=lastCol - firstCol + 1;\n  double coverage=(firstCol <= lastCol ? totalCount / totalLength : 0);\n  return new Pair<>(cgContent,coverage);\n}\n", "nl": "computes the CG content and coverage"}
{"code": "@SuppressWarnings(\"rawtypes\") public static <T>T fromObject(Object json,Class<T> t){\n  if (json instanceof String) {\n    Gson g=new Gson();\n    return g.fromJson((String)json,t);\n  }\n else   if (json instanceof Reader) {\n    Gson g=new Gson();\n    return g.fromJson((Reader)json,t);\n  }\n else   if (json instanceof byte[]) {\n    Gson g=new Gson();\n    byte[] b1=(byte[])json;\n    return g.fromJson(new String(b1),t);\n  }\n else   if (json instanceof Map) {\n    try {\n      Map m=(Map)json;\n      T t1=t.newInstance();\n      Field[] fs=t.getDeclaredFields();\n      for (      Field f : fs) {\n        String name=f.getName();\n        if (m.containsKey(name)) {\n          f.setAccessible(true);\n          f.set(t1,m.get(name));\n        }\n      }\n      return t1;\n    }\n catch (    Exception e) {\n      log.error(json,e);\n    }\n  }\n  return null;\n}\n", "nl": "parse the json object to Class object"}
{"code": "private void extractElementNode(Element eElement,DataSchema schema) throws PIRException {\n  String name=eElement.getElementsByTagName(\"name\").item(0).getTextContent().trim();\n  String type=eElement.getElementsByTagName(\"type\").item(0).getTextContent().trim();\n  schema.getTypeMap().put(name,type);\n  Node isArrayNode=eElement.getElementsByTagName(\"isArray\").item(0);\n  if (isArrayNode != null) {\n    String isArrayValue=isArrayNode.getTextContent().trim().toLowerCase();\n    String isArray=isArrayValue.isEmpty() ? \"true\" : isArrayValue;\n    if (isArray.equals(\"true\")) {\n      schema.getArrayElements().add(name);\n    }\n  }\n  String partitionerTypeName=PrimitiveTypePartitioner.class.getName();\n  boolean isPrimitivePartitioner=true;\n  if (eElement.getElementsByTagName(\"partitioner\").item(0) != null) {\n    partitionerTypeName=eElement.getElementsByTagName(\"partitioner\").item(0).getTextContent().trim();\n    isPrimitivePartitioner=partitionerTypeName.equals(PrimitiveTypePartitioner.class.getName());\n  }\n  DataPartitioner partitioner;\n  if (isPrimitivePartitioner) {\n    validateIsPrimitiveType(type);\n    partitioner=new PrimitiveTypePartitioner();\n  }\n else {\n    partitioner=instantiatePartitioner(partitionerTypeName);\n  }\n  schema.getPartitionerTypeMap().put(name,partitionerTypeName);\n  schema.getPartitionerInstances().put(partitionerTypeName,partitioner);\n  logger.info(\"name = \" + name + \" javaType = \"+ type+ \" isArray = \"+ schema.getArrayElements().contains(name)+ \" partitioner \"+ partitionerTypeName);\n}\n", "nl": "Extracts a data schema element node's contents"}
{"code": "public void destroy(){\n  if (group.isDestroyed())   return;\n  int activeCount=group.activeCount();\n  Thread[] activeThreads=new Thread[activeCount];\n  int numThreads=group.enumerate(activeThreads);\n  for (int i=0; i < numThreads; i++) {\n    try {\n      if (activeThreads[i] instanceof PoolableThread)       ((PoolableThread)activeThreads[i]).cleanStop();\n      activeThreads[i].interrupt();\n    }\n catch (    Exception ex) {\n      logger.log(Level.WARNING,\"Failed to stop active thread \" + activeThreads[i].getId(),ex);\n      ex.printStackTrace();\n    }\n    remove(activeThreads[i]);\n  }\n  group.interrupt();\n  destroyChildGroup(group);\n  for (int i=0; group.activeCount() > 0 && i < 10; i++) {\n    try {\n      Thread.sleep(10);\n    }\n catch (    InterruptedException e) {\n      logger.log(Level.WARNING,\"Interrupted while destroying latent Threads\",e);\n    }\n  }\n  try {\n    if (!group.isDestroyed())     group.destroy();\n  }\n catch (  IllegalThreadStateException e) {\n    if (!group.isDestroyed()) {\n      logger.log(Level.WARNING,\"IllegalThreadState destroying ThreadGroup\",e);\n    }\n  }\n}\n", "nl": "destroy all the threads spawned by this pool"}
{"code": "public int addEntry(ConsoleEntry entry){\n  int entryType=entry.type;\n  if (entryType == LOG) {\n    ++logCount;\n  }\n else   if (entryType == WARNING) {\n    ++warningCount;\n  }\n else   if (isErrorType(entryType)) {\n    ++errorCount;\n  }\n  entries.addObject(entry);\n  if (isFiltering()) {\n    if (filterEntry(entry)) {\n      if (collapsed) {\n        ConsoleCollapsedEntry collapsedEntry=entryLookup.addEntry(entry);\n        if (collapsedEntry.index < filteredEntries.trimmedCount()) {\n          collapsedEntry.index=filteredEntries.totalCount();\n          filteredEntries.addObject(collapsedEntry);\n        }\n        return collapsedEntry.index - filteredEntries.trimmedCount();\n      }\n      filteredEntries.addObject(entry);\n      return filteredEntries.totalCount() - 1;\n    }\n    return -1;\n  }\n  return entries.totalCount() - 1;\n}\n", "nl": "Adds a new entry object"}
{"code": "public static void fillAutoSaveList(ShoppingCart cart,LocalDispatcher dispatcher) throws GeneralException {\n  if (cart != null && dispatcher != null) {\n    GenericValue userLogin=ShoppingListEvents.getCartUserLogin(cart);\n    Delegator delegator=cart.getDelegator();\n    String autoSaveListId=cart.getAutoSaveListId();\n    if (autoSaveListId == null) {\n      autoSaveListId=getAutoSaveListId(delegator,dispatcher,null,userLogin,cart.getProductStoreId());\n      cart.setAutoSaveListId(autoSaveListId);\n    }\n    GenericValue shoppingList=EntityQuery.use(delegator).from(\"ShoppingList\").where(\"shoppingListId\",autoSaveListId).queryOne();\n    Integer currentListSize=0;\n    if (UtilValidate.isNotEmpty(shoppingList)) {\n      List<GenericValue> shoppingListItems=shoppingList.getRelated(\"ShoppingListItem\",null,null,false);\n      if (UtilValidate.isNotEmpty(shoppingListItems)) {\n        currentListSize=shoppingListItems.size();\n      }\n    }\n    try {\n      String[] itemsArray=makeCartItemsArray(cart);\n      if (itemsArray != null && itemsArray.length != 0) {\n        addBulkFromCart(delegator,dispatcher,cart,userLogin,autoSaveListId,null,itemsArray,false,false);\n      }\n else       if (itemsArray.length == 0 && currentListSize != 0) {\n        clearListInfo(delegator,autoSaveListId);\n      }\n    }\n catch (    IllegalArgumentException e) {\n      throw new GeneralException(e.getMessage(),e);\n    }\n  }\n}\n", "nl": "Fills the specialized shopping list with the current shopping cart if one exists (if not leaves it alone)"}
{"code": "@Override public List<Writable> next(){\n  Text t=(Text)super.next().iterator().next();\n  String val=new String(t.getBytes());\n  List<Writable> ret=new ArrayList<>();\n  StringTokenizer tok;\n  int index, max;\n  String col;\n  double value;\n  try {\n    max=0;\n    tok=new StringTokenizer(val,\" \\t\");\n    tok.nextToken();\n    while (tok.hasMoreTokens()) {\n      col=tok.nextToken();\n      if (col.startsWith(\"#\"))       break;\n      if (col.startsWith(\"qid:\"))       continue;\n      index=Integer.parseInt(col.substring(0,col.indexOf(\":\")));\n      if (index > max)       max=index;\n    }\n    tok=new StringTokenizer(val,\" \\t\");\n    double classVal=Double.parseDouble(tok.nextToken());\n    while (tok.hasMoreTokens()) {\n      col=tok.nextToken();\n      if (col.startsWith(\"#\"))       break;\n      if (col.startsWith(\"qid:\"))       continue;\n      index=Integer.parseInt(col.substring(0,col.indexOf(\":\")));\n      value=Double.parseDouble(col.substring(col.indexOf(\":\") + 1));\n      ret.add(new DoubleWritable(value));\n    }\n    ret.add(new DoubleWritable(classVal));\n  }\n catch (  Exception e) {\n    log.error(\"Error parsing line '\" + val + \"': \",e);\n  }\n  return ret;\n}\n", "nl": "next() method for getting another K/V pair off disk from the SVMLight text file"}
{"code": "public void addSample(String sample,int sampleSize,BlastMode mode,int srcId,Map<String,Map<Integer,Integer[]>> sourceClassification2class2counts){\n  if (!Arrays.asList(this.getSampleNames()).contains(sample)) {\n    this.sampleSizes.add(sampleSize);\n    this.sampleNames.add(sample);\n    this.sampleUIds.add(System.currentTimeMillis());\n    this.blastModes.add(mode);\n    int tarId=Basic.getIndex(sample,this.sampleNames);\n    for (    String classification : sourceClassification2class2counts.keySet()) {\n      Map<Integer,Integer[]> sourceClass2counts=sourceClassification2class2counts.get(classification);\n      Map<Integer,Integer[]> targetClass2counts=this.classification2class2counts.get(classification);\n      if (targetClass2counts == null) {\n        targetClass2counts=new HashMap<>();\n        this.classification2class2counts.put(classification,targetClass2counts);\n      }\n      for (      Integer classId : sourceClass2counts.keySet()) {\n        Integer[] sourceCounts=sourceClass2counts.get(classId);\n        if (sourceCounts != null && srcId < sourceCounts.length && sourceCounts[srcId] != null) {\n          Integer[] targetCounts=targetClass2counts.get(classId);\n          Integer[] newCounts=new Integer[tarId + 1];\n          if (targetCounts != null) {\n            System.arraycopy(targetCounts,0,newCounts,0,targetCounts.length);\n          }\n          newCounts[tarId]=sourceCounts[srcId];\n          targetClass2counts.put(classId,newCounts);\n        }\n      }\n    }\n    if (this.totalReads >= 0)     this.totalReads+=sampleSize;\n else     this.totalReads=sampleSize;\n  }\n}\n", "nl": "add the named sample"}
{"code": "@Override public void updateClassifications(String[] cNames,List<UpdateItem> updateItemList,ProgressListener progressListener) throws IOException, CanceledException {\n  final UpdateItemList updateItems=(UpdateItemList)updateItemList;\n  long maxProgress=0;\n  for (int i=0; i < cNames.length; i++) {\n    maxProgress+=updateItems.getClassIds(i).size();\n  }\n  progressListener.setMaximum(maxProgress);\n  final Map<Integer,ListOfLongs>[] fName2ClassId2Location=new HashMap[cNames.length];\n  final Map<Integer,Integer>[] fName2ClassId2Weight=new HashMap[cNames.length];\n  for (int i=0; i < cNames.length; i++) {\n    fName2ClassId2Location[i]=new HashMap<>(10000);\n    fName2ClassId2Weight[i]=new HashMap<>(10000);\n  }\n  for (int i=0; i < cNames.length; i++) {\n    final Map<Integer,ListOfLongs> classId2Location=fName2ClassId2Location[i];\n    final Map<Integer,Integer> classId2weight=fName2ClassId2Weight[i];\n    for (    Integer classId : updateItems.getClassIds(i)) {\n      int weightedSize=updateItems.getSize(i,classId);\n      final ListOfLongs positions=new ListOfLongs();\n      classId2Location.put(classId,positions);\n      classId2weight.put(classId,weightedSize);\n      if (weightedSize > 0) {\n        for (UpdateItem item=updateItems.getFirst(i,classId); item != null; item=updateItems.getUpdateItem(item.getNextInClassification(i))) {\n          positions.add(item.getReadUId());\n        }\n      }\n      progressListener.incrementProgress();\n    }\n  }\n  ModifyClassificationsDAA.saveClassifications(daaHeader,cNames,fName2ClassId2Location,fName2ClassId2Weight);\n}\n", "nl": "rescan classifications after running the data processor"}
{"code": "private String fetchComment(SVNStatusSyncInfo info){\n  String fetchedComment=Policy.bind(\"SynchronizeView.standardIncomingChangeSetComment\");\n  IResourceVariant remoteResource=info.getRemote();\n  if (remoteResource instanceof ISVNRemoteResource) {\n    ISVNRemoteResource svnRemoteResource=(ISVNRemoteResource)remoteResource;\n    ISVNClientAdapter client=null;\n    try {\n      client=svnRemoteResource.getRepository().getSVNClient();\n      SVNUrl url=svnRemoteResource.getRepository().getRepositoryRoot();\n      SVNRevision rev=svnRemoteResource.getLastChangedRevision();\n      ISVNLogMessage[] logMessages=client.getLogMessages(url,rev,rev,false);\n      if (logMessages.length != 0) {\n        String logComment=logMessages[0].getMessage();\n        if (logComment.trim().length() != 0) {\n          fetchedComment=flattenComment(logComment);\n        }\n else {\n          fetchedComment=\"\";\n        }\n      }\n    }\n catch (    SVNException e1) {\n      if (!e1.operationInterrupted()) {\n        SVNUIPlugin.log(e1);\n      }\n    }\ncatch (    SVNClientException e) {\n      SVNUIPlugin.log(SVNException.wrapException(e));\n    }\n finally {\n      svnRemoteResource.getRepository().returnSVNClient(client);\n    }\n  }\n  return fetchedComment;\n}\n", "nl": "Fetch the comment of the given SyncInfo"}
{"code": "private void loadAudioFile(String file) throws IllegalArgumentException, SecurityException, IllegalStateException, IOException {\n  if (this.isStreaming(file)) {\n    this.player.setDataSource(file);\n    this.player.setAudioStreamType(AudioManager.STREAM_MUSIC);\n    this.setMode(MODE.PLAY);\n    this.setState(STATE.MEDIA_STARTING);\n    this.player.setOnPreparedListener(this);\n    this.player.prepareAsync();\n  }\n else {\n    if (file.startsWith(\"/android_asset/\")) {\n      String f=file.substring(15);\n      android.content.res.AssetFileDescriptor fd=this.handler.cordova.getActivity().getAssets().openFd(f);\n      this.player.setDataSource(fd.getFileDescriptor(),fd.getStartOffset(),fd.getLength());\n    }\n else {\n      File fp=new File(file);\n      if (fp.exists()) {\n        FileInputStream fileInputStream=new FileInputStream(file);\n        this.player.setDataSource(fileInputStream.getFD());\n        fileInputStream.close();\n      }\n else {\n        this.player.setDataSource(Environment.getExternalStorageDirectory().getPath() + \"/\" + file);\n      }\n    }\n    this.setState(STATE.MEDIA_STARTING);\n    this.player.setOnPreparedListener(this);\n    this.player.prepare();\n    this.duration=getDurationInSeconds();\n  }\n}\n", "nl": "load audio file"}
{"code": "public EigenvalueDecomposition(Matrix Arg){\n  double[][] A=Arg.getArray();\n  n=Arg.getColumnDimension();\n  V=new double[n][n];\n  d=new double[n];\n  e=new double[n];\n  issymmetric=true;\n  for (int j=0; (j < n) & issymmetric; j++) {\n    for (int i=0; (i < n) & issymmetric; i++) {\n      issymmetric=(A[i][j] == A[j][i]);\n    }\n  }\n  if (issymmetric) {\n    for (int i=0; i < n; i++) {\n      for (int j=0; j < n; j++) {\n        V[i][j]=A[i][j];\n      }\n    }\n    tred2();\n    tql2();\n  }\n else {\n    H=new double[n][n];\n    ort=new double[n];\n    for (int j=0; j < n; j++) {\n      for (int i=0; i < n; i++) {\n        H[i][j]=A[i][j];\n      }\n    }\n    orthes();\n    hqr2();\n  }\n}\n", "nl": "Check for symmetry, then construct the eigenvalue decomposition"}
{"code": "public void addResource(RType rType,IdType idType,String name,String idValue){\n  Set<RDotTxtEntry> resourceSet=null;\n  if (this.rTypeResourceMap.containsKey(rType)) {\n    resourceSet=this.rTypeResourceMap.get(rType);\n  }\n else {\n    resourceSet=new HashSet<RDotTxtEntry>();\n    this.rTypeResourceMap.put(rType,resourceSet);\n  }\n  RDotTxtEntry rDotTxtEntry=new RDotTxtEntry(idType,rType,name,idValue);\n  boolean increaseResource=false;\n  if (!resourceSet.contains(rDotTxtEntry)) {\n    if (this.originalResourceMap.containsKey(rDotTxtEntry)) {\n      this.rTypeEnumeratorMap.get(rType).previous();\n      rDotTxtEntry=this.originalResourceMap.get(rDotTxtEntry);\n    }\n else {\n      increaseResource=true;\n    }\n    resourceSet.add(rDotTxtEntry);\n  }\n  Set<RDotTxtEntry> increaseResourceSet=null;\n  if (this.rTypeIncreaseResourceMap.containsKey(rType)) {\n    increaseResourceSet=this.rTypeIncreaseResourceMap.get(rType);\n  }\n else {\n    increaseResourceSet=new HashSet<RDotTxtEntry>();\n    this.rTypeIncreaseResourceMap.put(rType,increaseResourceSet);\n  }\n  if (increaseResource) {\n    increaseResourceSet.add(rDotTxtEntry);\n  }\n}\n", "nl": "add resource"}
{"code": "@Override public void flush(Map<TopicPartition,OffsetAndMetadata> offsets) throws ConnectException {\n  fLog.trace(\"Flush start at \" + System.currentTimeMillis());\n  try {\n    if (iDelivery > FASTEST)     iWriter.flush();\n    if (iDelivery == SYNCHRONIZED) {\n      int size=offsets.size();\n      String[] topicArray=new String[size];\n      Integer[] partitionArray=new Integer[size];\n      Long[] offsetArray=new Long[size];\n      Iterator<Map.Entry<TopicPartition,OffsetAndMetadata>> iterator=offsets.entrySet().iterator();\n      for (int i=0; i < size; ++i) {\n        Entry<TopicPartition,OffsetAndMetadata> entry=iterator.next();\n        TopicPartition key=entry.getKey();\n        OffsetAndMetadata value=entry.getValue();\n        topicArray[i]=key.topic();\n        partitionArray[i]=key.partition();\n        offsetArray[i]=value.offset();\n      }\n      iFlushStatement.setArray(1,iConnection.createArrayOf(\"varchar\",topicArray));\n      iFlushStatement.setArray(2,iConnection.createArrayOf(\"integer\",partitionArray));\n      iFlushStatement.setArray(3,iConnection.createArrayOf(\"bigint\",offsetArray));\n      iFlushStatement.executeQuery();\n    }\n  }\n catch (  SQLException|IOException exception) {\n    throw new ConnectException(exception);\n  }\n  fLog.trace(\"Flush stop at \" + System.currentTimeMillis());\n}\n", "nl": "Flushes content to the database"}
{"code": "static void turnAI(){\n  boolean withoutAI=true;\n  for (int y=0; y < field_size; y++) {\n    for (int x=0; x < field_size; x++) {\n      if (isCellBusy(x,y,dotHuman) && withoutAI) {\n        for (int y1=y - 1; y1 < y + field_size; y1++) {\n          for (int x1=x - 1; x1 < x + field_size; x1++) {\n            if (!((y == y1) && (x == x1))) {\n              if (isCellBusy(x1,y1,dotHuman)) {\n                if (isCellBusy(x * 2 - x1,y * 2 - y1,dotEmpty)) {\n                  field[x * 2 - x1][y * 2 - y1]=dotAI;\n                  withoutAI=false;\n                }\n                if (isCellBusy(x1 * 2 - x,y1 * 2 - y,dotEmpty)) {\n                  field[x1 * 2 - x][y1 * 2 - y]=dotAI;\n                  withoutAI=false;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int x, y;\n  if (withoutAI) {\n    do {\n      x=rand.nextInt(field_size);\n      y=rand.nextInt(field_size);\n    }\n while (!isCellBusy(x,y,dotEmpty));\n    field[x][y]=dotAI;\n  }\n}\n", "nl": "Player Turn - Computer"}
{"code": "private void adjustViewsUpOrDown(){\n  final int childCount=getChildCount();\n  int delta;\n  if (childCount > 0) {\n    if (!mStackFromBottom) {\n      final int firstTop=getScrollChildTop();\n      delta=firstTop - mListPadding.top;\n      if (mFirstPosition != 0) {\n        delta-=mDividerHeight;\n      }\n      if (delta < 0) {\n        delta=0;\n      }\n    }\n else {\n      final int lastBottom=getScrollChildBottom();\n      delta=lastBottom - (getHeight() - mListPadding.bottom);\n      if (mFirstPosition + childCount < mItemCount) {\n        delta+=mDividerHeight;\n      }\n      if (delta > 0) {\n        delta=0;\n      }\n    }\n    if (delta != 0) {\n      tryOffsetChildrenTopAndBottom(-delta);\n    }\n  }\n}\n", "nl": "Make sure views are touching the top or bottom edge, as appropriate for our gravity"}
{"code": "public MithraTransaction startOrContinueTransaction(TransactionStyle style) throws MithraTransactionException {\n  MithraTransaction result;\n  MithraTransaction parent=this.getCurrentTransaction();\n  if (parent != null) {\n    result=new MithraNestedTransaction(parent);\n  }\n else {\n    Transaction jtaTx;\n    try {\n      if (this.getJtaTransactionManager().getStatus() != Status.STATUS_ACTIVE) {\n        this.getJtaTransactionManager().setTransactionTimeout(style.getTimeout());\n        this.getJtaTransactionManager().begin();\n      }\n      jtaTx=this.getJtaTransactionManager().getTransaction();\n      result=this.createMithraRootTransaction(jtaTx,style.getTimeout() * 1000);\n    }\n catch (    NotSupportedException e) {\n      throw new MithraTransactionException(\"JTA exception\",e);\n    }\ncatch (    SystemException e) {\n      throw new MithraTransactionException(\"JTA exception\",e);\n    }\ncatch (    RollbackException e) {\n      throw new MithraTransactionException(\"JTA exception\",e);\n    }\n  }\n  this.setThreadTransaction(result);\n  return result;\n}\n", "nl": "Behaves like startOrContinueTransaction(), but with a custom transaction style"}
{"code": "public boolean unhideIsApplicable(){\n  try {\n    if (getSelectedColumns().size() == 1 && getSelectedAttributes().size() == 0) {\n      int which=0;\n      if (which < dataGrid.getAttributesOrder().size()) {\n        String next=dataGrid.getAttributesOrder().get(which);\n        if (samplesViewer.getSampleAttributeTable().isHiddenAttribute(next))         return true;\n      }\n      return false;\n    }\n    for (    String attribute : getSelectedAttributes()) {\n      int which=dataGrid.getAttributesOrder().indexOf(attribute) - 1;\n      if (which >= 0) {\n        String next=dataGrid.getAttributesOrder().get(which);\n        if (samplesViewer.getSampleAttributeTable().isHiddenAttribute(next)) {\n          return true;\n        }\n      }\n      which=dataGrid.getAttributesOrder().indexOf(attribute) + 1;\n      if (which > 0 && which < dataGrid.getAttributesOrder().size()) {\n        String next=dataGrid.getAttributesOrder().get(which);\n        if (samplesViewer.getSampleAttributeTable().isHiddenAttribute(next)) {\n          return true;\n        }\n      }\n    }\n  }\n catch (  Exception ex) {\n    if (Platform.isFxApplicationThread())     Basic.caught(ex);\n  }\n  return false;\n}\n", "nl": "is unhide applicable to current selection?"}
{"code": "public static double[][] computeProfiles(Document doc,ViewerBase graphView){\n  final int totalSamples=doc.getNumberOfSamples();\n  int totalClasses=0;\n  for (Node v=graphView.getGraph().getFirstNode(); v != null; v=v.getNext()) {\n    if (graphView.getSelected(v)) {\n      totalClasses++;\n    }\n  }\n  double[][] profiles=new double[totalSamples][totalClasses];\n  int classCount=0;\n  for (Node v=graphView.getGraph().getFirstNode(); v != null; v=v.getNext()) {\n    if (graphView.getSelected(v)) {\n      int[] counts=(v.getOutDegree() == 0 ? graphView.getNodeData(v).getSummarized() : graphView.getNodeData(v).getAssigned());\n      for (int sampleCount=0; sampleCount < totalSamples; sampleCount++) {\n        profiles[sampleCount][classCount]=counts[sampleCount];\n      }\n      classCount++;\n    }\n  }\n  for (  double[] profile : profiles) {\n    double sum=0;\n    for (    double value : profile)     sum+=value;\n    if (sum > 0) {\n      for (int i=0; i < profile.length; i++) {\n        profile[i]/=sum;\n      }\n    }\n  }\n  return profiles;\n}\n", "nl": "compute profiles for  analysis"}
{"code": "private void drawYAxisTicksLog(Graphics2D gc){\n  gc.setFont(getFont(ChartViewer.FontKeys.YAxisFont.toString()));\n  int x0=leftMargin;\n  int y0=getHeight() - bottomMargin;\n  int y1=topMargin;\n  double maxValue=getChartData().getRangeY().get2().doubleValue();\n  double botY=0;\n  double topY=computeMaxYAxisValueLogScale(maxValue);\n  double yFactor;\n  if (topY > botY)   yFactor=(y0 - y1) / (topY - botY);\n else   yFactor=1;\n  double value=0;\n  double previousY=-100000;\n  int mantisse=0;\n  int exponent=0;\n  while (value <= maxValue) {\n    if (maxDisplayedYValue != null && value > maxDisplayedYValue)     break;\n    double yPos=y0 - (value > 0 ? Math.log10(value) : 0) * yFactor;\n    if ((mantisse <= 1 || mantisse == 5) && Math.abs(yPos - previousY) >= 20) {\n      String label=\"\" + (long)value;\n      Dimension labelSize=Basic.getStringSize(gc,label,gc.getFont()).getSize();\n      previousY=yPos;\n      int x=leftMargin - (int)(labelSize.getWidth() + 3);\n      int y=(int)(yPos + labelSize.getHeight() / 2.0);\n      gc.drawString(label,x,y);\n      gc.drawLine(x0,(int)Math.round(yPos),x0 + 2,(int)Math.round(yPos));\n    }\n    if (mantisse < 9)     mantisse++;\n else {\n      mantisse=1;\n      exponent++;\n    }\n    value=mantisse * Math.pow(10,exponent);\n  }\n}\n", "nl": "draw the ticks along the Y axis"}
{"code": "public void parseBuffer(ByteInputBuffer buffer){\n  int query_len=buffer.readIntLittleEndian();\n  queryName=buffer.readBytesNullTerminated();\n  int flags=buffer.readCharBigEndian();\n  boolean hasN=((flags & 1) == 1);\nswitch (daaParser.getHeader().getAlignMode()) {\ncase blastp:\n{\n      byte[] packed=PackedSequence.readPackedSequence(buffer,query_len,5);\n      sourceSequence=context[0]=PackedSequence.getUnpackedSequence(packed,query_len,5);\n      break;\n    }\ncase blastx:\n{\n    byte[] packed=PackedSequence.readPackedSequence(buffer,query_len,hasN ? 3 : 2);\n    sourceSequence=PackedSequence.getUnpackedSequence(packed,query_len,hasN ? 3 : 2);\n    byte[][] sixFrameTranslation=Translator.getSixFrameTranslations(sourceSequence);\n    System.arraycopy(sixFrameTranslation,0,context,0,sixFrameTranslation.length);\n    break;\n  }\ncase blastn:\n{\n  byte[] packed=PackedSequence.readPackedSequence(buffer,query_len,hasN ? 3 : 2);\n  sourceSequence=PackedSequence.getUnpackedSequence(packed,query_len,hasN ? 3 : 2);\n  context[0]=sourceSequence;\n  context[1]=Translator.getReverseComplement(sourceSequence);\n  break;\n}\ndefault :\n}\n}\n", "nl": "parses a buffer"}
{"code": "private void reduceInstructions(){\n  for (int i=0; i < this.insns.size() - 1; i++) {\n    Insn curInsn=this.insns.get(i);\n    if (curInsn instanceof AddressInsn)     continue;\n    if (!curInsn.getOpcode().name.startsWith(\"move/\"))     continue;\n    Insn nextInsn=null;\n    int nextIndex=-1;\n    for (int j=i + 1; j < this.insns.size(); j++) {\n      Insn candidate=this.insns.get(j);\n      if (candidate instanceof AddressInsn)       continue;\n      nextInsn=candidate;\n      nextIndex=j;\n      break;\n    }\n    if (nextInsn == null || !nextInsn.getOpcode().name.startsWith(\"move/\"))     continue;\n    if (nextIndex == this.insns.size() - 1)     continue;\n    Register firstTarget=curInsn.getRegs().get(0);\n    Register firstSource=curInsn.getRegs().get(1);\n    Register secondTarget=nextInsn.getRegs().get(0);\n    Register secondSource=nextInsn.getRegs().get(1);\n    if (firstTarget.equals(secondSource) && secondTarget.equals(firstSource)) {\n      Stmt origStmt=insnStmtMap.get(nextInsn);\n      if (origStmt == null || !isJumpTarget(origStmt)) {\n        Insn nextStmt=this.insns.get(nextIndex + 1);\n        insns.remove(nextIndex);\n        if (origStmt != null) {\n          insnStmtMap.remove(nextInsn);\n          insnStmtMap.put(nextStmt,origStmt);\n        }\n      }\n    }\n  }\n}\n", "nl": "Reduces the instruction list by removing unnecessary instruction pairs such as move v0 v1; move v1 v0;"}
{"code": "public static void destroyInstance(WorldMapInstance instance){\n  if (instance.getEmptyInstanceTask() != null) {\n    instance.getEmptyInstanceTask().cancel(false);\n  }\n  int worldId=instance.getMapId();\n  WorldMap map=World.getInstance().getWorldMap(worldId);\n  if (!map.isInstanceType()) {\n    return;\n  }\n  int instanceId=instance.getInstanceId();\n  map.removeWorldMapInstance(instanceId);\n  log.info(\"Destroying instance:\" + worldId + \" \"+ instanceId);\n  Iterator<VisibleObject> it=instance.objectIterator();\n  while (it.hasNext()) {\n    VisibleObject obj=it.next();\n    if (obj instanceof Player) {\n      Player player=(Player)obj;\n      PacketSendUtility.sendPacket(player,new SM_SYSTEM_MESSAGE(SystemMessageId.LEAVE_INSTANCE_NOT_PARTY));\n      moveToExitPoint((Player)obj);\n    }\n else {\n      obj.getController().onDelete();\n    }\n  }\n  instance.getInstanceHandler().onInstanceDestroy();\n  if (instance instanceof WorldMap2DInstance) {\n    WorldMap2DInstance w2d=(WorldMap2DInstance)instance;\n    if (w2d.isPersonal()) {\n      HousingService.getInstance().onInstanceDestroy(w2d.getOwnerId());\n    }\n  }\n  WalkerFormator.onInstanceDestroy(worldId,instanceId);\n}\n", "nl": "Instance will be destroyed All players moved to bind location All objects - deleted"}
{"code": "public static String createEvent(String json,String index,TaskListener listener){\n  String protocol=Systems.getEnvVarOrSystemProperty(\"PIPELINE_ELASTICSEARCH_PROTOCOL\",\"http\");\n  String server=Systems.getEnvVarOrSystemProperty(\"PIPELINE_ELASTICSEARCH_HOST\",\"elasticsearch\");\n  String port=Systems.getEnvVarOrSystemProperty(\"ELASTICSEARCH_SERVICE_PORT\",\"9200\");\n  if (!isUrlReachable(protocol + \"://\" + server+ \":\"+ port)) {\n    return null;\n  }\n else {\n    listener.getLogger().println(\"Found Elasticsearch server, sending:\" + json);\n  }\n  try {\n    RestAssured.baseURI=protocol + \"://\" + server+ \":\"+ port+ \"/\"+ index+ \"/custom\";\n    Response r=given().contentType(\"application/json\").body(json).when().post(\"\");\n    ResponseBody body=r.getBody();\n    if (body != null) {\n      JsonPath path=body.jsonPath();\n      if (path != null) {\n        Boolean created=path.get(\"created\");\n        if (created != null && created == true) {\n          listener.getLogger().println(\"Event created\");\n          return path.get(\"_id\");\n        }\n else         if (path.get(\"error\") != null) {\n          listener.error(\"Elasticsearch response: \" + path.get(\"error.reason\"));\n        }\n      }\n    }\n    return null;\n  }\n catch (  Exception e) {\n    e.printStackTrace(listener.getLogger());\n    listener.error(\"Failed to send event: \" + json);\n    return null;\n  }\n}\n", "nl": "Attempts to send an event to elasticsearch for the `pipeline` index"}
{"code": "public void transformContainerToContainer(WidgetContainer oldContainer,ConstraintWidgetContainer newContainer){\n  WidgetContainer parent=(WidgetContainer)oldContainer.getParent();\n  if (newContainer.getCompanionWidget() == null) {\n    newContainer.setCompanionWidget(oldContainer.getCompanionWidget());\n  }\n  newContainer.setOrigin(oldContainer.getX(),oldContainer.getY());\n  newContainer.setDimension(oldContainer.getWidth(),oldContainer.getHeight());\n  newContainer.setHorizontalDimensionBehaviour(oldContainer.getHorizontalDimensionBehaviour());\n  newContainer.setVerticalDimensionBehaviour(oldContainer.getVerticalDimensionBehaviour());\n  ArrayList<ConstraintWidget> children=new ArrayList<>(oldContainer.getChildren());\n  for (  ConstraintWidget child : children) {\n    newContainer.add(child);\n  }\n  for (  ConstraintAnchor anchor : oldContainer.getAnchors()) {\n    if (anchor.isConnected()) {\n      newContainer.getAnchor(anchor.getType()).connect(anchor.getTarget(),anchor.getMargin(),anchor.getStrength(),anchor.getConnectionCreator());\n    }\n  }\n  for (  ConstraintWidget child : newContainer.getChildren()) {\n    child.resetAnchors();\n  }\n  if (parent != null) {\n    parent.remove(oldContainer);\n    parent.add(newContainer);\n  }\n else {\n    removeWidget(oldContainer);\n  }\n  mWidgets.remove(getTag(oldContainer));\n  setWidget(newContainer);\n  if (mRoot != null) {\n    boolean previousAnimationState=Animator.doAnimation();\n    Animator.setAnimationEnabled(false);\n    mRoot.layout();\n    Animator.setAnimationEnabled(previousAnimationState);\n  }\n}\n", "nl": "Move the content of an old container to a new container"}
{"code": "public int computeWeightedLCA(final Map<Integer,Integer> tax2weight,final double proportionOfWeightToCover){\n  if (tax2weight.size() == 0)   return IdMapper.UNASSIGNED_ID;\n  if (tax2weight.size() == 1)   return tax2weight.keySet().iterator().next();\n  if (tax2weight.size() > addresses.length) {\n    addresses=new String[tax2weight.size()];\n    weights=new int[tax2weight.size()];\n  }\n  int length=0;\n  int aTaxon=0;\n  int totalWeight=0;\n  for (  Integer taxonId : tax2weight.keySet()) {\n    if (taxonId > 0) {\n      String address=TaxonomyData.getAddress(taxonId);\n      Integer weight=tax2weight.get(taxonId);\n      if (address != null && weight != null) {\n        addresses[length]=address;\n        weights[length]=weight;\n        totalWeight+=weight;\n        if (length == 0)         aTaxon=taxonId;\n        length++;\n      }\n    }\n  }\n  if (length == 0)   return IdMapper.UNASSIGNED_ID;\n else   if (length == 1)   return aTaxon;\n  try {\n    final int weightToCover=Math.min(totalWeight,(int)Math.ceil(proportionOfWeightToCover * totalWeight));\n    final String address=getCommonPrefix(weightToCover,addresses,weights,length);\n    if (address != null) {\n      return TaxonomyData.getAddress2Id(address);\n    }\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n  }\n  return 1;\n}\n", "nl": "computes the weighted LCA"}
{"code": "public void updateNlModel(@NotNull List<NlComponent> components,boolean deepUpdate){\n  ArrayList<ConstraintWidget> widgets=new ArrayList<>(myWidgetsScene.getWidgets());\n  if (widgets.size() > 0) {\n    for (    NlComponent component : components) {\n      findComponent(component,widgets);\n    }\n    if (widgets.size() > 0) {\n      for (      ConstraintWidget widget : widgets) {\n        myWidgetsScene.removeWidget(widget);\n      }\n    }\n  }\n  for (  NlComponent component : components) {\n    createSolverWidgetFromComponent(component);\n  }\n  for (  NlComponent component : components) {\n    updateSolverWidgetFromComponent(component,deepUpdate);\n  }\n  if (USE_GUIDELINES_DURING_DND) {\n    if (myDragDropWidget != null && !myWidgetsScene.getWidgets().contains(myDragDropWidget)) {\n      myDragDropWidget=null;\n    }\n  }\n  updateConstraintLayoutRoots(myWidgetsScene.getRoot());\n  WidgetContainer root=myWidgetsScene.getRoot();\n  if (root != null) {\n    root=root.getRootWidgetContainer();\n    if (root != null) {\n      root.layout();\n    }\n  }\n}\n", "nl": "Use the new components in our model"}
{"code": "@Override public Schema transform(Schema schema){\n  int nCols=schema.numColumns();\n  List<String> colNames=schema.getColumnNames();\n  List<ColumnMetaData> meta=schema.getColumnMetaData();\n  List<ColumnMetaData> newMeta=new ArrayList<>(nCols);\n  for (int i=0; i < nCols; i++) {\n    String name=colNames.get(i);\n    ColumnMetaData inMeta=meta.get(i);\n    if (keyColumnsSet != null && keyColumnsSet.contains(name)) {\n      newMeta.add(inMeta);\n      continue;\n    }\n    if (customReductions != null && customReductions.containsKey(name)) {\n      ColumnReduction reduction=customReductions.get(name);\n      String outName=reduction.getColumnOutputName(name);\n      ColumnMetaData outMeta=reduction.getColumnOutputMetaData(outName,inMeta);\n      newMeta.add(outMeta);\n      continue;\n    }\n    if (conditionalReductions != null && conditionalReductions.containsKey(name)) {\n      ConditionalReduction reduction=conditionalReductions.get(name);\n      String outName=reduction.getOutputName();\n      ColumnMetaData m=getMetaForColumn(reduction.getReduction(),name,inMeta);\n      m.setName(outName);\n      newMeta.add(m);\n      continue;\n    }\n    ReduceOp op=opMap.get(name);\n    if (op == null)     op=defaultOp;\n    newMeta.add(getMetaForColumn(op,name,inMeta));\n  }\n  return schema.newSchema(newMeta);\n}\n", "nl": "Get the output schema, given the input schema"}
{"code": "private void rdp_encoding(){\n  int off, d, p, diag;\n  int packet_size=stripe_unit_size / w;\n  for (d=1; d < disks; d++) {\n    diag=d;\n    for (p=0; p < w; p++) {\n      if (diag <= w - 1) {\n        for (off=0; off < packet_size; off++) {\n          odata[0][p * packet_size + off]^=idata[d][p * packet_size + off];\n          odata[1][diag * packet_size + off]^=idata[d][p * packet_size + off];\n        }\n        diag++;\n      }\n else {\n        for (off=0; off < packet_size; off++) {\n          odata[0][p * packet_size + off]^=idata[d][p * packet_size + off];\n        }\n        diag=0;\n      }\n    }\n  }\n  for (p=1; p < w; p++) {\n    for (off=0; off < packet_size; off++) {\n      odata[1][(p - 1) * packet_size + off]^=odata[0][p * packet_size + off];\n    }\n  }\n  System.arraycopy(odata[0],0,idata[disks],0,stripe_unit_size);\n  System.arraycopy(odata[1],0,idata[disks + 1],0,stripe_unit_size);\n}\n", "nl": "rdp encoding algorithm"}
{"code": "XSComplexTypeDecl traverseGlobal(Element complexTypeNode,XSDocumentInfo schemaDoc,SchemaGrammar grammar){\n  Object[] attrValues=fAttrChecker.checkAttributes(complexTypeNode,true,schemaDoc);\n  String complexTypeName=(String)attrValues[XSAttributeChecker.ATTIDX_NAME];\n  contentBackup();\n  XSComplexTypeDecl type=traverseComplexTypeDecl(complexTypeNode,complexTypeName,attrValues,schemaDoc,grammar);\n  contentRestore();\n  grammar.addComplexTypeDecl(type,fSchemaHandler.element2Locator(complexTypeNode));\n  if (complexTypeName == null) {\n    reportSchemaError(\"s4s-att-must-appear\",new Object[]{SchemaSymbols.ELT_COMPLEXTYPE,SchemaSymbols.ATT_NAME},complexTypeNode);\n    type=null;\n  }\n else {\n    if (grammar.getGlobalTypeDecl(type.getName()) == null) {\n      grammar.addGlobalComplexTypeDecl(type);\n    }\n    final String loc=fSchemaHandler.schemaDocument2SystemId(schemaDoc);\n    final XSTypeDefinition type2=grammar.getGlobalTypeDecl(type.getName(),loc);\n    if (type2 == null) {\n      grammar.addGlobalComplexTypeDecl(type,loc);\n    }\n    if (fSchemaHandler.fTolerateDuplicates) {\n      if (type2 != null) {\n        if (type2 instanceof XSComplexTypeDecl) {\n          type=(XSComplexTypeDecl)type2;\n        }\n      }\n      fSchemaHandler.addGlobalTypeDecl(type);\n    }\n  }\n  fAttrChecker.returnAttrArray(attrValues,schemaDoc);\n  return type;\n}\n", "nl": "Traverse global complexType declarations"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"openServer url=\");\n  final String url=np.getWordFileNamePunctuation();\n  String user=\"\";\n  if (np.peekMatchIgnoreCase(\"user\")) {\n    np.matchIgnoreCase(\"user=\");\n    user=np.getWordRespectCase();\n  }\n  String password=\"\";\n  if (np.peekMatchIgnoreCase(\"password\")) {\n    np.matchIgnoreCase(\"password=\");\n    password=np.getWordRespectCase();\nsynchronized (syncObject) {\n      if (password.equals(HIDDEN_PASSWORD) && hiddenPassword != null)       password=hiddenPassword;\n      hiddenPassword=null;\n    }\n  }\n  np.matchIgnoreCase(\";\");\n  if (!((megan.remote.RemoteServiceBrowser)getViewer()).selectServiceTab(url)) {\n    IRemoteService service=RemoteServiceManager.createService(url,user,password);\n    if (service != null) {\n      if (service instanceof LocalService) {\n        ((LocalService)service).rescan(((Director)getDir()).getDocument().getProgressListener());\n      }\n      if (service.isAvailable()) {\n        ((megan.remote.RemoteServiceBrowser)getViewer()).addService(service);\n        ((megan.remote.RemoteServiceBrowser)getViewer()).saveConfig();\n      }\n    }\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "public int delete(KeyInfo keyInfo) throws MyException {\n  ServerInfo server;\n  ProtoCommon.PkgHeader header;\n  byte[] bsPackage;\n  header=new ProtoCommon.PkgHeader();\n  header.key_hash_code=keyInfo.getHashCode();\n  server=this.serverGroup.getServer(header.key_hash_code);\n  if (server == null) {\n    this.status=2;\n    return this.status;\n  }\n  try {\n    header.body_len=keyInfo.getPackLength();\n    header.cmd=ProtoCommon.FDHT_PROTO_CMD_DEL;\n    header.keep_alive=(byte)(this.serverGroup.keep_alive ? 1 : 0);\n    header.timestamp=(int)(System.currentTimeMillis() / 1000);\n    header.expires=0;\n    bsPackage=new byte[ProtoCommon.FDHT_PROTO_PKG_HEADER_SIZE + header.body_len];\n    ProtoCommon.packHeader(header,bsPackage);\n    keyInfo.pack(bsPackage,ProtoCommon.FDHT_PROTO_PKG_HEADER_SIZE);\n    OutputStream out=server.sock.getOutputStream();\n    out.write(bsPackage);\n    ProtoCommon.PkgInfo pkgInfo=ProtoCommon.recvPackage(server.sock.getInputStream(),ProtoCommon.FDHT_PROTO_CMD_RESP,0);\n    this.status=pkgInfo.header.status;\n    return this.status;\n  }\n catch (  IOException ex) {\n    System.err.println(\"server \" + server.address.getAddress().getHostAddress() + \":\"+ server.address.getPort()+ \" IOException, error msg: \"+ ex.getMessage());\n    this.serverGroup.forceClose(server);\n    this.status=5;\n    return this.status;\n  }\n finally {\n    this.serverGroup.closeServer(server);\n  }\n}\n", "nl": "delete key"}
{"code": "public Matrix solve(Matrix B){\n  if (B.getRowDimension() != m) {\n    throw new IllegalArgumentException(\"Matrix row dimensions must agree.\");\n  }\n  if (!this.isNonsingular()) {\n    throw new RuntimeException(\"Matrix is singular.\");\n  }\n  int nx=B.getColumnDimension();\n  Matrix Xmat=B.getMatrix(piv,0,nx - 1);\n  double[][] X=Xmat.getArray();\n  for (int k=0; k < n; k++) {\n    for (int i=k + 1; i < n; i++) {\n      for (int j=0; j < nx; j++) {\n        X[i][j]-=X[k][j] * LU[i][k];\n      }\n    }\n  }\n  for (int k=n - 1; k >= 0; k--) {\n    for (int j=0; j < nx; j++) {\n      X[k][j]/=LU[k][k];\n    }\n    for (int i=0; i < k; i++) {\n      for (int j=0; j < nx; j++) {\n        X[i][j]-=X[k][j] * LU[i][k];\n      }\n    }\n  }\n  return Xmat;\n}\n", "nl": "Solve A*X = B"}
{"code": "public int delete_file(String group_name,String remote_filename) throws IOException, MyException {\n  boolean bNewConnection=this.newUpdatableStorageConnection(group_name,remote_filename);\n  Socket storageSocket=this.storageServer.getSocket();\n  try {\n    this.send_package(ProtoCommon.STORAGE_PROTO_CMD_DELETE_FILE,group_name,remote_filename);\n    ProtoCommon.RecvPackageInfo pkgInfo=ProtoCommon.recvPackage(storageSocket.getInputStream(),ProtoCommon.STORAGE_PROTO_CMD_RESP,0);\n    this.errno=pkgInfo.errno;\n    return pkgInfo.errno;\n  }\n catch (  IOException ex) {\n    if (!bNewConnection) {\n      try {\n        this.storageServer.close();\n      }\n catch (      IOException ex1) {\n        ex1.printStackTrace();\n      }\n finally {\n        this.storageServer=null;\n      }\n    }\n    throw ex;\n  }\n finally {\n    if (bNewConnection) {\n      try {\n        this.storageServer.close();\n      }\n catch (      IOException ex1) {\n        ex1.printStackTrace();\n      }\n finally {\n        this.storageServer=null;\n      }\n    }\n  }\n}\n", "nl": "delete file from storage server"}
{"code": "protected void determineServerStatus(boolean parametersSent){\n  long timeToLive=System.currentTimeMillis() + Context.MAX_LIFE_TIME_FROM_FINISHED;\n  if (!parametersSent) {\n    timeToLive=System.currentTimeMillis() + MAX_WAIT_FOR_NETWORK_FAILURE;\n  }\n  boolean noValidResponse=true;\n  while (System.currentTimeMillis() < timeToLive && noValidResponse) {\n    try {\n      int code=this.factory.fastFailPing(this.url);\n      if (code == 401 || code == 403) {\n        throw new PspRuntimeException(\"Authorization required for \" + this.url + \" (HTTP/\"+ code+ \"). Please provide valid credentials to servlet factory!\");\n      }\n      if (code == 404) {\n        throw new PspRuntimeException(\"Could not find \" + this.url + \" (HTTP/404). Looks like the servlet is not properly configured!\");\n      }\n      if (code == 200) {\n        noValidResponse=false;\n      }\n else {\n        LOGGER.warn(\"Ping request to {} resulted in HTTP/{}\",this.url,code);\n      }\n    }\n catch (    IOException e) {\n      LOGGER.warn(\"could not ping server at {}\",this.url,e);\n    }\n    try {\n      if (noValidResponse) {\n        Thread.sleep(PING_INTERVAL);\n      }\n    }\n catch (    InterruptedException e) {\n    }\n  }\n  if (noValidResponse) {\n    throw new PspRuntimeException(\"Could not reach server at \" + this.url);\n  }\n}\n", "nl": "pings the server until it responds or we give up"}
{"code": "public GenericValue previous(){\n  try {\n    if (resultSet.previous()) {\n      return currentGenericValue();\n    }\n else {\n      return null;\n    }\n  }\n catch (  SQLException e) {\n    if (!closed) {\n      try {\n        this.close();\n      }\n catch (      GenericEntityException e1) {\n        Debug.logError(e1,\"Error auto-closing EntityListIterator on error, so info below for more info on original error; close error: \" + e1.toString(),module);\n      }\n      Debug.logWarning(\"Warning: auto-closed EntityListIterator because of exception: \" + e.toString(),module);\n    }\n    throw new GeneralRuntimeException(\"Error getting the previous result\",e);\n  }\ncatch (  GenericEntityException e) {\n    if (!closed) {\n      try {\n        this.close();\n      }\n catch (      GenericEntityException e1) {\n        Debug.logError(e1,\"Error auto-closing EntityListIterator on error, so info below for more info on original error; close error: \" + e1.toString(),module);\n      }\n      Debug.logWarning(\"Warning: auto-closed EntityListIterator because of exception: \" + e.toString(),module);\n    }\n    throw new GeneralRuntimeException(\"Error creating GenericValue\",e);\n  }\n}\n", "nl": "Moves the cursor to the previous position and returns the GenericValue object for that position; if there is no previous, returns null"}
{"code": "private void loadAudioFile(String file) throws IllegalArgumentException, SecurityException, IllegalStateException, IOException {\n  if (this.isStreaming(file)) {\n    this.player.setDataSource(file);\n    this.player.setAudioStreamType(AudioManager.STREAM_MUSIC);\n    this.setMode(MODE.PLAY);\n    this.setState(STATE.MEDIA_STARTING);\n    this.player.setOnPreparedListener(this);\n    this.player.prepareAsync();\n  }\n else {\n    if (file.startsWith(\"/android_asset/\")) {\n      String f=file.substring(15);\n      android.content.res.AssetFileDescriptor fd=this.handler.cordova.getActivity().getAssets().openFd(f);\n      this.player.setDataSource(fd.getFileDescriptor(),fd.getStartOffset(),fd.getLength());\n    }\n else {\n      File fp=new File(file);\n      if (fp.exists()) {\n        FileInputStream fileInputStream=new FileInputStream(file);\n        this.player.setDataSource(fileInputStream.getFD());\n        fileInputStream.close();\n      }\n else {\n        this.player.setDataSource(Environment.getExternalStorageDirectory().getPath() + \"/\" + file);\n      }\n    }\n    this.setState(STATE.MEDIA_STARTING);\n    this.player.setOnPreparedListener(this);\n    this.player.prepare();\n    this.duration=getDurationInSeconds();\n  }\n}\n", "nl": "load audio file"}
{"code": "void ensureStackCapacity(){\n  if (fElementDepth == fElemDeclStack.length) {\n    int newSize=fElementDepth + INC_STACK_SIZE;\n    boolean[] newArrayB=new boolean[newSize];\n    System.arraycopy(fSubElementStack,0,newArrayB,0,fElementDepth);\n    fSubElementStack=newArrayB;\n    XSElementDecl[] newArrayE=new XSElementDecl[newSize];\n    System.arraycopy(fElemDeclStack,0,newArrayE,0,fElementDepth);\n    fElemDeclStack=newArrayE;\n    newArrayB=new boolean[newSize];\n    System.arraycopy(fNilStack,0,newArrayB,0,fElementDepth);\n    fNilStack=newArrayB;\n    XSNotationDecl[] newArrayN=new XSNotationDecl[newSize];\n    System.arraycopy(fNotationStack,0,newArrayN,0,fElementDepth);\n    fNotationStack=newArrayN;\n    XSTypeDefinition[] newArrayT=new XSTypeDefinition[newSize];\n    System.arraycopy(fTypeStack,0,newArrayT,0,fElementDepth);\n    fTypeStack=newArrayT;\n    XSCMValidator[] newArrayC=new XSCMValidator[newSize];\n    System.arraycopy(fCMStack,0,newArrayC,0,fElementDepth);\n    fCMStack=newArrayC;\n    newArrayB=new boolean[newSize];\n    System.arraycopy(fSawTextStack,0,newArrayB,0,fElementDepth);\n    fSawTextStack=newArrayB;\n    newArrayB=new boolean[newSize];\n    System.arraycopy(fStringContent,0,newArrayB,0,fElementDepth);\n    fStringContent=newArrayB;\n    newArrayB=new boolean[newSize];\n    System.arraycopy(fStrictAssessStack,0,newArrayB,0,fElementDepth);\n    fStrictAssessStack=newArrayB;\n    int[][] newArrayIA=new int[newSize][];\n    System.arraycopy(fCMStateStack,0,newArrayIA,0,fElementDepth);\n    fCMStateStack=newArrayIA;\n  }\n}\n", "nl": "ensure element stack capacity"}
{"code": "private long binomialCoefficient(int n,int k) throws MathRuntimeException {\n  if (binomialCache.size() > n) {\n    Long cachedResult=binomialCache.get(n).get(Integer.valueOf(k));\n    if (cachedResult != null) {\n      return cachedResult.longValue();\n    }\n  }\n  long result=-1;\n  if ((n == k) || (k == 0)) {\n    result=1;\n  }\n else   if ((k == 1) || (k == n - 1)) {\n    result=n;\n  }\n else {\n    if (k < n - 100) {\n      binomialCoefficient(n - 100,k);\n    }\n    if (k > 100) {\n      binomialCoefficient(n - 100,k - 100);\n    }\n    result=ArithmeticUtils.addAndCheck(binomialCoefficient(n - 1,k - 1),binomialCoefficient(n - 1,k));\n  }\n  if (result == -1) {\n    throw new MathRuntimeException(LocalizedCoreFormats.ARITHMETIC_EXCEPTION);\n  }\n  for (int i=binomialCache.size(); i < n + 1; i++) {\n    binomialCache.add(new HashMap<Integer,Long>());\n  }\n  binomialCache.get(n).put(Integer.valueOf(k),Long.valueOf(result));\n  return result;\n}\n", "nl": "Exact (caching) recursive implementation to test against"}
{"code": "public void putSettingsValue(String key,Object value){\n  try {\n    JSONObject settingsObject=readSettings();\n    if (value instanceof Integer) {\n      settingsObject.put(key,(int)value);\n    }\n else     if (value instanceof Boolean) {\n      settingsObject.put(key,(boolean)value);\n    }\n else     if (value instanceof String) {\n      settingsObject.put(key,value);\n    }\n else     if (value instanceof Pair) {\n      String pairKey=(String)((Pair)value).first;\n      String pairValue=(String)((Pair)value).second;\n      JSONObject streamForItem=new JSONObject();\n      JSONArray streamsArray=settingsObject.has(key) ? settingsObject.getJSONArray(key) : new JSONArray();\n      JSONArray newStreamsArray=new JSONArray();\n      streamForItem.put(pairKey,pairValue);\n      for (int i=0; i < streamsArray.length(); i++) {\n        if (!streamsArray.getJSONObject(i).has(pairKey)) {\n          newStreamsArray.put(streamsArray.getJSONObject(i));\n        }\n      }\n      newStreamsArray.put(streamForItem);\n      settingsObject.put(key,newStreamsArray);\n    }\n    saveSettings(settingsObject);\n  }\n catch (  JSONException e) {\n    Logger.printInfo(TAG,\"Can't put value for key: \" + key + \" to json settings\");\n    e.printStackTrace();\n  }\n}\n", "nl": "Automatically saves settings"}
{"code": "public void rotateSelectedSubTree(){\n  boolean changed=false;\n  if (treeView.getNumberSelectedNodes() > 1) {\n    for (    Node v : treeView.getSelectedNodes()) {\n      if (v.getInDegree() == 0 || !treeView.getSelected(v.getFirstInEdge().getSource())) {\n        Stack<Node> stack=new Stack<>();\n        stack.push(v);\n        while (stack.size() > 0) {\n          Node w=stack.pop();\n          if (w.getOutDegree() > 1) {\n            w.reverseOrderAdjacentEdges();\n            changed=true;\n          }\n          if (w.getOutDegree() > 0) {\n            for (Edge e=w.getFirstOutEdge(); e != null; e=w.getNextOutEdge(e)) {\n              stack.push(e.getTarget());\n            }\n          }\n        }\n      }\n    }\n  }\n  if (changed) {\n    labelOrder.clear();\n    labelOrder.addAll(getLabelOrder(treeView));\n    UPGMA.embedTree(treeView);\n    flipCoordinates(treeView,rootSide);\n    previousRectangle=null;\n  }\n}\n", "nl": "rotate all currently selected subtrees"}
{"code": "public static ItemStack deserialize(Map<String,Object> args){\n  Material type=Material.getMaterial((String)args.get(\"type\"));\n  short damage=0;\n  int amount=1;\n  if (args.containsKey(\"damage\")) {\n    damage=((Number)args.get(\"damage\")).shortValue();\n  }\n  if (args.containsKey(\"amount\")) {\n    amount=((Number)args.get(\"amount\")).intValue();\n  }\n  ItemStack result=new ItemStack(type,amount,damage);\n  if (args.containsKey(\"enchantments\")) {\n    Object raw=args.get(\"enchantments\");\n    if (raw instanceof Map) {\n      Map<?,?> map=(Map<?,?>)raw;\n      for (      Map.Entry<?,?> entry : map.entrySet()) {\n        Enchantment enchantment=Enchantment.getByName(entry.getKey().toString());\n        if ((enchantment != null) && (entry.getValue() instanceof Integer)) {\n          result.addUnsafeEnchantment(enchantment,(Integer)entry.getValue());\n        }\n      }\n    }\n  }\n else   if (args.containsKey(\"meta\")) {\n    Object raw=args.get(\"meta\");\n    if (raw instanceof ItemMeta) {\n      result.setItemMeta((ItemMeta)raw);\n    }\n  }\n  return result;\n}\n", "nl": "Required method for configuration serialization"}
{"code": "@Override public void renderAxisLabels(Canvas c){\n  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;\n  float[] positions=new float[mYAxis.mEntryCount * 2];\n  for (int i=0; i < positions.length; i+=2) {\n    positions[i]=mYAxis.mEntries[i / 2];\n  }\n  mTrans.pointValuesToPixel(positions);\n  mAxisLabelPaint.setTypeface(mYAxis.getTypeface());\n  mAxisLabelPaint.setTextSize(mYAxis.getTextSize());\n  mAxisLabelPaint.setColor(mYAxis.getTextColor());\n  mAxisLabelPaint.setTextAlign(Align.CENTER);\n  float baseYOffset=Utils.convertDpToPixel(2.5f);\n  float textHeight=Utils.calcTextHeight(mAxisLabelPaint,\"Q\");\n  AxisDependency dependency=mYAxis.getAxisDependency();\n  YAxisLabelPosition labelPosition=mYAxis.getLabelPosition();\n  float yPos;\n  if (dependency == AxisDependency.LEFT) {\n    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {\n      yPos=mViewPortHandler.contentTop() - baseYOffset;\n    }\n else {\n      yPos=mViewPortHandler.contentTop() - baseYOffset;\n    }\n  }\n else {\n    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {\n      yPos=mViewPortHandler.contentBottom() + textHeight + baseYOffset;\n    }\n else {\n      yPos=mViewPortHandler.contentBottom() + textHeight + baseYOffset;\n    }\n  }\n  drawYLabels(c,yPos,positions,mYAxis.getYOffset());\n}\n", "nl": "draws the y-axis labels to the screen"}
{"code": "private void loadProperties(){\n  String property=System.getProperty(\"carbon.properties.filepath\");\n  if (null == property) {\n    property=CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH;\n  }\n  File file=new File(property);\n  LOGGER.info(\"Property file path: \" + file.getAbsolutePath());\n  FileInputStream fis=null;\n  try {\n    if (file.exists()) {\n      fis=new FileInputStream(file);\n      carbonProperties.load(fis);\n    }\n  }\n catch (  FileNotFoundException e) {\n    LOGGER.error(\"The file: \" + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH + \" does not exist\");\n  }\ncatch (  IOException e) {\n    LOGGER.error(\"Error while reading the file: \" + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH);\n  }\n finally {\n    if (null != fis) {\n      try {\n        fis.close();\n      }\n catch (      IOException e) {\n        LOGGER.error(\"Error while closing the file stream for file: \" + CarbonCommonConstants.CARBON_PROPERTIES_FILE_PATH);\n      }\n    }\n  }\n  print();\n}\n", "nl": "This method will read all the properties from file and load it into memory"}
{"code": "public static Map<String,Object> removeRoleType(DispatchContext ctx,Map<String,? extends Object> context){\n  Map<String,Object> result=new HashMap<String,Object>();\n  Delegator delegator=ctx.getDelegator();\n  String orderId=(String)context.get(\"orderId\");\n  String partyId=(String)context.get(\"partyId\");\n  String roleTypeId=(String)context.get(\"roleTypeId\");\n  GenericValue testValue=null;\n  try {\n    testValue=EntityQuery.use(delegator).from(\"OrderRole\").where(\"orderId\",orderId,\"partyId\",partyId,\"roleTypeId\",roleTypeId).queryOne();\n  }\n catch (  GenericEntityException e) {\n    result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_ERROR);\n    result.put(ModelService.ERROR_MESSAGE,\"ERROR: Could not add role to order (\" + e.getMessage() + \").\");\n    return result;\n  }\n  if (testValue == null) {\n    result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_SUCCESS);\n    return result;\n  }\n  try {\n    GenericValue value=EntityQuery.use(delegator).from(\"OrderRole\").where(\"orderId\",orderId,\"partyId\",partyId,\"roleTypeId\",roleTypeId).queryOne();\n    value.remove();\n  }\n catch (  GenericEntityException e) {\n    result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_ERROR);\n    result.put(ModelService.ERROR_MESSAGE,\"ERROR: Could not remove role from order (\" + e.getMessage() + \").\");\n    return result;\n  }\n  result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_SUCCESS);\n  return result;\n}\n", "nl": "Service to remove a role type from an order"}
{"code": "protected ExecuteBatchQuery requests(AbstractQueryBuilder... value){\n  StringBuilder builder=new StringBuilder();\n  builder.append(\"return [\");\n  int requestIndex=0;\n  for (  AbstractQueryBuilder request : value) {\n    builder.append(\"API.\").append(request.getMethod()).append(\"(\");\n    Map<String,String> params=new HashMap<>(request.build());\n    params.remove(\"access_token\");\n    params.remove(\"v\");\n    if (!params.isEmpty()) {\n      builder.append(\"{\");\n      int paramIndex=0;\n      for (      Map.Entry<String,String> param : params.entrySet()) {\n        builder.append(\"\\\"\").append(param.getKey()).append(\"\\\":\").append(\"\\\"\").append(param.getValue()).append(\"\\\"\");\n        if (paramIndex < (params.size() - 1)) {\n          builder.append(\",\");\n        }\n        paramIndex++;\n      }\n      builder.append(\"}\");\n    }\n    builder.append(\")\");\n    if (requestIndex < (value.length - 1)) {\n      builder.append(\",\");\n    }\n    requestIndex++;\n  }\n  builder.append(\"];\");\n  return unsafeParam(\"code\",builder.toString());\n}\n", "nl": "Batch requests"}
{"code": "@Override public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (obj == null) {\n    return false;\n  }\n  if (!(obj instanceof TableInfo)) {\n    return false;\n  }\n  TableInfo other=(TableInfo)obj;\n  if (databaseName == null) {\n    if (other.databaseName != null) {\n      return false;\n    }\n  }\n else   if (!tableUniqueName.equals(other.tableUniqueName)) {\n    return false;\n  }\n  if (tableUniqueName == null) {\n    if (other.tableUniqueName != null) {\n      return false;\n    }\n  }\n else   if (!tableUniqueName.equals(other.tableUniqueName)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Overridden equals method"}
{"code": "public void calcRenew(long now){\n  endTime=lease.getExpiration();\n  if (renewalsDone()) {\n    if (null == desiredExpirationListener()) {\n      renew=Long.MAX_VALUE;\n    }\n else {\n      renew=expiration;\n    }\n    return;\n  }\n  long delta=endTime - now;\n  if (delta <= renewalRTT * 2) {\n    delta=renewalRTT;\n  }\n else   if (delta <= renewalRTT * 8) {\n    delta/=2;\n  }\n else   if (delta <= 1000 * 60 * 60* 24* 7) {\n    delta/=8;\n  }\n else   if (delta <= 1000 * 60 * 60* 24* 14) {\n    delta=1000 * 60 * 60* 24;\n  }\n else {\n    delta=1000 * 60 * 60* 24* 3;\n  }\n  renew=endTime - delta;\n}\n", "nl": "Calculate the renew time for the lease entry"}
{"code": "@Override protected void runImpl(){\n  name=ChatUtil.getRealAdminName(name);\n  String formatname=Util.convertName(name);\n  Player sender=getConnection().getActivePlayer();\n  Player receiver=World.getInstance().findPlayer(formatname);\n  if (LoggingConfig.LOG_CHAT) {\n    log.info(String.format(\"[MESSAGE] [%s] Whisper To: %s, Message: %s\",sender.getName(),formatname,message));\n  }\n  if (receiver == null) {\n    sendPacket(SM_SYSTEM_MESSAGE.STR_NO_SUCH_USER(formatname));\n  }\n else   if (!receiver.isWispable()) {\n    PacketSendUtility.sendMessage(sender,\"You can't talk with this gm.\");\n  }\n else   if (sender.getLevel() < CustomConfig.LEVEL_TO_WHISPER) {\n    sendPacket(SM_SYSTEM_MESSAGE.STR_CANT_WHISPER_LEVEL(String.valueOf(CustomConfig.LEVEL_TO_WHISPER)));\n  }\n else   if (receiver.getBlockList().contains(sender.getObjectId())) {\n    sendPacket(SM_SYSTEM_MESSAGE.STR_YOU_EXCLUDED(receiver.getName()));\n  }\n else   if ((!CustomConfig.SPEAKING_BETWEEN_FACTIONS) && (sender.getRace().getRaceId() != receiver.getRace().getRaceId()) && (sender.getAccessLevel() < AdminConfig.GM_LEVEL)&& (receiver.getAccessLevel() < AdminConfig.GM_LEVEL)) {\n    sendPacket(SM_SYSTEM_MESSAGE.STR_NO_SUCH_USER(formatname));\n  }\n else {\n    if (RestrictionsManager.canChat(sender)) {\n      PacketSendUtility.sendPacket(receiver,new SM_MESSAGE(sender,NameRestrictionService.filterMessage(message),ChatType.WHISPER));\n    }\n  }\n}\n", "nl": "Print debug info"}
{"code": "public static final void isAttrValueWF(DOMErrorHandler errorHandler,DOMErrorImpl error,DOMLocatorImpl locator,NamedNodeMap attributes,Attr a,String value,boolean xml11Version){\n  if (a instanceof AttrImpl && ((AttrImpl)a).hasStringValue()) {\n    isXMLCharWF(errorHandler,error,locator,value,xml11Version);\n  }\n else {\n    NodeList children=a.getChildNodes();\n    for (int j=0; j < children.getLength(); j++) {\n      Node child=children.item(j);\n      if (child.getNodeType() == Node.ENTITY_REFERENCE_NODE) {\n        Document owner=a.getOwnerDocument();\n        Entity ent=null;\n        if (owner != null) {\n          DocumentType docType=owner.getDoctype();\n          if (docType != null) {\n            NamedNodeMap entities=docType.getEntities();\n            ent=(Entity)entities.getNamedItemNS(\"*\",child.getNodeName());\n          }\n        }\n        if (ent == null) {\n          String msg=DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,\"UndeclaredEntRefInAttrValue\",new Object[]{a.getNodeName()});\n          reportDOMError(errorHandler,error,locator,msg,DOMError.SEVERITY_ERROR,\"UndeclaredEntRefInAttrValue\");\n        }\n      }\n else {\n        isXMLCharWF(errorHandler,error,locator,child.getNodeValue(),xml11Version);\n      }\n    }\n  }\n}\n", "nl": "NON-DOM: check if attribute value is well-formed"}
{"code": "public static Map<String,Object> runEntitySync(DispatchContext dctx,Map<String,? extends Object> context){\n  Locale locale=(Locale)context.get(\"locale\");\n  EntitySyncContext esc=null;\n  try {\n    esc=new EntitySyncContext(dctx,context);\n    if (\"Y\".equals(esc.entitySync.get(\"forPullOnly\"))) {\n      return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"EntityExtCannotDoEntitySyncPush\",locale));\n    }\n    esc.runPushStartRunning();\n    esc.setSplitStartTime();\n    while (esc.hasMoreTimeToSync()) {\n      esc.totalSplits++;\n      ArrayList<GenericValue> valuesToCreate=esc.assembleValuesToCreate();\n      ArrayList<GenericValue> valuesToStore=esc.assembleValuesToStore();\n      List<GenericEntity> keysToRemove=esc.assembleKeysToRemove();\n      esc.runPushSendData(valuesToCreate,valuesToStore,keysToRemove);\n      esc.saveResultsReportedFromDataStore();\n      esc.advanceRunTimes();\n    }\n    esc.saveFinalSyncResults();\n  }\n catch (  SyncAbortException e) {\n    return e.returnError(module);\n  }\ncatch (  SyncErrorException e) {\n    e.saveSyncErrorInfo(esc);\n    return e.returnError(module);\n  }\n  return ServiceUtil.returnSuccess();\n}\n", "nl": "Run an Entity Sync (checks to see if other already running, etc)"}
{"code": "public static long tick2microsecond(Sequence seq,long tick,TempoCache cache){\n  if (seq.getDivisionType() != Sequence.PPQ) {\n    double seconds=((double)tick / (double)(seq.getDivisionType() * seq.getResolution()));\n    return (long)(1000000 * seconds);\n  }\n  if (cache == null) {\n    cache=new TempoCache(seq);\n  }\n  int resolution=seq.getResolution();\n  long[] ticks=cache.ticks;\n  int[] tempos=cache.tempos;\n  int cacheCount=tempos.length;\n  int snapshotIndex=cache.snapshotIndex;\n  int snapshotMicro=cache.snapshotMicro;\n  long us=0;\n  if (snapshotIndex <= 0 || snapshotIndex >= cacheCount || ticks[snapshotIndex] > tick) {\n    snapshotMicro=0;\n    snapshotIndex=0;\n  }\n  if (cacheCount > 0) {\n    int i=snapshotIndex + 1;\n    while (i < cacheCount && ticks[i] <= tick) {\n      snapshotMicro+=ticks2microsec(ticks[i] - ticks[i - 1],tempos[i - 1],resolution);\n      snapshotIndex=i;\n      i++;\n    }\n    us=snapshotMicro + ticks2microsec(tick - ticks[snapshotIndex],tempos[snapshotIndex],resolution);\n  }\n  cache.snapshotIndex=snapshotIndex;\n  cache.snapshotMicro=snapshotMicro;\n  return us;\n}\n", "nl": "Given a tick, convert to microsecond"}
{"code": "public void requestAddNodesStart(int inclusionMode){\n  if (exclusion == true || inclusion == true) {\n    logger.debug(\"ZWave exclusion already in progress - aborted\");\n    return;\n  }\n  logger.debug(\"ZWave controller start inclusion - mode {}\",inclusionMode);\n  if (inclusionMode == 2 && hasApiCapability(SerialMessageClass.ExploreRequestInclusion) == false) {\n    inclusionMode=1;\n  }\n  boolean highPower;\n  boolean networkWide;\nswitch (inclusionMode) {\ncase 0:\n    highPower=false;\n  networkWide=false;\nbreak;\ncase 1:\nhighPower=true;\nnetworkWide=false;\nbreak;\ndefault :\nhighPower=true;\nnetworkWide=true;\nbreak;\n}\nenqueue(new AddNodeMessageClass().doRequestStart(highPower,networkWide));\ninclusion=true;\nstartInclusionTimer();\n}\n", "nl": "Puts the controller into inclusion mode to add new nodes"}
{"code": "protected void drawLabels(Canvas c,float pos,MPPointF anchor){\n  final float labelRotationAngleDegrees=mXAxis.getLabelRotationAngle();\n  final boolean centeringEnabled=mXAxis.isCenterAxisLabelsEnabled();\n  float[] positions=new float[mXAxis.mEntryCount << 1];\n  for (int i=0; i < positions.length; i+=2) {\n    if (centeringEnabled) {\n      positions[i]=mXAxis.mCenteredEntries[i >> 1];\n    }\n else {\n      positions[i]=mXAxis.mEntries[i >> 1];\n    }\n  }\n  mTrans.pointValuesToPixel(positions);\n  AxisValueFormatter formatter=mXAxis.getValueFormatter();\n  for (int i=0; i < mXAxis.mEntries.length; i++) {\n    float x=positions[i << 1];\n    if (!mViewPortHandler.isInBoundsX(x))     return;\n    String label=formatter.getFormattedValue(mXAxis.mEntries[i],mXAxis);\n    if (mXAxis.isAvoidFirstLastClippingEnabled()) {\n      if (i == 0) {\n        x+=mViewPortHandler.offsetLeft();\n      }\n else       if (i == mXAxis.mEntries.length - 1) {\n        x-=mViewPortHandler.offsetRight();\n      }\n    }\n    drawLabel(c,label,x,pos,anchor,labelRotationAngleDegrees);\n  }\n}\n", "nl": "draws the x-labels on the specified y-position"}
{"code": "@deprecated public final String formatOffsetRFC822(int offset){\n  StringBuilder buf=new StringBuilder();\n  char sign='+';\n  if (offset < 0) {\n    sign='-';\n    offset=-offset;\n  }\n  buf.append(sign);\n  int offsetH=offset / 3600000;\n  offset%=3600000;\n  int offsetM=offset / 60000;\n  offset%=60000;\n  int offsetS=offset / 1000;\n  assert ((offsetH >= 0) && (offsetH < 100));\n  assert ((offsetM >= 0) && (offsetM < 60));\n  assert ((offsetS >= 0) && (offsetS < 60));\n  int num=0;\n  int denom=0;\n  if (offsetS == 0) {\n    offset=offsetH * 100 + offsetM;\n    num=offset % 10000;\n    denom=1000;\n  }\n else {\n    offset=offsetH * 10000 + offsetM * 100 + offsetS;\n    num=offset % 1000000;\n    denom=100000;\n  }\n  while (denom >= 1) {\n    char digit=(char)(num / denom + 48);\n    buf.append(digit);\n    num%=denom;\n    denom/=10;\n  }\n  return buf.toString();\n}\n", "nl": "/*     "}
{"code": "private void performCrop(Uri picUri,int destType,Intent cameraIntent){\n  try {\n    Intent cropIntent=new Intent(\"com.android.camera.action.CROP\");\n    cropIntent.setDataAndType(picUri,\"image/*\");\n    cropIntent.putExtra(\"crop\",\"true\");\n    if (targetWidth > 0) {\n      cropIntent.putExtra(\"outputX\",targetWidth);\n    }\n    if (targetHeight > 0) {\n      cropIntent.putExtra(\"outputY\",targetHeight);\n    }\n    if (targetHeight > 0 && targetWidth > 0 && targetWidth == targetHeight) {\n      cropIntent.putExtra(\"aspectX\",1);\n      cropIntent.putExtra(\"aspectY\",1);\n    }\n    croppedUri=Uri.fromFile(createCaptureFile(this.encodingType,System.currentTimeMillis() + \"\"));\n    cropIntent.putExtra(\"output\",croppedUri);\n    if (this.cordova != null) {\n      this.cordova.startActivityForResult((CordovaPlugin)this,cropIntent,CROP_CAMERA + destType);\n    }\n  }\n catch (  ActivityNotFoundException anfe) {\n    Log.e(LOG_TAG,\"Crop operation not supported on this device\");\n    try {\n      processResultFromCamera(destType,cameraIntent);\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n      Log.e(LOG_TAG,\"Unable to write to file\");\n    }\n  }\n}\n", "nl": "Brings up the UI to perform crop on passed image URI"}
{"code": "public void notifyObservers(ObserverType type,Object... object){\n  List<ActionObserver> tempOnceused=Collections.emptyList();\n  lock.lock();\n  try {\n    if (onceUsedObservers.size() > 0) {\n      tempOnceused=new ArrayList<ActionObserver>();\n      Iterator<ActionObserver> iterator=onceUsedObservers.iterator();\n      while (iterator.hasNext()) {\n        ActionObserver observer=iterator.next();\n        if (observer.getObserverType().matchesObserver(type)) {\n          if (observer.tryUse()) {\n            tempOnceused.add(observer);\n            iterator.remove();\n          }\n        }\n      }\n    }\n  }\n  finally {\n    lock.unlock();\n  }\n  for (  ActionObserver observer : tempOnceused) {\n    notifyAction(type,observer,object);\n  }\n  if (observers.size() > 0) {\n    for (    ActionObserver observer : observers) {\n      if (observer.getObserverType().matchesObserver(type)) {\n        notifyAction(type,observer,object);\n      }\n    }\n  }\n}\n", "nl": "notify all observers"}
{"code": "private void doScroll(int delta){\n  scrollingOffset+=delta;\n  int count=scrollingOffset / getItemHeight();\n  int pos=currentItem - count;\n  if (isCyclic && adapter.getItemsCount() > 0) {\n    while (pos < 0) {\n      pos+=adapter.getItemsCount();\n    }\n    pos%=adapter.getItemsCount();\n  }\n else   if (isScrollingPerformed) {\n    if (pos < 0) {\n      count=currentItem;\n      pos=0;\n    }\n else     if (pos >= adapter.getItemsCount()) {\n      count=currentItem - adapter.getItemsCount() + 1;\n      pos=adapter.getItemsCount() - 1;\n    }\n  }\n else {\n    pos=Math.max(pos,0);\n    pos=Math.min(pos,adapter.getItemsCount() - 1);\n  }\n  int offset=scrollingOffset;\n  if (pos != currentItem) {\n    setCurrentItem(pos,false);\n  }\n else {\n    invalidate();\n  }\n  scrollingOffset=offset - count * getItemHeight();\n  if (scrollingOffset > getHeight()) {\n    scrollingOffset=scrollingOffset % getHeight() + getHeight();\n  }\n}\n", "nl": "Scrolls the wheel"}
{"code": "private boolean movePlatform(BlockPos anchor,boolean up){\n  IBlockState state=worldObj.getBlockState(anchor);\n  if (state.getBlock() != BWMBlocks.ANCHOR)   return false;\n  HashSet<BlockPos> platformBlocks=new HashSet<>();\n  platformBlocks.add(anchor);\n  Block b=worldObj.getBlockState(anchor.down()).getBlock();\n  boolean success=worldObj.getBlockState(anchor.down()).getBlock() == PLATFORM ? addToList(platformBlocks,anchor.down(),up) : up || isValidBlock(b,anchor.down());\n  if (!success) {\n    return false;\n  }\n  for (  BlockPos blockPos : platformBlocks) {\n    Arrays.asList(new BlockPos[]{blockPos.north(),blockPos.south()}).forEach(null);\n    Arrays.asList(new BlockPos[]{blockPos.east(),blockPos.west()}).forEach(null);\n  }\n  if (!worldObj.isRemote) {\n    for (    BlockPos blockPos : platformBlocks) {\n      IBlockState blockState=worldObj.getBlockState(blockPos.up());\n      b=blockState.getBlock();\n      blockState=(b == Blocks.REDSTONE_WIRE || b instanceof BlockRailBase ? blockState : null);\n      Vec3i offset=blockPos.subtract(anchor.up());\n      rope.addBlock(offset,worldObj.getBlockState(blockPos));\n      if (blockState != null) {\n        rope.addBlock(new Vec3i(offset.getX(),offset.getY() + 1,offset.getZ()),blockState);\n        worldObj.setBlockToAir(blockPos.up());\n      }\n      worldObj.setBlockToAir(blockPos);\n    }\n  }\n  return true;\n}\n", "nl": "Turns the platform into entities and moves them with the rope"}
{"code": "private boolean normalizeDefaultAttrValue(XMLString value){\n  boolean skipSpace=true;\n  int current=value.offset;\n  int end=value.offset + value.length;\n  for (int i=value.offset; i < end; i++) {\n    if (value.ch[i] == ' ') {\n      if (!skipSpace) {\n        value.ch[current++]=' ';\n        skipSpace=true;\n      }\n else {\n      }\n    }\n else {\n      if (current != i) {\n        value.ch[current]=value.ch[i];\n      }\n      current++;\n      skipSpace=false;\n    }\n  }\n  if (current != end) {\n    if (skipSpace) {\n      current--;\n    }\n    value.length=current - value.offset;\n    return true;\n  }\n  return false;\n}\n", "nl": "Normalize the attribute value of a non CDATA default attribute collapsing sequences of space characters (x20)"}
{"code": "public boolean before(Model m){\n  String uri=m.getURI();\n  for (  String name : filters.keySet()) {\n    if (uri.matches(name)) {\n      Object o=filters.get(name);\n      try {\n        IFilter f=null;\n        if (o instanceof IFilter) {\n          f=(IFilter)o;\n        }\n else {\n          f=(IFilter)(Class.forName((String)o).newInstance());\n          filters.put(name,f);\n        }\n        if (!f.before(m)) {\n          return false;\n        }\n      }\n catch (      Exception e) {\n        log.error(e.getMessage(),e);\n        filters.remove(name);\n      }\n    }\n  }\n  Module m1=floor();\n  if (m1 != null) {\n    return m1.before(m);\n  }\n  return true;\n}\n", "nl": "handle by filter ad invoke the before"}
{"code": "public static void drawSnapHorizontalMargin(ViewTransform transform,Graphics2D g,int x1,int x2,int y1,String text,boolean textOver){\n  Canvas c=new Canvas();\n  FontMetrics fm=c.getFontMetrics(sFont);\n  g.setFont(sFont);\n  int padding=transform.getSwingDimension(4);\n  Rectangle2D bounds=fm.getStringBounds(text,g);\n  int tw=(int)bounds.getWidth();\n  int offset=6 * CONNECTION_ARROW_SIZE;\n  if (x1 > x2) {\n    int temp=x1;\n    x1=x2;\n    x2=temp;\n  }\n  int w=((x2 - x1) - (tw + 2 * padding)) / 2;\n  if (w <= padding) {\n    g.drawLine(x1,y1,x2,y1);\n    if (textOver) {\n      offset=-1 * offset / 2;\n    }\n    g.drawString(text,x1 + w + padding,y1 + offset);\n  }\n else {\n    g.drawLine(x1,y1,x1 + w,y1);\n    g.drawLine(x2 - w,y1,x2,y1);\n    g.drawString(text,x1 + w + padding,(int)(y1 + (bounds.getHeight() / 2)));\n  }\n  g.drawLine(x1,y1 - CONNECTION_ARROW_SIZE,x1,y1 + CONNECTION_ARROW_SIZE);\n  g.drawLine(x2,y1 - CONNECTION_ARROW_SIZE,x2,y1 + CONNECTION_ARROW_SIZE);\n}\n", "nl": "Draw a snap horizontal margin indicator"}
{"code": "private void doWrite(List<String> args) throws DumpUsageException {\n  String usagePrefix=\"Usage: prefs write <path> <key> <type> <value>, where type is one of: \";\n  Iterator<String> argsIter=args.iterator();\n  String path=nextArg(argsIter,\"Expected <path>\");\n  String key=nextArg(argsIter,\"Expected <key>\");\n  String typeName=nextArg(argsIter,\"Expected <type>\");\n  Type type=Type.of(typeName);\n  if (type == null) {\n    throw new DumpUsageException(Type.appendNamesList(new StringBuilder(usagePrefix),\", \").toString());\n  }\n  SharedPreferences sharedPreferences=getSharedPreferences(path);\n  SharedPreferences.Editor editor=sharedPreferences.edit();\nswitch (type) {\ncase BOOLEAN:\n    editor.putBoolean(key,Boolean.valueOf(nextArgValue(argsIter)));\n  break;\ncase INT:\neditor.putInt(key,Integer.valueOf(nextArgValue(argsIter)));\nbreak;\ncase LONG:\neditor.putLong(key,Long.valueOf(nextArgValue(argsIter)));\nbreak;\ncase FLOAT:\neditor.putFloat(key,Float.valueOf(nextArgValue(argsIter)));\nbreak;\ncase STRING:\neditor.putString(key,nextArgValue(argsIter));\nbreak;\ncase SET:\nputStringSet(editor,key,argsIter);\nbreak;\n}\neditor.commit();\n}\n", "nl": "Executes command to update one value in the shared preferences"}
{"code": "public void check() throws IOException {\n  boolean ok=false;\n  if (type != null) {\n    for (    AcceptableTypes acceptable : AcceptableTypes.values()) {\n      if (acceptable.toString().equalsIgnoreCase(type)) {\n        ok=true;\n        break;\n      }\n    }\n  }\n  if (!ok)   throw new IOException(\"type=\" + type + \", must be one of: \"+ Basic.toString(AcceptableTypes.values(),\", \").replaceAll(\"_\",\" \"));\n  ok=false;\n  if (matrix_type != null) {\n    for (    AcceptableMatrixTypes acceptable : AcceptableMatrixTypes.values()) {\n      if (acceptable.toString().equalsIgnoreCase(matrix_type)) {\n        ok=true;\n        break;\n      }\n    }\n  }\n  if (!ok)   throw new IOException(\"matrix_type=\" + matrix_type + \", must be one of: \"+ Basic.toString(AcceptableMatrixTypes.values(),\", \"));\n  ok=false;\n  if (matrix_element_type != null) {\n    for (    AcceptableMatrixElementTypes acceptable : AcceptableMatrixElementTypes.values()) {\n      if (acceptable.toString().equalsIgnoreCase(matrix_element_type)) {\n        ok=true;\n        break;\n      }\n    }\n  }\n  if (!ok)   throw new IOException(\"matrix_element_type=\" + matrix_element_type + \", must be one of: \"+ Basic.toString(AcceptableMatrixElementTypes.values(),\", \"));\n}\n", "nl": "check whether data is acceptable"}
{"code": "@deprecated protected int writeValueAndFinal(int i,boolean isFinal){\n  if ((0 <= i) && (i <= 64)) {\n    return write(16 + i << 1 | (isFinal ? 1 : 0));\n  }\n  int length=1;\n  if ((i < 0) || (i > 16777215)) {\n    this.intBytes[0]=Byte.MAX_VALUE;\n    this.intBytes[1]=((byte)(i >> 24));\n    this.intBytes[2]=((byte)(i >> 16));\n    this.intBytes[3]=((byte)(i >> 8));\n    this.intBytes[4]=((byte)i);\n    length=5;\n  }\n else {\n    if (i <= 6911) {\n      this.intBytes[0]=((byte)(81 + (i >> 8)));\n    }\n else {\n      if (i <= 1179647) {\n        this.intBytes[0]=((byte)(108 + (i >> 16)));\n      }\n else {\n        this.intBytes[0]=126;\n        this.intBytes[1]=((byte)(i >> 16));\n        length=2;\n      }\n      this.intBytes[(length++)]=((byte)(i >> 8));\n    }\n    this.intBytes[(length++)]=((byte)i);\n  }\n  this.intBytes[0]=((byte)(this.intBytes[0] << 1 | (isFinal ? 1 : 0)));\n  return write(this.intBytes,length);\n}\n", "nl": "/*    "}
{"code": "private Object[] process(Object[] row) throws KettleException {\n  Object[] outputRow=null;\n  if (meta.getNoDictionaryCount() > 0 || meta.getComplexDimsCount() > 0) {\n    outputRow=new Object[measureCount + 1 + 1];\n  }\n else {\n    outputRow=new Object[measureCount + 1];\n  }\n  int l=0;\n  int index=0;\n  for (int i=0; i < measureCount; i++) {\n    if (aggType[i] == CarbonCommonConstants.BIG_DECIMAL_MEASURE) {\n      outputRow[l++]=RemoveDictionaryUtil.getMeasure(index++,row);\n    }\n else     if (aggType[i] == CarbonCommonConstants.BIG_INT_MEASURE) {\n      outputRow[l++]=(Long)RemoveDictionaryUtil.getMeasure(index++,row);\n    }\n else {\n      outputRow[l++]=(Double)RemoveDictionaryUtil.getMeasure(index++,row);\n    }\n  }\n  outputRow[l]=RemoveDictionaryUtil.getByteArrayForNoDictionaryCols(row);\n  int[] highCardExcludedRows=new int[segmentProperties.getDimColumnsCardinality().length];\n  for (int i=0; i < highCardExcludedRows.length; i++) {\n    Object key=RemoveDictionaryUtil.getDimension(i,row);\n    highCardExcludedRows[i]=(Integer)key;\n  }\n  try {\n    outputRow[outputRow.length - 1]=data.generator.generateKey(highCardExcludedRows);\n  }\n catch (  KeyGenException e) {\n    throw new KettleException(\"unable to generate the mdkey\",e);\n  }\n  return outputRow;\n}\n", "nl": "This method will be used to get the row from previous step and then it will generate the mdkey and then send the mdkey to next step"}
{"code": "private static void writeMD(DAAMatchRecord match,ByteOutputBuffer buffer,byte[] queryAlphabet){\n{\n    int matches=0, del=0;\n    for (    CombinedOperation cop : match.getTranscript().gather()) {\nswitch (cop.getEditOperation()) {\ncase op_match:\n        del=0;\n      matches+=cop.getCount();\n    break;\ncase op_insertion:\n  break;\ncase op_substitution:\nif (matches > 0) {\n  buffer.writeString(String.format(\"%d\",matches));\n  matches=0;\n}\n else if (del > 0) {\n  buffer.write((byte)'0');\n  del=0;\n}\nbuffer.write(queryAlphabet[cop.getLetter()]);\nbreak;\ncase op_deletion:\nif (matches > 0) {\nbuffer.writeString(String.format(\"%d\",matches));\nmatches=0;\n}\nif (del == 0) buffer.write((byte)'^');\nbuffer.write(queryAlphabet[cop.getLetter()]);\n++del;\n}\n}\nif (matches > 0) buffer.writeString(String.format(\"%d\",matches));\n}\n}\n", "nl": "write the MD string"}
{"code": "public void doUpdate(){\n  boolean needUpdate=false;\n  Calendar lastCal=Calendar.getInstance();\n  lastCal.setTimeInMillis(lastUpdate);\n  Calendar curCal=Calendar.getInstance();\n  curCal.setTimeInMillis(System.currentTimeMillis());\n  if (lastCal.get(Calendar.DAY_OF_MONTH) != curCal.get(Calendar.DAY_OF_MONTH) || lastCal.get(Calendar.MONTH) != curCal.get(Calendar.MONTH) || lastCal.get(Calendar.YEAR) != curCal.get(Calendar.YEAR)) {\n    this.dailyAP=0;\n    this.dailyGP=0;\n    this.dailyKill=0;\n    needUpdate=true;\n  }\n  if (lastCal.get(Calendar.WEEK_OF_YEAR) != curCal.get(Calendar.WEEK_OF_YEAR) || lastCal.get(Calendar.YEAR) != curCal.get(Calendar.YEAR)) {\n    this.lastKill=this.weeklyKill;\n    this.lastAP=this.weeklyAP;\n    this.lastGP=this.weeklyGP;\n    this.weeklyKill=0;\n    this.weeklyAP=0;\n    this.weeklyGP=0;\n    needUpdate=true;\n  }\n  if (rank.getId() > maxRank) {\n    maxRank=rank.getId();\n    needUpdate=true;\n  }\n  this.lastUpdate=System.currentTimeMillis();\n  if (needUpdate) {\n    setPersistentState(PersistentState.UPDATE_REQUIRED);\n  }\n}\n", "nl": "Make an update for the daily/weekly/last kill & ap counts & gp counts"}
{"code": "public static String wildcardToRegex(String wildcard){\n  StringBuilder s=new StringBuilder(wildcard.length());\n  for (int i=0, is=wildcard.length(); i < is; i++) {\n    char c=wildcard.charAt(i);\nswitch (c) {\ncase '*':\n      s.append(\".*\");\n    break;\ncase '?':\n  s.append(\".\");\nbreak;\ncase '(':\ncase ')':\ncase '[':\ncase ']':\ncase '$':\ncase '^':\ncase '.':\ncase '{':\ncase '}':\ncase '|':\ncase '\\\\':\ns.append(\"\\\\\");\ns.append(c);\nbreak;\ndefault :\ns.append(c);\nbreak;\n}\n}\nlogger.debug(\"regex = \" + s.toString());\nreturn (s.toString());\n}\n", "nl": "Method to convert a URI wildcard query into a java regex"}
{"code": "public static Map<String,Object> convertDocumentFileToFile(DispatchContext dctx,Map<String,? extends Object> context){\n  XMultiComponentFactory xmulticomponentfactory=null;\n  String stringUrl=(String)context.get(\"filenameFrom\");\n  String stringConvertedFile=(String)context.get(\"filenameTo\");\n  String inputMimeType=(String)context.get(\"inputMimeType\");\n  String outputMimeType=(String)context.get(\"outputMimeType\");\n  String oooHost=(String)context.get(\"oooHost\");\n  String oooPort=(String)context.get(\"oooPort\");\n  try {\n    xmulticomponentfactory=OpenOfficeWorker.getRemoteServer(oooHost,oooPort);\n    File inputFile=new File(stringUrl);\n    long fileSize=inputFile.length();\n    FileInputStream fis=new FileInputStream(inputFile);\n    ByteArrayOutputStream baos=new ByteArrayOutputStream((int)fileSize);\n    int c;\n    while ((c=fis.read()) != -1) {\n      baos.write(c);\n    }\n    OpenOfficeByteArrayInputStream oobais=new OpenOfficeByteArrayInputStream(baos.toByteArray());\n    OpenOfficeByteArrayOutputStream oobaos=OpenOfficeWorker.convertOODocByteStreamToByteStream(xmulticomponentfactory,oobais,inputMimeType,outputMimeType);\n    FileOutputStream fos=new FileOutputStream(stringConvertedFile);\n    fos.write(oobaos.toByteArray());\n    fos.close();\n    fis.close();\n    oobais.close();\n    oobaos.close();\n    Map results=ServiceUtil.returnSuccess();\n    return results;\n  }\n catch (  IOException e) {\n    Debug.logError(e,\"Error in OpenOffice operation: \",module);\n    return ServiceUtil.returnError(e.toString());\n  }\ncatch (  Exception e) {\n    Debug.logError(e,\"Error in OpenOffice operation: \",module);\n    return ServiceUtil.returnError(e.toString());\n  }\n}\n", "nl": "Use OpenOffice to convert documents between types"}
{"code": "private String readLogFile(){\n  String[] logFileName=Log_OC.getLogFileNames();\n  StringBuilder text=new StringBuilder();\n  BufferedReader br=null;\n  try {\n    String line;\n    for (int i=logFileName.length - 1; i >= 0; i--) {\n      File file=new File(mLogPath,logFileName[i]);\n      if (file.exists()) {\n        if (new FileReader(file).ready()) {\n          br=new BufferedReader(new FileReader(file));\n          while ((line=br.readLine()) != null) {\n            text.append(line);\n            text.append('\\n');\n          }\n        }\n      }\n    }\n  }\n catch (  IOException e) {\n    Log_OC.d(TAG,e.getMessage().toString());\n  }\n finally {\n    if (br != null) {\n      try {\n        br.close();\n      }\n catch (      IOException e) {\n      }\n    }\n  }\n  return text.toString();\n}\n", "nl": "Read and show log file info"}
{"code": "public void loadFromFile(String fileName) throws IOException {\n  System.err.print(\"Loading \" + Basic.getFileNameWithoutPath(fileName) + \": \");\n  try (BufferedReader r=new BufferedReader(new InputStreamReader(ResourceManager.getFileAsStream(fileName)))){\n    String aLine;\n    while ((aLine=r.readLine()) != null) {\n      if (aLine.length() > 0 && !aLine.startsWith(\"#\")) {\n        String[] tokens=Basic.split(aLine,'\\t');\n        if (tokens.length >= 2) {\n          if (tokens[0].trim().length() == 0)           continue;\n          int id=Integer.parseInt(tokens[0]);\n          String name=tokens[1];\n          name2id.put(name,id);\n          id2name.put(id,name);\n          boolean hasToolTip=tokens.length > 2 && tokens[tokens.length - 1].startsWith(\"\\\"\");\n          int tokensLengthWithoutToolTip=(hasToolTip ? tokens.length - 1 : tokens.length);\n          Integer rank=null;\n          if (tokensLengthWithoutToolTip == 3 && Basic.isInteger(tokens[2])) {\n            rank=Integer.parseInt(tokens[2]);\n          }\n else           if (tokensLengthWithoutToolTip == 4) {\n            rank=Integer.parseInt(tokens[3]);\n          }\n          if (hasToolTip) {\n            String quotedToolTip=tokens[tokens.length - 1];\n            id2toolTip.put(id,quotedToolTip.substring(1,quotedToolTip.length() - 1));\n          }\n          if (rank != null)           id2rank.put(id,rank);\n        }\n      }\n    }\n  }\n   System.err.println(String.format(\"%,9d\",id2name.size()));\n}\n", "nl": "load from file"}
{"code": "private static int writeAsTreeRec(ViewerBase viewer,NodeSet toUse,Node v,Writer writer,boolean showInternalLabels,boolean showUnassignedNodes,boolean simplify,int count) throws IOException {\n  if (v.getOutDegree() == 0) {\n    writer.write(Basic.toCleanName(viewer.getLabel(v)));\n    count++;\n  }\n else {\n    LinkedList<Edge> toVisit=new LinkedList<>();\n    for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n      Node w=e.getTarget();\n      if ((toUse != null && toUse.contains(w)) || (toUse == null && (showUnassignedNodes || !(w.getInfo() instanceof Integer && (Integer)w.getInfo() <= 0)))) {\n        toVisit.add(e);\n      }\n    }\n    if (!simplify || toVisit.size() > 1)     writer.write(\"(\");\n    boolean first=true;\n    for (    Edge e : toVisit) {\n      Node w=e.getTarget();\n      if (first)       first=false;\n else       writer.write(\",\");\n      count=writeAsTreeRec(viewer,toUse,w,writer,showInternalLabels,showUnassignedNodes,simplify,count);\n    }\n    if (!simplify || toVisit.size() > 1)     writer.write(\")\");\n    if (showInternalLabels && viewer.getLabel(v) != null && (!simplify || count != 1)) {\n      writer.write(Basic.toCleanName(viewer.getLabel(v)));\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "recursively write the tree"}
{"code": "public static long export(String classification,Collection<Integer> classIds,BlastMode blastMode,IConnector connector,String fileName,ProgressListener progressListener) throws IOException {\n  long countMatches=0;\n  try {\n    progressListener.setTasks(\"Export\",\"Writing selected matches\");\n    try (BufferedWriter w=new BufferedWriter(new FileWriter(fileName))){\n      w.write(blastMode.toString().toUpperCase() + \" file generated by MEGAN6\\n\\n\");\n      int maxProgress=100000 * classIds.size();\n      int currentProgress=0;\n      progressListener.setMaximum(maxProgress);\n      progressListener.setProgress(currentProgress);\n      int count=0;\n      for (      Integer classId : classIds) {\n        count++;\n        currentProgress=100000 * count;\n        IReadBlockIterator it=connector.getReadsIterator(classification,classId,0,10000,true,true);\n        long progressIncrement=100000 / (it.getMaximumProgress() + 1);\n        while (it.hasNext()) {\n          countMatches+=writeMatches(it.next(),w);\n          progressListener.setProgress(currentProgress);\n          currentProgress+=progressIncrement;\n        }\n      }\n    }\n   }\n catch (  CanceledException ex) {\n    System.err.println(\"USER CANCELED\");\n  }\n  return countMatches;\n}\n", "nl": "export all matches for given set of classids in the given classification"}
{"code": "public static int inflate(byte[] previous,int previousLength,byte[] current,int currentLength,byte[] result){\n  if (previous == null) {\n    System.arraycopy(current,0,result,0,currentLength);\n    return currentLength;\n  }\n  int length=0;\n  int start1=0;\n  int start2=0;\n  while (start1 < previousLength && start2 < currentLength) {\n    int end1=start1;\n    while (end1 < previousLength && previous[end1] != '\\t') {\n      end1++;\n    }\n    int end2=start2;\n    while (end2 < currentLength && current[end2] != '\\t') {\n      end2++;\n    }\n    if (current[start2] == '&' && end2 == start2 + 1) {\n      for (int i=start1; i < end1; i++)       result[length++]=previous[i];\n    }\n else {\n      for (int i=start2; i < end2; i++)       result[length++]=current[i];\n    }\n    if (end2 < currentLength)     result[length++]='\\t';\n    start1=end1 + 1;\n    start2=end2 + 1;\n  }\n  return length;\n}\n", "nl": "inflate the current SAM line by replacing all & by the corresponding field in the previous SAM line"}
{"code": "public void save() throws IOException {\n  try (OutputWriterLittleEndian outs=new OutputWriterLittleEndian(new FileRandomAccessReadWriteAdapter(fileName,\"rw\"))){\n    outs.writeLong(magicNumber);\n    outs.writeLong(version);\n    outs.writeLong(diamondBuild);\n    outs.writeLong(dbSeqs);\n    outs.writeLong(dbSeqsUsed);\n    outs.writeLong(dbLetters);\n    outs.writeLong(flags);\n    outs.writeLong(queryRecords);\n    outs.writeInt(modeRank);\n    outs.writeInt(gapOpen);\n    outs.writeInt(gapExtend);\n    outs.writeInt(reward);\n    outs.writeInt(penalty);\n    outs.writeInt(reserved1);\n    outs.writeInt(reserved2);\n    outs.writeInt(reserved3);\n    outs.writeDouble(k);\n    outs.writeDouble(lambda);\n    outs.writeDouble(reserved4);\n    outs.writeDouble(reserved5);\n    for (    byte a : scoreMatrix) {\n      outs.write(a);\n    }\n    scoreMatrixName=Basic.toString(scoreMatrix);\n    for (    long a : blockSize) {\n      outs.writeLong(a);\n    }\n    for (    byte a : blockTypeRank) {\n      outs.write(a);\n    }\n  }\n }\n", "nl": "read the header of a DAA file and all reference names"}
{"code": "protected void handleTargetTextUnit(ITextUnit textUnit){\n  if (!textUnit.isTranslatable()) {\n    return;\n  }\n  Locale targetLocale=localeService.findByBcp47Tag(targetLocaleId.toBCP47());\n  String name=textUnit.getName();\n  String sourceContent=textUnit.getSource().toString();\n  String translation=textUnit.getTarget(targetLocaleId).toString();\n  ImportExportNote importExportNote=textUnitUtils.getImportExportNote(textUnit);\n  if (!Strings.isNullOrEmpty(translation)) {\n    Long tmTextUnitId=tmTextUnitIdsByMd5ForAsset.get(tmService.computeTMTextUnitMD5(name,sourceContent,importExportNote.getSourceComment()));\n    if (tmTextUnitId == null) {\n      String msg=\"Trying to add a translation to an non existing text unit, name: \" + name + \", comment: \"+ importExportNote.getSourceComment()+ \", source: \"+ sourceContent;\n      logger.error(msg);\n      throw new RuntimeException(msg);\n    }\n    TMTextUnitVariant addTMTextUnitVariant=null;\n    if (updateTM) {\n      logger.debug(\"Import assuming there is already some translations in the TM\");\n      addTMTextUnitVariant=tmService.addCurrentTMTextUnitVariant(tmTextUnitId,targetLocale.getId(),translation,importExportNote.getStatus(),importExportNote.isIncludedInLocalizedFile(),importExportNote.getCreatedDate());\n    }\n else {\n      logger.debug(\"Import assuming there is no translation in the TM yet (optimized, don't check for update)\");\n      addTMTextUnitVariant=tmService.addTMTextUnitVariant(tmTextUnitId,targetLocale.getId(),translation,importExportNote.getTargetComment(),importExportNote.getStatus(),importExportNote.isIncludedInLocalizedFile(),importExportNote.getCreatedDate());\n      tmService.makeTMTextUnitVariantCurrent(asset.getRepository().getTm().getId(),tmTextUnitId,targetLocale.getId(),addTMTextUnitVariant.getId());\n    }\n    for (    TMTextUnitVariantComment variantComment : importExportNote.getVariantComments()) {\n      tmTextUnitVariantCommentService.addComment(addTMTextUnitVariant.getId(),variantComment.getType(),variantComment.getSeverity(),variantComment.getContent());\n    }\n  }\n else {\n    logger.debug(\"Empty translation for name: {}, skip it\",name);\n  }\n}\n", "nl": "Import target text units into the TM"}
{"code": "public synchronized void erase(){\n  if (fileTable != null) {\nsynchronized (this) {\n      Set<Object> keys=new HashSet<Object>();\n      try {\n        addAllFileTableKeys(keys);\n      }\n catch (      IOException e) {\n        Debug.logError(e,module);\n      }\n      for (      Object key : keys) {\n        try {\n          V value=fileTable.get(key);\n          noteRemoval(toKey(key),value);\n          removeHitCount.incrementAndGet();\n          fileTable.remove(key);\n          jdbmMgr.commit();\n        }\n catch (        IOException e) {\n          Debug.logError(e,module);\n        }\n      }\n    }\n    memoryTable.clear();\n  }\n else {\n    Iterator<Map.Entry<Object,CacheLine<V>>> it=memoryTable.entrySet().iterator();\n    while (it.hasNext()) {\n      Map.Entry<Object,CacheLine<V>> entry=it.next();\n      noteRemoval(toKey(entry.getKey()),entry.getValue().getValue());\n      removeHitCount.incrementAndGet();\n      it.remove();\n    }\n  }\n}\n", "nl": "Removes all elements from this cache"}
{"code": "private static boolean calculateGap(Rectangle a,Rectangle b,Rectangle gap){\n  if (a.intersects(b)) {\n    gap.width=0;\n    return false;\n  }\n  int ax1=a.x;\n  int ax2=a.x + a.width;\n  int ay1=a.y;\n  int ay2=a.y + a.height;\n  int bx1=b.x;\n  int bx2=b.x + b.width;\n  int by1=b.y;\n  int by2=b.y + b.height;\n  int xOverlap=Math.min(ax2,bx2) - Math.max(ax1,bx1);\n  int yOverlap=Math.min(ay2,by2) - Math.max(ay1,by1);\n  if (xOverlap <= 0 && yOverlap <= 0) {\n    gap.width=0;\n    return false;\n  }\n  if (xOverlap > 0) {\n    gap.x=Math.max(ax1,bx1);\n    gap.y=(ay1 > by1) ? by2 : ay2;\n    gap.width=xOverlap;\n    gap.height=-yOverlap;\n  }\n  if (yOverlap > 0) {\n    gap.x=(ax1 > bx1) ? bx2 : ax2;\n    gap.y=Math.max(ay1,by1);\n    gap.width=-xOverlap;\n    gap.height=yOverlap;\n  }\n  return true;\n}\n", "nl": "Calculate the gap rectangle between two rectangles"}
{"code": "public Matrix solve(Matrix B){\n  if (B.getRowDimension() != m) {\n    throw new IllegalArgumentException(\"Matrix row dimensions must agree.\");\n  }\n  if (!this.isFullRank()) {\n    throw new RuntimeException(\"Matrix is rank deficient.\");\n  }\n  int nx=B.getColumnDimension();\n  double[][] X=B.getArrayCopy();\n  for (int k=0; k < n; k++) {\n    for (int j=0; j < nx; j++) {\n      double s=0.0;\n      for (int i=k; i < m; i++) {\n        s+=QR[i][k] * X[i][j];\n      }\n      s=-s / QR[k][k];\n      for (int i=k; i < m; i++) {\n        X[i][j]+=s * QR[i][k];\n      }\n    }\n  }\n  for (int k=n - 1; k >= 0; k--) {\n    for (int j=0; j < nx; j++) {\n      X[k][j]/=Rdiag[k];\n    }\n    for (int i=0; i < k; i++) {\n      for (int j=0; j < nx; j++) {\n        X[i][j]-=X[k][j] * QR[i][k];\n      }\n    }\n  }\n  return (new Matrix(X,n,nx).getMatrix(0,n - 1,0,nx - 1));\n}\n", "nl": "Least squares solution of A*X = B"}
{"code": "public Item unEquipItem(int itemUniqueId,long slot){\n  if (owner.getInventory().isFull()) {\n    return null;\n  }\nsynchronized (equipment) {\n    Item itemToUnequip=null;\n    for (    Item item : equipment.values()) {\n      if (item.getObjectId() == itemUniqueId) {\n        itemToUnequip=item;\n        break;\n      }\n    }\n    if (itemToUnequip == null || !itemToUnequip.isEquipped()) {\n      return null;\n    }\n    if (itemToUnequip.getEquipmentSlot() == ItemSlot.MAIN_HAND.getSlotIdMask()) {\n      Item ohWeapon=equipment.get(ItemSlot.SUB_HAND.getSlotIdMask());\n      if (ohWeapon != null && ohWeapon.getItemTemplate().isWeapon()) {\n        if (owner.getInventory().getFreeSlots() < 2) {\n          return null;\n        }\n        unEquip(ItemSlot.SUB_HAND.getSlotIdMask());\n      }\n    }\n    if (itemToUnequip.getItemTemplate().isArmor() && itemToUnequip.getItemTemplate().getCategory() == ItemCategory.SHARD) {\n      owner.unsetState(CreatureState.POWERSHARD);\n      PacketSendUtility.sendPacket(owner,new SM_EMOTION(owner,EmotionType.POWERSHARD_OFF,0,0));\n    }\n    if (!StigmaService.notifyUnequipAction(owner,itemToUnequip)) {\n      return null;\n    }\n    unEquip(itemToUnequip.getEquipmentSlot());\n    return itemToUnequip;\n  }\n}\n", "nl": "Called when CM_EQUIP_ITEM packet arrives with action 1"}
{"code": "@Override public boolean start() throws ContainerException {\n  ContainerConfig.Container cfg=ContainerConfig.getContainer(name,configFile);\n  String dispatcherName=ContainerConfig.getPropertyValue(cfg,\"dispatcher-name\",\"JavaMailDispatcher\");\n  String delegatorName=ContainerConfig.getPropertyValue(cfg,\"delegator-name\",\"default\");\n  this.deleteMail=\"true\".equals(ContainerConfig.getPropertyValue(cfg,\"delete-mail\",\"false\"));\n  this.delegator=DelegatorFactory.getDelegator(delegatorName);\n  this.dispatcher=ServiceContainer.getLocalDispatcher(dispatcherName,delegator);\n  this.timerDelay=ContainerConfig.getPropertyValue(cfg,\"poll-delay\",300000);\n  this.maxSize=ContainerConfig.getPropertyValue(cfg,\"maxSize\",1000000);\n  String runAsUser=ContainerConfig.getPropertyValue(cfg,\"run-as-user\",\"system\");\n  try {\n    this.userLogin=EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\",runAsUser).queryOne();\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,\"Unable to load run-as-user UserLogin; cannot start container\",module);\n    return false;\n  }\n  ServiceMcaUtil.readConfig();\n  List<ContainerConfig.Container.Property> configs=cfg.getPropertiesWithValue(\"store-listener\");\n  for (  ContainerConfig.Container.Property prop : configs) {\n    Session session=this.makeSession(prop);\n    Store store=this.getStore(session);\n    if (store != null) {\n      stores.put(store,session);\n      store.addStoreListener(new LoggingStoreListener());\n    }\n  }\n  if (UtilValidate.isNotEmpty(stores)) {\n    pollTimer.scheduleAtFixedRate(new PollerTask(dispatcher,userLogin),timerDelay,timerDelay,TimeUnit.MILLISECONDS);\n  }\n else {\n    Debug.logWarning(\"No JavaMail Store(s) configured; poller disabled.\",module);\n  }\n  return true;\n}\n", "nl": "Start the container"}
{"code": "private void draw(){\n  if (animate && rectangle != null) {\n    Rectangle2D visibleRect=panel.getVisibleRect();\n    double xMin=Math.max(rectangle.getX(),visibleRect.getX());\n    double xMax=Math.min(rectangle.getX() + rectangle.getWidth(),visibleRect.getX() + visibleRect.getWidth() - 2);\n    double width=xMax - xMin;\n    double yMin=Math.max(rectangle.getY(),visibleRect.getY());\n    double yMax=Math.min(rectangle.getY() + rectangle.getHeight(),visibleRect.getY() + visibleRect.getHeight() - 2);\n    double height=yMax - yMin;\n    drawRectangle.setRect(xMin,yMin,width,height);\n    Graphics2D gc=(Graphics2D)panel.getGraphics();\n    if (gc != null) {\n      gc.setStroke(backgroundStroke);\n      gc.setColor(Color.WHITE);\n      gc.draw(drawRectangle);\n      gc.setColor(highlightColor);\n      if (even) {\n        gc.setStroke(evenStroke);\n        even=false;\n      }\n else {\n        gc.setStroke(oddStroke);\n        even=true;\n      }\n      gc.draw(drawRectangle);\n      gc.setStroke(basicStroke);\n    }\n  }\n}\n", "nl": "draws the blinking rectangle"}
{"code": "protected static ModelRecord findModelForLine(String line,int lineNum,ModelDataFile modelDataFile) throws DataFileException {\n  ModelRecord modelRecord=null;\n  for (  ModelRecord curModelRecord : modelDataFile.records) {\n    if (curModelRecord.tcPosition < 0) {\n      modelRecord=curModelRecord;\n      break;\n    }\n    String typeCode=line.substring(curModelRecord.tcPosition,curModelRecord.tcPosition + curModelRecord.tcLength);\n    if (curModelRecord.typeCode.length() > 0) {\n      if (typeCode != null && typeCode.equals(curModelRecord.typeCode)) {\n        modelRecord=curModelRecord;\n        break;\n      }\n    }\n else     if (curModelRecord.tcMin.length() > 0 || curModelRecord.tcMax.length() > 0) {\n      if (curModelRecord.tcIsNum) {\n        long typeCodeNum=Long.parseLong(typeCode);\n        if ((curModelRecord.tcMinNum < 0 || typeCodeNum >= curModelRecord.tcMinNum) && (curModelRecord.tcMaxNum < 0 || typeCodeNum <= curModelRecord.tcMaxNum)) {\n          modelRecord=curModelRecord;\n          break;\n        }\n      }\n else {\n        if ((typeCode.compareTo(curModelRecord.tcMin) >= 0) && (typeCode.compareTo(curModelRecord.tcMax) <= 0)) {\n          modelRecord=curModelRecord;\n          break;\n        }\n      }\n    }\n  }\n  if (modelRecord == null) {\n    throw new DataFileException(\"Could not find record definition for line \" + lineNum + \"; first bytes: \"+ line.substring(0,(line.length() > 5) ? 5 : line.length()));\n  }\n  return modelRecord;\n}\n", "nl": "Searches through the record models to find one with a matching type-code, if no type-code exists that model will always be used if it gets to it"}
{"code": "boolean waitForNext(int iteration){\n  try {\n    _sharedObjectListLock.readLock().lock();\n    if (_accumulatedItems.size() > iteration) {\n      if (_logger.isLoggable(Level.FINEST))       _logger.finest(\"getting next item from the shared iterator source buffer [\" + _identifier + \"]\");\n      return true;\n    }\n  }\n  finally {\n    _sharedObjectListLock.readLock().unlock();\n  }\n  try {\n    _sharedObjectListLock.writeLock().lock();\n    if (_accumulatedItems.size() > iteration) {\n      if (_logger.isLoggable(Level.FINEST))       _logger.finest(\"getting next item from the shared iterator source buffer [\" + _identifier + \"]\");\n      return true;\n    }\n    if (_closed)     return false;\n    if (_sourceDataIterator == null || !_sourceDataIterator.hasNext()) {\n      sourceIteratorExhaushted();\n      return false;\n    }\n    if (_logger.isLoggable(Level.FINEST))     _logger.finest(\"getting next item from the shared iterator source wrapped iterator [\" + _identifier + \"]\");\n    T next=_sourceDataIterator.next();\n    _accumulatedItems.add(next);\n    return true;\n  }\n  finally {\n    _sharedObjectListLock.writeLock().unlock();\n  }\n}\n", "nl": "Called by the shared iterators, this method blocks until a next element is available"}
{"code": "public static QueryResponseJSON extractQueryResponseJSON(QueryInfo queryInfo,QuerySchema qSchema,List<BigInteger> parts) throws PIRException {\n  QueryResponseJSON qrJSON=new QueryResponseJSON(queryInfo);\n  DataSchema dSchema=DataSchemaRegistry.get(qSchema.getDataSchemaName());\n  int numArrayElementsToReturn=SystemConfiguration.getIntProperty(\"pir.numReturnArrayElements\",1);\n  logger.debug(\"parts.size() = \" + parts.size());\n  int partsIndex=0;\n  if (queryInfo.getEmbedSelector()) {\n    String selectorFieldName=qSchema.getSelectorName();\n    String type=dSchema.getElementType(selectorFieldName);\n    String embeddedSelector=getEmbeddedSelectorFromPartitions(parts,partsIndex,type,dSchema.getPartitionerForElement(selectorFieldName));\n    qrJSON.setSelector(embeddedSelector);\n    partsIndex+=4;\n    logger.debug(\"Extracted embedded selector = \" + embeddedSelector + \" parts.size() = \"+ parts.size());\n  }\n  List<String> dataFieldsToExtract=qSchema.getElementNames();\n  for (  String fieldName : dataFieldsToExtract) {\n    int numElements=1;\n    if (dSchema.isArrayElement(fieldName)) {\n      numElements=numArrayElementsToReturn;\n    }\n    for (int i=0; i < numElements; ++i) {\n      String type=dSchema.getElementType(fieldName);\n      logger.debug(\"Extracting value for fieldName = \" + fieldName + \" type = \"+ type+ \" partsIndex = \"+ partsIndex);\n      Object element=dSchema.getPartitionerForElement(fieldName).fromPartitions(parts,partsIndex,type);\n      qrJSON.setMapping(fieldName,element);\n      partsIndex+=dSchema.getPartitionerForElement(fieldName).getNumPartitions(type);\n      logger.debug(\"Adding qrJSON element = \" + element + \" element.getClass() = \"+ element.getClass());\n    }\n  }\n  return qrJSON;\n}\n", "nl": "Method to convert the given BigInteger raw data element partitions to a QueryResponseJSON object based upon the given queryType"}
{"code": "private void addDescriptors(List<FoldingDescriptor> descriptors,ASTNode node){\n  IElementType type=node.getElementType();\n  if (type == BuildElementTypes.FUNCTION_STATEMENT) {\n    ASTNode colon=node.findChildByType(BuildToken.fromKind(TokenKind.COLON));\n    if (colon == null) {\n      return;\n    }\n    ASTNode stmtList=node.findChildByType(BuildElementTypes.STATEMENT_LIST);\n    if (stmtList == null) {\n      return;\n    }\n    int start=colon.getStartOffset() + 1;\n    int end=endOfList(stmtList);\n    descriptors.add(new FoldingDescriptor(node,range(start,end)));\n  }\n else   if (type == BuildElementTypes.FUNCALL_EXPRESSION || type == BuildElementTypes.LOAD_STATEMENT) {\n    ASTNode listNode=type == BuildElementTypes.FUNCALL_EXPRESSION ? node.findChildByType(BuildElementTypes.ARGUMENT_LIST) : node;\n    if (listNode == null) {\n      return;\n    }\n    ASTNode lParen=listNode.findChildByType(BuildToken.fromKind(TokenKind.LPAREN));\n    ASTNode rParen=listNode.findChildByType(BuildToken.fromKind(TokenKind.RPAREN));\n    if (lParen == null || rParen == null) {\n      return;\n    }\n    int start=lParen.getStartOffset() + 1;\n    int end=rParen.getTextRange().getEndOffset() - 1;\n    descriptors.add(new FoldingDescriptor(node,range(start,end)));\n  }\n}\n", "nl": "Only folding top-level statements"}
{"code": "public static void appendMDString(final String alignedQuery,final String alignedReference,final StringBuilder buffer){\n  buffer.append(\"MD:Z:\");\n  int countMatches=0;\n  boolean inDeletion=false;\n  for (int i=0; i < alignedQuery.length(); i++) {\n    final char qChar=alignedQuery.charAt(i);\n    final char rChar=alignedReference.charAt(i);\n    if (qChar == '-') {\n      if (countMatches > 0) {\n        buffer.append(countMatches);\n        countMatches=0;\n      }\n      if (!inDeletion) {\n        buffer.append(\"^\");\n        inDeletion=true;\n      }\n      buffer.append(rChar);\n    }\n else     if (rChar != '-') {\n      if (qChar == rChar) {\n        countMatches++;\n      }\n else {\n        if (inDeletion)         buffer.append(\"0\");\n        if (countMatches > 0) {\n          buffer.append(countMatches);\n          countMatches=0;\n        }\n        buffer.append(rChar);\n      }\n      if (inDeletion)       inDeletion=false;\n    }\n  }\n  if (countMatches > 0)   buffer.append(countMatches);\n else   if (inDeletion)   buffer.append(0);\n}\n", "nl": "append the MD string"}
{"code": "@SuppressWarnings(\"unchecked\") @EdmFunctionImport(name=\"CreateCustomerReview\",entitySet=\"CustomerReviews\",returnType=@ReturnType(type=Type.ENTITY,isCollection=false)) public CustomerReview createCustomerReview(@EdmFunctionImportParameter(name=\"ProductId\") String productId,@EdmFunctionImportParameter(name=\"FirstName\") String firstName,@EdmFunctionImportParameter(name=\"LastName\") String lastName,@EdmFunctionImportParameter(name=\"Rating\") String rating,@EdmFunctionImportParameter(name=\"CreationDate\") String creationDate,@EdmFunctionImportParameter(name=\"Comment\") String comment) throws ODataException, ParseException {\n  EntityManagerFactory emf=Utility.getEntityManagerFactory();\n  EntityManager em=emf.createEntityManager();\n  Product prod=null;\n  CustomerReview customerReview=null;\n  try {\n    em.getTransaction().begin();\n    prod=em.find(Product.class,productId);\n    try {\n      customerReview=new CustomerReview();\n      customerReview.setComment(comment);\n      Calendar cal=Calendar.getInstance();\n      cal.setTime(new Date(Long.parseLong(creationDate)));\n      customerReview.setCreationDate(cal);\n      customerReview.setFirstName(firstName);\n      customerReview.setLastName(lastName);\n      customerReview.setRating(Integer.parseInt(rating));\n      customerReview.setProductId(productId);\n      customerReview.setProduct(prod);\n      em.persist(customerReview);\n      prod.addReview(customerReview);\n      em.getTransaction().commit();\n      return customerReview;\n    }\n catch (    NoResultException e) {\n      throw new ODataApplicationException(\"Error creating customer review:\",Locale.ENGLISH,HttpStatusCodes.BAD_REQUEST);\n    }\n  }\n  finally {\n    em.close();\n  }\n}\n", "nl": "Function Import implementation for getting customer reviews created"}
{"code": "public MapOptions build(){\n  MapOptions options=new MapOptions();\n  options.center=this.center;\n  options.zoom=this.zoom;\n  options.minZoom=this.minZoom;\n  options.layers=this.layers;\n  options.maxZoom=this.maxZoom;\n  options.maxBounds=this.maxBounds;\n  options.dragging=this.dragging;\n  options.touchZoom=this.touchZoom;\n  options.scrollWheelZoom=this.scrollWheelZoom;\n  options.doubleClickZoom=this.doubleClickZoom;\n  options.boxZoom=this.boxZoom;\n  options.tap=this.tap;\n  options.tapTolerance=this.tapTolerance;\n  options.trackResize=this.trackResize;\n  options.worldCopyJump=this.worldCopyJump;\n  options.closePopupOnClick=this.closePopupOnClick;\n  options.bounceAtZoomLimits=this.bounceAtZoomLimits;\n  options.keyboard=this.keyboard;\n  options.keyboardPanOffset=this.keyboardPanOffset;\n  options.keyboardZoomOffset=this.keyboardPanOffset;\n  options.inertia=this.inertia;\n  options.inertiaDeceleration=this.inertiaDeceleration;\n  options.inertiaMaxSpeed=this.inertiaMaxSpeed;\n  options.inertiaThreshold=this.inertiaThreshold;\n  options.zoomControl=this.zoomControl;\n  options.attributionControl=this.attributionControl;\n  options.fadeAnimation=this.fadeAnimation;\n  options.zoomAnimation=this.zoomAnimation;\n  options.zoomAnimationThreshold=this.zoomAnimationThreshold;\n  options.markerZoomAnimation=this.markerZoomAnimation;\n  return options;\n}\n", "nl": "Builds the options"}
{"code": "private Bitmap compress(String imagePath,int width,int height){\n  BitmapFactory.Options options=new BitmapFactory.Options();\n  options.inJustDecodeBounds=true;\n  BitmapFactory.decodeFile(imagePath,options);\n  int outH=options.outHeight;\n  int outW=options.outWidth;\n  int inSampleSize=1;\n  if (outH > height || outW > width) {\n    int halfH=outH / 2;\n    int halfW=outW / 2;\n    while ((halfH / inSampleSize) > height && (halfW / inSampleSize) > width) {\n      inSampleSize*=2;\n    }\n  }\n  options.inSampleSize=inSampleSize;\n  options.inJustDecodeBounds=false;\n  int heightRatio=(int)Math.ceil(options.outHeight / (float)height);\n  int widthRatio=(int)Math.ceil(options.outWidth / (float)width);\n  if (heightRatio > 1 || widthRatio > 1) {\n    if (heightRatio > widthRatio) {\n      options.inSampleSize=heightRatio;\n    }\n else {\n      options.inSampleSize=widthRatio;\n    }\n  }\n  options.inJustDecodeBounds=false;\n  return BitmapFactory.decodeFile(imagePath,options);\n}\n", "nl": "obtain the thumbnail that specify the size"}
{"code": "protected void splitLU(FieldMatrix<Fraction> lu,Fraction[][] lowerData,Fraction[][] upperData){\n  if (!lu.isSquare()) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.NON_SQUARE_MATRIX,lu.getRowDimension(),lu.getColumnDimension());\n  }\n  if (lowerData.length != lowerData[0].length) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,lowerData.length,lowerData[0].length);\n  }\n  if (upperData.length != upperData[0].length) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,upperData.length,upperData[0].length);\n  }\n  if (lowerData.length != upperData.length) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,lowerData.length,upperData.length);\n  }\n  if (lowerData.length != lu.getRowDimension()) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.DIMENSIONS_MISMATCH,lowerData.length,lu.getRowDimension());\n  }\n  int n=lu.getRowDimension();\n  for (int i=0; i < n; i++) {\n    for (int j=0; j < n; j++) {\n      if (j < i) {\n        lowerData[i][j]=lu.getEntry(i,j);\n        upperData[i][j]=Fraction.ZERO;\n      }\n else       if (i == j) {\n        lowerData[i][j]=Fraction.ONE;\n        upperData[i][j]=lu.getEntry(i,j);\n      }\n else {\n        lowerData[i][j]=Fraction.ZERO;\n        upperData[i][j]=lu.getEntry(i,j);\n      }\n    }\n  }\n}\n", "nl": "extracts the l  and u matrices from compact lu representation"}
{"code": "private String printToScreenOneLine(List<IntervalFeature> listToPrint){\n  List<String> printable=new ArrayList<String>();\n  for (int i=0; i < this.getGc().getMapping().size(); i++) {\n    printable.add(\" \");\n  }\n  for (  IntervalFeature intervalFeature : listToPrint) {\n    if (intervalFeature.getScreenFrom() == -1) {\n      continue;\n    }\n    intervalFeature.setGtfAttributeForName(this.getGtfAttributeForName());\n    String nameOnFeature=intervalFeature.getName().trim() + \"_\";\n    int relPos=0;\n    for (int j=intervalFeature.getScreenFrom(); j <= intervalFeature.getScreenTo(); j++) {\n      String text=intervalFeature.assignTextToFeature(this.isNoFormat());\n      if ((intervalFeature.getScreenTo() - intervalFeature.getScreenFrom() + 1) > 4 && j < intervalFeature.getScreenTo() && relPos < nameOnFeature.length() && !nameOnFeature.equals(\"._\")) {\n        Character x=nameOnFeature.charAt(relPos);\n        if (this.isNoFormat()) {\n          text=Character.toString(x);\n        }\n else {\n          text=FormatGTF.format(x,intervalFeature.getStrand());\n        }\n        relPos+=1;\n      }\n      printable.set(j,text);\n    }\n  }\n  return StringUtils.join(printable,\"\");\n}\n", "nl": "Return a string of a single line of (typically de-stacked) reads"}
{"code": "public void handleStep(final ODEStateInterpolator interpolator,final boolean isLast) throws MathIllegalStateException {\n  if (last == null) {\n    first=interpolator.getPreviousState();\n    last=first;\n    forward=interpolator.isForward();\n    if (!forward) {\n      h=-h;\n    }\n  }\n  double nextTime=(mode == StepNormalizerMode.INCREMENT) ? last.getTime() + h : (FastMath.floor(last.getTime() / h) + 1) * h;\n  if (mode == StepNormalizerMode.MULTIPLES && Precision.equals(nextTime,last.getTime(),1)) {\n    nextTime+=h;\n  }\n  boolean nextInStep=isNextInStep(nextTime,interpolator);\n  while (nextInStep) {\n    doNormalizedStep(false);\n    last=interpolator.getInterpolatedState(nextTime);\n    nextTime+=h;\n    nextInStep=isNextInStep(nextTime,interpolator);\n  }\n  if (isLast) {\n    boolean addLast=bounds.lastIncluded() && last.getTime() != interpolator.getCurrentState().getTime();\n    doNormalizedStep(!addLast);\n    if (addLast) {\n      last=interpolator.getCurrentState();\n      doNormalizedStep(true);\n    }\n  }\n}\n", "nl": "Handle the last accepted step"}
{"code": "private float recursiveConnectedDistanceToRoot(ScoutWidget[] list,Direction direction){\n  if (isDistanceToRootCache(direction)) {\n    return mDistToRootCache[direction.getDirection()];\n  }\n  ConstraintAnchor.Type anchorType=lookupType(direction);\n  ConstraintAnchor anchor=mConstraintWidget.getAnchor(anchorType);\n  if (anchor == null || !anchor.isConnected()) {\n    return Float.NaN;\n  }\n  float margin=anchor.getMargin();\n  ConstraintAnchor toAnchor=anchor.getTarget();\n  ConstraintWidget toWidget=toAnchor.getOwner();\n  if (list[0].mConstraintWidget == toWidget) {\n    return margin;\n  }\n  if (toAnchor.getType() == anchorType) {\n    for (    ScoutWidget scoutWidget : list) {\n      if (scoutWidget.mConstraintWidget == toWidget) {\n        float dist=scoutWidget.recursiveConnectedDistanceToRoot(list,direction);\n        scoutWidget.cacheRootDistance(direction,dist);\n        return margin + dist;\n      }\n    }\n  }\n  if (toAnchor.getType() == lookupType(direction.getOpposite())) {\n    for (    ScoutWidget scoutWidget : list) {\n      if (scoutWidget.mConstraintWidget == toWidget) {\n        margin+=scoutWidget.getLength(direction);\n        float dist=scoutWidget.recursiveConnectedDistanceToRoot(list,direction);\n        scoutWidget.cacheRootDistance(direction,dist);\n        return margin + dist;\n      }\n    }\n  }\n  return Float.NaN;\n}\n", "nl": "Walk the widget connections to get the distance to the container in a direction"}
{"code": "private void clustering(int tagetClusterSize,String linkageType){\n  assert clusterList != null;\n  int minClusterOne=0;\n  int minClusterTwo=0;\n  double minDistance;\n  for (int i=clusterList.size(); i > tagetClusterSize; i--) {\n    minDistance=this.MINDISTANCE;\n    for (int j=0; j < clusterList.size(); j++) {\n      Cluster clusterOne=clusterList.get(j);\n      for (int k=(j + 1); k < clusterList.size(); k++) {\n        Cluster clusterTwo=clusterList.get(k);\n        double distance=getClusterDistance(clusterOne,clusterTwo,linkageType);\n        if (hasSimilarityMeasure()) {\n          if (distance < minDistance) {\n            minDistance=distance;\n            minClusterOne=j;\n            minClusterTwo=k;\n          }\n        }\n else {\n          if (distance > minDistance) {\n            minDistance=distance;\n            minClusterOne=j;\n            minClusterTwo=k;\n          }\n        }\n      }\n    }\n    Cluster clusterOne=clusterList.get(minClusterOne);\n    Cluster clusterTwo=clusterList.get(minClusterTwo);\n    clusterOne.mergeCluster(clusterTwo);\n    clusterList.remove(clusterTwo);\n  }\n  printClusterData();\n}\n", "nl": "Clustering with user-defined target cluster size"}
{"code": "public float calculateTableConfidence(Rectangle[] widgets){\n  int[][] bounds;\n  mValidTable=true;\n  bounds=new int[4][widgets.length];\n  for (int i=0; i < widgets.length; i++) {\n    Rectangle widget=widgets[i];\n    bounds[0][i]=widget.y;\n    bounds[1][i]=bounds[0][i] + widget.height;\n    bounds[2][i]=widget.x;\n    bounds[3][i]=bounds[2][i] + widget.width;\n  }\n  mRows=Utils.gaps(bounds[0],bounds[1]);\n  mCols=Utils.gaps(bounds[2],bounds[3]);\n  int[] r=Utils.cells(bounds[0],bounds[1]);\n  int[] c=Utils.cells(bounds[2],bounds[3]);\n  Rectangle[][] table=new Rectangle[mCols][mRows];\n  for (  Rectangle widget : widgets) {\n    int row=Utils.getPosition(r,widget.y,widget.y + widget.height);\n    int col=Utils.getPosition(c,widget.x,widget.x + widget.width);\n    if (row == -1 || col == -1) {\n      mValidTable=false;\n      return 0;\n    }\n    table[col][row]=widget;\n  }\n  float sumprob=0;\n  for (  Rectangle[] rec : table) {\n    float prob=alignmentProbability(rec);\n    sumprob=prob + sumprob - (sumprob * prob);\n  }\n  return sumprob;\n}\n", "nl": "calculate the probability of this being a table"}
{"code": "private List<Phone> parseIntoPhones() throws Exception {\n  phones=new ArrayList<Phone>(units.size() / 2);\n  int u=0;\n  while (u < units.size()) {\n    SelectedUnit unit=units.get(u);\n    HalfPhoneTarget target=(HalfPhoneTarget)unit.getTarget();\n    if (target.isLeftHalf()) {\n      if (u < units.size() - 1) {\n        SelectedUnit nextUnit=units.get(u + 1);\n        HalfPhoneTarget nextTarget=(HalfPhoneTarget)nextUnit.getTarget();\n        if (nextTarget.isRightHalf()) {\n          phones.add(new Phone(unit,nextUnit,sampleRate));\n          u++;\n        }\n else {\n          phones.add(new Phone(unit,null,sampleRate));\n        }\n      }\n else {\n        phones.add(new Phone(unit,null,sampleRate));\n      }\n    }\n else {\n      phones.add(new Phone(null,unit,sampleRate));\n    }\n    u++;\n  }\n  assert u == units.size();\n  insertTargetF0Values();\n  return phones;\n}\n", "nl": "Parse a list of selected units into the corresponding phone segments"}
{"code": "private CompletableFuture<Void> delete(boolean failIfHasSubscriptions){\n  CompletableFuture<Void> deleteFuture=new CompletableFuture<>();\n  lock.writeLock().lock();\n  try {\n    if (isFenced) {\n      log.warn(\"[{}] Topic is already being closed or deleted\",topic);\n      deleteFuture.completeExceptionally(new TopicFencedException(\"Topic is already fenced\"));\n      return deleteFuture;\n    }\n    if (usageCount.get() == 0) {\n      isFenced=true;\n      List<CompletableFuture<Void>> futures=Lists.newArrayList();\n      if (failIfHasSubscriptions) {\n        if (!subscriptions.isEmpty()) {\n          isFenced=false;\n          deleteFuture.completeExceptionally(new TopicBusyException(\"Topic has subscriptions\"));\n          return deleteFuture;\n        }\n      }\n else {\n        subscriptions.forEach(null);\n      }\n      FutureUtil.waitForAll(futures).whenComplete(null);\n    }\n else {\n      deleteFuture.completeExceptionally(new TopicBusyException(\"Topic has \" + usageCount.get() + \" connected producers/consumers\"));\n    }\n  }\n  finally {\n    lock.writeLock().unlock();\n  }\n  return deleteFuture;\n}\n", "nl": "Delete the managed ledger associated with this topic"}
{"code": "public static Map<String,Object> deleteContactMech(DispatchContext ctx,Map<String,? extends Object> context){\n  Map<String,Object> result=FastMap.newInstance();\n  Delegator delegator=ctx.getDelegator();\n  Security security=ctx.getSecurity();\n  GenericValue userLogin=(GenericValue)context.get(\"userLogin\");\n  Locale locale=(Locale)context.get(\"locale\");\n  String partyId=ServiceUtil.getPartyIdCheckSecurity(userLogin,security,context,result,\"PARTYMGR\",\"_PCM_DELETE\");\n  if (result.size() > 0)   return result;\n  String contactMechId=(String)context.get(\"contactMechId\");\n  GenericValue partyContactMech=null;\n  try {\n    partyContactMech=EntityQuery.use(delegator).from(\"PartyContactMech\").where(\"partyId\",partyId,\"contactMechId\",contactMechId).orderBy(\"fromDate\").filterByDate().queryFirst();\n  }\n catch (  GenericEntityException e) {\n    Debug.logWarning(e.toString(),module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resourceError,\"contactmechservices.could_not_delete_contact_info_read\",UtilMisc.toMap(\"errMessage\",e.getMessage()),locale));\n  }\n  if (partyContactMech == null) {\n    return ServiceUtil.returnError(UtilProperties.getMessage(resourceError,\"contactmechservices.could_not_delete_contact_info_no_contact_found\",locale));\n  }\n  partyContactMech.set(\"thruDate\",UtilDateTime.nowTimestamp());\n  try {\n    partyContactMech.store();\n  }\n catch (  GenericEntityException e) {\n    Debug.logWarning(e.toString(),module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resourceError,\"contactmechservices.could_not_delete_contact_info_write\",locale));\n  }\n  result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_SUCCESS);\n  return result;\n}\n", "nl": "Deletes a ContactMech <b>security check</b>: userLogin partyId must equal partyId, or must have PARTYMGR_DELETE permission"}
{"code": "private void createShader(){\n  mDefaultAngularFrequency=2.0f * Math.PI / DEFAULT_WAVE_LENGTH_RATIO / getWidth();\n  mDefaultAmplitude=getHeight() * DEFAULT_AMPLITUDE_RATIO;\n  mDefaultWaterLevel=getHeight() * DEFAULT_WATER_LEVEL_RATIO;\n  mDefaultWaveLength=getWidth();\n  Bitmap bitmap=Bitmap.createBitmap(getWidth(),getHeight(),Bitmap.Config.ARGB_8888);\n  Canvas canvas=new Canvas(bitmap);\n  Paint wavePaint=new Paint();\n  wavePaint.setStrokeWidth(2);\n  wavePaint.setAntiAlias(true);\n  wavePaint.setColor(mFrontWaveColor);\n  final int endX=getWidth() + 1;\n  final int endY=getHeight() + 1;\n  float[] waveY=new float[endX];\n  wavePaint.setColor(mBehindWaveColor);\n  for (int beginX=0; beginX < endX; beginX++) {\n    double wx=beginX * mDefaultAngularFrequency;\n    float beginY=(float)(mDefaultWaterLevel + mDefaultAmplitude * Math.sin(wx));\n    canvas.drawLine(beginX,beginY,beginX,-1,wavePaint);\n    waveY[beginX]=beginY;\n  }\n  wavePaint.setColor(mFrontWaveColor);\n  final int wave2Shift=(int)(mDefaultWaveLength / 4);\n  for (int beginX=0; beginX < endX; beginX++) {\n    canvas.drawLine(beginX,waveY[(beginX + wave2Shift) % endX],beginX,-1,wavePaint);\n  }\n  mWaveShader=new BitmapShader(bitmap,Shader.TileMode.REPEAT,Shader.TileMode.CLAMP);\n  mViewPaint.setShader(mWaveShader);\n}\n", "nl": "Create the shader with default waves which repeat horizontally, and clamp vertically"}
{"code": "private boolean hasSideEffectsOrCallsSink(SootMethod method,Set<SootMethod> runList){\n  if (!method.hasActiveBody())   return false;\n  Boolean hasSideEffects=methodSideEffects.get(method);\n  if (hasSideEffects != null)   return hasSideEffects;\n  Boolean hasSink=methodSinks.get(method);\n  if (hasSink != null)   return hasSink;\n  if (!runList.add(method))   return false;\n  if (methodIsAndroidStub(method)) {\n    methodSideEffects.put(method,false);\n    return false;\n  }\n  for (  Unit u : method.getActiveBody().getUnits()) {\n    if (u instanceof AssignStmt) {\n      AssignStmt assign=(AssignStmt)u;\n      if (assign.getLeftOp() instanceof FieldRef || assign.getLeftOp() instanceof ArrayRef) {\n        methodSideEffects.put(method,true);\n        return true;\n      }\n    }\n    Stmt s=(Stmt)u;\n    if (taintWrapper != null && taintWrapper.supportsCallee(s)) {\n      methodSideEffects.put(method,true);\n      return true;\n    }\n    if (s.containsInvokeExpr()) {\n      if (sourceSinkManager != null && sourceSinkManager.isSink((Stmt)u,icfg,null)) {\n        methodSinks.put(method,true);\n        return true;\n      }\n      for (Iterator<Edge> edgeIt=Scene.v().getCallGraph().edgesOutOf(u); edgeIt.hasNext(); ) {\n        Edge e=edgeIt.next();\n        if (hasSideEffectsOrCallsSink(e.getTgt().method(),runList))         return true;\n      }\n    }\n  }\n  methodSideEffects.put(method,false);\n  return false;\n}\n", "nl": "Checks whether the given method or one of its transitive callees has side-effects or calls a sink method"}
{"code": "@Path(path=\"popup2\",login=true,access=\"access.user.query\") public void popup2(){\n  String access=this.getString(\"access\");\n  List<User> list=null;\n  if (!X.isEmpty(access)) {\n    list=User.loadByAccess(access);\n  }\n else {\n    Beans<User> bs=User.load(W.create().and(X.ID,0,W.OP_GT),0,1000);\n    if (bs != null) {\n      list=bs.getList();\n    }\n  }\n  JSON jo=new JSON();\n  if (list != null && list.size() > 0) {\n    List<JSON> arr=new ArrayList<JSON>();\n    for (    User e : list) {\n      JSON j=new JSON();\n      j.put(\"value\",e.getId());\n      j.put(\"name\",e.get(\"nickname\") + \"(\" + e.get(\"name\")+ \")\");\n      arr.add(j);\n    }\n    jo.put(\"list\",arr);\n    jo.put(X.STATE,200);\n  }\n else {\n    jo.put(X.STATE,201);\n  }\n  this.response(jo);\n}\n", "nl": "get user list by \"access\" token"}
{"code": "@Override public void apply(NexusStreamParser np) throws Exception {\n  np.matchIgnoreCase(\"load mapFile=\");\n  final String fileName=np.getWordFileNamePunctuation();\n  np.matchIgnoreCase(\"mapType=\");\n  final IdMapper.MapType mapType=IdMapper.MapType.valueOf(np.getWordMatchesRespectingCase(Basic.toString(IdMapper.MapType.values(),\" \")));\n  np.matchIgnoreCase(\"cName=\");\n  final String cName=np.getWordMatchesRespectingCase(Basic.toString(ClassificationManager.getAllSupportedClassifications(),\" \"));\n  np.matchIgnoreCase(\";\");\n  try {\n    Classification classification=ClassificationManager.get(cName,true);\n    ProgressListener progressListener;\n    if (ProgramProperties.isUseGUI())     progressListener=new ProgressDialog(\"Loading file\",\"\",(Component)getParent());\n else     progressListener=new ProgressPercentage();\n    try {\n      final IdMapper mapper=classification.getIdMapper();\n      mapper.loadMappingFile(fileName,mapType,true,progressListener);\n    }\n  finally {\n      progressListener.close();\n    }\n    if (getParent() instanceof ImportBlastDialog) {\n      ((ImportBlastDialog)getParent()).getCommandManager().execute(\"use cViewer=\" + cName + \" state=true;\");\n    }\n    ProgramProperties.put(ClassificationManager.getMapFileKey(cName,mapType),fileName);\n  }\n catch (  Exception ex) {\n    Basic.caught(ex);\n  }\n}\n", "nl": "parses the given command and executes it"}
{"code": "synchronized final void releaseDTDLoader(String xmlVersion,XMLDTDLoader loader){\n  if (\"1.1\".equals(xmlVersion)) {\n    ++freeXML11DTDLoaderIndex;\n    if (xml11DTDLoaders.length == freeXML11DTDLoaderIndex) {\n      xml11DTDLoaderCurrentSize+=SIZE;\n      SoftReference[] newarray=new SoftReference[xml11DTDLoaderCurrentSize];\n      System.arraycopy(xml11DTDLoaders,0,newarray,0,xml11DTDLoaders.length);\n      xml11DTDLoaders=newarray;\n    }\n    SoftReference ref=xml11DTDLoaders[freeXML11DTDLoaderIndex];\n    if (ref != null) {\n      XMLDTDLoaderHolder holder=(XMLDTDLoaderHolder)ref.get();\n      if (holder != null) {\n        holder.loader=loader;\n        return;\n      }\n    }\n    xml11DTDLoaders[freeXML11DTDLoaderIndex]=new SoftReference(new XMLDTDLoaderHolder(loader));\n  }\n else {\n    ++freeXML10DTDLoaderIndex;\n    if (xml10DTDLoaders.length == freeXML10DTDLoaderIndex) {\n      xml10DTDLoaderCurrentSize+=SIZE;\n      SoftReference[] newarray=new SoftReference[xml10DTDLoaderCurrentSize];\n      System.arraycopy(xml10DTDLoaders,0,newarray,0,xml10DTDLoaders.length);\n      xml10DTDLoaders=newarray;\n    }\n    SoftReference ref=xml10DTDLoaders[freeXML10DTDLoaderIndex];\n    if (ref != null) {\n      XMLDTDLoaderHolder holder=(XMLDTDLoaderHolder)ref.get();\n      if (holder != null) {\n        holder.loader=loader;\n        return;\n      }\n    }\n    xml10DTDLoaders[freeXML10DTDLoaderIndex]=new SoftReference(new XMLDTDLoaderHolder(loader));\n  }\n}\n", "nl": "NON-DOM: release DTD loader"}
{"code": "private void updateStyleImp(Map<String,Object> style){\n  if (style != null) {\n    if (style.containsKey(WXDomPropConstant.WX_LINES)) {\n      int lines=WXStyle.getLines(style);\n      if (lines > 0) {\n        mNumberOfLines=lines;\n      }\n    }\n    if (style.containsKey(WXDomPropConstant.WX_FONTSIZE)) {\n      mFontSize=WXStyle.getFontSize(style);\n    }\n    if (style.containsKey(WXDomPropConstant.WX_FONTWEIGHT)) {\n      mFontWeight=WXStyle.getFontWeight(style);\n    }\n    if (style.containsKey(WXDomPropConstant.WX_FONTSTYLE)) {\n      mFontStyle=WXStyle.getFontStyle(style);\n    }\n    if (style.containsKey(WXDomPropConstant.WX_COLOR)) {\n      mColor=WXResourceUtils.getColor(WXStyle.getTextColor(style));\n      mIsColorSet=mColor != Integer.MIN_VALUE;\n    }\n    if (style.containsKey(WXDomPropConstant.WX_TEXTDECORATION)) {\n      mTextDecoration=WXStyle.getTextDecoration(style);\n    }\n    if (style.containsKey(WXDomPropConstant.WX_FONTFAMILY)) {\n      mFontFamily=WXStyle.getFontFamily(style);\n    }\n    mAlignment=WXStyle.getTextAlignment(style);\n    textOverflow=WXStyle.getTextOverflow(style);\n    int lineHeight=WXStyle.getLineHeight(style);\n    if (lineHeight != UNSET) {\n      mLineHeight=lineHeight;\n    }\n  }\n}\n", "nl": "Record the property according to the given style"}
{"code": "private BTreeNode findLastLeafNode(IndexKey key,BTreeNode node){\n  int childNodeIndex;\n  int low=0;\n  int high=node.nodeSize() - 1;\n  int mid=0;\n  int compareRes=-1;\n  IndexKey[] nodeKeys=node.getNodeKeys();\n  while (low <= high) {\n    mid=(low + high) >>> 1;\n    compareRes=compareIndexes(key,nodeKeys[mid]);\n    if (compareRes < 0) {\n      high=mid - 1;\n    }\n else     if (compareRes > 0) {\n      low=mid + 1;\n    }\n else {\n      int currentPos=mid;\n      while (currentPos + 1 < node.nodeSize() && compareIndexes(key,nodeKeys[currentPos + 1]) == 0) {\n        currentPos++;\n      }\n      mid=currentPos;\n      break;\n    }\n  }\n  if (compareRes < 0) {\n    if (mid > 0) {\n      mid--;\n    }\n    childNodeIndex=mid;\n  }\n else {\n    childNodeIndex=mid;\n  }\n  node=node.getChild(childNodeIndex);\n  return node;\n}\n", "nl": "Binary search used to get the last tentative block of the btree based on search key"}
